//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# Port port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------

#define USE_BLENDER
using MatterHackers.Agg.Font;
using MatterHackers.Agg.Image;
using MatterHackers.Agg.RasterizerScanline;
using MatterHackers.Agg.Transform;
using MatterHackers.Agg.VertexSource;
using MatterHackers.VectorMath;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;

#region Affine.cs

namespace MatterHackers.Agg.Transform
{
    //============================================================trans_affine
    //
    // See Implementation agg_trans_affine.cpp
    //
    // Affine transformation are linear transformations in Cartesian coordinates
    // (strictly speaking not only in Cartesian, but for the beginning we will 
    // think so). They are rotation, scaling, translation and skewing.  
    // After any affine transformation a line segment remains a line segment 
    // and it will never become a curve. 
    //
    // There will be no math about matrix calculations, since it has been 
    // described many times. Ask yourself a very simple question:
    // "why do we need to understand and use some matrix stuff instead of just 
    // rotating, scaling and so on". The answers are:
    //
    // 1. Any combination of transformations can be done by only 4 multiplications
    //    and 4 additions in floating point.
    // 2. One matrix transformation is equivalent to the number of consecutive
    //    discrete transformations, i.e. the matrix "accumulates" all transformations 
    //    in the order of their settings. Suppose we have 4 transformations: 
    //       * rotate by 30 degrees,
    //       * scale X to 2.0, 
    //       * scale Y to 1.5, 
    //       * move to (100, 100). 
    //    The result will depend on the order of these transformations, 
    //    and the advantage of matrix is that the sequence of discret calls:
    //    rotate(30), scaleX(2.0), scaleY(1.5), move(100,100) 
    //    will have exactly the same result as the following matrix transformations:
    //   
    //    affine_matrix m;
    //    m *= rotate_matrix(30); 
    //    m *= scaleX_matrix(2.0);
    //    m *= scaleY_matrix(1.5);
    //    m *= move_matrix(100,100);
    //
    //    m.transform_my_point_at_last(x, y);
    //
    // What is the good of it? In real life we will set-up the matrix only once
    // and then transform many points, let alone the convenience to set any 
    // combination of transformations.
    //
    // So, how to use it? Very easy - literally as it's shown above. Not quite,
    // let us write a correct example:
    //
    // agg::trans_affine m;
    // m *= agg::trans_affine_rotation(30.0 * 3.1415926 / 180.0);
    // m *= agg::trans_affine_scaling(2.0, 1.5);
    // m *= agg::trans_affine_translation(100.0, 100.0);
    // m.transform(&x, &y);
    //
    // The affine matrix is all you need to perform any linear transformation,
    // but all transformations have origin point (0,0). It means that we need to 
    // use 2 translations if we want to rotate someting around (100,100):
    // 
    // m *= agg::trans_affine_translation(-100.0, -100.0);         // move to (0,0)
    // m *= agg::trans_affine_rotation(30.0 * 3.1415926 / 180.0);  // rotate
    // m *= agg::trans_affine_translation(100.0, 100.0);           // move back to (100,100)
    //----------------------------------------------------------------------
    public struct Affine : ITransform
    {
        static public readonly double affine_epsilon = 1e-14;

        public double sx, shy, shx, sy, tx, ty;

        //------------------------------------------ Construction
        public Affine(Affine copyFrom)
        {
            sx = copyFrom.sx;
            shy = copyFrom.shy;
            shx = copyFrom.shx;
            sy = copyFrom.sy;
            tx = copyFrom.tx;
            ty = copyFrom.ty;
        }

        // Custom matrix. Usually used in derived classes
        public Affine(double v0, double v1, double v2, double v3, double v4, double v5)
        {
            sx = v0;
            shy = v1;
            shx = v2;
            sy = v3;
            tx = v4;
            ty = v5;
        }

        // Custom matrix from m[6]
        public Affine(double[] m)
        {
            sx = m[0];
            shy = m[1];
            shx = m[2];
            sy = m[3];
            tx = m[4];
            ty = m[5];
        }

        // Identity matrix
        public static Affine NewIdentity()
        {
            Affine newAffine = new Affine();
            newAffine.sx = 1.0;
            newAffine.shy = 0.0;
            newAffine.shx = 0.0;
            newAffine.sy = 1.0;
            newAffine.tx = 0.0;
            newAffine.ty = 0.0;

            return newAffine;
        }

        //====================================================trans_affine_rotation
        // Rotation matrix. sin() and cos() are calculated twice for the same angle.
        // There's no harm because the performance of sin()/cos() is very good on all
        // modern processors. Besides, this operation is not going to be invoked too 
        // often.
        public static Affine NewRotation(double AngleRadians)
        {
            return new Affine(Math.Cos(AngleRadians), Math.Sin(AngleRadians), -Math.Sin(AngleRadians), Math.Cos(AngleRadians), 0.0, 0.0);
        }

        //====================================================trans_affine_scaling
        // Scaling matrix. x, y - scale coefficients by X and Y respectively
        public static Affine NewScaling(double Scale)
        {
            return new Affine(Scale, 0.0, 0.0, Scale, 0.0, 0.0);
        }

        public static Affine NewScaling(double x, double y)
        {
            return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
        }

        public static Affine NewTranslation(double x, double y)
        {
            return new Affine(1.0, 0.0, 0.0, 1.0, x, y);
        }

        public static Affine NewTranslation(Vector2 offset)
        {
            return new Affine(1.0, 0.0, 0.0, 1.0, offset.x, offset.y);
        }

        public static Affine NewSkewing(double x, double y)
        {
            return new Affine(1.0, Math.Tan(y), Math.Tan(x), 1.0, 0.0, 0.0);
        }

        /*
        //===============================================trans_affine_line_segment
        // Rotate, Scale and Translate, associating 0...dist with line segment 
        // x1,y1,x2,y2
        public static Affine NewScaling(double x, double y)
        {
            return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
        }
        public sealed class trans_affine_line_segment : Affine
        {
            public trans_affine_line_segment(double x1, double y1, double x2, double y2,
                                      double dist)
            {
                double dx = x2 - x1;
                double dy = y2 - y1;
                if (dist > 0.0)
                {
                    //multiply(trans_affine_scaling(sqrt(dx * dx + dy * dy) / dist));
                }
                //multiply(trans_affine_rotation(Math.Atan2(dy, dx)));
                //multiply(trans_affine_translation(x1, y1));
            }
        };


        //============================================trans_affine_reflection_unit
        // Reflection matrix. Reflect coordinates across the line through 
        // the origin containing the unit vector (ux, uy).
        // Contributed by John Horigan
        public static Affine NewScaling(double x, double y)
        {
            return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
        }
        public class trans_affine_reflection_unit : Affine
        {
            public trans_affine_reflection_unit(double ux, double uy)
                :
              base(2.0 * ux * ux - 1.0,
                           2.0 * ux * uy,
                           2.0 * ux * uy,
                           2.0 * uy * uy - 1.0,
                           0.0, 0.0)
            { }
        };


        //=================================================trans_affine_reflection
        // Reflection matrix. Reflect coordinates across the line through 
        // the origin at the angle a or containing the non-unit vector (x, y).
        // Contributed by John Horigan
        public static Affine NewScaling(double x, double y)
        {
            return new Affine(x, 0.0, 0.0, y, 0.0, 0.0);
        }
        public sealed class trans_affine_reflection : trans_affine_reflection_unit
        {
            public trans_affine_reflection(double a)
                :
              base(Math.Cos(a), Math.Sin(a))
            { }


            public trans_affine_reflection(double x, double y)
                :
              base(x / Math.Sqrt(x * x + y * y), y / Math.Sqrt(x * x + y * y))
            { }
        };
         */

        /*
        // Rectangle to a parallelogram.
        trans_affine(double x1, double y1, double x2, double y2, double* parl)
        {
            rect_to_parl(x1, y1, x2, y2, parl);
        }

        // Parallelogram to a rectangle.
        trans_affine(double* parl, 
                     double x1, double y1, double x2, double y2)
        {
            parl_to_rect(parl, x1, y1, x2, y2);
        }

        // Arbitrary parallelogram transformation.
        trans_affine(double* src, double* dst)
        {
            parl_to_parl(src, dst);
        }

        //---------------------------------- Parellelogram transformations
        // transform a parallelogram to another one. Src and dst are 
        // pointers to arrays of three points (double[6], x1,y1,...) that 
        // identify three corners of the parallelograms assuming implicit 
        // fourth point. The arguments are arrays of double[6] mapped 
        // to x1,y1, x2,y2, x3,y3  where the coordinates are:
        //        *-----------------*
        //       /          (x3,y3)/
        //      /                 /
        //     /(x1,y1)   (x2,y2)/
        //    *-----------------*
		trans_affine parl_to_parl(double* src, double* dst)
		{
			sx  = src[2] - src[0];
			shy = src[3] - src[1];
			shx = src[4] - src[0];
			sy  = src[5] - src[1];
			tx  = src[0];
			ty  = src[1];
			invert();
			multiply(trans_affine(dst[2] - dst[0], dst[3] - dst[1], 
				dst[4] - dst[0], dst[5] - dst[1],
				dst[0], dst[1]));
			return *this;
		}

		trans_affine rect_to_parl(double x1, double y1, 
			double x2, double y2, 
			double* parl)
		{
			double src[6];
			src[0] = x1; src[1] = y1;
			src[2] = x2; src[3] = y1;
			src[4] = x2; src[5] = y2;
			parl_to_parl(src, parl);
			return *this;
		}

		trans_affine parl_to_rect(double* parl, 
			double x1, double y1, 
			double x2, double y2)
		{
			double dst[6];
			dst[0] = x1; dst[1] = y1;
			dst[2] = x2; dst[3] = y1;
			dst[4] = x2; dst[5] = y2;
			parl_to_parl(parl, dst);
			return *this;
		}

         */

        //------------------------------------------ Operations
        // Reset - load an identity matrix
        public void identity()
        {
            sx = sy = 1.0;
            shy = shx = tx = ty = 0.0;
        }

        // Direct transformations operations
        public void translate(double x, double y)
        {
            tx += x;
            ty += y;
        }

        public void rotate(double AngleRadians)
        {
            double ca = Math.Cos(AngleRadians);
            double sa = Math.Sin(AngleRadians);
            double t0 = sx * ca - shy * sa;
            double t2 = shx * ca - sy * sa;
            double t4 = tx * ca - ty * sa;
            shy = sx * sa + shy * ca;
            sy = shx * sa + sy * ca;
            ty = tx * sa + ty * ca;
            sx = t0;
            shx = t2;
            tx = t4;
        }

        public void scale(double x, double y)
        {
            double mm0 = x; // Possible hint for the optimizer
            double mm3 = y;
            sx *= mm0;
            shx *= mm0;
            tx *= mm0;
            shy *= mm3;
            sy *= mm3;
            ty *= mm3;
        }

        public void scale(double scaleAmount)
        {
            sx *= scaleAmount;
            shx *= scaleAmount;
            tx *= scaleAmount;
            shy *= scaleAmount;
            sy *= scaleAmount;
            ty *= scaleAmount;
        }

        // Multiply matrix to another one
        void multiply(Affine m)
        {
            double t0 = sx * m.sx + shy * m.shx;
            double t2 = shx * m.sx + sy * m.shx;
            double t4 = tx * m.sx + ty * m.shx + m.tx;
            shy = sx * m.shy + shy * m.sy;
            sy = shx * m.shy + sy * m.sy;
            ty = tx * m.shy + ty * m.sy + m.ty;
            sx = t0;
            shx = t2;
            tx = t4;
        }
        /*

        // Multiply "m" to "this" and assign the result to "this"
        trans_affine premultiply(trans_affine m)
        {
            trans_affine t = m;
            return *this = t.multiply(*this);
        }

        // Multiply matrix to inverse of another one
        trans_affine multiply_inv(trans_affine m)
        {
            trans_affine t = m;
            t.invert();
            return multiply(t);
        }

        // Multiply inverse of "m" to "this" and assign the result to "this"
        trans_affine premultiply_inv(trans_affine m)
        {
            trans_affine t = m;
            t.invert();
            return *this = t.multiply(*this);
        }
         */

        // Invert matrix. Do not try to invert degenerate matrices, 
        // there's no check for validity. If you set scale to 0 and 
        // then try to invert matrix, expect unpredictable result.
        public void invert()
        {
            double d = determinant_reciprocal();

            double t0 = sy * d;
            sy = sx * d;
            shy = -shy * d;
            shx = -shx * d;

            double t4 = -tx * t0 - ty * shx;
            ty = -tx * shy - ty * sy;

            sx = t0;
            tx = t4;
        }

        /*

        // Mirroring around X
		trans_affine flip_x()
		{
			sx  = -sx;
			shy = -shy;
			tx  = -tx;
			return *this;
		}

        // Mirroring around Y
		trans_affine flip_y()
		{
			shx = -shx;
			sy  = -sy;
			ty  = -ty;
			return *this;
		}

        //------------------------------------------- Load/Store
        // Store matrix to an array [6] of double
        void store_to(double* m)
        {
            *m++ = sx; *m++ = shy; *m++ = shx; *m++ = sy; *m++ = tx; *m++ = ty;
        }

        // Load matrix from an array [6] of double
        trans_affine load_from(double* m)
        {
            sx = *m++; shy = *m++; shx = *m++; sy = *m++; tx = *m++;  ty = *m++;
            return *this;
        }

        //------------------------------------------- Operators
        
         */
        // Multiply the matrix by another one and return
        // the result in a separete matrix.
        public static Affine operator *(Affine a, Affine b)
        {
            Affine temp = new Affine(a);
            temp.multiply(b);
            return temp;
        }

        public static Affine operator +(Affine a, Vector2 b)
        {
            Affine temp = new Affine(a);
            temp.tx += b.x;
            temp.ty += b.y;
            return temp;
        }
        /*

        // Multiply the matrix by inverse of another one 
        // and return the result in a separete matrix.
        static trans_affine operator / (trans_affine a, trans_affine b)
        {
            return new trans_affine(a).multiply_inv(b);
        }

        // Calculate and return the inverse matrix
        static trans_affine operator ~ (trans_affine a)
        {
            new trans_affine(a).invert();
        }

        // Equal operator with default epsilon
        static bool operator == (trans_affine a, trans_affine b)
        {
            return a.is_equal(b, affine_epsilon);
        }

        // Not Equal operator with default epsilon
        static bool operator != (trans_affine a, trans_affine b)
        {
            return !a.is_equal(b, affine_epsilon);
        }

         */
        //-------------------------------------------- Transformations
        // Direct transformation of x and y
        public void transform(ref double x, ref double y)
        {
            double tmp = x;
            x = tmp * sx + y * shx + tx;
            y = tmp * shy + y * sy + ty;
        }

        public void transform(ref Vector2 pointToTransform)
        {
            transform(ref pointToTransform.x, ref pointToTransform.y);
        }

        public void transform(ref RectangleDouble rectToTransform)
        {
            transform(ref rectToTransform.Left, ref rectToTransform.Bottom);
            transform(ref rectToTransform.Right, ref rectToTransform.Top);
        }
        /*

        // Direct transformation of x and y, 2x2 matrix only, no translation
        void transform_2x2(double* x, double* y)
        {
            register double tmp = *x;
            *x = tmp * sx  + *y * shx;
            *y = tmp * shy + *y * sy;
        }

         */
        // Inverse transformation of x and y. It works slower than the 
        // direct transformation. For massive operations it's better to 
        // invert() the matrix and then use direct transformations. 
        public void inverse_transform(ref double x, ref double y)
        {
            double d = determinant_reciprocal();
            double a = (x - tx) * d;
            double b = (y - ty) * d;
            x = a * sy - b * shx;
            y = b * sx - a * shy;
        }

        public void inverse_transform(ref Vector2 pointToTransform)
        {
            inverse_transform(ref pointToTransform.x, ref pointToTransform.y);
        }
        /*

        //-------------------------------------------- Auxiliary
        // Calculate the determinant of matrix
        double determinant()
        {
            return sx * sy - shy * shx;
        }

         */
        // Calculate the reciprocal of the determinant
        double determinant_reciprocal()
        {
            return 1.0 / (sx * sy - shy * shx);
        }

        // Get the average scale (by X and Y). 
        // Basically used to calculate the approximation_scale when
        // decomposinting curves into line segments.
        public double GetScale()
        {
            double x = 0.707106781 * sx + 0.707106781 * shx;
            double y = 0.707106781 * shy + 0.707106781 * sy;
            return Math.Sqrt(x * x + y * y);
        }

        // Check to see if the matrix is not degenerate
        public bool is_valid(double epsilon)
        {
            return Math.Abs(sx) > epsilon && Math.Abs(sy) > epsilon;
        }

        // Check to see if it's an identity matrix
        public bool is_identity()
        {
            return is_identity(affine_epsilon);
        }

        public bool is_identity(double epsilon)
        {
            return agg_basics.is_equal_eps(sx, 1.0, epsilon) &&
                agg_basics.is_equal_eps(shy, 0.0, epsilon) &&
                agg_basics.is_equal_eps(shx, 0.0, epsilon) &&
                agg_basics.is_equal_eps(sy, 1.0, epsilon) &&
                agg_basics.is_equal_eps(tx, 0.0, epsilon) &&
                agg_basics.is_equal_eps(ty, 0.0, epsilon);
        }

        // Check to see if two matrices are equal
        public bool is_equal(Affine m, double epsilon)
        {
            return agg_basics.is_equal_eps(sx, m.sx, epsilon) &&
                agg_basics.is_equal_eps(shy, m.shy, epsilon) &&
                agg_basics.is_equal_eps(shx, m.shx, epsilon) &&
                agg_basics.is_equal_eps(sy, m.sy, epsilon) &&
                agg_basics.is_equal_eps(tx, m.tx, epsilon) &&
                agg_basics.is_equal_eps(ty, m.ty, epsilon);
        }

        // Determine the major parameters. Use with caution considering 
        // possible degenerate cases.
        public double rotation()
        {
            double x1 = 0.0;
            double y1 = 0.0;
            double x2 = 1.0;
            double y2 = 0.0;
            transform(ref x1, ref y1);
            transform(ref x2, ref y2);
            return Math.Atan2(y2 - y1, x2 - x1);
        }

        public void translation(out double dx, out double dy)
        {
            dx = tx;
            dy = ty;
        }

        public void scaling(out double x, out double y)
        {
            double x1 = 0.0;
            double y1 = 0.0;
            double x2 = 1.0;
            double y2 = 1.0;
            Affine t = new Affine(this);
            t *= NewRotation(-rotation());
            t.transform(ref x1, ref y1);
            t.transform(ref x2, ref y2);
            x = x2 - x1;
            y = y2 - y1;
        }

        public void scaling_abs(out double x, out double y)
        {
            // Used to calculate scaling coefficients in image resampling. 
            // When there is considerable shear this method gives us much
            // better estimation than just sx, sy.
            x = Math.Sqrt(sx * sx + shx * shx);
            y = Math.Sqrt(shy * shy + sy * sy);
        }
    };
}

#endregion //Affine.cs
#region agg_alpha_mask_u8.cs

namespace MatterHackers.Agg
{
    public interface IAlphaMask
    {
        byte pixel(int x, int y);
        byte combine_pixel(int x, int y, byte val);
        void fill_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix);
        void fill_vspan(int x, int y, byte[] dst, int dstIndex, int num_pix);
        void combine_hspanFullCover(int x, int y, byte[] dst, int dstIndex, int num_pix);
        void combine_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix);
        void combine_vspan(int x, int y, byte[] dst, int dstIndex, int num_pix);
    };

    public sealed class AlphaMaskByteUnclipped : IAlphaMask
    {
        IImageByte m_rbuf;
        uint m_Step;
        uint m_Offset;

        public static readonly int cover_shift = 8;
        public static readonly int cover_none = 0;
        public static readonly int cover_full = 255;

        public AlphaMaskByteUnclipped(IImageByte rbuf, uint Step, uint Offset)
        {
            m_Step = Step;
            m_Offset = Offset;
            m_rbuf = rbuf;
        }

        public void attach(IImageByte rbuf) { m_rbuf = rbuf; }

        //--------------------------------------------------------------------
        public byte pixel(int x, int y)
        {
            int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
            byte[] buffer = m_rbuf.GetBuffer();
            return buffer[bufferIndex];
        }

        //--------------------------------------------------------------------
        public byte combine_pixel(int x, int y, byte val)
        {
            unchecked
            {
                int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
                byte[] buffer = m_rbuf.GetBuffer();
                return (byte)((255 + val * buffer[bufferIndex]) >> 8);
            }
        }

        public void fill_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix)
        {
            throw new NotImplementedException();
#if false
            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *dst++ = *mask;
                mask += m_Step;
            }
            while (--num_pix != 0);
#endif
        }

        public void combine_hspanFullCover(int x, int y, byte[] covers, int coversIndex, int count)
        {
            int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
            byte[] mask = m_rbuf.GetBuffer();
            do
            {
                covers[coversIndex++] = mask[maskIndex++];
            }
            while (--count != 0);
        }

        public void combine_hspan(int x, int y, byte[] covers, int coversIndex, int count)
        {
            int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
            byte[] mask = m_rbuf.GetBuffer();
            do
            {
                covers[coversIndex] = (byte)((255 + (covers[coversIndex]) * mask[maskIndex]) >> 8);
                coversIndex++;
                maskIndex++;
            }
            while (--count != 0);
        }

        public void fill_vspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
        {
            throw new NotImplementedException();
#if false
            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *dst++ = *mask;
                mask += m_rbuf.StrideInBytes();
            }
            while (--num_pix != 0);
#endif
        }

        public void combine_vspan(int x, int y, byte[] dst, int dstIndex, int num_pix)
        {
            throw new NotImplementedException();
#if false
            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *dst = (byte)((cover_full + (*dst) * (*mask)) >> cover_shift);
                ++dst;
                mask += m_rbuf.StrideInBytes();
            }
            while (--num_pix != 0);
#endif
        }
    };

    public sealed class AlphaMaskByteClipped : IAlphaMask
    {
        IImageByte m_rbuf;
        uint m_Step;
        uint m_Offset;

        public static readonly int cover_shift = 8;
        public static readonly int cover_none = 0;
        public static readonly int cover_full = 255;

        public AlphaMaskByteClipped(IImageByte rbuf, uint Step, uint Offset)
        {
            m_Step = Step;
            m_Offset = Offset;
            m_rbuf = rbuf;
        }

        public void attach(IImageByte rbuf) { m_rbuf = rbuf; }


        //--------------------------------------------------------------------
        public byte pixel(int x, int y)
        {
            unchecked
            {
                if ((uint)x < (uint)m_rbuf.Width && (uint)y < (uint)m_rbuf.Height)
                {
                    int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
                    byte[] buffer = m_rbuf.GetBuffer();
                    return buffer[bufferIndex];
                }
            }

            return 0;
        }

        public byte combine_pixel(int x, int y, byte val)
        {
            unchecked
            {
                if ((uint)x < (uint)m_rbuf.Width
                    && (uint)y < (uint)m_rbuf.Height)
                {
                    int bufferIndex = m_rbuf.GetBufferOffsetXY(x, y);
                    byte[] buffer = m_rbuf.GetBuffer();
                    return (byte)((val * buffer[bufferIndex] + 255) >> 8);
                }
            }
            return 0;
        }

        public void fill_hspan(int x, int y, byte[] dst, int dstIndex, int num_pix)
        {
            throw new NotImplementedException();
#if false
            int xmax = (int)m_rbuf.Width() - 1;
            int ymax = (int)m_rbuf.Height() - 1;

            int count = num_pix;
            byte[] covers = dst;

            if (y < 0 || y > ymax)
            {
                agg_basics.MemClear(dst, num_pix);
                return;
            }

            if (x < 0)
            {
                count += x;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, -x);
                covers -= x;
                x = 0;
            }

            if (x + count > xmax)
            {
                int rest = x + count - xmax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers + count, rest);
            }

            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *covers++ = *(mask);
                mask += m_Step;
            }
            while (--count != 0);
#endif
        }

        public void combine_hspanFullCover(int x, int y, byte[] covers, int coversIndex, int num_pix)
        {
            int xmax = (int)m_rbuf.Width - 1;
            int ymax = (int)m_rbuf.Height - 1;

            int count = num_pix;

            if (y < 0 || y > ymax)
            {
                agg_basics.MemClear(covers, coversIndex, num_pix);
                return;
            }

            if (x < 0)
            {
                count += x;
                if (count <= 0)
                {
                    agg_basics.MemClear(covers, coversIndex, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, coversIndex, -x);
                coversIndex -= x;
                x = 0;
            }

            if (x + count > xmax)
            {
                int rest = x + count - xmax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(covers, coversIndex, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, coversIndex + count, rest);
            }

            int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
            byte[] mask = m_rbuf.GetBuffer();
            do
            {
                covers[coversIndex++] = mask[maskIndex++];
            }
            while (--count != 0);
        }

        public void combine_hspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
        {
            int xmax = (int)m_rbuf.Width - 1;
            int ymax = (int)m_rbuf.Height - 1;

            int count = num_pix;
            byte[] covers = buffer;
            int coversIndex = bufferIndex;

            if (y < 0 || y > ymax)
            {
                agg_basics.MemClear(buffer, bufferIndex, num_pix);
                return;
            }

            if (x < 0)
            {
                count += x;
                if (count <= 0)
                {
                    agg_basics.MemClear(buffer, bufferIndex, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, coversIndex, -x);
                coversIndex -= x;
                x = 0;
            }

            if (x + count > xmax)
            {
                int rest = x + count - xmax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(buffer, bufferIndex, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, coversIndex + count, rest);
            }

            int maskIndex = m_rbuf.GetBufferOffsetXY(x, y);
            byte[] mask = m_rbuf.GetBuffer();
            do
            {
                covers[coversIndex] = (byte)(((covers[coversIndex]) * mask[maskIndex] + 255) >> 8);
                coversIndex++;
                maskIndex++;
            }
            while (--count != 0);
        }

        public void fill_vspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
        {
            throw new NotImplementedException();
#if false
            int xmax = (int)m_rbuf.Width() - 1;
            int ymax = (int)m_rbuf.Height() - 1;

            int count = num_pix;
            byte[] covers = dst;

            if (x < 0 || x > xmax)
            {
                agg_basics.MemClear(dst, num_pix);
                return;
            }

            if (y < 0)
            {
                count += y;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, -y);
                covers -= y;
                y = 0;
            }

            if (y + count > ymax)
            {
                int rest = y + count - ymax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers + count, rest);
            }

            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *covers++ = *mask;
                mask += m_rbuf.StrideInBytes();
            }
            while (--count != 0);
#endif
        }

        public void combine_vspan(int x, int y, byte[] buffer, int bufferIndex, int num_pix)
        {
            throw new NotImplementedException();
#if false
            int xmax = (int)m_rbuf.Width() - 1;
            int ymax = (int)m_rbuf.Height() - 1;

            int count = num_pix;
            byte[] covers = dst;

            if (x < 0 || x > xmax)
            {
                agg_basics.MemClear(dst, num_pix);
                return;
            }

            if (y < 0)
            {
                count += y;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers, -y);
                covers -= y;
                y = 0;
            }

            if (y + count > ymax)
            {
                int rest = y + count - ymax - 1;
                count -= rest;
                if (count <= 0)
                {
                    agg_basics.MemClear(dst, num_pix);
                    return;
                }
                agg_basics.MemClear(covers + count, rest);
            }

            byte[] mask = m_rbuf.GetPixelPointerY(y) + x * m_Step + m_Offset;
            do
            {
                *covers = (byte)((cover_full + (*covers) * (*mask)) >> cover_shift);
                ++covers;
                mask += m_rbuf.StrideInBytes();
            }
            while (--count != 0);
#endif
        }
    };
}

#endregion //agg_alpha_mask_u8.cs
#region agg_array.cs

namespace MatterHackers.Agg
{
    public interface IDataContainer<T>
    {
        T[] Array { get; }
        void RemoveLast();
    }

    public class ArrayPOD<T> : IDataContainer<T>
    {
        public ArrayPOD() : this(64) { }

        public ArrayPOD(int size)
        {
            m_array = new T[size];
            m_size = size;
        }

        public void RemoveLast()
        {
            throw new NotImplementedException();
        }

        public ArrayPOD(ArrayPOD<T> v)
        {
            m_array = (T[])v.m_array.Clone();
            m_size = v.m_size;
        }

        public void Resize(int size)
        {
            if (size != m_size)
            {
                m_array = new T[size];
            }
        }

        public int Size() { return m_size; }

        public T this[int index]
        {
            get
            {
                return m_array[index];
            }

            set
            {
                m_array[index] = value;
            }
        }

        public T[] Array
        {
            get
            {
                return m_array;
            }
        }
        private T[] m_array;
        private int m_size;
    }


    //--------------------------------------------------------------pod_vector
    // A simple class template to store Plain Old Data, a vector
    // of a fixed size. The data is contiguous in memory
    //------------------------------------------------------------------------
    public class VectorPOD<dataType> : IDataContainer<dataType>
    {
        protected int currentSize;
        private dataType[] internalArray = new dataType[0];

        public int Count
        {
            get { return currentSize; }
        }

        public IEnumerable<dataType> DataIterator()
        {
            for (int index = 0; index < currentSize; index++)
            {
                // Yield each day of the week. 
                yield return internalArray[index];
            }
        }

        public IEnumerator GetEnumerator()
        {
            for (int index = 0; index < currentSize; index++)
            {
                // Yield each day of the week. 
                yield return internalArray[index];
            }
        }

        public int AllocatedSize
        {
            get
            {
                return internalArray.Length;
            }
        }

        public VectorPOD()
        {
        }

        public VectorPOD(int cap) : this(cap, 0) { }

        public VectorPOD(int capacity, int extraTail)
        {
            Allocate(capacity, extraTail);
        }

        public virtual void Remove(int indexToRemove)
        {
            if (indexToRemove >= Length)
            {
                throw new Exception("requested remove past end of array");
            }

            for (int i = indexToRemove; i < Length - 1; i++)
            {
                internalArray[i] = internalArray[i + 1];
            }

            currentSize--;
        }

        public virtual void RemoveLast()
        {
            if (currentSize != 0)
            {
                currentSize--;
            }
        }

        // Copying
        public VectorPOD(VectorPOD<dataType> vectorToCopy)
        {
            currentSize = vectorToCopy.currentSize;
            internalArray = (dataType[])vectorToCopy.internalArray.Clone();
        }

        public void CopyFrom(VectorPOD<dataType> vetorToCopy)
        {
            Allocate(vetorToCopy.currentSize);
            if (vetorToCopy.currentSize != 0)
            {
                vetorToCopy.internalArray.CopyTo(internalArray, 0);
            }
        }

        // Set new capacity. All data is lost, size is set to zero.
        public void Capacity(int newCapacity)
        {
            Capacity(newCapacity, 0);
        }

        public void Capacity(int newCapacity, int extraTail)
        {
            currentSize = 0;
            if (newCapacity > AllocatedSize)
            {
                internalArray = null;
                int sizeToAllocate = newCapacity + extraTail;
                if (sizeToAllocate != 0)
                {
                    internalArray = new dataType[sizeToAllocate];
                }
            }
        }

        public int Capacity() { return AllocatedSize; }

        // Allocate n elements. All data is lost, 
        // but elements can be accessed in range 0...size-1. 
        public void Allocate(int size)
        {
            Allocate(size, 0);
        }

        public void Allocate(int size, int extraTail)
        {
            Capacity(size, extraTail);
            currentSize = size;
        }

        // Resize keeping the content.
        public void Resize(int newSize)
        {
            if (newSize > currentSize)
            {
                if (newSize > AllocatedSize)
                {
                    var newArray = new dataType[newSize];
                    if (internalArray != null)
                    {
                        for (int i = 0; i < internalArray.Length; i++)
                        {
                            newArray[i] = internalArray[i];
                        }
                    }
                    internalArray = newArray;
                }
            }
        }

#pragma warning disable 649
        static dataType zeroed_object;
#pragma warning restore 649

        public void zero()
        {
            int NumItems = internalArray.Length;
            for (int i = 0; i < NumItems; i++)
            {
                internalArray[i] = zeroed_object;
            }
        }

        public void Add(dataType v)
        {
            add(v);
        }

        public virtual void add(dataType v)
        {
            if (internalArray == null || internalArray.Length < (currentSize + 1))
            {
                if (currentSize < 100000)
                {
                    Resize(currentSize + (currentSize / 2) + 16);
                }
                else
                {
                    Resize(currentSize + currentSize / 4);
                }
            }
            internalArray[currentSize++] = v;
        }

        public void push_back(dataType v) { internalArray[currentSize++] = v; }

        public void Insert(int index, dataType value)
        {
            insert_at(index, value);
        }

        public void insert_at(int pos, dataType val)
        {
            if (pos >= currentSize)
            {
                internalArray[currentSize] = val;
            }
            else
            {
                for (int i = 0; i < currentSize - pos; i++)
                {
                    internalArray[i + pos + 1] = internalArray[i + pos];
                }
                internalArray[pos] = val;
            }
            ++currentSize;
        }

        public void inc_size(int size) { currentSize += size; }
        public int size() { return currentSize; }

        public dataType this[int i]
        {
            get
            {
                return internalArray[i];
            }
        }

        public dataType[] Array
        {
            get
            {
                return internalArray;
            }
        }

        public dataType at(int i) { return internalArray[i]; }
        public dataType value_at(int i) { return internalArray[i]; }

        public dataType[] data() { return internalArray; }

        public void remove_all() { currentSize = 0; }
        public void clear() { currentSize = 0; }
        public void cut_at(int num) { if (num < currentSize) currentSize = num; }

        public int Length
        {
            get
            {
                return currentSize;
            }
        }

        public void Clear()
        {
            currentSize = 0;
        }

        public void Remove(dataType itemToRemove)
        {
            for (int i = 0; i < Length; i++)
            {
                if ((object)internalArray[i] == (object)itemToRemove)
                {
                    Remove(i);
                }
            }
        }
    }

    //----------------------------------------------------------range_adaptor
    public class VectorPOD_RangeAdaptor
    {
        VectorPOD<int> m_array;
        int m_start;
        int m_size;

        public VectorPOD_RangeAdaptor(VectorPOD<int> array, int start, int size)
        {
            m_array = (array);
            m_start = (start);
            m_size = (size);
        }

        public int size() { return m_size; }
        public int this[int i]
        {
            get
            {
                return m_array.Array[m_start + i];
            }

            set
            {
                m_array.Array[m_start + i] = value;
            }
        }
        public int at(int i) { return m_array.Array[m_start + i]; }
        public int value_at(int i) { return m_array.Array[m_start + i]; }
    }

    public class FirstInFirstOutQueue<T>
    {
        T[] itemArray;
        int size;
        int head;
        int shiftFactor;
        int mask;

        public int Count
        {
            get { return size; }
        }

        public FirstInFirstOutQueue(int shiftFactor)
        {
            this.shiftFactor = shiftFactor;
            mask = (1 << shiftFactor) - 1;
            itemArray = new T[1 << shiftFactor];
            head = 0;
            size = 0;
        }

        public T First
        {
            get { return itemArray[head & mask]; }
        }

        public void Enqueue(T itemToQueue)
        {
            if (size == itemArray.Length)
            {
                int headIndex = head & mask;
                shiftFactor += 1;
                mask = (1 << shiftFactor) - 1;
                T[] newArray = new T[1 << shiftFactor];
                // copy the from head to the end
                Array.Copy(itemArray, headIndex, newArray, 0, size - headIndex);
                // copy form 0 to the size
                Array.Copy(itemArray, 0, newArray, size - headIndex, headIndex);
                itemArray = newArray;
                head = 0;
            }
            itemArray[(head + (size++)) & mask] = itemToQueue;
        }

        public T Dequeue()
        {
            int headIndex = head & mask;
            T firstItem = itemArray[headIndex];
            if (size > 0)
            {
                head++;
                size--;
            }
            return firstItem;
        }
    }
}

#endregion //agg_array.cs
#region agg_basics.cs

namespace MatterHackers.Agg
{
    static public class agg_basics
    {
        //----------------------------------------------------------filling_rule_e
        public enum filling_rule_e
        {
            fill_non_zero,
            fill_even_odd
        }

        public static void memcpy(Byte[] dest, int destIndex, Byte[] source, int sourceIndex, int Count)
        {
#if USE_UNSAFE
#else
            for (int i = 0; i < Count; i++)
            {
                dest[destIndex + i] = source[sourceIndex + i];
            }
#endif
        }

        public static int ComputeHash(byte[] data)
        {
            unchecked
            {
                const int p = 16777619;
                int hash = (int)2166136261;

                for (int i = 0; i < data.Length; i++)
                {
                    hash = (hash ^ data[i]) * p;
                }

                hash += hash << 13;
                hash ^= hash >> 7;
                hash += hash << 3;
                hash ^= hash >> 17;
                hash += hash << 5;
                return hash;
            }
        }

        public static void memcpy(int[] dest, int destIndex, int[] source, int sourceIndex, int Count)
        {
            for (int i = 0; i < Count; i++)
            {
                dest[destIndex + i] = source[sourceIndex + i];
            }
        }

        public static void memcpy(float[] dest, int destIndex, float[] source, int sourceIndex, int count)
        {
            for (int i = 0; i < count; i++)
            {
                dest[destIndex++] = source[sourceIndex++];
            }
        }

        public static void memmove(Byte[] dest, int destIndex, Byte[] source, int sourceIndex, int Count)
        {
            if (source != dest || destIndex < sourceIndex)
            {
                memcpy(dest, destIndex, source, sourceIndex, Count);
            }
            else
            {
                throw new Exception("this code needs to be tested");
                /*
                for (int i = Count-1; i > 0; i--)
                {
                    dest[destIndex + i] = source[sourceIndex + i];
                }
                 */
            }
        }

        public static void memmove(int[] dest, int destIndex, int[] source, int sourceIndex, int Count)
        {
            if (source != dest || destIndex < sourceIndex)
            {
                memcpy(dest, destIndex, source, sourceIndex, Count);
            }
            else
            {
                throw new Exception("this code needs to be tested");
                /*
                for (int i = Count-1; i > 0; i--)
                {
                    dest[destIndex + i] = source[sourceIndex + i];
                }
                 */
            }
        }

        public static void memmove(float[] dest, int destIndex, float[] source, int sourceIndex, int Count)
        {
            if (source != dest || destIndex < sourceIndex)
            {
                memcpy(dest, destIndex, source, sourceIndex, Count);
            }
            else
            {
                throw new Exception("this code needs to be tested");
                /*
                for (int i = Count-1; i > 0; i--)
                {
                    dest[destIndex + i] = source[sourceIndex + i];
                }
                 */
            }
        }

        public static void memset(int[] dest, int destIndex, int Val, int Count)
        {
            for (int i = 0; i < Count; i++)
            {
                dest[destIndex + i] = Val;
            }
        }

        public static void memset(Byte[] dest, int destIndex, byte ByteVal, int Count)
        {
            for (int i = 0; i < Count; i++)
            {
                dest[destIndex + i] = ByteVal;
            }
        }

        public static void MemClear(int[] dest, int destIndex, int Count)
        {
            for (int i = 0; i < Count; i++)
            {
                dest[destIndex + i] = 0;
            }
        }

        public static void MemClear(Byte[] dest, int destIndex, int Count)
        {
            for (int i = 0; i < Count; i++)
            {
                dest[destIndex + i] = 0;
            }
            /*
            // dword align to dest
            while (((int)pDest & 3) != 0
                && Count > 0)
            {
                *pDest++ = 0;
                Count--;
            }

            int NumLongs = Count / 4;

            while (NumLongs-- > 0)
            {
                *((int*)pDest) = 0;

                pDest += 4;
            }

            switch (Count & 3)
            {
                case 3:
                    pDest[2] = 0;
                    goto case 2;
                case 2:
                    pDest[1] = 0;
                    goto case 1;
                case 1:
                    pDest[0] = 0;
                    break;
            }
             */
        }

        public static bool is_equal_eps(double v1, double v2, double epsilon)
        {
            return Math.Abs(v1 - v2) <= (double)(epsilon);
        }

        //------------------------------------------------------------------deg2rad
        public static double deg2rad(double deg)
        {
            return deg * Math.PI / 180.0;
        }

        //------------------------------------------------------------------rad2deg
        public static double rad2deg(double rad)
        {
            return rad * 180.0 / Math.PI;
        }

        public static int iround(double v)
        {
            unchecked
            {
                return (int)((v < 0.0) ? v - 0.5 : v + 0.5);
            }
        }

        public static int iround(double v, int saturationLimit)
        {
            if (v < (double)(-saturationLimit)) return -saturationLimit;
            if (v > (double)(saturationLimit)) return saturationLimit;
            return iround(v);
        }

        public static int uround(double v)
        {
            return (int)(uint)(v + 0.5);
        }

        public static int ufloor(double v)
        {
            return (int)(uint)(v);
        }

        public static int uceil(double v)
        {
            return (int)(uint)(Math.Ceiling(v));
        }

        //----------------------------------------------------poly_subpixel_scale_e
        // These constants determine the subpixel accuracy, to be more precise, 
        // the number of bits of the fractional part of the coordinates. 
        // The possible coordinate capacity in bits can be calculated by formula:
        // sizeof(int) * 8 - poly_subpixel_shift, i.e, for 32-bit integers and
        // 8-bits fractional part the capacity is 24 bits.
        public enum poly_subpixel_scale_e
        {
            poly_subpixel_shift = 8,                      //----poly_subpixel_shift
            poly_subpixel_scale = 1 << poly_subpixel_shift, //----poly_subpixel_scale 
            poly_subpixel_mask = poly_subpixel_scale - 1,  //----poly_subpixel_mask 
        }
    }
}

#endregion //agg_basics.cs
#region agg_bounding_rect.cs

namespace MatterHackers.Agg
{
    static public class bounding_rect
    {
        public static bool get_bounding_rect(PathStorage vs, int[] gi, int start, int num, out double x1, out double y1, out double x2, out double y2)
        {
            int i;
            double x = 0;
            double y = 0;
            bool first = true;

            x1 = 1;
            y1 = 1;
            x2 = 0;
            y2 = 0;

            for (i = 0; i < num; i++)
            {
                vs.rewind(gi[start + i]);
                ShapePath.FlagsAndCommand PathAndFlags;
                while (!ShapePath.is_stop(PathAndFlags = vs.vertex(out x, out y)))
                {
                    if (ShapePath.is_vertex(PathAndFlags))
                    {
                        if (first)
                        {
                            x1 = x;
                            y1 = y;
                            x2 = x;
                            y2 = y;
                            first = false;
                        }
                        else
                        {
                            if (x < x1) x1 = x;
                            if (y < y1) y1 = y;
                            if (x > x2) x2 = x;
                            if (y > y2) y2 = y;
                        }
                    }
                }
            }
            return x1 <= x2 && y1 <= y2;
        }

        public static bool get_bounding_rect(PathStorage vs, int[] gi, int start, int num, out RectangleDouble boundingRect)
        {
            return get_bounding_rect(vs, gi, start, num, out boundingRect.Left, out boundingRect.Bottom, out boundingRect.Right, out boundingRect.Top);
        }

        public static bool bounding_rect_single(IVertexSource vs, int path_id, ref RectangleDouble rect)
        {
            double x1, y1, x2, y2;
            bool rValue = bounding_rect_single(vs, path_id, out x1, out y1, out x2, out y2);
            rect.Left = x1;
            rect.Bottom = y1;
            rect.Right = x2;
            rect.Top = y2;
            return rValue;
        }

        //-----------------------------------------------------bounding_rect_single
        //template<class VertexSource, class CoordT> 
        public static bool bounding_rect_single(IVertexSource vs, int path_id, out double x1, out double y1, out double x2, out double y2)
        {
            double x = 0;
            double y = 0;
            bool first = true;

            x1 = 1;
            y1 = 1;
            x2 = 0;
            y2 = 0;

            vs.rewind(path_id);
            ShapePath.FlagsAndCommand PathAndFlags;
            while (!ShapePath.is_stop(PathAndFlags = vs.vertex(out x, out y)))
            {
                if (ShapePath.is_vertex(PathAndFlags))
                {
                    if (first)
                    {
                        x1 = x;
                        y1 = y;
                        x2 = x;
                        y2 = y;
                        first = false;
                    }
                    else
                    {
                        if (x < x1) x1 = x;
                        if (y < y1) y1 = y;
                        if (x > x2) x2 = x;
                        if (y > y2) y2 = y;
                    }
                }
            }
            return x1 <= x2 && y1 <= y2;
        }
    }
}

//#endif

#endregion //agg_bounding_rect.cs
#region agg_bspline.cs

namespace MatterHackers.Agg
{
    //----------------------------------------------------------------bspline
    // A very simple class of Bi-cubic Spline interpolation.
    // First call init(num, x[], y[]) where num - number of source points, 
    // x, y - arrays of X and Y values respectively. Here Y must be a function 
    // of X. It means that all the X-coordinates must be arranged in the ascending
    // order. 
    // Then call get(x) that calculates a value Y for the respective X. 
    // The class supports extrapolation, i.e. you can call get(x) where x is
    // outside the given with init() X-range. Extrapolation is a simple linear 
    // function.
    //------------------------------------------------------------------------
    public sealed class bspline
    {
        private int m_max;
        private int m_num;
        private int m_xOffset;
        private int m_yOffset;
        private ArrayPOD<double> m_am = new ArrayPOD<double>(16);
        private int m_last_idx;

        //------------------------------------------------------------------------
        public bspline()
        {
            m_max = (0);
            m_num = (0);
            m_xOffset = (0);
            m_yOffset = (0);
            m_last_idx = -1;
        }

        //------------------------------------------------------------------------
        public bspline(int num)
        {
            m_max = (0);
            m_num = (0);
            m_xOffset = (0);
            m_yOffset = (0);
            m_last_idx = -1;

            init(num);
        }

        //------------------------------------------------------------------------
        public bspline(int num, double[] x, double[] y)
        {
            m_max = (0);
            m_num = (0);
            m_xOffset = (0);
            m_yOffset = (0);
            m_last_idx = -1;
            init(num, x, y);
        }

        //------------------------------------------------------------------------
        public void init(int max)
        {
            if (max > 2 && max > m_max)
            {
                m_am.Resize(max * 3);
                m_max = max;
                m_xOffset = m_max;
                m_yOffset = m_max * 2;
            }
            m_num = 0;
            m_last_idx = -1;
        }

        //------------------------------------------------------------------------
        public void add_point(double x, double y)
        {
            if (m_num < m_max)
            {
                m_am[m_xOffset + m_num] = x;
                m_am[m_yOffset + m_num] = y;
                ++m_num;
            }
        }

        //------------------------------------------------------------------------
        public void prepare()
        {
            if (m_num > 2)
            {
                int i, k;
                int r;
                int s;
                double h, p, d, f, e;

                for (k = 0; k < m_num; k++)
                {
                    m_am[k] = 0.0;
                }

                int n1 = 3 * m_num;

                ArrayPOD<double> al = new ArrayPOD<double>(n1);

                for (k = 0; k < n1; k++)
                {
                    al[k] = 0.0;
                }

                r = m_num;
                s = m_num * 2;

                n1 = m_num - 1;
                d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];
                e = (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d;

                for (k = 1; k < n1; k++)
                {
                    h = d;
                    d = m_am[m_xOffset + k + 1] - m_am[m_xOffset + k];
                    f = e;
                    e = (m_am[m_yOffset + k + 1] - m_am[m_yOffset + k]) / d;
                    al[k] = d / (d + h);
                    al[r + k] = 1.0 - al[k];
                    al[s + k] = 6.0 * (e - f) / (h + d);
                }

                for (k = 1; k < n1; k++)
                {
                    p = 1.0 / (al[r + k] * al[k - 1] + 2.0);
                    al[k] *= -p;
                    al[s + k] = (al[s + k] - al[r + k] * al[s + k - 1]) * p;
                }

                m_am[n1] = 0.0;
                al[n1 - 1] = al[s + n1 - 1];
                m_am[n1 - 1] = al[n1 - 1];

                for (k = n1 - 2, i = 0; i < m_num - 2; i++, k--)
                {
                    al[k] = al[k] * al[k + 1] + al[s + k];
                    m_am[k] = al[k];
                }
            }
            m_last_idx = -1;
        }

        //------------------------------------------------------------------------
        public void init(int num, double[] x, double[] y)
        {
            if (num > 2)
            {
                init(num);
                int i;
                for (i = 0; i < num; i++)
                {
                    add_point(x[i], y[i]);
                }
                prepare();
            }
            m_last_idx = -1;
        }

        //------------------------------------------------------------------------
        void bsearch(int n, int xOffset, double x0, out int i)
        {
            int j = n - 1;
            int k;

            for (i = 0; (j - i) > 1; )
            {
                k = (i + j) >> 1;
                if (x0 < m_am[xOffset + k]) j = k;
                else i = k;
            }
        }

        //------------------------------------------------------------------------
        double interpolation(double x, int i)
        {
            int j = i + 1;
            double d = m_am[m_xOffset + i] - m_am[m_xOffset + j];
            double h = x - m_am[m_xOffset + j];
            double r = m_am[m_xOffset + i] - x;
            double p = d * d / 6.0;
            return (m_am[j] * r * r * r + m_am[i] * h * h * h) / 6.0 / d +
                   ((m_am[m_yOffset + j] - m_am[j] * p) * r + (m_am[m_yOffset + i] - m_am[i] * p) * h) / d;
        }

        //------------------------------------------------------------------------
        double extrapolation_left(double x)
        {
            double d = m_am[m_xOffset + 1] - m_am[m_xOffset + 0];
            return (-d * m_am[1] / 6 + (m_am[m_yOffset + 1] - m_am[m_yOffset + 0]) / d) *
                   (x - m_am[m_xOffset + 0]) +
                   m_am[m_yOffset + 0];
        }

        //------------------------------------------------------------------------
        double extrapolation_right(double x)
        {
            double d = m_am[m_xOffset + m_num - 1] - m_am[m_xOffset + m_num - 2];
            return (d * m_am[m_num - 2] / 6 + (m_am[m_yOffset + m_num - 1] - m_am[m_yOffset + m_num - 2]) / d) *
                   (x - m_am[m_xOffset + m_num - 1]) +
                   m_am[m_yOffset + m_num - 1];
        }

        //------------------------------------------------------------------------
        public double get(double x)
        {
            if (m_num > 2)
            {
                int i;

                // Extrapolation on the left
                if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);

                // Extrapolation on the right
                if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);

                // Interpolation
                bsearch(m_num, m_xOffset, x, out i);
                return interpolation(x, i);
            }
            return 0.0;
        }

        //------------------------------------------------------------------------
        public double get_stateful(double x)
        {
            if (m_num > 2)
            {
                // Extrapolation on the left
                if (x < m_am[m_xOffset + 0]) return extrapolation_left(x);

                // Extrapolation on the right
                if (x >= m_am[m_xOffset + m_num - 1]) return extrapolation_right(x);

                if (m_last_idx >= 0)
                {
                    // Check if x is not in current range
                    if (x < m_am[m_xOffset + m_last_idx] || x > m_am[m_xOffset + m_last_idx + 1])
                    {
                        // Check if x between next points (most probably)
                        if (m_last_idx < m_num - 2 &&
                           x >= m_am[m_xOffset + m_last_idx + 1] &&
                           x <= m_am[m_xOffset + m_last_idx + 2])
                        {
                            ++m_last_idx;
                        }
                        else
                            if (m_last_idx > 0 &&
                               x >= m_am[m_xOffset + m_last_idx - 1] &&
                               x <= m_am[m_xOffset + m_last_idx])
                            {
                                // x is between pevious points
                                --m_last_idx;
                            }
                            else
                            {
                                // Else perform full search
                                bsearch(m_num, m_xOffset, x, out m_last_idx);
                            }
                    }
                    return interpolation(x, m_last_idx);
                }
                else
                {
                    // Interpolation
                    bsearch(m_num, m_xOffset, x, out m_last_idx);
                    return interpolation(x, m_last_idx);
                }
            }
            return 0.0;
        }
    }
}

#endregion //agg_bspline.cs
#region agg_clip_liang_barsky.cs

namespace MatterHackers.Agg
{
    public static class ClipLiangBarsky
    {
        //------------------------------------------------------------------------
        enum clipping_flags_e
        {
            clipping_flags_x1_clipped = 4,
            clipping_flags_x2_clipped = 1,
            clipping_flags_y1_clipped = 8,
            clipping_flags_y2_clipped = 2,
            clipping_flags_x_clipped = clipping_flags_x1_clipped | clipping_flags_x2_clipped,
            clipping_flags_y_clipped = clipping_flags_y1_clipped | clipping_flags_y2_clipped
        };

        //----------------------------------------------------------clipping_flags
        // Determine the clipping code of the vertex according to the 
        // Cyrus-Beck line clipping algorithm
        //
        //        |        |
        //  0110  |  0010  | 0011
        //        |        |
        // -------+--------+-------- clip_box.y2
        //        |        |
        //  0100  |  0000  | 0001
        //        |        |
        // -------+--------+-------- clip_box.y1
        //        |        |
        //  1100  |  1000  | 1001
        //        |        |
        //  clip_box.x1  clip_box.x2
        //
        // 
        //template<class T>
        public static int clipping_flags(int x, int y, RectangleInt clip_box)
        {
            return ((x > clip_box.Right) ? 1 : 0)
                | ((y > clip_box.Top) ? 1 << 1 : 0)
                | ((x < clip_box.Left) ? 1 << 2 : 0)
                | ((y < clip_box.Bottom) ? 1 << 3 : 0);
        }

        public static int clipping_flags_x(int x, RectangleInt clip_box)
        {
            return ((x > clip_box.Right ? 1 : 0) | ((x < clip_box.Left ? 1 : 0) << 2));
        }

        public static int clipping_flags_y(int y, RectangleInt clip_box)
        {
            return (((y > clip_box.Top ? 1 : 0) << 1) | ((y < clip_box.Bottom ? 1 : 0) << 3));
        }

        public static int clip_liang_barsky(int x1, int y1, int x2, int y2, RectangleInt clip_box, int[] x, int[] y)
        {
            int XIndex = 0;
            int YIndex = 0;
            double nearzero = 1e-30;

            double deltax = x2 - x1;
            double deltay = y2 - y1;
            double xin;
            double xout;
            double yin;
            double yout;
            double tinx;
            double tiny;
            double toutx;
            double touty;
            double tin1;
            double tin2;
            double tout1;
            int np = 0;

            if (deltax == 0.0)
            {
                // bump off of the vertical
                deltax = (x1 > clip_box.Left) ? -nearzero : nearzero;
            }

            if (deltay == 0.0)
            {
                // bump off of the horizontal 
                deltay = (y1 > clip_box.Bottom) ? -nearzero : nearzero;
            }

            if (deltax > 0.0)
            {
                // points to right
                xin = clip_box.Left;
                xout = clip_box.Right;
            }
            else
            {
                xin = clip_box.Right;
                xout = clip_box.Left;
            }

            if (deltay > 0.0)
            {
                // points up
                yin = clip_box.Bottom;
                yout = clip_box.Top;
            }
            else
            {
                yin = clip_box.Top;
                yout = clip_box.Bottom;
            }

            tinx = (xin - x1) / deltax;
            tiny = (yin - y1) / deltay;

            if (tinx < tiny)
            {
                // hits x first
                tin1 = tinx;
                tin2 = tiny;
            }
            else
            {
                // hits y first
                tin1 = tiny;
                tin2 = tinx;
            }

            if (tin1 <= 1.0)
            {
                if (0.0 < tin1)
                {
                    x[XIndex++] = (int)xin;
                    y[YIndex++] = (int)yin;
                    ++np;
                }

                if (tin2 <= 1.0)
                {
                    toutx = (xout - x1) / deltax;
                    touty = (yout - y1) / deltay;

                    tout1 = (toutx < touty) ? toutx : touty;

                    if (tin2 > 0.0 || tout1 > 0.0)
                    {
                        if (tin2 <= tout1)
                        {
                            if (tin2 > 0.0)
                            {
                                if (tinx > tiny)
                                {
                                    x[XIndex++] = (int)xin;
                                    y[YIndex++] = (int)(y1 + tinx * deltay);
                                }
                                else
                                {
                                    x[XIndex++] = (int)(x1 + tiny * deltax);
                                    y[YIndex++] = (int)yin;
                                }
                                ++np;
                            }

                            if (tout1 < 1.0)
                            {
                                if (toutx < touty)
                                {
                                    x[XIndex++] = (int)xout;
                                    y[YIndex++] = (int)(y1 + toutx * deltay);
                                }
                                else
                                {
                                    x[XIndex++] = (int)(x1 + touty * deltax);
                                    y[YIndex++] = (int)yout;
                                }
                            }
                            else
                            {
                                x[XIndex++] = x2;
                                y[YIndex++] = y2;
                            }
                            ++np;
                        }
                        else
                        {
                            if (tinx > tiny)
                            {
                                x[XIndex++] = (int)xin;
                                y[YIndex++] = (int)yout;
                            }
                            else
                            {
                                x[XIndex++] = (int)xout;
                                y[YIndex++] = (int)yin;
                            }
                            ++np;
                        }
                    }
                }
            }
            return np;
        }

        public static bool clip_move_point(int x1, int y1, int x2, int y2, RectangleInt clip_box, ref int x, ref int y, int flags)
        {
            int bound;

            if ((flags & (int)clipping_flags_e.clipping_flags_x_clipped) != 0)
            {
                if (x1 == x2)
                {
                    return false;
                }
                bound = ((flags & (int)clipping_flags_e.clipping_flags_x1_clipped) != 0) ? clip_box.Left : clip_box.Right;
                y = (int)((double)(bound - x1) * (y2 - y1) / (x2 - x1) + y1);
                x = bound;
            }

            flags = clipping_flags_y(y, clip_box);
            if ((flags & (int)clipping_flags_e.clipping_flags_y_clipped) != 0)
            {
                if (y1 == y2)
                {
                    return false;
                }
                bound = ((flags & (int)clipping_flags_e.clipping_flags_x1_clipped) != 0) ? clip_box.Bottom : clip_box.Top;
                x = (int)((double)(bound - y1) * (x2 - x1) / (y2 - y1) + x1);
                y = bound;
            }
            return true;
        }

        //-------------------------------------------------------clip_line_segment
        // Returns: ret >= 4        - Fully clipped
        //          (ret & 1) != 0  - First point has been moved
        //          (ret & 2) != 0  - Second point has been moved
        //
        //template<class T>
        public static int clip_line_segment(ref int x1, ref int y1, ref int x2, ref int y2, RectangleInt clip_box)
        {
            int f1 = clipping_flags(x1, y1, clip_box);
            int f2 = clipping_flags(x2, y2, clip_box);
            int ret = 0;

            if ((f2 | f1) == 0)
            {
                // Fully visible
                return 0;
            }

            if ((f1 & (int)clipping_flags_e.clipping_flags_x_clipped) != 0 &&
               (f1 & (int)clipping_flags_e.clipping_flags_x_clipped) == (f2 & (int)clipping_flags_e.clipping_flags_x_clipped))
            {
                // Fully clipped
                return 4;
            }

            if ((f1 & (int)clipping_flags_e.clipping_flags_y_clipped) != 0 &&
               (f1 & (int)clipping_flags_e.clipping_flags_y_clipped) == (f2 & (int)clipping_flags_e.clipping_flags_y_clipped))
            {
                // Fully clipped
                return 4;
            }

            int tx1 = x1;
            int ty1 = y1;
            int tx2 = x2;
            int ty2 = y2;
            if (f1 != 0)
            {
                if (!clip_move_point(tx1, ty1, tx2, ty2, clip_box, ref x1, ref y1, f1))
                {
                    return 4;
                }
                if (x1 == x2 && y1 == y2)
                {
                    return 4;
                }
                ret |= 1;
            }
            if (f2 != 0)
            {
                if (!clip_move_point(tx1, ty1, tx2, ty2, clip_box, ref x2, ref y2, f2))
                {
                    return 4;
                }
                if (x1 == x2 && y1 == y2)
                {
                    return 4;
                }
                ret |= 2;
            }
            return ret;
        }
    }
}

//#endif

#endregion //agg_clip_liang_barsky.cs
#region agg_color_gray.cs

namespace MatterHackers.Agg
{

    //===================================================================gray8
    public struct gray8
    {
        const int base_shift = 8;
        const uint base_scale = (uint)(1 << base_shift);
        const uint base_mask = base_scale - 1;

        byte v;
        byte a;

        //--------------------------------------------------------------------
        public gray8(uint v_) : this(v_, (uint)base_mask) { }

        public gray8(uint v_, uint a_)
        {
            v = (byte)(v_);
            a = (byte)(a_);
        }

        //--------------------------------------------------------------------
        gray8(gray8 c, uint a_)
        {
            v = (c.v);
            a = (byte)(a_);
        }

        //--------------------------------------------------------------------
        public gray8(RGBA_Floats c)
        {
            v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
            a = ((byte)agg_basics.uround(c.Alpha0To255 * (double)(base_mask)));
        }


        //--------------------------------------------------------------------
        public gray8(RGBA_Floats c, double a_)
        {
            v = ((byte)agg_basics.uround((0.299 * c.Red0To255 + 0.587 * c.Green0To255 + 0.114 * c.Blue0To255) * (double)(base_mask)));
            a = ((byte)agg_basics.uround(a_ * (double)(base_mask)));
        }

        //--------------------------------------------------------------------
        public gray8(RGBA_Bytes c)
        {
            v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
            a = (byte)(c.Alpha0To255);
        }

        //--------------------------------------------------------------------
        public gray8(RGBA_Bytes c, int a_)
        {
            v = (byte)((c.Red0To255 * 77 + c.Green0To255 * 150 + c.Blue0To255 * 29) >> 8);
            a = (byte)(a_);
        }

        //--------------------------------------------------------------------
        public void clear()
        {
            v = a = 0;
        }

        //--------------------------------------------------------------------
        public gray8 transparent()
        {
            a = 0;
            return this;
        }

        //--------------------------------------------------------------------
        public void opacity(double a_)
        {
            if (a_ < 0.0) a_ = 0.0;
            if (a_ > 1.0) a_ = 1.0;
            a = (byte)agg_basics.uround(a_ * (double)(base_mask));
        }

        //--------------------------------------------------------------------
        public double opacity()
        {
            return (double)(a) / (double)(base_mask);
        }


        //--------------------------------------------------------------------
        public gray8 premultiply()
        {
            if (a == (byte)base_mask) return this;
            if (a == 0)
            {
                v = 0;
                return this;
            }
            v = (byte)(((int)(v) * a) >> base_shift);
            return this;
        }

        //--------------------------------------------------------------------
        public gray8 premultiply(int a_)
        {
            if (a == (int)base_mask && a_ >= (int)base_mask) return this;
            if (a == 0 || a_ == 0)
            {
                v = a = 0;
                return this;
            }
            int v_ = ((int)(v) * a_) / a;
            v = (byte)((v_ > a_) ? a_ : v_);
            a = (byte)(a_);
            return this;
        }

        //--------------------------------------------------------------------
        public gray8 demultiply()
        {
            if (a == (int)base_mask) return this;
            if (a == 0)
            {
                v = 0;
                return this;
            }
            int v_ = ((int)(v) * (int)base_mask) / a;
            v = (byte)((v_ > (int)base_mask) ? (byte)base_mask : v_);
            return this;
        }

        //--------------------------------------------------------------------
        public gray8 gradient(gray8 c, double k)
        {
            gray8 ret;
            int ik = agg_basics.uround(k * (int)base_scale);
            ret.v = (byte)((int)(v) + ((((int)(c.v) - v) * ik) >> base_shift));
            ret.a = (byte)((int)(a) + ((((int)(c.a) - a) * ik) >> base_shift));
            return ret;
        }

        /*
        //--------------------------------------------------------------------
        void add(gray8 c, int cover)
        {
            int cv, ca;
            if(cover == cover_mask)
            {
                if (c.a == base_mask) 
                {
                    *this = c;
                }
                else
                {
                    cv = v + c.v; v = (cv > (int)(base_mask)) ? (int)(base_mask) : cv;
                    ca = a + c.a; a = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
                }
            }
            else
            {
                cv = v + ((c.v * cover + cover_mask/2) >> cover_shift);
                ca = a + ((c.a * cover + cover_mask/2) >> cover_shift);
                v = (cv > (int)(base_mask)) ? (int)(base_mask) : cv;
                a = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
            }
        }
         */

        //--------------------------------------------------------------------
        //static gray8 no_color() { return gray8(0,0); }

        /*
        static gray8 gray8_pre(int v, int a = gray8.base_mask)
        {
            return gray8(v,a).premultiply();
        }

        static gray8 gray8_pre(gray8 c, uint a)
        {
            return gray8(c,a).premultiply();
        }

        static gray8 gray8_pre(rgba& c)
        {
            return gray8(c).premultiply();
        }

        static gray8 gray8_pre(rgba& c, double a)
        {
            return gray8(c,a).premultiply();
        }

        static gray8 gray8_pre(rgba8& c)
        {
            return gray8(c).premultiply();
        }

        static gray8 gray8_pre(rgba8& c, uint a)
        {
            return gray8(c,a).premultiply();
        }
         */
    }
}

#endregion //agg_color_gray.cs
#region agg_color_rgba.cs

namespace MatterHackers.Agg
{
    // Supported byte orders for RGB and RGBA pixel formats
    //=======================================================================
    struct order_rgb { enum rgb_e { R = 0, G = 1, B = 2, rgb_tag }; };       //----order_rgb
    struct order_bgr { enum bgr_e { B = 0, G = 1, R = 2, rgb_tag }; };       //----order_bgr
    struct order_rgba { enum rgba_e { R = 0, G = 1, B = 2, A = 3, rgba_tag }; }; //----order_rgba
    struct order_argb { enum argb_e { A = 0, R = 1, G = 2, B = 3, rgba_tag }; }; //----order_argb
    struct order_abgr { enum abgr_e { A = 0, B = 1, G = 2, R = 3, rgba_tag }; }; //----order_abgr
    struct order_bgra { enum bgra_e { B = 0, G = 1, R = 2, A = 3, rgba_tag }; }; //----order_bgra

    public struct RGBA_Floats : IColorType
    {
        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        public float red;
        public float green;
        public float blue;
        public float alpha;

        public int Red0To255 { get { return (int)agg_basics.uround(red * (float)base_mask); } set { red = (float)value / (float)base_mask; } }
        public int Green0To255 { get { return (int)agg_basics.uround(green * (float)base_mask); } set { green = (float)value / (float)base_mask; } }
        public int Blue0To255 { get { return (int)agg_basics.uround(blue * (float)base_mask); } set { blue = (float)value / (float)base_mask; } }
        public int Alpha0To255 { get { return (int)agg_basics.uround(alpha * (float)base_mask); } set { alpha = (float)value / (float)base_mask; } }

        public float Red0To1 { get { return red; } set { red = value; } }
        public float Green0To1 { get { return green; } set { green = value; } }
        public float Blue0To1 { get { return blue; } set { blue = value; } }
        public float Alpha0To1 { get { return alpha; } set { alpha = value; } }

        #region Defined Colors
        public static readonly RGBA_Floats White = new RGBA_Floats(1, 1, 1, 1);
        public static readonly RGBA_Floats Black = new RGBA_Floats(0, 0, 0, 1);
        public static readonly RGBA_Floats Red = new RGBA_Floats(1, 0, 0, 1);
        public static readonly RGBA_Floats Green = new RGBA_Floats(0, 1, 0, 1);
        public static readonly RGBA_Floats Blue = new RGBA_Floats(0, 0, 1, 1);
        public static readonly RGBA_Floats Cyan = new RGBA_Floats(0, 1, 1, 1);
        public static readonly RGBA_Floats Magenta = new RGBA_Floats(1, 0, 1, 1);
        public static readonly RGBA_Floats Yellow = new RGBA_Floats(1, 1, 0, 1);
        #endregion // Defined Colors

        #region Constructors
        public RGBA_Floats(double r_, double g_, double b_) : this(r_, g_, b_, 1.0) { }

        public RGBA_Floats(double r_, double g_, double b_, double a_)
        {
            red = (float)r_;
            green = (float)g_;
            blue = (float)b_;
            alpha = (float)a_;
        }

        public RGBA_Floats(float r_, float g_, float b_) : this(r_, g_, b_, 1.0f) { }

        public RGBA_Floats(float r_, float g_, float b_, float a_)
        {
            red = r_;
            green = g_;
            blue = b_;
            alpha = a_;
        }

        public RGBA_Floats(RGBA_Floats c) : this(c, c.alpha) { }

        public RGBA_Floats(RGBA_Floats c, float a_)
        {
            red = c.red;
            green = c.green;
            blue = c.blue;
            alpha = a_;
        }

        public RGBA_Floats(float wavelen) : this(wavelen, 1.0f) { }

        public RGBA_Floats(float wavelen, float gamma)
        {
            this = from_wavelength(wavelen, gamma);
        }

        public RGBA_Floats(RGBA_Bytes color)
        {
            red = color.Red0To1;
            green = color.Green0To1;
            blue = color.Blue0To1;
            alpha = color.Alpha0To1;
        }
        #endregion Constructors

        #region HSL
        // Given H,S,L,A in range of 0-1
        // Returns a Color (RGB struct) in range of 0-255
        public static RGBA_Floats FromHSL(double hue0To1, double saturation0To1, double lightness0To1, double alpha = 1)
        {
            double v;
            double r, g, b;
            if (alpha > 1.0)
            {
                alpha = 1.0;
            }

            r = lightness0To1;   // default to gray
            g = lightness0To1;
            b = lightness0To1;
            v = lightness0To1 + saturation0To1 - lightness0To1 * saturation0To1;
            if (lightness0To1 <= 0.5)
            {
                v = lightness0To1 * (1.0 + saturation0To1);
            }

            if (v > 0)
            {
                double m;
                double sv;
                int sextant;
                double fract, vsf, mid1, mid2;

                m = lightness0To1 + lightness0To1 - v;
                sv = (v - m) / v;
                hue0To1 *= 6.0;
                sextant = (int)hue0To1;
                fract = hue0To1 - sextant;
                vsf = v * sv * fract;
                mid1 = m + vsf;
                mid2 = v - vsf;
                switch (sextant)
                {
                    case 0:
                        r = v;
                        g = mid1;
                        b = m;
                        break;
                    case 1:
                        r = mid2;
                        g = v;
                        b = m;
                        break;
                    case 2:
                        r = m;
                        g = v;
                        b = mid1;
                        break;
                    case 3:
                        r = m;
                        g = mid2;
                        b = v;
                        break;
                    case 4:
                        r = mid1;
                        g = m;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = m;
                        b = mid2;
                        break;
                    case 6:
                        goto case 0;
                }
            }

            return new RGBA_Floats(r, g, b, alpha);
        }

        public void GetHSL(out double hue0To1, out double saturation0To1, out double lightness0To1)
        {
            double maxRGB = Math.Max(red, Math.Max(green, blue));
            double minRGB = Math.Min(red, Math.Min(green, blue));
            double deltaMaxToMin = maxRGB - minRGB;
            double r2, g2, b2;

            hue0To1 = 0; // default to black
            saturation0To1 = 0;
            lightness0To1 = 0;
            lightness0To1 = (minRGB + maxRGB) / 2.0;
            if (lightness0To1 <= 0.0)
            {
                return;
            }
            saturation0To1 = deltaMaxToMin;
            if (saturation0To1 > 0.0)
            {
                saturation0To1 /= (lightness0To1 <= 0.5) ? (maxRGB + minRGB) : (2.0 - maxRGB - minRGB);
            }
            else
            {
                return;
            }
            r2 = (maxRGB - red) / deltaMaxToMin;
            g2 = (maxRGB - green) / deltaMaxToMin;
            b2 = (maxRGB - blue) / deltaMaxToMin;
            if (red == maxRGB)
            {
                if (green == minRGB)
                {
                    hue0To1 = 5.0 + b2;
                }
                else
                {
                    hue0To1 = 1.0 - g2;
                }
            }
            else if (green == maxRGB)
            {
                if (blue == minRGB)
                {
                    hue0To1 = 1.0 + r2;
                }
                else
                {
                    hue0To1 = 3.0 - b2;
                }
            }
            else
            {
                if (red == minRGB)
                {
                    hue0To1 = 3.0 + g2;
                }
                else
                {
                    hue0To1 = 5.0 - r2;
                }
            }
            hue0To1 /= 6.0;
        }

        public static RGBA_Floats AdjustSaturation(RGBA_Floats original, double saturationMultiplier)
        {
            double hue0To1;
            double saturation0To1;
            double lightness0To1;
            original.GetHSL(out hue0To1, out saturation0To1, out lightness0To1);
            saturation0To1 *= saturationMultiplier;

            return FromHSL(hue0To1, saturation0To1, lightness0To1);
        }

        public static RGBA_Floats AdjustLightness(RGBA_Floats original, double lightnessMultiplier)
        {
            double hue0To1;
            double saturation0To1;
            double lightness0To1;
            original.GetHSL(out hue0To1, out saturation0To1, out lightness0To1);
            lightness0To1 *= lightnessMultiplier;

            return FromHSL(hue0To1, saturation0To1, lightness0To1);
        }

        #endregion // HSL

        public static bool operator ==(RGBA_Floats a, RGBA_Floats b)
        {
            if (a.red == b.red && a.green == b.green && a.blue == b.blue && a.alpha == b.alpha)
            {
                return true;
            }

            return false;
        }

        public static bool operator !=(RGBA_Floats a, RGBA_Floats b)
        {
            if (a.red != b.red || a.green != b.green || a.blue != b.blue || a.alpha != b.alpha)
            {
                return true;
            }

            return false;
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() == typeof(RGBA_Floats))
            {
                return this == (RGBA_Floats)obj;
            }
            return false;
        }

        public override int GetHashCode()
        {
            return new { blue, green, red, alpha }.GetHashCode();
        }

        public RGBA_Bytes GetAsRGBA_Bytes()
        {
            return new RGBA_Bytes(Red0To255, Green0To255, Blue0To255, Alpha0To255);
        }

        public RGBA_Floats GetAsRGBA_Floats()
        {
            return this;
        }

        static public RGBA_Floats operator +(RGBA_Floats A, RGBA_Floats B)
        {
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red + B.red;
            temp.green = A.green + B.green;
            temp.blue = A.blue + B.blue;
            temp.alpha = A.alpha + B.alpha;
            return temp;
        }

        static public RGBA_Floats operator -(RGBA_Floats A, RGBA_Floats B)
        {
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red - B.red;
            temp.green = A.green - B.green;
            temp.blue = A.blue - B.blue;
            temp.alpha = A.alpha - B.alpha;
            return temp;
        }

        static public RGBA_Floats operator *(RGBA_Floats A, RGBA_Floats B)
        {
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red * B.red;
            temp.green = A.green * B.green;
            temp.blue = A.blue * B.blue;
            temp.alpha = A.alpha * B.alpha;
            return temp;
        }

        static public RGBA_Floats operator /(RGBA_Floats A, RGBA_Floats B)
        {
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red / B.red;
            temp.green = A.green / B.green;
            temp.blue = A.blue / B.blue;
            temp.alpha = A.alpha / B.alpha;
            return temp;
        }

        static public RGBA_Floats operator /(RGBA_Floats A, float B)
        {
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red / B;
            temp.green = A.green / B;
            temp.blue = A.blue / B;
            temp.alpha = A.alpha / B;
            return temp;
        }

        static public RGBA_Floats operator /(RGBA_Floats A, double doubleB)
        {
            float B = (float)doubleB;
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red / B;
            temp.green = A.green / B;
            temp.blue = A.blue / B;
            temp.alpha = A.alpha / B;
            return temp;
        }

        static public RGBA_Floats operator *(RGBA_Floats A, float B)
        {
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red * B;
            temp.green = A.green * B;
            temp.blue = A.blue * B;
            temp.alpha = A.alpha * B;
            return temp;
        }

        static public RGBA_Floats operator *(RGBA_Floats A, double doubleB)
        {
            float B = (float)doubleB;
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red * B;
            temp.green = A.green * B;
            temp.blue = A.blue * B;
            temp.alpha = A.alpha * B;
            return temp;
        }

        public void clear()
        {
            red = green = blue = alpha = 0;
        }

        public RGBA_Floats transparent()
        {
            alpha = 0.0f;
            return this;
        }

        public RGBA_Floats opacity(float a_)
        {
            if (a_ < 0.0) a_ = 0.0f;
            if (a_ > 1.0) a_ = 1.0f;
            alpha = a_;
            return this;
        }

        public float opacity()
        {
            return alpha;
        }

        public RGBA_Floats premultiply()
        {
            red *= alpha;
            green *= alpha;
            blue *= alpha;
            return this;
        }

        public RGBA_Floats premultiply(float a_)
        {
            if (alpha <= 0.0 || a_ <= 0.0)
            {
                red = green = blue = alpha = 0.0f;
                return this;
            }
            a_ /= alpha;
            red *= a_;
            green *= a_;
            blue *= a_;
            alpha = a_;
            return this;
        }

        public RGBA_Floats demultiply()
        {
            if (alpha == 0)
            {
                red = green = blue = 0;
                return this;
            }
            float a_ = 1.0f / alpha;
            red *= a_;
            green *= a_;
            blue *= a_;
            return this;
        }

        public RGBA_Bytes gradient(RGBA_Bytes c_8, double k)
        {
            RGBA_Floats c = c_8.GetAsRGBA_Floats();
            RGBA_Floats ret;
            ret.red = (float)(red + (c.red - red) * k);
            ret.green = (float)(green + (c.green - green) * k);
            ret.blue = (float)(blue + (c.blue - blue) * k);
            ret.alpha = (float)(alpha + (c.alpha - alpha) * k);
            return ret.GetAsRGBA_Bytes();
        }


        public static IColorType no_color() { return (IColorType)new RGBA_Floats(0, 0, 0, 0); }

        public static RGBA_Floats from_wavelength(float wl)
        {
            return from_wavelength(wl, 1.0f);
        }

        public static RGBA_Floats from_wavelength(float wl, float gamma)
        {
            RGBA_Floats t = new RGBA_Floats(0.0f, 0.0f, 0.0f);

            if (wl >= 380.0 && wl <= 440.0)
            {
                t.red = (float)(-1.0 * (wl - 440.0) / (440.0 - 380.0));
                t.blue = 1.0f;
            }
            else if (wl >= 440.0 && wl <= 490.0)
            {
                t.green = (float)((wl - 440.0) / (490.0 - 440.0));
                t.blue = 1.0f;
            }
            else if (wl >= 490.0 && wl <= 510.0)
            {
                t.green = 1.0f;
                t.blue = (float)(-1.0 * (wl - 510.0) / (510.0 - 490.0));
            }
            else if (wl >= 510.0 && wl <= 580.0)
            {
                t.red = (float)((wl - 510.0) / (580.0 - 510.0));
                t.green = 1.0f;
            }
            else if (wl >= 580.0 && wl <= 645.0)
            {
                t.red = 1.0f;
                t.green = (float)(-1.0 * (wl - 645.0) / (645.0 - 580.0));
            }
            else if (wl >= 645.0 && wl <= 780.0)
            {
                t.red = 1.0f;
            }

            float s = 1.0f;
            if (wl > 700.0) s = (float)(0.3 + 0.7 * (780.0 - wl) / (780.0 - 700.0));
            else if (wl < 420.0) s = (float)(0.3 + 0.7 * (wl - 380.0) / (420.0 - 380.0));

            t.red = (float)Math.Pow(t.red * s, gamma);
            t.green = (float)Math.Pow(t.green * s, gamma);
            t.blue = (float)Math.Pow(t.blue * s, gamma);

            return t;
        }

        public static RGBA_Floats rgba_pre(double r, double g, double b)
        {
            return rgba_pre((float)r, (float)g, (float)b, 1.0f);
        }

        public static RGBA_Floats rgba_pre(float r, float g, float b)
        {
            return rgba_pre(r, g, b, 1.0f);
        }

        public static RGBA_Floats rgba_pre(float r, float g, float b, float a)
        {
            return new RGBA_Floats(r, g, b, a).premultiply();
        }

        public static RGBA_Floats rgba_pre(double r, double g, double b, double a)
        {
            return new RGBA_Floats((float)r, (float)g, (float)b, (float)a).premultiply();
        }

        public static RGBA_Floats rgba_pre(RGBA_Floats c)
        {
            return new RGBA_Floats(c).premultiply();
        }

        public static RGBA_Floats rgba_pre(RGBA_Floats c, float a)
        {
            return new RGBA_Floats(c, a).premultiply();
        }

        public static RGBA_Floats GetTweenColor(RGBA_Floats Color1, RGBA_Floats Color2, double RatioOf2)
        {
            if (RatioOf2 <= 0)
            {
                return new RGBA_Floats(Color1);
            }

            if (RatioOf2 >= 1.0)
            {
                return new RGBA_Floats(Color2);
            }

            // figure out how much of each color we should be.
            double RatioOf1 = 1.0 - RatioOf2;
            return new RGBA_Floats(
                Color1.red * RatioOf1 + Color2.red * RatioOf2,
                Color1.green * RatioOf1 + Color2.green * RatioOf2,
                Color1.blue * RatioOf1 + Color2.blue * RatioOf2);
        }

        public RGBA_Floats Blend(RGBA_Floats other, double weight)
        {
            RGBA_Floats result = new RGBA_Floats(this);
            result = this * (1 - weight) + other * weight;
            return result;
        }

        public double SumOfDistances(RGBA_Floats other)
        {
            double dist = Math.Abs(red - other.red) + Math.Abs(green - other.green) + Math.Abs(blue - other.blue);
            return dist;
        }


        void Clamp0To1(ref float value)
        {
            if (value < 0)
            {
                value = 0;
            }
            else if (value > 1)
            {
                value = 1;
            }
        }

        public void Clamp0To1()
        {
            Clamp0To1(ref red);
            Clamp0To1(ref green);
            Clamp0To1(ref blue);
            Clamp0To1(ref alpha);
        }
    }

    public struct RGBA_Bytes : IColorType
    {
        public const int cover_shift = 8;
        public const int cover_size = 1 << cover_shift;  //----cover_size 
        public const int cover_mask = cover_size - 1;    //----cover_mask 
        //public const int cover_none  = 0,                 //----cover_none 
        //public const int cover_full  = cover_mask         //----cover_full 

        public const int base_shift = 8;
        public const int base_scale = (int)(1 << base_shift);
        public const int base_mask = base_scale - 1;

        public byte blue;
        public byte green;
        public byte red;
        public byte alpha;

        public static readonly RGBA_Bytes White = new RGBA_Bytes(255, 255, 255, 255);
        public static readonly RGBA_Bytes LightGray = new RGBA_Bytes(225, 225, 225, 255);
        public static readonly RGBA_Bytes Gray = new RGBA_Bytes(125, 125, 125, 235);
        public static readonly RGBA_Bytes DarkGray = new RGBA_Bytes(85, 85, 85, 255);
        public static readonly RGBA_Bytes Black = new RGBA_Bytes(0, 0, 0, 255);
        public static readonly RGBA_Bytes Red = new RGBA_Bytes(255, 0, 0, 255);
        public static readonly RGBA_Bytes Orange = new RGBA_Bytes(255, 127, 0, 255);
        public static readonly RGBA_Bytes Pink = new RGBA_Bytes(255, 192, 203, 255);
        public static readonly RGBA_Bytes Green = new RGBA_Bytes(0, 255, 0, 255);
        public static readonly RGBA_Bytes Blue = new RGBA_Bytes(0, 0, 255, 255);
        public static readonly RGBA_Bytes Indigo = new RGBA_Bytes(75, 0, 130, 255);
        public static readonly RGBA_Bytes Violet = new RGBA_Bytes(143, 0, 255, 255);
        public static readonly RGBA_Bytes Cyan = new RGBA_Bytes(0, 255, 255, 255);
        public static readonly RGBA_Bytes Magenta = new RGBA_Bytes(255, 0, 255, 255);
        public static readonly RGBA_Bytes Yellow = new RGBA_Bytes(255, 255, 0, 255);
        public static readonly RGBA_Bytes YellowGreen = new RGBA_Bytes(154, 205, 50, 255);

        public int Red0To255 { get { return (int)red; } set { red = (byte)value; } }
        public int Green0To255 { get { return (int)green; } set { green = (byte)value; } }
        public int Blue0To255 { get { return (int)blue; } set { blue = (byte)value; } }
        public int Alpha0To255 { get { return (int)alpha; } set { alpha = (byte)value; } }

        public float Red0To1 { get { return red / 255.0f; } set { red = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }
        public float Green0To1 { get { return green / 255.0f; } set { green = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }
        public float Blue0To1 { get { return blue / 255.0f; } set { blue = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }
        public float Alpha0To1 { get { return alpha / 255.0f; } set { alpha = (byte)Math.Max(0, Math.Min((int)(value * 255), 255)); } }

        public RGBA_Bytes(int r_, int g_, int b_) : this(r_, g_, b_, base_mask) { }

        public RGBA_Bytes(int r_, int g_, int b_, int a_)
        {
            red = (byte)Math.Min(Math.Max(r_, 0), 255);
            green = (byte)Math.Min(Math.Max(g_, 0), 255);
            blue = (byte)Math.Min(Math.Max(b_, 0), 255);
            alpha = (byte)Math.Min(Math.Max(a_, 0), 255);
        }

        public RGBA_Bytes(double r_, double g_, double b_, double a_)
        {
            red = ((byte)agg_basics.uround(r_ * (double)base_mask));
            green = ((byte)agg_basics.uround(g_ * (double)base_mask));
            blue = ((byte)agg_basics.uround(b_ * (double)base_mask));
            alpha = ((byte)agg_basics.uround(a_ * (double)base_mask));
        }

        public RGBA_Bytes(double r_, double g_, double b_)
        {
            red = ((byte)agg_basics.uround(r_ * (double)base_mask));
            green = ((byte)agg_basics.uround(g_ * (double)base_mask));
            blue = ((byte)agg_basics.uround(b_ * (double)base_mask));
            alpha = (byte)base_mask;
        }

        public RGBA_Bytes(RGBA_Floats c, double a_)
        {
            red = ((byte)agg_basics.uround(c.red * (double)base_mask));
            green = ((byte)agg_basics.uround(c.green * (double)base_mask));
            blue = ((byte)agg_basics.uround(c.blue * (double)base_mask));
            alpha = ((byte)agg_basics.uround(a_ * (double)base_mask));
        }

        public RGBA_Bytes(RGBA_Bytes c) : this(c, c.alpha) { }

        public RGBA_Bytes(RGBA_Bytes c, int a_)
        {
            red = (byte)c.red;
            green = (byte)c.green;
            blue = (byte)c.blue;
            alpha = (byte)a_;
        }

        public RGBA_Bytes(uint fourByteColor)
        {
            red = (byte)((fourByteColor >> 16) & 0xFF);
            green = (byte)((fourByteColor >> 8) & 0xFF);
            blue = (byte)((fourByteColor >> 0) & 0xFF);
            alpha = (byte)((fourByteColor >> 24) & 0xFF);
        }

        public RGBA_Bytes(RGBA_Floats c)
        {
            red = ((byte)agg_basics.uround(c.red * (double)base_mask));
            green = ((byte)agg_basics.uround(c.green * (double)base_mask));
            blue = ((byte)agg_basics.uround(c.blue * (double)base_mask));
            alpha = ((byte)agg_basics.uround(c.alpha * (double)base_mask));
        }

        public static bool operator ==(RGBA_Bytes a, RGBA_Bytes b)
        {
            if (a.red == b.red && a.green == b.green && a.blue == b.blue && a.alpha == b.alpha)
            {
                return true;
            }

            return false;
        }

        public static bool operator !=(RGBA_Bytes a, RGBA_Bytes b)
        {
            if (a.red != b.red || a.green != b.green || a.blue != b.blue || a.alpha != b.alpha)
            {
                return true;
            }

            return false;
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() == typeof(RGBA_Bytes))
            {
                return this == (RGBA_Bytes)obj;
            }
            return false;
        }

        public override int GetHashCode()
        {
            return new { blue, green, red, alpha }.GetHashCode();
        }

        public RGBA_Floats GetAsRGBA_Floats()
        {
            return new RGBA_Floats((float)red / (float)base_mask, (float)green / (float)base_mask, (float)blue / (float)base_mask, (float)alpha / (float)base_mask);
        }

        public RGBA_Bytes GetAsRGBA_Bytes()
        {
            return this;
        }

        public string GetAsHTMLString()
        {
            string html = string.Format("#{0:X2}{1:X2}{2:X2}", red, green, blue);
            return html;
        }

        void clear()
        {
            red = green = blue = alpha = 0;
        }

        public RGBA_Bytes gradient(RGBA_Bytes c, double k)
        {
            RGBA_Bytes ret = new RGBA_Bytes();
            int ik = agg_basics.uround(k * base_scale);
            ret.Red0To255 = (byte)((int)(Red0To255) + ((((int)(c.Red0To255) - Red0To255) * ik) >> base_shift));
            ret.Green0To255 = (byte)((int)(Green0To255) + ((((int)(c.Green0To255) - Green0To255) * ik) >> base_shift));
            ret.Blue0To255 = (byte)((int)(Blue0To255) + ((((int)(c.Blue0To255) - Blue0To255) * ik) >> base_shift));
            ret.Alpha0To255 = (byte)((int)(Alpha0To255) + ((((int)(c.Alpha0To255) - Alpha0To255) * ik) >> base_shift));
            return ret;
        }

        static public RGBA_Bytes operator +(RGBA_Bytes A, RGBA_Bytes B)
        {
            RGBA_Bytes temp = new RGBA_Bytes();
            temp.red = (byte)((A.red + B.red) > 255 ? 255 : (A.red + B.red));
            temp.green = (byte)((A.green + B.green) > 255 ? 255 : (A.green + B.green));
            temp.blue = (byte)((A.blue + B.blue) > 255 ? 255 : (A.blue + B.blue));
            temp.alpha = (byte)((A.alpha + B.alpha) > 255 ? 255 : (A.alpha + B.alpha));
            return temp;
        }

        static public RGBA_Bytes operator -(RGBA_Bytes A, RGBA_Bytes B)
        {
            RGBA_Bytes temp = new RGBA_Bytes();
            temp.red = (byte)((A.red - B.red) < 0 ? 0 : (A.red - B.red));
            temp.green = (byte)((A.green - B.green) < 0 ? 0 : (A.green - B.green));
            temp.blue = (byte)((A.blue - B.blue) < 0 ? 0 : (A.blue - B.blue));
            temp.alpha = 255;// (byte)((A.m_A - B.m_A) < 0 ? 0 : (A.m_A - B.m_A));
            return temp;
        }

        static public RGBA_Bytes operator *(RGBA_Bytes A, double doubleB)
        {
            float B = (float)doubleB;
            RGBA_Floats temp = new RGBA_Floats();
            temp.red = A.red / 255.0f * B;
            temp.green = A.green / 255.0f * B;
            temp.blue = A.blue / 255.0f * B;
            temp.alpha = A.alpha / 255.0f * B;
            return new RGBA_Bytes(temp);
        }

        public void add(RGBA_Bytes c, int cover)
        {
            int cr, cg, cb, ca;
            if (cover == cover_mask)
            {
                if (c.Alpha0To255 == base_mask)
                {
                    this = c;
                }
                else
                {
                    cr = Red0To255 + c.Red0To255; Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;
                    cg = Green0To255 + c.Green0To255; Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;
                    cb = Blue0To255 + c.Blue0To255; Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;
                    ca = Alpha0To255 + c.Alpha0To255; Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
                }
            }
            else
            {
                cr = Red0To255 + ((c.Red0To255 * cover + cover_mask / 2) >> cover_shift);
                cg = Green0To255 + ((c.Green0To255 * cover + cover_mask / 2) >> cover_shift);
                cb = Blue0To255 + ((c.Blue0To255 * cover + cover_mask / 2) >> cover_shift);
                ca = Alpha0To255 + ((c.Alpha0To255 * cover + cover_mask / 2) >> cover_shift);
                Red0To255 = (cr > (int)(base_mask)) ? (int)(base_mask) : cr;
                Green0To255 = (cg > (int)(base_mask)) ? (int)(base_mask) : cg;
                Blue0To255 = (cb > (int)(base_mask)) ? (int)(base_mask) : cb;
                Alpha0To255 = (ca > (int)(base_mask)) ? (int)(base_mask) : ca;
            }
        }

        public void apply_gamma_dir(GammaLookUpTable gamma)
        {
            Red0To255 = gamma.dir((byte)Red0To255);
            Green0To255 = gamma.dir((byte)Green0To255);
            Blue0To255 = gamma.dir((byte)Blue0To255);
        }

        public static IColorType no_color() { return new RGBA_Bytes(0, 0, 0, 0); }

        //-------------------------------------------------------------rgb8_packed
        static public RGBA_Bytes rgb8_packed(int v)
        {
            return new RGBA_Bytes((v >> 16) & 0xFF, (v >> 8) & 0xFF, v & 0xFF);
        }

        public RGBA_Bytes Blend(RGBA_Bytes other, double weight)
        {
            RGBA_Bytes result = new RGBA_Bytes(this);
            result = this * (1 - weight) + other * weight;
            return result;
        }
    }
}

#endregion //agg_color_rgba.cs
#region agg_curves.cs

namespace MatterHackers.Agg.VertexSource
{
    public static class Curves
    {
        //--------------------------------------------curve_approximation_method_e
        public enum CurveApproximationMethod
        {
            curve_inc,
            curve_div
        }

        public static readonly double curve_distance_epsilon = 1e-30;
        public static readonly double curve_collinearity_epsilon = 1e-30;
        public static readonly double curve_angle_tolerance_epsilon = 0.01;
        public enum curve_recursion_limit_e { curve_recursion_limit = 32 };

        //-------------------------------------------------------catrom_to_bezier
        public static curve4_points catrom_to_bezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            // Trans. matrix Catmull-Rom to Bezier
            //
            //  0       1       0       0
            //  -1/6    1       1/6     0
            //  0       1/6     1       -1/6
            //  0       0       1       0
            //
            return new curve4_points(
                x2,
                y2,
                (-x1 + 6 * x2 + x3) / 6,
                (-y1 + 6 * y2 + y3) / 6,
                (x2 + 6 * x3 - x4) / 6,
                (y2 + 6 * y3 - y4) / 6,
                x3,
                y3);
        }

        //-----------------------------------------------------------------------
        public static curve4_points catrom_to_bezier(curve4_points cp)
        {
            return catrom_to_bezier(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        //-----------------------------------------------------ubspline_to_bezier
        public static curve4_points ubspline_to_bezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            // Trans. matrix Uniform BSpline to Bezier
            //
            //  1/6     4/6     1/6     0
            //  0       4/6     2/6     0
            //  0       2/6     4/6     0
            //  0       1/6     4/6     1/6
            //
            return new curve4_points(
                (x1 + 4 * x2 + x3) / 6,
                (y1 + 4 * y2 + y3) / 6,
                (4 * x2 + 2 * x3) / 6,
                (4 * y2 + 2 * y3) / 6,
                (2 * x2 + 4 * x3) / 6,
                (2 * y2 + 4 * y3) / 6,
                (x2 + 4 * x3 + x4) / 6,
                (y2 + 4 * y3 + y4) / 6);
        }

        //-----------------------------------------------------------------------
        public static curve4_points
        ubspline_to_bezier(curve4_points cp)
        {
            return ubspline_to_bezier(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        //------------------------------------------------------hermite_to_bezier
        public static curve4_points hermite_to_bezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            // Trans. matrix Hermite to Bezier
            //
            //  1       0       0       0
            //  1       0       1/3     0
            //  0       1       0       -1/3
            //  0       1       0       0
            //
            return new curve4_points(
                x1,
                y1,
                (3 * x1 + x3) / 3,
                (3 * y1 + y3) / 3,
                (3 * x2 - x4) / 3,
                (3 * y2 - y4) / 3,
                x2,
                y2);
        }

        //-----------------------------------------------------------------------
        public static curve4_points
        hermite_to_bezier(curve4_points cp)
        {
            return hermite_to_bezier(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }
    }

    //--------------------------------------------------------------curve3_inc
    public sealed class curve3_inc
    {
        int m_num_steps;
        int m_step;
        double m_scale;
        double m_start_x;
        double m_start_y;
        double m_end_x;
        double m_end_y;
        double m_fx;
        double m_fy;
        double m_dfx;
        double m_dfy;
        double m_ddfx;
        double m_ddfy;
        double m_saved_fx;
        double m_saved_fy;
        double m_saved_dfx;
        double m_saved_dfy;

        public curve3_inc()
        {
            m_num_steps = (0);
            m_step = (0);
            m_scale = (1.0);
        }

        public curve3_inc(double x1, double y1, double x2, double y2, double x3, double y3)
        {
            m_num_steps = (0);
            m_step = (0);
            m_scale = (1.0);
            init(x1, y1, x2, y2, x3, y3);
        }

        public void reset() { m_num_steps = 0; m_step = -1; }

        public void init(double x1, double y1, double cx, double cy, double x2, double y2)
        {
            m_start_x = x1;
            m_start_y = y1;
            m_end_x = x2;
            m_end_y = y2;

            double dx1 = cx - x1;
            double dy1 = cy - y1;
            double dx2 = x2 - cx;
            double dy2 = y2 - cy;

            double len = Math.Sqrt(dx1 * dx1 + dy1 * dy1) + Math.Sqrt(dx2 * dx2 + dy2 * dy2);

            m_num_steps = (int)agg_basics.uround(len * 0.25 * m_scale);

            if (m_num_steps < 4)
            {
                m_num_steps = 4;
            }

            double subdivide_step = 1.0 / m_num_steps;
            double subdivide_step2 = subdivide_step * subdivide_step;

            double tmpx = (x1 - cx * 2.0 + x2) * subdivide_step2;
            double tmpy = (y1 - cy * 2.0 + y2) * subdivide_step2;

            m_saved_fx = m_fx = x1;
            m_saved_fy = m_fy = y1;

            m_saved_dfx = m_dfx = tmpx + (cx - x1) * (2.0 * subdivide_step);
            m_saved_dfy = m_dfy = tmpy + (cy - y1) * (2.0 * subdivide_step);

            m_ddfx = tmpx * 2.0;
            m_ddfy = tmpy * 2.0;

            m_step = m_num_steps;
        }


        public void approximation_method(Curves.CurveApproximationMethod method) { }
        public Curves.CurveApproximationMethod approximation_method() { return Curves.CurveApproximationMethod.curve_inc; }

        public void approximation_scale(double s)
        {
            m_scale = s;
        }

        public double approximation_scale()
        {
            return m_scale;
        }

        public void angle_tolerance(double angle) { }
        public double angle_tolerance() { return 0.0; }

        public void cusp_limit(double limit) { }
        public double cusp_limit() { return 0.0; }

        public IEnumerable<VertexData> Vertices()
        {
            throw new NotImplementedException();
        }

        public void rewind(int path_id)
        {
            if (m_num_steps == 0)
            {
                m_step = -1;
                return;
            }
            m_step = m_num_steps;
            m_fx = m_saved_fx;
            m_fy = m_saved_fy;
            m_dfx = m_saved_dfx;
            m_dfy = m_saved_dfy;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (m_step < 0)
            {
                x = 0;
                y = 0;
                return ShapePath.FlagsAndCommand.CommandStop;
            }
            if (m_step == m_num_steps)
            {
                x = m_start_x;
                y = m_start_y;
                --m_step;
                return ShapePath.FlagsAndCommand.CommandMoveTo;
            }
            if (m_step == 0)
            {
                x = m_end_x;
                y = m_end_y;
                --m_step;
                return ShapePath.FlagsAndCommand.CommandLineTo;
            }
            m_fx += m_dfx;
            m_fy += m_dfy;
            m_dfx += m_ddfx;
            m_dfy += m_ddfy;
            x = m_fx;
            y = m_fy;
            --m_step;
            return ShapePath.FlagsAndCommand.CommandLineTo;
        }
    }

    //-------------------------------------------------------------curve3_div
    public sealed class curve3_div
    {
        double m_approximation_scale;
        double m_distance_tolerance_square;
        double m_angle_tolerance;
        int m_count;
        VectorPOD<Vector2> m_points;

        public curve3_div()
        {
            m_points = new VectorPOD<Vector2>();
            m_approximation_scale = (1.0);
            m_angle_tolerance = (0.0);
            m_count = (0);
        }

        public curve3_div(double x1, double y1, double cx, double cy, double x2, double y2)
        {
            m_approximation_scale = (1.0);
            m_angle_tolerance = (0.0);
            m_count = (0);
            init(x1, y1, cx, cy, x2, y2);
        }

        public void reset() { m_points.remove_all(); m_count = 0; }
        public void init(double x1, double y1, double cx, double cy, double x2, double y2)
        {
            m_points.remove_all();
            m_distance_tolerance_square = 0.5 / m_approximation_scale;
            m_distance_tolerance_square *= m_distance_tolerance_square;
            bezier(x1, y1, cx, cy, x2, y2);
            m_count = 0;
        }


        public void approximation_method(Curves.CurveApproximationMethod method) { }
        public Curves.CurveApproximationMethod approximation_method() { return Curves.CurveApproximationMethod.curve_div; }

        public void approximation_scale(double s) { m_approximation_scale = s; }
        public double approximation_scale() { return m_approximation_scale; }

        public void angle_tolerance(double a) { m_angle_tolerance = a; }
        public double angle_tolerance() { return m_angle_tolerance; }

        public void cusp_limit(double limit) { }
        public double cusp_limit() { return 0.0; }

        public IEnumerable<VertexData> Vertices()
        {
            for (int i = 0; i < m_points.size(); i++)
            {
                if (i == 0)
                {
                    yield return new VertexData(ShapePath.FlagsAndCommand.CommandMoveTo, m_points[i]);
                }
                else
                {
                    yield return new VertexData(ShapePath.FlagsAndCommand.CommandLineTo, m_points[i]);
                }
            }

            yield return new VertexData(ShapePath.FlagsAndCommand.CommandStop, new Vector2());
        }

        public void rewind(int idx)
        {
            m_count = 0;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (m_count >= m_points.size())
            {
                x = 0;
                y = 0;
                return ShapePath.FlagsAndCommand.CommandStop;
            }

            Vector2 p = m_points[m_count++];
            x = p.x;
            y = p.y;
            return (m_count == 1) ? ShapePath.FlagsAndCommand.CommandMoveTo : ShapePath.FlagsAndCommand.CommandLineTo;
        }

        private void bezier(double x1, double y1, double x2, double y2, double x3, double y3)
        {
            m_points.add(new Vector2(x1, y1));
            recursive_bezier(x1, y1, x2, y2, x3, y3, 0);
            m_points.add(new Vector2(x3, y3));
        }

        private void recursive_bezier(double x1, double y1, double x2, double y2, double x3, double y3, int level)
        {
            if (level > (int)Curves.curve_recursion_limit_e.curve_recursion_limit)
            {
                return;
            }

            // Calculate all the mid-points of the line segments
            //----------------------
            double x12 = (x1 + x2) / 2;
            double y12 = (y1 + y2) / 2;
            double x23 = (x2 + x3) / 2;
            double y23 = (y2 + y3) / 2;
            double x123 = (x12 + x23) / 2;
            double y123 = (y12 + y23) / 2;

            double dx = x3 - x1;
            double dy = y3 - y1;
            double d = Math.Abs(((x2 - x3) * dy - (y2 - y3) * dx));
            double da;

            if (d > Curves.curve_collinearity_epsilon)
            {
                // Regular case
                //-----------------
                if (d * d <= m_distance_tolerance_square * (dx * dx + dy * dy))
                {
                    // If the curvature doesn't exceed the distance_tolerance value
                    // we tend to finish subdivisions.
                    //----------------------
                    if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
                    {
                        m_points.add(new Vector2(x123, y123));
                        return;
                    }

                    // Angle & Cusp Condition
                    //----------------------
                    da = Math.Abs(Math.Atan2(y3 - y2, x3 - x2) - Math.Atan2(y2 - y1, x2 - x1));
                    if (da >= Math.PI) da = 2 * Math.PI - da;

                    if (da < m_angle_tolerance)
                    {
                        // Finally we can stop the recursion
                        //----------------------
                        m_points.add(new Vector2(x123, y123));
                        return;
                    }
                }
            }
            else
            {
                // Collinear case
                //------------------
                da = dx * dx + dy * dy;
                if (da == 0)
                {
                    d = agg_math.calc_sq_distance(x1, y1, x2, y2);
                }
                else
                {
                    d = ((x2 - x1) * dx + (y2 - y1) * dy) / da;
                    if (d > 0 && d < 1)
                    {
                        // Simple collinear case, 1---2---3
                        // We can leave just two endpoints
                        return;
                    }
                    if (d <= 0) d = agg_math.calc_sq_distance(x2, y2, x1, y1);
                    else if (d >= 1) d = agg_math.calc_sq_distance(x2, y2, x3, y3);
                    else d = agg_math.calc_sq_distance(x2, y2, x1 + d * dx, y1 + d * dy);
                }
                if (d < m_distance_tolerance_square)
                {
                    m_points.add(new Vector2(x2, y2));
                    return;
                }
            }

            // Continue subdivision
            //----------------------
            recursive_bezier(x1, y1, x12, y12, x123, y123, level + 1);
            recursive_bezier(x123, y123, x23, y23, x3, y3, level + 1);
        }
    }

    //-------------------------------------------------------------curve4_points
    public sealed class curve4_points
    {
        double[] cp = new double[8];
        public curve4_points() { }
        public curve4_points(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            cp[0] = x1; cp[1] = y1; cp[2] = x2; cp[3] = y2;
            cp[4] = x3; cp[5] = y3; cp[6] = x4; cp[7] = y4;
        }
        public void init(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            cp[0] = x1; cp[1] = y1; cp[2] = x2; cp[3] = y2;
            cp[4] = x3; cp[5] = y3; cp[6] = x4; cp[7] = y4;
        }

        public double this[int i]
        {
            get
            {
                return cp[i];
            }
        }

        //double  operator [] (int i){ return cp[i]; }
        //double& operator [] (int i)       { return cp[i]; }
    }

    //-------------------------------------------------------------curve4_inc
    public sealed class curve4_inc
    {
        int m_num_steps;
        int m_step;
        double m_scale;
        double m_start_x;
        double m_start_y;
        double m_end_x;
        double m_end_y;
        double m_fx;
        double m_fy;
        double m_dfx;
        double m_dfy;
        double m_ddfx;
        double m_ddfy;
        double m_dddfx;
        double m_dddfy;
        double m_saved_fx;
        double m_saved_fy;
        double m_saved_dfx;
        double m_saved_dfy;
        double m_saved_ddfx;
        double m_saved_ddfy;

        public curve4_inc()
        {
            m_num_steps = (0);
            m_step = (0);
            m_scale = (1.0);
        }

        public curve4_inc(double x1, double y1, double cx1, double cy1, double cx2, double cy2, double x2, double y2)
        {
            m_num_steps = (0);
            m_step = (0);
            m_scale = (1.0);
            init(x1, y1, cx1, cy1, cx2, cy2, x2, y2);
        }

        public curve4_inc(curve4_points cp)
        {
            m_num_steps = (0);
            m_step = (0);
            m_scale = (1.0);
            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        public void reset() { m_num_steps = 0; m_step = -1; }
        public void init(double x1, double y1, double cx1, double cy1, double cx2, double cy2, double x2, double y2)
        {
            m_start_x = x1;
            m_start_y = y1;
            m_end_x = x2;
            m_end_y = y2;

            double dx1 = cx1 - x1;
            double dy1 = cy1 - y1;
            double dx2 = cx2 - cx1;
            double dy2 = cy2 - cy1;
            double dx3 = x2 - cx2;
            double dy3 = y2 - cy2;

            double len = (Math.Sqrt(dx1 * dx1 + dy1 * dy1) +
                          Math.Sqrt(dx2 * dx2 + dy2 * dy2) +
                          Math.Sqrt(dx3 * dx3 + dy3 * dy3)) * 0.25 * m_scale;

            m_num_steps = (int)agg_basics.uround(len);

            if (m_num_steps < 4)
            {
                m_num_steps = 4;
            }

            double subdivide_step = 1.0 / m_num_steps;
            double subdivide_step2 = subdivide_step * subdivide_step;
            double subdivide_step3 = subdivide_step * subdivide_step * subdivide_step;

            double pre1 = 3.0 * subdivide_step;
            double pre2 = 3.0 * subdivide_step2;
            double pre4 = 6.0 * subdivide_step2;
            double pre5 = 6.0 * subdivide_step3;

            double tmp1x = x1 - cx1 * 2.0 + cx2;
            double tmp1y = y1 - cy1 * 2.0 + cy2;

            double tmp2x = (cx1 - cx2) * 3.0 - x1 + x2;
            double tmp2y = (cy1 - cy2) * 3.0 - y1 + y2;

            m_saved_fx = m_fx = x1;
            m_saved_fy = m_fy = y1;

            m_saved_dfx = m_dfx = (cx1 - x1) * pre1 + tmp1x * pre2 + tmp2x * subdivide_step3;
            m_saved_dfy = m_dfy = (cy1 - y1) * pre1 + tmp1y * pre2 + tmp2y * subdivide_step3;

            m_saved_ddfx = m_ddfx = tmp1x * pre4 + tmp2x * pre5;
            m_saved_ddfy = m_ddfy = tmp1y * pre4 + tmp2y * pre5;

            m_dddfx = tmp2x * pre5;
            m_dddfy = tmp2y * pre5;

            m_step = m_num_steps;
        }

        public void init(curve4_points cp)
        {
            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        public void approximation_method(Curves.CurveApproximationMethod method) { }
        public Curves.CurveApproximationMethod approximation_method() { return Curves.CurveApproximationMethod.curve_inc; }

        public void approximation_scale(double s)
        {
            m_scale = s;
        }

        public double approximation_scale()
        {
            return m_scale;
        }

        public void angle_tolerance(double angle) { }
        public double angle_tolerance() { return 0.0; }

        public void cusp_limit(double limit) { }
        public double cusp_limit() { return 0.0; }

        public IEnumerable<VertexData> Vertices()
        {
            throw new NotImplementedException();
        }

        public void rewind(int path_id)
        {
            if (m_num_steps == 0)
            {
                m_step = -1;
                return;
            }
            m_step = m_num_steps;
            m_fx = m_saved_fx;
            m_fy = m_saved_fy;
            m_dfx = m_saved_dfx;
            m_dfy = m_saved_dfy;
            m_ddfx = m_saved_ddfx;
            m_ddfy = m_saved_ddfy;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (m_step < 0)
            {
                x = 0;
                y = 0;
                return ShapePath.FlagsAndCommand.CommandStop;
            }

            if (m_step == m_num_steps)
            {
                x = m_start_x;
                y = m_start_y;
                --m_step;
                return ShapePath.FlagsAndCommand.CommandMoveTo;
            }

            if (m_step == 0)
            {
                x = m_end_x;
                y = m_end_y;
                --m_step;
                return ShapePath.FlagsAndCommand.CommandLineTo;
            }

            m_fx += m_dfx;
            m_fy += m_dfy;
            m_dfx += m_ddfx;
            m_dfy += m_ddfy;
            m_ddfx += m_dddfx;
            m_ddfy += m_dddfy;

            x = m_fx;
            y = m_fy;
            --m_step;
            return ShapePath.FlagsAndCommand.CommandLineTo;
        }

    }

    //-------------------------------------------------------------curve4_div
    public sealed class curve4_div
    {
        double m_approximation_scale;
        double m_distance_tolerance_square;
        double m_angle_tolerance;
        double m_cusp_limit;
        int m_count;
        VectorPOD<Vector2> m_points;

        public curve4_div()
        {
            m_points = new VectorPOD<Vector2>();
            m_approximation_scale = (1.0);
            m_angle_tolerance = (0.0);
            m_cusp_limit = (0.0);
            m_count = (0);
        }

        public curve4_div(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            m_approximation_scale = (1.0);
            m_angle_tolerance = (0.0);
            m_cusp_limit = (0.0);
            m_count = (0);
            init(x1, y1, x2, y2, x3, y3, x4, y4);
        }

        public curve4_div(curve4_points cp)
        {
            m_approximation_scale = (1.0);
            m_angle_tolerance = (0.0);
            m_count = (0);
            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        public void reset() { m_points.remove_all(); m_count = 0; }
        public void init(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            m_points.remove_all();
            m_distance_tolerance_square = 0.5 / m_approximation_scale;
            m_distance_tolerance_square *= m_distance_tolerance_square;
            bezier(x1, y1, x2, y2, x3, y3, x4, y4);
            m_count = 0;
        }


        public void init(curve4_points cp)
        {
            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        public void approximation_method(Curves.CurveApproximationMethod method) { }

        public Curves.CurveApproximationMethod approximation_method()
        {
            return Curves.CurveApproximationMethod.curve_div;
        }

        public void approximation_scale(double s) { m_approximation_scale = s; }
        public double approximation_scale() { return m_approximation_scale; }

        public void angle_tolerance(double a) { m_angle_tolerance = a; }
        public double angle_tolerance() { return m_angle_tolerance; }

        public void cusp_limit(double v)
        {
            m_cusp_limit = (v == 0.0) ? 0.0 : Math.PI - v;
        }

        public double cusp_limit()
        {
            return (m_cusp_limit == 0.0) ? 0.0 : Math.PI - m_cusp_limit;
        }

        public IEnumerable<VertexData> Vertices()
        {
            VertexData vertexData = new VertexData();
            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandMoveTo;
            vertexData.position = m_points[0];
            yield return vertexData;

            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandLineTo;
            for (int i = 1; i < m_points.size(); i++)
            {
                vertexData.position = m_points[i];
                yield return vertexData;
            }

            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandStop;
            vertexData.position = new Vector2();
            yield return vertexData;
        }

        public void rewind(int idx)
        {
            m_count = 0;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (m_count >= m_points.size())
            {
                x = 0;
                y = 0;
                return ShapePath.FlagsAndCommand.CommandStop;
            }
            Vector2 p = m_points[m_count++];
            x = p.x;
            y = p.y;
            return (m_count == 1) ? ShapePath.FlagsAndCommand.CommandMoveTo : ShapePath.FlagsAndCommand.CommandLineTo;
        }

        private void bezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
        {
            m_points.add(new Vector2(x1, y1));
            recursive_bezier(x1, y1, x2, y2, x3, y3, x4, y4, 0);
            m_points.add(new Vector2(x4, y4));
        }


        private void recursive_bezier(double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4, int level)
        {
            if (level > (int)Curves.curve_recursion_limit_e.curve_recursion_limit)
            {
                return;
            }

            // Calculate all the mid-points of the line segments
            //----------------------
            double x12 = (x1 + x2) / 2;
            double y12 = (y1 + y2) / 2;
            double x23 = (x2 + x3) / 2;
            double y23 = (y2 + y3) / 2;
            double x34 = (x3 + x4) / 2;
            double y34 = (y3 + y4) / 2;
            double x123 = (x12 + x23) / 2;
            double y123 = (y12 + y23) / 2;
            double x234 = (x23 + x34) / 2;
            double y234 = (y23 + y34) / 2;
            double x1234 = (x123 + x234) / 2;
            double y1234 = (y123 + y234) / 2;


            // Try to approximate the full cubic curve by a single straight line
            //------------------
            double dx = x4 - x1;
            double dy = y4 - y1;

            double d2 = Math.Abs(((x2 - x4) * dy - (y2 - y4) * dx));
            double d3 = Math.Abs(((x3 - x4) * dy - (y3 - y4) * dx));
            double da1, da2, k;

            int SwitchCase = 0;
            if (d2 > Curves.curve_collinearity_epsilon)
            {
                SwitchCase = 2;
            }
            if (d3 > Curves.curve_collinearity_epsilon)
            {
                SwitchCase++;
            }

            switch (SwitchCase)
            {
                case 0:
                    // All collinear OR p1==p4
                    //----------------------
                    k = dx * dx + dy * dy;
                    if (k == 0)
                    {
                        d2 = agg_math.calc_sq_distance(x1, y1, x2, y2);
                        d3 = agg_math.calc_sq_distance(x4, y4, x3, y3);
                    }
                    else
                    {
                        k = 1 / k;
                        da1 = x2 - x1;
                        da2 = y2 - y1;
                        d2 = k * (da1 * dx + da2 * dy);
                        da1 = x3 - x1;
                        da2 = y3 - y1;
                        d3 = k * (da1 * dx + da2 * dy);
                        if (d2 > 0 && d2 < 1 && d3 > 0 && d3 < 1)
                        {
                            // Simple collinear case, 1---2---3---4
                            // We can leave just two endpoints
                            return;
                        }
                        if (d2 <= 0) d2 = agg_math.calc_sq_distance(x2, y2, x1, y1);
                        else if (d2 >= 1) d2 = agg_math.calc_sq_distance(x2, y2, x4, y4);
                        else d2 = agg_math.calc_sq_distance(x2, y2, x1 + d2 * dx, y1 + d2 * dy);

                        if (d3 <= 0) d3 = agg_math.calc_sq_distance(x3, y3, x1, y1);
                        else if (d3 >= 1) d3 = agg_math.calc_sq_distance(x3, y3, x4, y4);
                        else d3 = agg_math.calc_sq_distance(x3, y3, x1 + d3 * dx, y1 + d3 * dy);
                    }
                    if (d2 > d3)
                    {
                        if (d2 < m_distance_tolerance_square)
                        {
                            m_points.add(new Vector2(x2, y2));
                            return;
                        }
                    }
                    else
                    {
                        if (d3 < m_distance_tolerance_square)
                        {
                            m_points.add(new Vector2(x3, y3));
                            return;
                        }
                    }
                    break;

                case 1:
                    // p1,p2,p4 are collinear, p3 is significant
                    //----------------------
                    if (d3 * d3 <= m_distance_tolerance_square * (dx * dx + dy * dy))
                    {
                        if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
                        {
                            m_points.add(new Vector2(x23, y23));
                            return;
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.Abs(Math.Atan2(y4 - y3, x4 - x3) - Math.Atan2(y3 - y2, x3 - x2));
                        if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;

                        if (da1 < m_angle_tolerance)
                        {
                            m_points.add(new Vector2(x2, y2));
                            m_points.add(new Vector2(x3, y3));
                            return;
                        }

                        if (m_cusp_limit != 0.0)
                        {
                            if (da1 > m_cusp_limit)
                            {
                                m_points.add(new Vector2(x3, y3));
                                return;
                            }
                        }
                    }
                    break;

                case 2:
                    // p1,p3,p4 are collinear, p2 is significant
                    //----------------------
                    if (d2 * d2 <= m_distance_tolerance_square * (dx * dx + dy * dy))
                    {
                        if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
                        {
                            m_points.add(new Vector2(x23, y23));
                            return;
                        }

                        // Angle Condition
                        //----------------------
                        da1 = Math.Abs(Math.Atan2(y3 - y2, x3 - x2) - Math.Atan2(y2 - y1, x2 - x1));
                        if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;

                        if (da1 < m_angle_tolerance)
                        {
                            m_points.add(new Vector2(x2, y2));
                            m_points.add(new Vector2(x3, y3));
                            return;
                        }

                        if (m_cusp_limit != 0.0)
                        {
                            if (da1 > m_cusp_limit)
                            {
                                m_points.add(new Vector2(x2, y2));
                                return;
                            }
                        }
                    }
                    break;

                case 3:
                    // Regular case
                    //-----------------
                    if ((d2 + d3) * (d2 + d3) <= m_distance_tolerance_square * (dx * dx + dy * dy))
                    {
                        // If the curvature doesn't exceed the distance_tolerance value
                        // we tend to finish subdivisions.
                        //----------------------
                        if (m_angle_tolerance < Curves.curve_angle_tolerance_epsilon)
                        {
                            m_points.add(new Vector2(x23, y23));
                            return;
                        }

                        // Angle & Cusp Condition
                        //----------------------
                        k = Math.Atan2(y3 - y2, x3 - x2);
                        da1 = Math.Abs(k - Math.Atan2(y2 - y1, x2 - x1));
                        da2 = Math.Abs(Math.Atan2(y4 - y3, x4 - x3) - k);
                        if (da1 >= Math.PI) da1 = 2 * Math.PI - da1;
                        if (da2 >= Math.PI) da2 = 2 * Math.PI - da2;

                        if (da1 + da2 < m_angle_tolerance)
                        {
                            // Finally we can stop the recursion
                            //----------------------
                            m_points.add(new Vector2(x23, y23));
                            return;
                        }

                        if (m_cusp_limit != 0.0)
                        {
                            if (da1 > m_cusp_limit)
                            {
                                m_points.add(new Vector2(x2, y2));
                                return;
                            }

                            if (da2 > m_cusp_limit)
                            {
                                m_points.add(new Vector2(x3, y3));
                                return;
                            }
                        }
                    }
                    break;
            }

            // Continue subdivision
            //----------------------
            recursive_bezier(x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1);
            recursive_bezier(x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1);
        }
    }

    //-----------------------------------------------------------------curve3
    public sealed class Curve3 : IVertexSource
    {
        curve3_inc m_curve_inc = new curve3_inc();
        curve3_div m_curve_div = new curve3_div();
        Curves.CurveApproximationMethod m_approximation_method;

        public Curve3()
        {
            m_approximation_method = Curves.CurveApproximationMethod.curve_div;
        }

        public Curve3(double x1, double y1, double cx, double cy, double x2, double y2)
            : base()
        {
            m_approximation_method = Curves.CurveApproximationMethod.curve_div;
            init(x1, y1, cx, cy, x2, y2);
        }

        public void reset()
        {
            m_curve_inc.reset();
            m_curve_div.reset();
        }

        public void init(double x1, double y1, double cx, double cy, double x2, double y2)
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                m_curve_inc.init(x1, y1, cx, cy, x2, y2);
            }
            else
            {
                m_curve_div.init(x1, y1, cx, cy, x2, y2);
            }
        }

        public void approximation_method(Curves.CurveApproximationMethod v)
        {
            m_approximation_method = v;
        }

        public Curves.CurveApproximationMethod approximation_method()
        {
            return m_approximation_method;
        }

        public void approximation_scale(double s)
        {
            m_curve_inc.approximation_scale(s);
            m_curve_div.approximation_scale(s);
        }

        public double approximation_scale()
        {
            return m_curve_inc.approximation_scale();
        }

        public void angle_tolerance(double a)
        {
            m_curve_div.angle_tolerance(a);
        }

        public double angle_tolerance()
        {
            return m_curve_div.angle_tolerance();
        }

        public void cusp_limit(double v)
        {
            m_curve_div.cusp_limit(v);
        }

        public double cusp_limit()
        {
            return m_curve_div.cusp_limit();
        }

        public IEnumerable<VertexData> Vertices()
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                foreach (VertexData vertexData in m_curve_inc.Vertices())
                {
                    yield return vertexData;
                }
            }
            else
            {
                foreach (VertexData vertexData in m_curve_div.Vertices())
                {
                    yield return vertexData;
                }
            }
        }

        public void rewind(int path_id)
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                m_curve_inc.rewind(path_id);
            }
            else
            {
                m_curve_div.rewind(path_id);
            }
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                return m_curve_inc.vertex(out x, out y);
            }
            return m_curve_div.vertex(out x, out y);
        }
    }

    //-----------------------------------------------------------------curve4
    public sealed class Curve4 : IVertexSource
    {
        curve4_inc m_curve_inc = new curve4_inc();
        curve4_div m_curve_div = new curve4_div();
        Curves.CurveApproximationMethod m_approximation_method;

        public Curve4()
        {
            m_approximation_method = Curves.CurveApproximationMethod.curve_div;
        }

        public Curve4(double x1, double y1, double cx1, double cy1, double cx2, double cy2, double x2, double y2)
            : base()
        {
            m_approximation_method = Curves.CurveApproximationMethod.curve_div;
            init(x1, y1, cx1, cy1, cx2, cy2, x2, y2);
        }

        public Curve4(curve4_points cp)
        {
            m_approximation_method = Curves.CurveApproximationMethod.curve_div;
            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        public void reset()
        {
            m_curve_inc.reset();
            m_curve_div.reset();
        }

        public void init(double x1, double y1, double cx1, double cy1, double cx2, double cy2, double x2, double y2)
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                m_curve_inc.init(x1, y1, cx1, cy1, cx2, cy2, x2, y2);
            }
            else
            {
                m_curve_div.init(x1, y1, cx1, cy1, cx2, cy2, x2, y2);
            }
        }

        public void init(curve4_points cp)
        {
            init(cp[0], cp[1], cp[2], cp[3], cp[4], cp[5], cp[6], cp[7]);
        }

        public void approximation_method(Curves.CurveApproximationMethod v)
        {
            m_approximation_method = v;
        }

        public Curves.CurveApproximationMethod approximation_method()
        {
            return m_approximation_method;
        }

        public void approximation_scale(double s)
        {
            m_curve_inc.approximation_scale(s);
            m_curve_div.approximation_scale(s);
        }
        public double approximation_scale() { return m_curve_inc.approximation_scale(); }

        public void angle_tolerance(double v)
        {
            m_curve_div.angle_tolerance(v);
        }

        public double angle_tolerance()
        {
            return m_curve_div.angle_tolerance();
        }

        public void cusp_limit(double v)
        {
            m_curve_div.cusp_limit(v);
        }

        public double cusp_limit()
        {
            return m_curve_div.cusp_limit();
        }

        public IEnumerable<VertexData> Vertices()
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                return m_curve_inc.Vertices();
            }
            else
            {
                return m_curve_div.Vertices();
            }
        }

        public void rewind(int path_id)
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                m_curve_inc.rewind(path_id);
            }
            else
            {
                m_curve_div.rewind(path_id);
            }
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (m_approximation_method == Curves.CurveApproximationMethod.curve_inc)
            {
                return m_curve_inc.vertex(out x, out y);
            }
            return m_curve_div.vertex(out x, out y);
        }
    }
}

#endregion //agg_curves.cs
#region agg_dda_line.cs


//----------------------------------------------------------------------------
//
// classes dda_line_interpolator, dda2_line_interpolator
//
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{
    //===================================================dda_line_interpolator
    public sealed class dda_line_interpolator
    {
        int m_y;
        int m_inc;
        int m_dy;
        //int m_YShift;
        int m_FractionShift;

        //--------------------------------------------------------------------
        public dda_line_interpolator(int FractionShift)
        {
            m_FractionShift = FractionShift;
        }

        //--------------------------------------------------------------------
        public dda_line_interpolator(int y1, int y2, int count, int FractionShift)
        {
            m_FractionShift = FractionShift;
            m_y = (y1);
            m_inc = (((y2 - y1) << m_FractionShift) / (int)(count));
            m_dy = (0);
        }

        //--------------------------------------------------------------------
        //public void operator ++ ()
        public void Next()
        {
            m_dy += m_inc;
        }

        //--------------------------------------------------------------------
        //public void operator -- ()
        public void Prev()
        {
            m_dy -= m_inc;
        }

        //--------------------------------------------------------------------
        //public void operator += (int n)
        public void Next(int n)
        {
            m_dy += m_inc * (int)n;
        }

        //--------------------------------------------------------------------
        //public void operator -= (int n)
        public void Prev(int n)
        {
            m_dy -= m_inc * (int)n;
        }


        //--------------------------------------------------------------------
        public int y() { return m_y + (m_dy >> (m_FractionShift)); } // - m_YShift)); }
        public int dy() { return m_dy; }
    }

    //=================================================dda2_line_interpolator
    public sealed class dda2_line_interpolator
    {
        enum save_size_e { save_size = 2 };

        //--------------------------------------------------------------------
        public dda2_line_interpolator() { }

        //-------------------------------------------- Forward-adjusted line
        public dda2_line_interpolator(int y1, int y2, int count)
        {
            m_cnt = (count <= 0 ? 1 : count);
            m_lft = ((y2 - y1) / m_cnt);
            m_rem = ((y2 - y1) % m_cnt);
            m_mod = (m_rem);
            m_y = (y1);

            if (m_mod <= 0)
            {
                m_mod += count;
                m_rem += count;
                m_lft--;
            }
            m_mod -= count;
        }

        //-------------------------------------------- Backward-adjusted line
        public dda2_line_interpolator(int y1, int y2, int count, int unused)
        {
            m_cnt = (count <= 0 ? 1 : count);
            m_lft = ((y2 - y1) / m_cnt);
            m_rem = ((y2 - y1) % m_cnt);
            m_mod = (m_rem);
            m_y = (y1);

            if (m_mod <= 0)
            {
                m_mod += count;
                m_rem += count;
                m_lft--;
            }
        }

        //-------------------------------------------- Backward-adjusted line
        public dda2_line_interpolator(int y, int count)
        {
            m_cnt = (count <= 0 ? 1 : count);
            m_lft = ((y) / m_cnt);
            m_rem = ((y) % m_cnt);
            m_mod = (m_rem);
            m_y = (0);

            if (m_mod <= 0)
            {
                m_mod += count;
                m_rem += count;
                m_lft--;
            }
        }

        /*
        //--------------------------------------------------------------------
        public void save(save_data_type* data)
        {
            data[0] = m_mod;
            data[1] = m_y;
        }

        //--------------------------------------------------------------------
        public void load(save_data_type* data)
        {
            m_mod = data[0];
            m_y   = data[1];
        }
         */

        //--------------------------------------------------------------------
        //public void operator++()
        public void Next()
        {
            m_mod += m_rem;
            m_y += m_lft;
            if (m_mod > 0)
            {
                m_mod -= m_cnt;
                m_y++;
            }
        }

        //--------------------------------------------------------------------
        //public void operator--()
        public void Prev()
        {
            if (m_mod <= m_rem)
            {
                m_mod += m_cnt;
                m_y--;
            }
            m_mod -= m_rem;
            m_y -= m_lft;
        }

        //--------------------------------------------------------------------
        public void adjust_forward()
        {
            m_mod -= m_cnt;
        }

        //--------------------------------------------------------------------
        public void adjust_backward()
        {
            m_mod += m_cnt;
        }

        //--------------------------------------------------------------------
        public int mod() { return m_mod; }
        public int rem() { return m_rem; }
        public int lft() { return m_lft; }

        //--------------------------------------------------------------------
        public int y() { return m_y; }

        private int m_cnt;
        private int m_lft;
        private int m_rem;
        private int m_mod;
        private int m_y;
    }


    //---------------------------------------------line_bresenham_interpolator
    public sealed class line_bresenham_interpolator
    {
        int m_x1_lr;
        int m_y1_lr;
        int m_x2_lr;
        int m_y2_lr;
        bool m_ver;
        int m_len;
        int m_inc;
        dda2_line_interpolator m_interpolator;

        public enum subpixel_scale_e
        {
            subpixel_shift = 8,
            subpixel_scale = 1 << subpixel_shift,
            subpixel_mask = subpixel_scale - 1
        }

        //--------------------------------------------------------------------
        public static int line_lr(int v) { return v >> (int)subpixel_scale_e.subpixel_shift; }

        //--------------------------------------------------------------------
        public line_bresenham_interpolator(int x1, int y1, int x2, int y2)
        {
            m_x1_lr = (line_lr(x1));
            m_y1_lr = (line_lr(y1));
            m_x2_lr = (line_lr(x2));
            m_y2_lr = (line_lr(y2));
            m_ver = (Math.Abs(m_x2_lr - m_x1_lr) < Math.Abs(m_y2_lr - m_y1_lr));
            if (m_ver)
            {
                m_len = (int)Math.Abs(m_y2_lr - m_y1_lr);
            }
            else
            {
                m_len = (int)Math.Abs(m_x2_lr - m_x1_lr);
            }

            m_inc = (m_ver ? ((y2 > y1) ? 1 : -1) : ((x2 > x1) ? 1 : -1));
            m_interpolator = new dda2_line_interpolator(m_ver ? x1 : y1,
                           m_ver ? x2 : y2,
                           (int)m_len);
        }

        //--------------------------------------------------------------------
        public bool is_ver() { return m_ver; }
        public int len() { return m_len; }
        public int inc() { return m_inc; }

        //--------------------------------------------------------------------
        public void hstep()
        {
            m_interpolator.Next();
            m_x1_lr += m_inc;
        }

        //--------------------------------------------------------------------
        public void vstep()
        {
            m_interpolator.Next();
            m_y1_lr += m_inc;
        }

        //--------------------------------------------------------------------
        public int x1() { return m_x1_lr; }
        public int y1() { return m_y1_lr; }
        public int x2() { return line_lr(m_interpolator.y()); }
        public int y2() { return line_lr(m_interpolator.y()); }
        public int x2_hr() { return m_interpolator.y(); }
        public int y2_hr() { return m_interpolator.y(); }
    }
}

#endregion //agg_dda_line.cs
#region agg_gamma_functions.cs


//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{
    public interface IGammaFunction
    {
        double GetGamma(double x);
    }

    public struct gamma_none : IGammaFunction
    {
        public double GetGamma(double x) { return x; }
    }


    //==============================================================gamma_power
    public class gamma_power : IGammaFunction
    {
        public gamma_power() { m_gamma = 1.0; }
        public gamma_power(double g) { m_gamma = g; }

        public void gamma(double g) { m_gamma = g; }
        public double gamma() { return m_gamma; }

        public double GetGamma(double x)
        {
            return Math.Pow(x, m_gamma);
        }

        double m_gamma;
    }

    //==========================================================gamma_threshold
    public class gamma_threshold : IGammaFunction
    {
        public gamma_threshold() { m_threshold = 0.5; }
        public gamma_threshold(double t) { m_threshold = t; }

        public void threshold(double t) { m_threshold = t; }
        public double threshold() { return m_threshold; }

        public double GetGamma(double x)
        {
            return (x < m_threshold) ? 0.0 : 1.0;
        }

        double m_threshold;
    }

    //============================================================gamma_linear
    public class gamma_linear : IGammaFunction
    {
        public gamma_linear()
        {
            m_start = (0.0);
            m_end = (1.0);
        }
        public gamma_linear(double s, double e)
        {
            m_start = (s);
            m_end = (e);
        }

        public void set(double s, double e) { m_start = s; m_end = e; }
        public void start(double s) { m_start = s; }
        public void end(double e) { m_end = e; }
        public double start() { return m_start; }
        public double end() { return m_end; }

        public double GetGamma(double x)
        {
            if (x < m_start) return 0.0;
            if (x > m_end) return 1.0;
            double EndMinusStart = m_end - m_start;
            if (EndMinusStart != 0)
                return (x - m_start) / EndMinusStart;
            else
                return 0.0;
        }

        double m_start;
        double m_end;
    }

    //==========================================================gamma_multiply
    public class gamma_multiply : IGammaFunction
    {
        public gamma_multiply()
        {
            m_mul = (1.0);
        }
        public gamma_multiply(double v)
        {
            m_mul = (v);
        }

        public void value(double v) { m_mul = v; }
        public double value() { return m_mul; }

        public double GetGamma(double x)
        {
            double y = x * m_mul;
            if (y > 1.0) y = 1.0;
            return y;
        }

        double m_mul;
    }
}

#endregion //agg_gamma_functions.cs
#region agg_gsv_text.cs


//----------------------------------------------------------------------------
//
// Class gsv_text
//
//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;
//using MatterHackers.VectorMath;

namespace MatterHackers.Agg.VertexSource
{
    [Obsolete("All of these shoud use the new font stuff.  You probably want a StringPrinter or a TextWidget in this spot.")]
    public sealed class gsv_text : IVertexSource
    {
        enum status
        {
            initial,
            next_char,
            start_glyph,
            glyph
        };

        double m_StartX;
        double m_CurrentX;
        double m_CurrentY;
        double m_WidthRatioOfHeight;
        double m_FontSize;
        double m_SpaceBetweenCharacters;
        double m_SpaceBetweenLines;
        string m_Text;
        int m_CurrentCharacterIndex;
        byte[] m_font;
        status m_status;
        int m_StartOfIndicesIndex;
        int m_StartOfGlyphsIndex;
        int m_BeginGlyphIndex;
        int m_EndGlyphIndex;
        double m_WidthScaleRatio;
        double m_HeightScaleRatio;

        public double FontSize
        {
            get
            {
                return m_FontSize;
            }
            set
            {
                m_FontSize = value;
                double base_height = translateIndex(4);
                m_HeightScaleRatio = m_FontSize / base_height;
                m_WidthScaleRatio = m_HeightScaleRatio * m_WidthRatioOfHeight;
            }
        }

        public double AscenderHeight
        {
            get
            {
                return m_FontSize * .15;
            }
        }
        public double DescenderHeight
        {
            get
            {
                return m_FontSize * .2;
            }
        }

        public gsv_text()
        {
            m_font = CGSVDefaultFont.gsv_default_font;
            m_CurrentX = 0.0;
            m_CurrentY = 0.0;
            m_StartX = 0.0;
            m_WidthRatioOfHeight = 1;
            FontSize = 0.0;
            m_SpaceBetweenCharacters = 0.0;
            m_status = status.initial;

            m_SpaceBetweenLines = 0.0;
        }

        /*
        public void font(void* font)
        {
            m_font = font;
            if(m_font == 0) m_font = &m_loaded_font[0];
        }
         */

        public void load_font(string file)
        {
            throw new System.NotImplementedException();
            /*
            m_loaded_font.resize(0);
            FILE* fd = fopen(file, "rb");
            if(fd)
            {
                int len;

                fseek(fd, 0l, SEEK_END);
                len = ftell(fd);
                fseek(fd, 0l, SEEK_SET);
                if(len > 0)
                {
                    m_loaded_font.resize(len);
                    fread(&m_loaded_font[0], 1, len, fd);
                    m_font = &m_loaded_font[0];
                }
                fclose(fd);
            }
             */
        }

        // This will set the desired height.  NOTE: The font may not render at the size that you say.
        // It depends on the way the font was originally created.  A 24 Point font may not actually be 24 points high
        public void SetFontSize(double fontSize)
        {
            SetFontSizeAndWidthRatio(fontSize, 1.0);
        }

        public void SetFontSizeAndWidthRatio(double fontSize, double widthRatioOfHeight)
        {
            if (fontSize == 0 || widthRatioOfHeight == 0)
            {
                throw new System.Exception("You can't have a font with 0 width or height.  Nothing will render.");
            }

            m_WidthRatioOfHeight = widthRatioOfHeight;
            FontSize = fontSize;

            m_SpaceBetweenLines = FontSize * 1.5;
        }

        public void SetSpaceBetweenCharacters(double spaceBetweenCharacters)
        {
            m_SpaceBetweenCharacters = spaceBetweenCharacters;
        }

        public void line_space(double spaceBetweenLines)
        {
            m_SpaceBetweenLines = spaceBetweenLines;
        }

        public void start_point(double x, double y)
        {
            m_CurrentX = m_StartX = x;
            m_CurrentY = y;
        }

        public string Text
        {
            get
            {
                return m_Text;
            }
            set
            {
                m_Text = value;
            }
        }

        public void text(string text)
        {
            m_Text = text;
        }

        private ushort translateIndex(int indicesIndex)
        {
            ushort v;
            v = m_font[indicesIndex + 0];
            v |= (ushort)(m_font[indicesIndex + 1] << 8);
            return v;
        }

        public IEnumerable<VertexData> Vertices()
        {
            throw new NotImplementedException();
        }

        public void rewind(int nothing)
        {
            m_status = status.initial;
            if (m_font == null) return;

            m_StartOfIndicesIndex = translateIndex(0);

            m_StartOfGlyphsIndex = m_StartOfIndicesIndex + 257 * 2; // one for x one for y
            m_CurrentCharacterIndex = 0;
        }

        private void GetSize(char characterToMeasure, out double width, out double height)
        {
            width = 0;
            height = 0;
            if (m_font == null)
            {
                return;
            }

            int maskedChracter = (int)(characterToMeasure & 0xFF);
            if (maskedChracter == '\r' || maskedChracter == '\n')
            {
                height -= (FontSize + m_SpaceBetweenLines);
                return;
            }

            int maskedChracterGlyphIndex = maskedChracter * 2; // we have an x and y in the array so it's * 2.
            int BeginGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex);
            int EndGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex + 2);

            do
            {
                if (BeginGlyphIndex >= EndGlyphIndex)
                {
                    return; // the character has no glyph
                }

                unchecked
                {
                    int DeltaX = (sbyte)m_font[BeginGlyphIndex++];
                    sbyte yc = (sbyte)m_font[BeginGlyphIndex++];

                    yc <<= 1;
                    yc >>= 1;
                    int DeltaY = (int)(yc);
                    width += (double)(DeltaX) * m_WidthScaleRatio;
                    height += (double)(DeltaY) * m_HeightScaleRatio;
                }
            } while (true);
        }

        public int GetCharacterIndexToStartBefore(Vector2 position)
        {
            int clostestIndex = -1;
            double clostestDist = double.MaxValue;
            Vector2 offset;
            offset.x = 0;
            offset.y = 0;
            int characterToMeasureStartIndexInclusive = 0;
            int characterToMeasureEndIndexInclusive = m_Text.Length - 1;
            if (m_Text.Length > 0)
            {
                characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, m_Text.Length - 1));
                characterToMeasureEndIndexInclusive = Math.Max(0, Math.Min(characterToMeasureEndIndexInclusive, m_Text.Length - 1));
                for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
                {
                    Vector2 delta = offset - position;
                    double distToChar = delta.Length;
                    if (distToChar < clostestDist)
                    {
                        clostestDist = distToChar;
                        clostestIndex = i;
                    }

                    char singleChar = m_Text[i];
                    if (singleChar == '\r' || singleChar == '\n')
                    {
                        offset.x = 0;
                        offset.y -= FontSize + m_SpaceBetweenLines;
                    }
                    else
                    {
                        double sigleWidth;
                        double sigleHeight;
                        GetSize(singleChar, out sigleWidth, out sigleHeight);
                        offset.x += sigleWidth + m_SpaceBetweenCharacters;
                        offset.y += sigleHeight;
                    }
                }

                Vector2 lastDelta = offset - position;
                double lastDistToChar = lastDelta.Length;
                if (lastDistToChar < clostestDist)
                {
                    clostestDist = lastDistToChar;
                    // we need to start after the lats character, or before the character after the last.
                    clostestIndex = characterToMeasureEndIndexInclusive + 1;
                }
            }

            return clostestIndex;
        }

        public void GetSize(out Vector2 pixelSize)
        {
            GetSize(0, m_Text.Length - 1, out pixelSize);
        }

        public void GetSize(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive, out Vector2 pixelSize)
        {
            double currentX = 0;
            pixelSize.x = 0;
            pixelSize.y = 0;
            if (m_Text.Length > 0)
            {
                characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, m_Text.Length - 1));
                characterToMeasureEndIndexInclusive = Math.Max(0, Math.Min(characterToMeasureEndIndexInclusive, m_Text.Length - 1));
                for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
                {
                    char singleChar = m_Text[i];
                    if (singleChar == '\r' || singleChar == '\n')
                    {
                        currentX = 0;
                        pixelSize.y -= FontSize + m_SpaceBetweenLines;
                    }
                    else
                    {
                        double sigleWidth;
                        double sigleHeight;
                        GetSize(singleChar, out sigleWidth, out sigleHeight);
                        currentX += sigleWidth + m_SpaceBetweenCharacters;
                        pixelSize.x = Math.Max(currentX, pixelSize.x);
                        pixelSize.y += sigleHeight;
                    }
                }
            }
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = 0;
            y = 0;
            bool quit = false;

            while (!quit)
            {
                switch (m_status)
                {
                    case status.initial:
                        if (m_font == null)
                        {
                            quit = true;
                            break;
                        }
                        m_status = status.next_char;
                        goto case status.next_char;

                    case status.next_char:
                        if (m_CurrentCharacterIndex == m_Text.Length)
                        {
                            quit = true;
                            break;
                        }
                        int maskedChracter = (int)((m_Text[m_CurrentCharacterIndex++]) & 0xFF);
                        if (maskedChracter == '\r' || maskedChracter == '\n')
                        {
                            m_CurrentX = m_StartX;
                            m_CurrentY -= FontSize + m_SpaceBetweenLines;
                            break;
                        }
                        int maskedChracterGlyphIndex = maskedChracter * 2; // we have an x and y in the array so it's * 2.
                        m_BeginGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex);
                        m_EndGlyphIndex = m_StartOfGlyphsIndex + translateIndex(m_StartOfIndicesIndex + maskedChracterGlyphIndex + 2);
                        m_status = status.start_glyph;
                        goto case status.start_glyph;

                    case status.start_glyph:
                        x = m_CurrentX;
                        y = m_CurrentY;
                        m_status = status.glyph;
                        return ShapePath.FlagsAndCommand.CommandMoveTo;

                    case status.glyph:
                        if (m_BeginGlyphIndex >= m_EndGlyphIndex)
                        {
                            m_status = status.next_char;
                            m_CurrentX += m_SpaceBetweenCharacters;
                            break;
                        }

                        sbyte IsAMoveTo_Flag;
                        unchecked
                        {
                            int DeltaX = (sbyte)m_font[m_BeginGlyphIndex++];
                            sbyte yc = (sbyte)m_font[m_BeginGlyphIndex++];

                            IsAMoveTo_Flag = (sbyte)(yc & 0x80);
                            yc <<= 1;
                            yc >>= 1;
                            int DeltaY = (int)(yc);
                            m_CurrentX += (double)(DeltaX) * m_WidthScaleRatio;
                            m_CurrentY += (double)(DeltaY) * m_HeightScaleRatio;
                        }
                        x = m_CurrentX;
                        y = m_CurrentY;
                        if (IsAMoveTo_Flag != 0)
                        {
                            return ShapePath.FlagsAndCommand.CommandMoveTo;
                        }

                        return ShapePath.FlagsAndCommand.CommandLineTo;

                    default:
                        throw new System.Exception("Unknown Status");
                }
            }

            return ShapePath.FlagsAndCommand.CommandStop;
        }
    };

    internal static class CGSVDefaultFont
    {
        static public byte[] gsv_default_font = 
		{
			0x40,0x00,0x6c,0x0f,0x15,0x00,0x0e,0x00,0xf9,0xff,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x0d,0x0a,0x0d,0x0a,0x46,0x6f,0x6e,0x74,0x20,0x28,
			0x63,0x29,0x20,0x4d,0x69,0x63,0x72,0x6f,0x50,0x72,
			0x6f,0x66,0x20,0x32,0x37,0x20,0x53,0x65,0x70,0x74,
			0x65,0x6d,0x62,0x2e,0x31,0x39,0x38,0x39,0x00,0x0d,
			0x0a,0x0d,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x02,0x00,0x12,0x00,0x34,0x00,0x46,0x00,0x94,0x00,
			0xd0,0x00,0x2e,0x01,0x3e,0x01,0x64,0x01,0x8a,0x01,
			0x98,0x01,0xa2,0x01,0xb4,0x01,0xba,0x01,0xc6,0x01,
			0xcc,0x01,0xf0,0x01,0xfa,0x01,0x18,0x02,0x38,0x02,
			0x44,0x02,0x68,0x02,0x98,0x02,0xa2,0x02,0xde,0x02,
			0x0e,0x03,0x24,0x03,0x40,0x03,0x48,0x03,0x52,0x03,
			0x5a,0x03,0x82,0x03,0xec,0x03,0xfa,0x03,0x26,0x04,
			0x4c,0x04,0x6a,0x04,0x7c,0x04,0x8a,0x04,0xb6,0x04,
			0xc4,0x04,0xca,0x04,0xe0,0x04,0xee,0x04,0xf8,0x04,
			0x0a,0x05,0x18,0x05,0x44,0x05,0x5e,0x05,0x8e,0x05,
			0xac,0x05,0xd6,0x05,0xe0,0x05,0xf6,0x05,0x00,0x06,
			0x12,0x06,0x1c,0x06,0x28,0x06,0x36,0x06,0x48,0x06,
			0x4e,0x06,0x60,0x06,0x6e,0x06,0x74,0x06,0x84,0x06,
			0xa6,0x06,0xc8,0x06,0xe6,0x06,0x08,0x07,0x2c,0x07,
			0x3c,0x07,0x68,0x07,0x7c,0x07,0x8c,0x07,0xa2,0x07,
			0xb0,0x07,0xb6,0x07,0xd8,0x07,0xec,0x07,0x10,0x08,
			0x32,0x08,0x54,0x08,0x64,0x08,0x88,0x08,0x98,0x08,
			0xac,0x08,0xb6,0x08,0xc8,0x08,0xd2,0x08,0xe4,0x08,
			0xf2,0x08,0x3e,0x09,0x48,0x09,0x94,0x09,0xc2,0x09,
			0xc4,0x09,0xd0,0x09,0xe2,0x09,0x04,0x0a,0x0e,0x0a,
			0x26,0x0a,0x34,0x0a,0x4a,0x0a,0x66,0x0a,0x70,0x0a,
			0x7e,0x0a,0x8e,0x0a,0x9a,0x0a,0xa6,0x0a,0xb4,0x0a,
			0xd8,0x0a,0xe2,0x0a,0xf6,0x0a,0x18,0x0b,0x22,0x0b,
			0x32,0x0b,0x56,0x0b,0x60,0x0b,0x6e,0x0b,0x7c,0x0b,
			0x8a,0x0b,0x9c,0x0b,0x9e,0x0b,0xb2,0x0b,0xc2,0x0b,
			0xd8,0x0b,0xf4,0x0b,0x08,0x0c,0x30,0x0c,0x56,0x0c,
			0x72,0x0c,0x90,0x0c,0xb2,0x0c,0xce,0x0c,0xe2,0x0c,
			0xfe,0x0c,0x10,0x0d,0x26,0x0d,0x36,0x0d,0x42,0x0d,
			0x4e,0x0d,0x5c,0x0d,0x78,0x0d,0x8c,0x0d,0x8e,0x0d,
			0x90,0x0d,0x92,0x0d,0x94,0x0d,0x96,0x0d,0x98,0x0d,
			0x9a,0x0d,0x9c,0x0d,0x9e,0x0d,0xa0,0x0d,0xa2,0x0d,
			0xa4,0x0d,0xa6,0x0d,0xa8,0x0d,0xaa,0x0d,0xac,0x0d,
			0xae,0x0d,0xb0,0x0d,0xb2,0x0d,0xb4,0x0d,0xb6,0x0d,
			0xb8,0x0d,0xba,0x0d,0xbc,0x0d,0xbe,0x0d,0xc0,0x0d,
			0xc2,0x0d,0xc4,0x0d,0xc6,0x0d,0xc8,0x0d,0xca,0x0d,
			0xcc,0x0d,0xce,0x0d,0xd0,0x0d,0xd2,0x0d,0xd4,0x0d,
			0xd6,0x0d,0xd8,0x0d,0xda,0x0d,0xdc,0x0d,0xde,0x0d,
			0xe0,0x0d,0xe2,0x0d,0xe4,0x0d,0xe6,0x0d,0xe8,0x0d,
			0xea,0x0d,0xec,0x0d,0x0c,0x0e,0x26,0x0e,0x48,0x0e,
			0x64,0x0e,0x88,0x0e,0x92,0x0e,0xa6,0x0e,0xb4,0x0e,
			0xd0,0x0e,0xee,0x0e,0x02,0x0f,0x16,0x0f,0x26,0x0f,
			0x3c,0x0f,0x58,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,
			0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,
			0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,
			0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x6c,0x0f,0x10,0x80,
			0x05,0x95,0x00,0x72,0x00,0xfb,0xff,0x7f,0x01,0x7f,
			0x01,0x01,0xff,0x01,0x05,0xfe,0x05,0x95,0xff,0x7f,
			0x00,0x7a,0x01,0x86,0xff,0x7a,0x01,0x87,0x01,0x7f,
			0xfe,0x7a,0x0a,0x87,0xff,0x7f,0x00,0x7a,0x01,0x86,
			0xff,0x7a,0x01,0x87,0x01,0x7f,0xfe,0x7a,0x05,0xf2,
			0x0b,0x95,0xf9,0x64,0x0d,0x9c,0xf9,0x64,0xfa,0x91,
			0x0e,0x00,0xf1,0xfa,0x0e,0x00,0x04,0xfc,0x08,0x99,
			0x00,0x63,0x04,0x9d,0x00,0x63,0x04,0x96,0xff,0x7f,
			0x01,0x7f,0x01,0x01,0x00,0x01,0xfe,0x02,0xfd,0x01,
			0xfc,0x00,0xfd,0x7f,0xfe,0x7e,0x00,0x7e,0x01,0x7e,
			0x01,0x7f,0x02,0x7f,0x06,0x7e,0x02,0x7f,0x02,0x7e,
			0xf2,0x89,0x02,0x7e,0x02,0x7f,0x06,0x7e,0x02,0x7f,
			0x01,0x7f,0x01,0x7e,0x00,0x7c,0xfe,0x7e,0xfd,0x7f,
			0xfc,0x00,0xfd,0x01,0xfe,0x02,0x00,0x01,0x01,0x01,
			0x01,0x7f,0xff,0x7f,0x10,0xfd,0x15,0x95,0xee,0x6b,
			0x05,0x95,0x02,0x7e,0x00,0x7e,0xff,0x7e,0xfe,0x7f,
			0xfe,0x00,0xfe,0x02,0x00,0x02,0x01,0x02,0x02,0x01,
			0x02,0x00,0x02,0x7f,0x03,0x7f,0x03,0x00,0x03,0x01,
			0x02,0x01,0xfc,0xf2,0xfe,0x7f,0xff,0x7e,0x00,0x7e,
			0x02,0x7e,0x02,0x00,0x02,0x01,0x01,0x02,0x00,0x02,
			0xfe,0x02,0xfe,0x00,0x07,0xf9,0x15,0x8d,0xff,0x7f,
			0x01,0x7f,0x01,0x01,0x00,0x01,0xff,0x01,0xff,0x00,
			0xff,0x7f,0xff,0x7e,0xfe,0x7b,0xfe,0x7d,0xfe,0x7e,
			0xfe,0x7f,0xfd,0x00,0xfd,0x01,0xff,0x02,0x00,0x03,
			0x01,0x02,0x06,0x04,0x02,0x02,0x01,0x02,0x00,0x02,
			0xff,0x02,0xfe,0x01,0xfe,0x7f,0xff,0x7e,0x00,0x7e,
			0x01,0x7d,0x02,0x7d,0x05,0x79,0x02,0x7e,0x03,0x7f,
			0x01,0x00,0x01,0x01,0x00,0x01,0xf1,0xfe,0xfe,0x01,
			0xff,0x02,0x00,0x03,0x01,0x02,0x02,0x02,0x00,0x86,
			0x01,0x7e,0x08,0x75,0x02,0x7e,0x02,0x7f,0x05,0x80,
			0x05,0x93,0xff,0x01,0x01,0x01,0x01,0x7f,0x00,0x7e,
			0xff,0x7e,0xff,0x7f,0x06,0xf1,0x0b,0x99,0xfe,0x7e,
			0xfe,0x7d,0xfe,0x7c,0xff,0x7b,0x00,0x7c,0x01,0x7b,
			0x02,0x7c,0x02,0x7d,0x02,0x7e,0xfe,0x9e,0xfe,0x7c,
			0xff,0x7d,0xff,0x7b,0x00,0x7c,0x01,0x7b,0x01,0x7d,
			0x02,0x7c,0x05,0x85,0x03,0x99,0x02,0x7e,0x02,0x7d,
			0x02,0x7c,0x01,0x7b,0x00,0x7c,0xff,0x7b,0xfe,0x7c,
			0xfe,0x7d,0xfe,0x7e,0x02,0x9e,0x02,0x7c,0x01,0x7d,
			0x01,0x7b,0x00,0x7c,0xff,0x7b,0xff,0x7d,0xfe,0x7c,
			0x09,0x85,0x08,0x95,0x00,0x74,0xfb,0x89,0x0a,0x7a,
			0x00,0x86,0xf6,0x7a,0x0d,0xf4,0x0d,0x92,0x00,0x6e,
			0xf7,0x89,0x12,0x00,0x04,0xf7,0x06,0x81,0xff,0x7f,
			0xff,0x01,0x01,0x01,0x01,0x7f,0x00,0x7e,0xff,0x7e,
			0xff,0x7f,0x06,0x84,0x04,0x89,0x12,0x00,0x04,0xf7,
			0x05,0x82,0xff,0x7f,0x01,0x7f,0x01,0x01,0xff,0x01,
			0x05,0xfe,0x00,0xfd,0x0e,0x18,0x00,0xeb,0x09,0x95,
			0xfd,0x7f,0xfe,0x7d,0xff,0x7b,0x00,0x7d,0x01,0x7b,
			0x02,0x7d,0x03,0x7f,0x02,0x00,0x03,0x01,0x02,0x03,
			0x01,0x05,0x00,0x03,0xff,0x05,0xfe,0x03,0xfd,0x01,
			0xfe,0x00,0x0b,0xeb,0x06,0x91,0x02,0x01,0x03,0x03,
			0x00,0x6b,0x09,0x80,0x04,0x90,0x00,0x01,0x01,0x02,
			0x01,0x01,0x02,0x01,0x04,0x00,0x02,0x7f,0x01,0x7f,
			0x01,0x7e,0x00,0x7e,0xff,0x7e,0xfe,0x7d,0xf6,0x76,
			0x0e,0x00,0x03,0x80,0x05,0x95,0x0b,0x00,0xfa,0x78,
			0x03,0x00,0x02,0x7f,0x01,0x7f,0x01,0x7d,0x00,0x7e,
			0xff,0x7d,0xfe,0x7e,0xfd,0x7f,0xfd,0x00,0xfd,0x01,
			0xff,0x01,0xff,0x02,0x11,0xfc,0x0d,0x95,0xf6,0x72,
			0x0f,0x00,0xfb,0x8e,0x00,0x6b,0x07,0x80,0x0f,0x95,
			0xf6,0x00,0xff,0x77,0x01,0x01,0x03,0x01,0x03,0x00,
			0x03,0x7f,0x02,0x7e,0x01,0x7d,0x00,0x7e,0xff,0x7d,
			0xfe,0x7e,0xfd,0x7f,0xfd,0x00,0xfd,0x01,0xff,0x01,
			0xff,0x02,0x11,0xfc,0x10,0x92,0xff,0x02,0xfd,0x01,
			0xfe,0x00,0xfd,0x7f,0xfe,0x7d,0xff,0x7b,0x00,0x7b,
			0x01,0x7c,0x02,0x7e,0x03,0x7f,0x01,0x00,0x03,0x01,
			0x02,0x02,0x01,0x03,0x00,0x01,0xff,0x03,0xfe,0x02,
			0xfd,0x01,0xff,0x00,0xfd,0x7f,0xfe,0x7e,0xff,0x7d,
			0x10,0xf9,0x11,0x95,0xf6,0x6b,0xfc,0x95,0x0e,0x00,
			0x03,0xeb,0x08,0x95,0xfd,0x7f,0xff,0x7e,0x00,0x7e,
			0x01,0x7e,0x02,0x7f,0x04,0x7f,0x03,0x7f,0x02,0x7e,
			0x01,0x7e,0x00,0x7d,0xff,0x7e,0xff,0x7f,0xfd,0x7f,
			0xfc,0x00,0xfd,0x01,0xff,0x01,0xff,0x02,0x00,0x03,
			0x01,0x02,0x02,0x02,0x03,0x01,0x04,0x01,0x02,0x01,
			0x01,0x02,0x00,0x02,0xff,0x02,0xfd,0x01,0xfc,0x00,
			0x0c,0xeb,0x10,0x8e,0xff,0x7d,0xfe,0x7e,0xfd,0x7f,
			0xff,0x00,0xfd,0x01,0xfe,0x02,0xff,0x03,0x00,0x01,
			0x01,0x03,0x02,0x02,0x03,0x01,0x01,0x00,0x03,0x7f,
			0x02,0x7e,0x01,0x7c,0x00,0x7b,0xff,0x7b,0xfe,0x7d,
			0xfd,0x7f,0xfe,0x00,0xfd,0x01,0xff,0x02,0x10,0xfd,
			0x05,0x8e,0xff,0x7f,0x01,0x7f,0x01,0x01,0xff,0x01,
			0x00,0xf4,0xff,0x7f,0x01,0x7f,0x01,0x01,0xff,0x01,
			0x05,0xfe,0x05,0x8e,0xff,0x7f,0x01,0x7f,0x01,0x01,
			0xff,0x01,0x01,0xf3,0xff,0x7f,0xff,0x01,0x01,0x01,
			0x01,0x7f,0x00,0x7e,0xff,0x7e,0xff,0x7f,0x06,0x84,
			0x14,0x92,0xf0,0x77,0x10,0x77,0x04,0x80,0x04,0x8c,
			0x12,0x00,0xee,0xfa,0x12,0x00,0x04,0xfa,0x04,0x92,
			0x10,0x77,0xf0,0x77,0x14,0x80,0x03,0x90,0x00,0x01,
			0x01,0x02,0x01,0x01,0x02,0x01,0x04,0x00,0x02,0x7f,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xff,0x7e,0xff,0x7f,
			0xfc,0x7e,0x00,0x7d,0x00,0xfb,0xff,0x7f,0x01,0x7f,
			0x01,0x01,0xff,0x01,0x09,0xfe,0x12,0x8d,0xff,0x02,
			0xfe,0x01,0xfd,0x00,0xfe,0x7f,0xff,0x7f,0xff,0x7d,
			0x00,0x7d,0x01,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x01,0x02,0xfb,0x88,0xfe,0x7e,0xff,0x7d,0x00,0x7d,
			0x01,0x7e,0x01,0x7f,0x07,0x8b,0xff,0x78,0x00,0x7e,
			0x02,0x7f,0x02,0x00,0x02,0x02,0x01,0x03,0x00,0x02,
			0xff,0x03,0xff,0x02,0xfe,0x02,0xfe,0x01,0xfd,0x01,
			0xfd,0x00,0xfd,0x7f,0xfe,0x7f,0xfe,0x7e,0xff,0x7e,
			0xff,0x7d,0x00,0x7d,0x01,0x7d,0x01,0x7e,0x02,0x7e,
			0x02,0x7f,0x03,0x7f,0x03,0x00,0x03,0x01,0x02,0x01,
			0x01,0x01,0xfe,0x8d,0xff,0x78,0x00,0x7e,0x01,0x7f,
			0x08,0xfb,0x09,0x95,0xf8,0x6b,0x08,0x95,0x08,0x6b,
			0xf3,0x87,0x0a,0x00,0x04,0xf9,0x04,0x95,0x00,0x6b,
			0x00,0x95,0x09,0x00,0x03,0x7f,0x01,0x7f,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xff,0x7f,0xfd,0x7f,0xf7,0x80,
			0x09,0x00,0x03,0x7f,0x01,0x7f,0x01,0x7e,0x00,0x7d,
			0xff,0x7e,0xff,0x7f,0xfd,0x7f,0xf7,0x00,0x11,0x80,
			0x12,0x90,0xff,0x02,0xfe,0x02,0xfe,0x01,0xfc,0x00,
			0xfe,0x7f,0xfe,0x7e,0xff,0x7e,0xff,0x7d,0x00,0x7b,
			0x01,0x7d,0x01,0x7e,0x02,0x7e,0x02,0x7f,0x04,0x00,
			0x02,0x01,0x02,0x02,0x01,0x02,0x03,0xfb,0x04,0x95,
			0x00,0x6b,0x00,0x95,0x07,0x00,0x03,0x7f,0x02,0x7e,
			0x01,0x7e,0x01,0x7d,0x00,0x7b,0xff,0x7d,0xff,0x7e,
			0xfe,0x7e,0xfd,0x7f,0xf9,0x00,0x11,0x80,0x04,0x95,
			0x00,0x6b,0x00,0x95,0x0d,0x00,0xf3,0xf6,0x08,0x00,
			0xf8,0xf5,0x0d,0x00,0x02,0x80,0x04,0x95,0x00,0x6b,
			0x00,0x95,0x0d,0x00,0xf3,0xf6,0x08,0x00,0x06,0xf5,
			0x12,0x90,0xff,0x02,0xfe,0x02,0xfe,0x01,0xfc,0x00,
			0xfe,0x7f,0xfe,0x7e,0xff,0x7e,0xff,0x7d,0x00,0x7b,
			0x01,0x7d,0x01,0x7e,0x02,0x7e,0x02,0x7f,0x04,0x00,
			0x02,0x01,0x02,0x02,0x01,0x02,0x00,0x03,0xfb,0x80,
			0x05,0x00,0x03,0xf8,0x04,0x95,0x00,0x6b,0x0e,0x95,
			0x00,0x6b,0xf2,0x8b,0x0e,0x00,0x04,0xf5,0x04,0x95,
			0x00,0x6b,0x04,0x80,0x0c,0x95,0x00,0x70,0xff,0x7d,
			0xff,0x7f,0xfe,0x7f,0xfe,0x00,0xfe,0x01,0xff,0x01,
			0xff,0x03,0x00,0x02,0x0e,0xf9,0x04,0x95,0x00,0x6b,
			0x0e,0x95,0xf2,0x72,0x05,0x85,0x09,0x74,0x03,0x80,
			0x04,0x95,0x00,0x6b,0x00,0x80,0x0c,0x00,0x01,0x80,
			0x04,0x95,0x00,0x6b,0x00,0x95,0x08,0x6b,0x08,0x95,
			0xf8,0x6b,0x08,0x95,0x00,0x6b,0x04,0x80,0x04,0x95,
			0x00,0x6b,0x00,0x95,0x0e,0x6b,0x00,0x95,0x00,0x6b,
			0x04,0x80,0x09,0x95,0xfe,0x7f,0xfe,0x7e,0xff,0x7e,
			0xff,0x7d,0x00,0x7b,0x01,0x7d,0x01,0x7e,0x02,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x02,0x02,0x01,0x02,
			0x01,0x03,0x00,0x05,0xff,0x03,0xff,0x02,0xfe,0x02,
			0xfe,0x01,0xfc,0x00,0x0d,0xeb,0x04,0x95,0x00,0x6b,
			0x00,0x95,0x09,0x00,0x03,0x7f,0x01,0x7f,0x01,0x7e,
			0x00,0x7d,0xff,0x7e,0xff,0x7f,0xfd,0x7f,0xf7,0x00,
			0x11,0xf6,0x09,0x95,0xfe,0x7f,0xfe,0x7e,0xff,0x7e,
			0xff,0x7d,0x00,0x7b,0x01,0x7d,0x01,0x7e,0x02,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x02,0x02,0x01,0x02,
			0x01,0x03,0x00,0x05,0xff,0x03,0xff,0x02,0xfe,0x02,
			0xfe,0x01,0xfc,0x00,0x03,0xef,0x06,0x7a,0x04,0x82,
			0x04,0x95,0x00,0x6b,0x00,0x95,0x09,0x00,0x03,0x7f,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xff,0x7e,0xff,0x7f,
			0xfd,0x7f,0xf7,0x00,0x07,0x80,0x07,0x75,0x03,0x80,
			0x11,0x92,0xfe,0x02,0xfd,0x01,0xfc,0x00,0xfd,0x7f,
			0xfe,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,0x02,0x7f,
			0x06,0x7e,0x02,0x7f,0x01,0x7f,0x01,0x7e,0x00,0x7d,
			0xfe,0x7e,0xfd,0x7f,0xfc,0x00,0xfd,0x01,0xfe,0x02,
			0x11,0xfd,0x08,0x95,0x00,0x6b,0xf9,0x95,0x0e,0x00,
			0x01,0xeb,0x04,0x95,0x00,0x71,0x01,0x7d,0x02,0x7e,
			0x03,0x7f,0x02,0x00,0x03,0x01,0x02,0x02,0x01,0x03,
			0x00,0x0f,0x04,0xeb,0x01,0x95,0x08,0x6b,0x08,0x95,
			0xf8,0x6b,0x09,0x80,0x02,0x95,0x05,0x6b,0x05,0x95,
			0xfb,0x6b,0x05,0x95,0x05,0x6b,0x05,0x95,0xfb,0x6b,
			0x07,0x80,0x03,0x95,0x0e,0x6b,0x00,0x95,0xf2,0x6b,
			0x11,0x80,0x01,0x95,0x08,0x76,0x00,0x75,0x08,0x95,
			0xf8,0x76,0x09,0xf5,0x11,0x95,0xf2,0x6b,0x00,0x95,
			0x0e,0x00,0xf2,0xeb,0x0e,0x00,0x03,0x80,0x03,0x93,
			0x00,0x6c,0x01,0x94,0x00,0x6c,0xff,0x94,0x05,0x00,
			0xfb,0xec,0x05,0x00,0x02,0x81,0x00,0x95,0x0e,0x68,
			0x00,0x83,0x06,0x93,0x00,0x6c,0x01,0x94,0x00,0x6c,
			0xfb,0x94,0x05,0x00,0xfb,0xec,0x05,0x00,0x03,0x81,
			0x03,0x87,0x08,0x05,0x08,0x7b,0xf0,0x80,0x08,0x04,
			0x08,0x7c,0x03,0xf9,0x01,0x80,0x10,0x00,0x01,0x80,
			0x06,0x95,0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7f,
			0x01,0x01,0xff,0x01,0x05,0xef,0x0f,0x8e,0x00,0x72,
			0x00,0x8b,0xfe,0x02,0xfe,0x01,0xfd,0x00,0xfe,0x7f,
			0xfe,0x7e,0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,
			0x02,0x7f,0x03,0x00,0x02,0x01,0x02,0x02,0x04,0xfd,
			0x04,0x95,0x00,0x6b,0x00,0x8b,0x02,0x02,0x02,0x01,
			0x03,0x00,0x02,0x7f,0x02,0x7e,0x01,0x7d,0x00,0x7e,
			0xff,0x7d,0xfe,0x7e,0xfe,0x7f,0xfd,0x00,0xfe,0x01,
			0xfe,0x02,0x0f,0xfd,0x0f,0x8b,0xfe,0x02,0xfe,0x01,
			0xfd,0x00,0xfe,0x7f,0xfe,0x7e,0xff,0x7d,0x00,0x7e,
			0x01,0x7d,0x02,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x02,0x02,0x03,0xfd,0x0f,0x95,0x00,0x6b,0x00,0x8b,
			0xfe,0x02,0xfe,0x01,0xfd,0x00,0xfe,0x7f,0xfe,0x7e,
			0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,0x02,0x7f,
			0x03,0x00,0x02,0x01,0x02,0x02,0x04,0xfd,0x03,0x88,
			0x0c,0x00,0x00,0x02,0xff,0x02,0xff,0x01,0xfe,0x01,
			0xfd,0x00,0xfe,0x7f,0xfe,0x7e,0xff,0x7d,0x00,0x7e,
			0x01,0x7d,0x02,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x02,0x02,0x03,0xfd,0x0a,0x95,0xfe,0x00,0xfe,0x7f,
			0xff,0x7d,0x00,0x6f,0xfd,0x8e,0x07,0x00,0x03,0xf2,
			0x0f,0x8e,0x00,0x70,0xff,0x7d,0xff,0x7f,0xfe,0x7f,
			0xfd,0x00,0xfe,0x01,0x09,0x91,0xfe,0x02,0xfe,0x01,
			0xfd,0x00,0xfe,0x7f,0xfe,0x7e,0xff,0x7d,0x00,0x7e,
			0x01,0x7d,0x02,0x7e,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x02,0x02,0x04,0xfd,0x04,0x95,0x00,0x6b,0x00,0x8a,
			0x03,0x03,0x02,0x01,0x03,0x00,0x02,0x7f,0x01,0x7d,
			0x00,0x76,0x04,0x80,0x03,0x95,0x01,0x7f,0x01,0x01,
			0xff,0x01,0xff,0x7f,0x01,0xf9,0x00,0x72,0x04,0x80,
			0x05,0x95,0x01,0x7f,0x01,0x01,0xff,0x01,0xff,0x7f,
			0x01,0xf9,0x00,0x6f,0xff,0x7d,0xfe,0x7f,0xfe,0x00,
			0x09,0x87,0x04,0x95,0x00,0x6b,0x0a,0x8e,0xf6,0x76,
			0x04,0x84,0x07,0x78,0x02,0x80,0x04,0x95,0x00,0x6b,
			0x04,0x80,0x04,0x8e,0x00,0x72,0x00,0x8a,0x03,0x03,
			0x02,0x01,0x03,0x00,0x02,0x7f,0x01,0x7d,0x00,0x76,
			0x00,0x8a,0x03,0x03,0x02,0x01,0x03,0x00,0x02,0x7f,
			0x01,0x7d,0x00,0x76,0x04,0x80,0x04,0x8e,0x00,0x72,
			0x00,0x8a,0x03,0x03,0x02,0x01,0x03,0x00,0x02,0x7f,
			0x01,0x7d,0x00,0x76,0x04,0x80,0x08,0x8e,0xfe,0x7f,
			0xfe,0x7e,0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,
			0x02,0x7f,0x03,0x00,0x02,0x01,0x02,0x02,0x01,0x03,
			0x00,0x02,0xff,0x03,0xfe,0x02,0xfe,0x01,0xfd,0x00,
			0x0b,0xf2,0x04,0x8e,0x00,0x6b,0x00,0x92,0x02,0x02,
			0x02,0x01,0x03,0x00,0x02,0x7f,0x02,0x7e,0x01,0x7d,
			0x00,0x7e,0xff,0x7d,0xfe,0x7e,0xfe,0x7f,0xfd,0x00,
			0xfe,0x01,0xfe,0x02,0x0f,0xfd,0x0f,0x8e,0x00,0x6b,
			0x00,0x92,0xfe,0x02,0xfe,0x01,0xfd,0x00,0xfe,0x7f,
			0xfe,0x7e,0xff,0x7d,0x00,0x7e,0x01,0x7d,0x02,0x7e,
			0x02,0x7f,0x03,0x00,0x02,0x01,0x02,0x02,0x04,0xfd,
			0x04,0x8e,0x00,0x72,0x00,0x88,0x01,0x03,0x02,0x02,
			0x02,0x01,0x03,0x00,0x01,0xf2,0x0e,0x8b,0xff,0x02,
			0xfd,0x01,0xfd,0x00,0xfd,0x7f,0xff,0x7e,0x01,0x7e,
			0x02,0x7f,0x05,0x7f,0x02,0x7f,0x01,0x7e,0x00,0x7f,
			0xff,0x7e,0xfd,0x7f,0xfd,0x00,0xfd,0x01,0xff,0x02,
			0x0e,0xfd,0x05,0x95,0x00,0x6f,0x01,0x7d,0x02,0x7f,
			0x02,0x00,0xf8,0x8e,0x07,0x00,0x03,0xf2,0x04,0x8e,
			0x00,0x76,0x01,0x7d,0x02,0x7f,0x03,0x00,0x02,0x01,
			0x03,0x03,0x00,0x8a,0x00,0x72,0x04,0x80,0x02,0x8e,
			0x06,0x72,0x06,0x8e,0xfa,0x72,0x08,0x80,0x03,0x8e,
			0x04,0x72,0x04,0x8e,0xfc,0x72,0x04,0x8e,0x04,0x72,
			0x04,0x8e,0xfc,0x72,0x07,0x80,0x03,0x8e,0x0b,0x72,
			0x00,0x8e,0xf5,0x72,0x0e,0x80,0x02,0x8e,0x06,0x72,
			0x06,0x8e,0xfa,0x72,0xfe,0x7c,0xfe,0x7e,0xfe,0x7f,
			0xff,0x00,0x0f,0x87,0x0e,0x8e,0xf5,0x72,0x00,0x8e,
			0x0b,0x00,0xf5,0xf2,0x0b,0x00,0x03,0x80,0x09,0x99,
			0xfe,0x7f,0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7e,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xfe,0x7e,0x01,0x8e,
			0xff,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xfc,0x7e,0x04,0x7e,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xff,0x7f,0xff,0x7e,0x00,0x7e,
			0x01,0x7e,0xff,0x8e,0x02,0x7e,0x00,0x7e,0xff,0x7e,
			0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,
			0x02,0x7f,0x05,0x87,0x04,0x95,0x00,0x77,0x00,0xfd,
			0x00,0x77,0x04,0x80,0x05,0x99,0x02,0x7f,0x01,0x7f,
			0x01,0x7e,0x00,0x7e,0xff,0x7e,0xff,0x7f,0xff,0x7e,
			0x00,0x7e,0x02,0x7e,0xff,0x8e,0x01,0x7e,0x00,0x7e,
			0xff,0x7e,0xff,0x7f,0xff,0x7e,0x00,0x7e,0x01,0x7e,
			0x04,0x7e,0xfc,0x7e,0xff,0x7e,0x00,0x7e,0x01,0x7e,
			0x01,0x7f,0x01,0x7e,0x00,0x7e,0xff,0x7e,0x01,0x8e,
			0xfe,0x7e,0x00,0x7e,0x01,0x7e,0x01,0x7f,0x01,0x7e,
			0x00,0x7e,0xff,0x7e,0xff,0x7f,0xfe,0x7f,0x09,0x87,
			0x03,0x86,0x00,0x02,0x01,0x03,0x02,0x01,0x02,0x00,
			0x02,0x7f,0x04,0x7d,0x02,0x7f,0x02,0x00,0x02,0x01,
			0x01,0x02,0xee,0xfe,0x01,0x02,0x02,0x01,0x02,0x00,
			0x02,0x7f,0x04,0x7d,0x02,0x7f,0x02,0x00,0x02,0x01,
			0x01,0x03,0x00,0x02,0x03,0xf4,0x10,0x80,0x03,0x80,
			0x07,0x15,0x08,0x6b,0xfe,0x85,0xf5,0x00,0x10,0xfb,
			0x0d,0x95,0xf6,0x00,0x00,0x6b,0x0a,0x00,0x02,0x02,
			0x00,0x08,0xfe,0x02,0xf6,0x00,0x0e,0xf4,0x03,0x80,
			0x00,0x15,0x0a,0x00,0x02,0x7e,0x00,0x7e,0x00,0x7d,
			0x00,0x7e,0xfe,0x7f,0xf6,0x00,0x0a,0x80,0x02,0x7e,
			0x01,0x7e,0x00,0x7d,0xff,0x7d,0xfe,0x7f,0xf6,0x00,
			0x10,0x80,0x03,0x80,0x00,0x15,0x0c,0x00,0xff,0x7e,
			0x03,0xed,0x03,0xfd,0x00,0x03,0x02,0x00,0x00,0x12,
			0x02,0x03,0x0a,0x00,0x00,0x6b,0x02,0x00,0x00,0x7d,
			0xfe,0x83,0xf4,0x00,0x11,0x80,0x0f,0x80,0xf4,0x00,
			0x00,0x15,0x0c,0x00,0xff,0xf6,0xf5,0x00,0x0f,0xf5,
			0x04,0x95,0x07,0x76,0x00,0x0a,0x07,0x80,0xf9,0x76,
			0x00,0x75,0xf8,0x80,0x07,0x0c,0x09,0xf4,0xf9,0x0c,
			0x09,0xf4,0x03,0x92,0x02,0x03,0x07,0x00,0x03,0x7d,
			0x00,0x7b,0xfc,0x7e,0x04,0x7d,0x00,0x7a,0xfd,0x7e,
			0xf9,0x00,0xfe,0x02,0x06,0x89,0x02,0x00,0x06,0xf5,
			0x03,0x95,0x00,0x6b,0x0c,0x15,0x00,0x6b,0x02,0x80,
			0x03,0x95,0x00,0x6b,0x0c,0x15,0x00,0x6b,0xf8,0x96,
			0x03,0x00,0x07,0xea,0x03,0x80,0x00,0x15,0x0c,0x80,
			0xf7,0x76,0xfd,0x00,0x03,0x80,0x0a,0x75,0x03,0x80,
			0x03,0x80,0x07,0x13,0x02,0x02,0x03,0x00,0x00,0x6b,
			0x02,0x80,0x03,0x80,0x00,0x15,0x09,0x6b,0x09,0x15,
			0x00,0x6b,0x03,0x80,0x03,0x80,0x00,0x15,0x00,0xf6,
			0x0d,0x00,0x00,0x8a,0x00,0x6b,0x03,0x80,0x07,0x80,
			0xfd,0x00,0xff,0x03,0x00,0x04,0x00,0x07,0x00,0x04,
			0x01,0x02,0x03,0x01,0x06,0x00,0x03,0x7f,0x01,0x7e,
			0x01,0x7c,0x00,0x79,0xff,0x7c,0xff,0x7d,0xfd,0x00,
			0xfa,0x00,0x0e,0x80,0x03,0x80,0x00,0x15,0x0c,0x00,
			0x00,0x6b,0x02,0x80,0x03,0x80,0x00,0x15,0x0a,0x00,
			0x02,0x7f,0x01,0x7d,0x00,0x7b,0xff,0x7e,0xfe,0x7f,
			0xf6,0x00,0x10,0xf7,0x11,0x8f,0xff,0x03,0xff,0x02,
			0xfe,0x01,0xfa,0x00,0xfd,0x7f,0xff,0x7e,0x00,0x7c,
			0x00,0x79,0x00,0x7b,0x01,0x7e,0x03,0x00,0x06,0x00,
			0x02,0x00,0x01,0x03,0x01,0x02,0x03,0xfb,0x03,0x95,
			0x0c,0x00,0xfa,0x80,0x00,0x6b,0x09,0x80,0x03,0x95,
			0x00,0x77,0x06,0x7a,0x06,0x06,0x00,0x09,0xfa,0xf1,
			0xfa,0x7a,0x0e,0x80,0x03,0x87,0x00,0x0b,0x02,0x02,
			0x03,0x00,0x02,0x7e,0x01,0x02,0x04,0x00,0x02,0x7e,
			0x00,0x75,0xfe,0x7e,0xfc,0x00,0xff,0x01,0xfe,0x7f,
			0xfd,0x00,0xfe,0x02,0x07,0x8e,0x00,0x6b,0x09,0x80,
			0x03,0x80,0x0e,0x15,0xf2,0x80,0x0e,0x6b,0x03,0x80,
			0x03,0x95,0x00,0x6b,0x0e,0x00,0x00,0x7d,0xfe,0x98,
			0x00,0x6b,0x05,0x80,0x03,0x95,0x00,0x75,0x02,0x7d,
			0x0a,0x00,0x00,0x8e,0x00,0x6b,0x02,0x80,0x03,0x95,
			0x00,0x6b,0x10,0x00,0x00,0x15,0xf8,0x80,0x00,0x6b,
			0x0a,0x80,0x03,0x95,0x00,0x6b,0x10,0x00,0x00,0x15,
			0xf8,0x80,0x00,0x6b,0x0a,0x00,0x00,0x7d,0x02,0x83,
			0x10,0x80,0x03,0x95,0x00,0x6b,0x09,0x00,0x03,0x02,
			0x00,0x08,0xfd,0x02,0xf7,0x00,0x0e,0x89,0x00,0x6b,
			0x03,0x80,0x03,0x95,0x00,0x6b,0x09,0x00,0x03,0x02,
			0x00,0x08,0xfd,0x02,0xf7,0x00,0x0e,0xf4,0x03,0x92,
			0x02,0x03,0x07,0x00,0x03,0x7d,0x00,0x70,0xfd,0x7e,
			0xf9,0x00,0xfe,0x02,0x03,0x89,0x09,0x00,0x02,0xf5,
			0x03,0x80,0x00,0x15,0x00,0xf5,0x07,0x00,0x00,0x08,
			0x02,0x03,0x06,0x00,0x02,0x7d,0x00,0x70,0xfe,0x7e,
			0xfa,0x00,0xfe,0x02,0x00,0x08,0x0c,0xf6,0x0f,0x80,
			0x00,0x15,0xf6,0x00,0xfe,0x7d,0x00,0x79,0x02,0x7e,
			0x0a,0x00,0xf4,0xf7,0x07,0x09,0x07,0xf7,0x03,0x8c,
			0x01,0x02,0x01,0x01,0x05,0x00,0x02,0x7f,0x01,0x7e,
			0x00,0x74,0x00,0x86,0xff,0x01,0xfe,0x01,0xfb,0x00,
			0xff,0x7f,0xff,0x7f,0x00,0x7c,0x01,0x7e,0x01,0x00,
			0x05,0x00,0x02,0x00,0x01,0x02,0x03,0xfe,0x04,0x8e,
			0x02,0x01,0x04,0x00,0x02,0x7f,0x01,0x7e,0x00,0x77,
			0xff,0x7e,0xfe,0x7f,0xfc,0x00,0xfe,0x01,0xff,0x02,
			0x00,0x09,0x01,0x02,0x02,0x02,0x03,0x01,0x02,0x01,
			0x01,0x01,0x01,0x02,0x02,0xeb,0x03,0x80,0x00,0x15,
			0x03,0x00,0x02,0x7e,0x00,0x7b,0xfe,0x7e,0xfd,0x00,
			0x03,0x80,0x04,0x00,0x03,0x7e,0x00,0x78,0xfd,0x7e,
			0xf9,0x00,0x0c,0x80,0x03,0x8c,0x02,0x02,0x02,0x01,
			0x03,0x00,0x02,0x7f,0x01,0x7d,0xfe,0x7e,0xf9,0x7d,
			0xff,0x7e,0x00,0x7d,0x03,0x7f,0x02,0x00,0x03,0x01,
			0x02,0x01,0x02,0xfe,0x0d,0x8c,0xff,0x02,0xfe,0x01,
			0xfc,0x00,0xfe,0x7f,0xff,0x7e,0x00,0x77,0x01,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x01,0x02,0x00,0x0f,
			0xff,0x02,0xfe,0x01,0xf9,0x00,0x0c,0xeb,0x03,0x88,
			0x0a,0x00,0x00,0x02,0x00,0x03,0xfe,0x02,0xfa,0x00,
			0xff,0x7e,0xff,0x7d,0x00,0x7b,0x01,0x7c,0x01,0x7f,
			0x06,0x00,0x02,0x02,0x03,0xfe,0x03,0x8f,0x06,0x77,
			0x06,0x09,0xfa,0x80,0x00,0x71,0xff,0x87,0xfb,0x79,
			0x07,0x87,0x05,0x79,0x02,0x80,0x03,0x8d,0x02,0x02,
			0x06,0x00,0x02,0x7e,0x00,0x7d,0xfc,0x7d,0x04,0x7e,
			0x00,0x7d,0xfe,0x7e,0xfa,0x00,0xfe,0x02,0x04,0x85,
			0x02,0x00,0x06,0xf9,0x03,0x8f,0x00,0x73,0x01,0x7e,
			0x07,0x00,0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,
			0x03,0x80,0x03,0x8f,0x00,0x73,0x01,0x7e,0x07,0x00,
			0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,0xf8,0x90,
			0x03,0x00,0x08,0xf0,0x03,0x80,0x00,0x15,0x00,0xf3,
			0x02,0x00,0x06,0x07,0xfa,0xf9,0x07,0x78,0x03,0x80,
			0x03,0x80,0x04,0x0c,0x02,0x03,0x04,0x00,0x00,0x71,
			0x02,0x80,0x03,0x80,0x00,0x0f,0x06,0x77,0x06,0x09,
			0x00,0x71,0x02,0x80,0x03,0x80,0x00,0x0f,0x0a,0xf1,
			0x00,0x0f,0xf6,0xf8,0x0a,0x00,0x02,0xf9,0x05,0x80,
			0xff,0x01,0xff,0x04,0x00,0x05,0x01,0x03,0x01,0x02,
			0x06,0x00,0x02,0x7e,0x00,0x7d,0x00,0x7b,0x00,0x7c,
			0xfe,0x7f,0xfa,0x00,0x0b,0x80,0x03,0x80,0x00,0x0f,
			0x00,0xfb,0x01,0x03,0x01,0x02,0x05,0x00,0x02,0x7e,
			0x01,0x7d,0x00,0x76,0x03,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,0x10,0x80,
			0x10,0x80,0x0a,0x8f,0x02,0x7f,0x01,0x7e,0x00,0x76,
			0xff,0x7f,0xfe,0x7f,0xfb,0x00,0xff,0x01,0xff,0x01,
			0x00,0x0a,0x01,0x02,0x01,0x01,0x05,0x00,0xf9,0x80,
			0x00,0x6b,0x0c,0x86,0x0d,0x8a,0xff,0x03,0xfe,0x02,
			0xfb,0x00,0xff,0x7e,0xff,0x7d,0x00,0x7b,0x01,0x7c,
			0x01,0x7f,0x05,0x00,0x02,0x01,0x01,0x03,0x03,0xfc,
			0x03,0x80,0x00,0x0f,0x00,0xfb,0x01,0x03,0x01,0x02,
			0x04,0x00,0x01,0x7e,0x01,0x7d,0x00,0x76,0x00,0x8a,
			0x01,0x03,0x02,0x02,0x03,0x00,0x02,0x7e,0x01,0x7d,
			0x00,0x76,0x03,0x80,0x03,0x8f,0x00,0x74,0x01,0x7e,
			0x02,0x7f,0x04,0x00,0x02,0x01,0x01,0x01,0x00,0x8d,
			0x00,0x6e,0xff,0x7e,0xfe,0x7f,0xfb,0x00,0xfe,0x01,
			0x0c,0x85,0x03,0x8d,0x01,0x02,0x03,0x00,0x02,0x7e,
			0x01,0x02,0x03,0x00,0x02,0x7e,0x00,0x74,0xfe,0x7f,
			0xfd,0x00,0xff,0x01,0xfe,0x7f,0xfd,0x00,0xff,0x01,
			0x00,0x0c,0x06,0x82,0x00,0x6b,0x08,0x86,0x03,0x80,
			0x0a,0x0f,0xf6,0x80,0x0a,0x71,0x03,0x80,0x03,0x8f,
			0x00,0x73,0x01,0x7e,0x07,0x00,0x02,0x02,0x00,0x0d,
			0x00,0xf3,0x01,0x7e,0x00,0x7e,0x03,0x82,0x03,0x8f,
			0x00,0x79,0x02,0x7e,0x08,0x00,0x00,0x89,0x00,0x71,
			0x02,0x80,0x03,0x8f,0x00,0x73,0x01,0x7e,0x03,0x00,
			0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,0x03,0x00,
			0x02,0x02,0x00,0x0d,0x00,0xf3,0x01,0x7e,0x03,0x80,
			0x03,0x8f,0x00,0x73,0x01,0x7e,0x03,0x00,0x02,0x02,
			0x00,0x0d,0x00,0xf3,0x01,0x7e,0x03,0x00,0x02,0x02,
			0x00,0x0d,0x00,0xf3,0x01,0x7e,0x00,0x7e,0x03,0x82,
			0x03,0x8d,0x00,0x02,0x02,0x00,0x00,0x71,0x08,0x00,
			0x02,0x02,0x00,0x06,0xfe,0x02,0xf8,0x00,0x0c,0xf6,
			0x03,0x8f,0x00,0x71,0x07,0x00,0x02,0x02,0x00,0x06,
			0xfe,0x02,0xf9,0x00,0x0c,0x85,0x00,0x71,0x02,0x80,
			0x03,0x8f,0x00,0x71,0x07,0x00,0x03,0x02,0x00,0x06,
			0xfd,0x02,0xf9,0x00,0x0c,0xf6,0x03,0x8d,0x02,0x02,
			0x06,0x00,0x02,0x7e,0x00,0x75,0xfe,0x7e,0xfa,0x00,
			0xfe,0x02,0x04,0x85,0x06,0x00,0x02,0xf9,0x03,0x80,
			0x00,0x0f,0x00,0xf8,0x04,0x00,0x00,0x06,0x02,0x02,
			0x04,0x00,0x02,0x7e,0x00,0x75,0xfe,0x7e,0xfc,0x00,
			0xfe,0x02,0x00,0x05,0x0a,0xf9,0x0d,0x80,0x00,0x0f,
			0xf7,0x00,0xff,0x7e,0x00,0x7b,0x01,0x7e,0x09,0x00,
			0xf6,0xfa,0x04,0x06,0x08,0xfa
		};
    };
}

#endregion //agg_gsv_text.cs
#region agg_image_filters.cs


//----------------------------------------------------------------------------
//
// Image transformation filters,
// Filtering classes (ImageFilterLookUpTable, image_filter),
// Basic filter shape classes
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{
    public interface IImageFilterFunction
    {
        double radius();
        double calc_weight(double x);
    }

    //-----------------------------------------------------ImageFilterLookUpTable
    public class ImageFilterLookUpTable
    {
        double m_radius;
        int m_diameter;
        int m_start;
        ArrayPOD<int> m_weight_array;

        public enum image_filter_scale_e
        {
            image_filter_shift = 14,                      //----image_filter_shift
            image_filter_scale = 1 << image_filter_shift, //----image_filter_scale 
            image_filter_mask = image_filter_scale - 1   //----image_filter_mask 
        }

        public enum image_subpixel_scale_e
        {
            image_subpixel_shift = 8,                         //----image_subpixel_shift
            image_subpixel_scale = 1 << image_subpixel_shift, //----image_subpixel_scale 
            image_subpixel_mask = image_subpixel_scale - 1   //----image_subpixel_mask 
        }

        public void calculate(IImageFilterFunction filter)
        {
            calculate(filter, true);
        }

        public void calculate(IImageFilterFunction filter, bool normalization)
        {
            double r = filter.radius();
            realloc_lut(r);
            int i;
            int pivot = diameter() << ((int)image_subpixel_scale_e.image_subpixel_shift - 1);
            for (i = 0; i < pivot; i++)
            {
                double x = (double)i / (double)image_subpixel_scale_e.image_subpixel_scale;
                double y = filter.calc_weight(x);
                m_weight_array.Array[pivot + i] =
                m_weight_array.Array[pivot - i] = agg_basics.iround(y * (int)image_filter_scale_e.image_filter_scale);
            }
            int end = (diameter() << (int)image_subpixel_scale_e.image_subpixel_shift) - 1;
            m_weight_array.Array[0] = m_weight_array.Array[end];
            if (normalization)
            {
                normalize();
            }
        }

        public ImageFilterLookUpTable()
        {
            m_weight_array = new ArrayPOD<int>(256);
            m_radius = (0);
            m_diameter = (0);
            m_start = (0);
        }

        public ImageFilterLookUpTable(IImageFilterFunction filter)
            : this(filter, true)
        {

        }
        public ImageFilterLookUpTable(IImageFilterFunction filter, bool normalization)
        {
            m_weight_array = new ArrayPOD<int>(256);
            calculate(filter, normalization);
        }

        public double radius() { return m_radius; }
        public int diameter() { return m_diameter; }
        public int start() { return m_start; }
        public int[] weight_array() { return m_weight_array.Array; }

        //--------------------------------------------------------------------
        // This function normalizes integer values and corrects the rounding 
        // errors. It doesn't do anything with the source floating point values
        // (m_weight_array_dbl), it corrects only integers according to the rule 
        // of 1.0 which means that any sum of pixel weights must be equal to 1.0.
        // So, the filter function must produce a graph of the proper shape.
        //--------------------------------------------------------------------
        public void normalize()
        {
            int i;
            int flip = 1;

            for (i = 0; i < (int)image_subpixel_scale_e.image_subpixel_scale; i++)
            {
                for (; ; )
                {
                    int sum = 0;
                    int j;
                    for (j = 0; j < m_diameter; j++)
                    {
                        sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i];
                    }

                    if (sum == (int)image_filter_scale_e.image_filter_scale) break;

                    double k = (double)((int)image_filter_scale_e.image_filter_scale) / (double)(sum);
                    sum = 0;
                    for (j = 0; j < m_diameter; j++)
                    {
                        sum += m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] =
                            (int)agg_basics.iround(m_weight_array.Array[j * (int)image_subpixel_scale_e.image_subpixel_scale + i] * k);
                    }

                    sum -= (int)image_filter_scale_e.image_filter_scale;
                    int inc = (sum > 0) ? -1 : 1;

                    for (j = 0; j < m_diameter && sum != 0; j++)
                    {
                        flip ^= 1;
                        int idx = flip != 0 ? m_diameter / 2 + j / 2 : m_diameter / 2 - j / 2;
                        int v = m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i];
                        if (v < (int)image_filter_scale_e.image_filter_scale)
                        {
                            m_weight_array.Array[idx * (int)image_subpixel_scale_e.image_subpixel_scale + i] += (int)inc;
                            sum += inc;
                        }
                    }
                }
            }

            int pivot = m_diameter << ((int)image_subpixel_scale_e.image_subpixel_shift - 1);

            for (i = 0; i < pivot; i++)
            {
                m_weight_array.Array[pivot + i] = m_weight_array.Array[pivot - i];
            }
            int end = (diameter() << (int)image_subpixel_scale_e.image_subpixel_shift) - 1;
            m_weight_array.Array[0] = m_weight_array.Array[end];
        }

        private void realloc_lut(double radius)
        {
            m_radius = radius;
            m_diameter = agg_basics.uceil(radius) * 2;
            m_start = -(int)(m_diameter / 2 - 1);
            int size = (int)m_diameter << (int)image_subpixel_scale_e.image_subpixel_shift;
            if (size > m_weight_array.Size())
            {
                m_weight_array.Resize(size);
            }
        }
    }

    /*

    //--------------------------------------------------------image_filter
    public class image_filter : ImageFilterLookUpTable
    {
        public image_filter()
        {
            calculate(m_filter_function);
        }
    
        private IImageFilter m_filter_function;
    };
     */


    //-----------------------------------------------image_filter_bilinear
    public struct image_filter_bilinear : IImageFilterFunction
    {
        public double radius() { return 1.0; }
        public double calc_weight(double x)
        {
            if (Math.Abs(x) < 1)
            {
                if (x < 0)
                {
                    return 1.0 + x;
                }
                else
                {
                    return 1.0 - x;
                }
            }

            return 0;
        }
    };

    //-----------------------------------------------image_filter_hanning
    public struct image_filter_hanning : IImageFilterFunction
    {
        public double radius() { return 1.0; }
        public double calc_weight(double x)
        {
            return 0.5 + 0.5 * Math.Cos(Math.PI * x);
        }
    };

    //-----------------------------------------------image_filter_hamming
    public struct image_filter_hamming : IImageFilterFunction
    {
        public double radius() { return 1.0; }
        public double calc_weight(double x)
        {
            return 0.54 + 0.46 * Math.Cos(Math.PI * x);
        }
    };

    //-----------------------------------------------image_filter_hermite
    public struct image_filter_hermite : IImageFilterFunction
    {
        public double radius() { return 1.0; }
        public double calc_weight(double x)
        {
            return (2.0 * x - 3.0) * x * x + 1.0;
        }
    };

    //------------------------------------------------image_filter_quadric
    public struct image_filter_quadric : IImageFilterFunction
    {
        public double radius() { return 1.5; }
        public double calc_weight(double x)
        {
            double t;
            if (x < 0.5) return 0.75 - x * x;
            if (x < 1.5) { t = x - 1.5; return 0.5 * t * t; }
            return 0.0;
        }
    };

    //------------------------------------------------image_filter_bicubic
    public class image_filter_bicubic : IImageFilterFunction
    {
        private static double pow3(double x)
        {
            return (x <= 0.0) ? 0.0 : x * x * x;
        }

        public double radius() { return 2.0; }
        public double calc_weight(double x)
        {
            return
                (1.0 / 6.0) *
                (pow3(x + 2) - 4 * pow3(x + 1) + 6 * pow3(x) - 4 * pow3(x - 1));
        }
    };

    //-------------------------------------------------image_filter_kaiser
    public class image_filter_kaiser : IImageFilterFunction
    {
        private double a;
        private double i0a;
        private double epsilon;

        public image_filter_kaiser()
            : this(6.33)
        {

        }
        public image_filter_kaiser(double b)
        {
            a = (b);
            epsilon = (1e-12);
            i0a = 1.0 / bessel_i0(b);
        }

        public double radius() { return 1.0; }
        public double calc_weight(double x)
        {
            return bessel_i0(a * Math.Sqrt(1.0 - x * x)) * i0a;
        }

        private double bessel_i0(double x)
        {
            int i;
            double sum, y, t;

            sum = 1.0;
            y = x * x / 4.0;
            t = y;

            for (i = 2; t > epsilon; i++)
            {
                sum += t;
                t *= (double)y / (i * i);
            }
            return sum;
        }
    };

    //----------------------------------------------image_filter_catrom
    public struct image_filter_catrom : IImageFilterFunction
    {
        public double radius() { return 2.0; }
        public double calc_weight(double x)
        {
            if (x < 1.0) return 0.5 * (2.0 + x * x * (-5.0 + x * 3.0));
            if (x < 2.0) return 0.5 * (4.0 + x * (-8.0 + x * (5.0 - x)));
            return 0.0;
        }
    };

    //---------------------------------------------image_filter_mitchell
    public class image_filter_mitchell : IImageFilterFunction
    {
        private double p0, p2, p3;
        private double q0, q1, q2, q3;

        public image_filter_mitchell()
            : this(1.0 / 3.0, 1.0 / 3.0)
        {

        }

        public image_filter_mitchell(double b, double c)
        {
            p0 = ((6.0 - 2.0 * b) / 6.0);
            p2 = ((-18.0 + 12.0 * b + 6.0 * c) / 6.0);
            p3 = ((12.0 - 9.0 * b - 6.0 * c) / 6.0);
            q0 = ((8.0 * b + 24.0 * c) / 6.0);
            q1 = ((-12.0 * b - 48.0 * c) / 6.0);
            q2 = ((6.0 * b + 30.0 * c) / 6.0);
            q3 = ((-b - 6.0 * c) / 6.0);
        }

        public double radius() { return 2.0; }
        public double calc_weight(double x)
        {
            if (x < 1.0) return p0 + x * x * (p2 + x * p3);
            if (x < 2.0) return q0 + x * (q1 + x * (q2 + x * q3));
            return 0.0;
        }
    };


    //----------------------------------------------image_filter_spline16
    public struct image_filter_spline16 : IImageFilterFunction
    {
        public double radius() { return 2.0; }
        public double calc_weight(double x)
        {
            if (x < 1.0)
            {
                return ((x - 9.0 / 5.0) * x - 1.0 / 5.0) * x + 1.0;
            }
            return ((-1.0 / 3.0 * (x - 1) + 4.0 / 5.0) * (x - 1) - 7.0 / 15.0) * (x - 1);
        }
    };


    //---------------------------------------------image_filter_spline36
    public struct image_filter_spline36 : IImageFilterFunction
    {
        public double radius() { return 3.0; }
        public double calc_weight(double x)
        {
            if (x < 1.0)
            {
                return ((13.0 / 11.0 * x - 453.0 / 209.0) * x - 3.0 / 209.0) * x + 1.0;
            }
            if (x < 2.0)
            {
                return ((-6.0 / 11.0 * (x - 1) + 270.0 / 209.0) * (x - 1) - 156.0 / 209.0) * (x - 1);
            }
            return ((1.0 / 11.0 * (x - 2) - 45.0 / 209.0) * (x - 2) + 26.0 / 209.0) * (x - 2);
        }
    };


    //----------------------------------------------image_filter_gaussian
    public struct image_filter_gaussian : IImageFilterFunction
    {
        public double radius() { return 2.0; }
        public double calc_weight(double x)
        {
            return Math.Exp(-2.0 * x * x) * Math.Sqrt(2.0 / Math.PI);
        }
    };


    //------------------------------------------------image_filter_bessel
    public struct image_filter_bessel : IImageFilterFunction
    {
        public double radius() { return 3.2383; }
        public double calc_weight(double x)
        {
            return (x == 0.0) ? Math.PI / 4.0 : agg_math.besj(Math.PI * x, 1) / (2.0 * x);
        }
    };


    //-------------------------------------------------image_filter_sinc
    public class image_filter_sinc : IImageFilterFunction
    {
        public image_filter_sinc(double r)
        {
            m_radius = (r < 2.0 ? 2.0 : r);
        }
        public double radius() { return m_radius; }
        public double calc_weight(double x)
        {
            if (x == 0.0) return 1.0;
            x *= Math.PI;
            return Math.Sin(x) / x;
        }

        private double m_radius;
    };


    //-----------------------------------------------image_filter_lanczos
    public class image_filter_lanczos : IImageFilterFunction
    {
        public image_filter_lanczos(double r)
        {
            m_radius = (r < 2.0 ? 2.0 : r);
        }
        public double radius() { return m_radius; }
        public double calc_weight(double x)
        {
            if (x == 0.0) return 1.0;
            if (x > m_radius) return 0.0;
            x *= Math.PI;
            double xr = x / m_radius;
            return (Math.Sin(x) / x) * (Math.Sin(xr) / xr);
        }
        private double m_radius;
    };

    //----------------------------------------------image_filter_blackman
    public class image_filter_blackman : IImageFilterFunction
    {
        public image_filter_blackman(double r)
        {
            m_radius = (r < 2.0 ? 2.0 : r);
        }

        public double radius() { return m_radius; }

        public double calc_weight(double x)
        {
            if (x == 0.0)
            {
                return 1.0;
            }

            if (x > m_radius)
            {
                return 0.0;
            }

            x *= Math.PI;
            double xr = x / m_radius;
            return (Math.Sin(x) / x) * (0.42 + 0.5 * Math.Cos(xr) + 0.08 * Math.Cos(2 * xr));
        }

        private double m_radius;
    };
}

#endregion //agg_image_filters.cs
#region agg_line_aa_basics.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{
    //---------------------------------------------------------------line_coord
    public struct line_coord
    {
        public static int conv(double x)
        {
            return (int)Math.Round(x * LineAABasics.line_subpixel_scale);
        }
    };

    //-----------------------------------------------------------line_coord_sat
    public struct line_coord_sat
    {
        public static int conv(double x)
        {
            return agg_basics.iround(x * LineAABasics.line_subpixel_scale, LineAABasics.line_max_coord);
        }
    };

    //==========================================================line_parameters
    public struct line_parameters
    {
        //---------------------------------------------------------------------
        public int x1, y1, x2, y2, dx, dy, sx, sy;
        public bool vertical;
        public int inc;
        public int len;
        public int octant;

        // The number of the octant is determined as a 3-bit value as follows:
        // bit 0 = vertical flag
        // bit 1 = sx < 0
        // bit 2 = sy < 0
        //
        // [N] shows the number of the orthogonal quadrant
        // <M> shows the number of the diagonal quadrant
        //               <1>
        //   [1]          |          [0]
        //       . (3)011 | 001(1) .
        //         .      |      .
        //           .    |    . 
        //             .  |  . 
        //    (2)010     .|.     000(0)
        // <2> ----------.+.----------- <0>
        //    (6)110   .  |  .   100(4)
        //           .    |    .
        //         .      |      .
        //       .        |        .
        //         (7)111 | 101(5) 
        //   [2]          |          [3]
        //               <3> 
        //                                                        0,1,2,3,4,5,6,7 
        public static readonly byte[] s_orthogonal_quadrant = { 0, 0, 1, 1, 3, 3, 2, 2 };
        public static readonly byte[] s_diagonal_quadrant = { 0, 1, 2, 1, 0, 3, 2, 3 };

        //---------------------------------------------------------------------
        public line_parameters(int x1_, int y1_, int x2_, int y2_, int len_)
        {
            x1 = (x1_);
            y1 = (y1_);
            x2 = (x2_);
            y2 = (y2_);
            dx = (Math.Abs(x2_ - x1_));
            dy = (Math.Abs(y2_ - y1_));
            sx = ((x2_ > x1_) ? 1 : -1);
            sy = ((y2_ > y1_) ? 1 : -1);
            vertical = (dy >= dx);
            inc = (vertical ? sy : sx);
            len = (len_);
            octant = ((sy & 4) | (sx & 2) | (vertical ? 1 : 0));
        }

        //---------------------------------------------------------------------
        public uint orthogonal_quadrant() { return s_orthogonal_quadrant[octant]; }
        public uint diagonal_quadrant() { return s_diagonal_quadrant[octant]; }

        //---------------------------------------------------------------------
        public bool same_orthogonal_quadrant(line_parameters lp)
        {
            return s_orthogonal_quadrant[octant] == s_orthogonal_quadrant[lp.octant];
        }

        //---------------------------------------------------------------------
        public bool same_diagonal_quadrant(line_parameters lp)
        {
            return s_diagonal_quadrant[octant] == s_diagonal_quadrant[lp.octant];
        }

        //---------------------------------------------------------------------
        public void divide(out line_parameters lp1, out line_parameters lp2)
        {
            int xmid = (x1 + x2) >> 1;
            int ymid = (y1 + y2) >> 1;
            int len2 = len >> 1;

            lp1 = this; // it is a struct so this is a copy
            lp2 = this; // it is a struct so this is a copy

            lp1.x2 = xmid;
            lp1.y2 = ymid;
            lp1.len = len2;
            lp1.dx = Math.Abs(lp1.x2 - lp1.x1);
            lp1.dy = Math.Abs(lp1.y2 - lp1.y1);

            lp2.x1 = xmid;
            lp2.y1 = ymid;
            lp2.len = len2;
            lp2.dx = Math.Abs(lp2.x2 - lp2.x1);
            lp2.dy = Math.Abs(lp2.y2 - lp2.y1);
        }
    };

    public static class LineAABasics
    {
        public const int line_subpixel_shift = 8;                          //----line_subpixel_shift
        public const int line_subpixel_scale = 1 << line_subpixel_shift;  //----line_subpixel_scale
        public const int line_subpixel_mask = line_subpixel_scale - 1;    //----line_subpixel_mask
        public const int line_max_coord = (1 << 28) - 1;              //----line_max_coord
        public const int line_max_length = 1 << (line_subpixel_shift + 10); //----line_max_length

        public const int line_mr_subpixel_shift = 4;                           //----line_mr_subpixel_shift
        public const int line_mr_subpixel_scale = 1 << line_mr_subpixel_shift; //----line_mr_subpixel_scale 
        public const int line_mr_subpixel_mask = line_mr_subpixel_scale - 1;   //----line_mr_subpixel_mask 

        public static int line_mr(int x)
        {
            return x >> (line_subpixel_shift - line_mr_subpixel_shift);
        }

        public static int line_hr(int x)
        {
            return x << (line_subpixel_shift - line_mr_subpixel_shift);
        }

        public static int line_dbl_hr(int x)
        {
            return x << line_subpixel_shift;
        }


        public static void bisectrix(line_parameters l1,
                   line_parameters l2,
                   out int x, out int y)
        {
            double k = (double)(l2.len) / (double)(l1.len);
            double tx = l2.x2 - (l2.x1 - l1.x1) * k;
            double ty = l2.y2 - (l2.y1 - l1.y1) * k;

            //All bisectrices must be on the right of the line
            //If the next point is on the left (l1 => l2.2)
            //then the bisectix should be rotated by 180 degrees.
            if ((double)(l2.x2 - l2.x1) * (double)(l2.y1 - l1.y1) <
               (double)(l2.y2 - l2.y1) * (double)(l2.x1 - l1.x1) + 100.0)
            {
                tx -= (tx - l2.x1) * 2.0;
                ty -= (ty - l2.y1) * 2.0;
            }

            // Check if the bisectrix is too short
            double dx = tx - l2.x1;
            double dy = ty - l2.y1;
            if ((int)Math.Sqrt(dx * dx + dy * dy) < line_subpixel_scale)
            {
                x = (l2.x1 + l2.x1 + (l2.y1 - l1.y1) + (l2.y2 - l2.y1)) >> 1;
                y = (l2.y1 + l2.y1 - (l2.x1 - l1.x1) - (l2.x2 - l2.x1)) >> 1;
                return;
            }

            x = agg_basics.iround(tx);
            y = agg_basics.iround(ty);
        }

        public static void fix_degenerate_bisectrix_start(line_parameters lp,
                                               ref int x, ref int y)
        {
            int d = agg_basics.iround(((double)(x - lp.x2) * (double)(lp.y2 - lp.y1) -
                            (double)(y - lp.y2) * (double)(lp.x2 - lp.x1)) / lp.len);
            if (d < line_subpixel_scale / 2)
            {
                x = lp.x1 + (lp.y2 - lp.y1);
                y = lp.y1 - (lp.x2 - lp.x1);
            }
        }

        public static void fix_degenerate_bisectrix_end(line_parameters lp,
                                             ref int x, ref int y)
        {
            int d = agg_basics.iround(((double)(x - lp.x2) * (double)(lp.y2 - lp.y1) -
                            (double)(y - lp.y2) * (double)(lp.x2 - lp.x1)) / lp.len);
            if (d < line_subpixel_scale / 2)
            {
                x = lp.x2 + (lp.y2 - lp.y1);
                y = lp.y2 - (lp.x2 - lp.x1);
            }
        }
    };
}

#endregion //agg_line_aa_basics.cs
#region agg_math.cs


//----------------------------------------------------------------------------
// Bessel function (besj) was adapted for use in AGG library by Andy Wilk 
// Contact: castor.vulgaris@gmail.com
//----------------------------------------------------------------------------
//using System;
//using MatterHackers.Agg.VertexSource;

namespace MatterHackers.Agg
{
    public static class agg_math
    {
        //------------------------------------------------------vertex_dist_epsilon
        // Coinciding points maximal distance (Epsilon)
        public const double vertex_dist_epsilon = 1e-14;

        //-----------------------------------------------------intersection_epsilon
        // See calc_intersection
        public const double intersection_epsilon = 1.0e-30;

        //------------------------------------------------------------cross_product
        public static double cross_product(double x1, double y1,
                                        double x2, double y2,
                                        double x, double y)
        {
            return (x - x2) * (y2 - y1) - (y - y2) * (x2 - x1);
        }

        //--------------------------------------------------------point_in_triangle
        public static bool point_in_triangle(double x1, double y1,
                                          double x2, double y2,
                                          double x3, double y3,
                                          double x, double y)
        {
            bool cp1 = cross_product(x1, y1, x2, y2, x, y) < 0.0;
            bool cp2 = cross_product(x2, y2, x3, y3, x, y) < 0.0;
            bool cp3 = cross_product(x3, y3, x1, y1, x, y) < 0.0;
            return cp1 == cp2 && cp2 == cp3 && cp3 == cp1;
        }

        //-----------------------------------------------------------calc_distance
        public static double calc_distance(double x1, double y1, double x2, double y2)
        {
            double dx = x2 - x1;
            double dy = y2 - y1;
            return Math.Sqrt(dx * dx + dy * dy);
        }

        //--------------------------------------------------------calc_sq_distance
        public static double calc_sq_distance(double x1, double y1, double x2, double y2)
        {
            double dx = x2 - x1;
            double dy = y2 - y1;
            return dx * dx + dy * dy;
        }

        //------------------------------------------------calc_line_point_distance
        public static double calc_line_point_distance(double x1, double y1,
                                                   double x2, double y2,
                                                   double x, double y)
        {
            double dx = x2 - x1;
            double dy = y2 - y1;
            double d = Math.Sqrt(dx * dx + dy * dy);
            if (d < vertex_dist_epsilon)
            {
                return calc_distance(x1, y1, x, y);
            }
            return ((x - x2) * dy - (y - y2) * dx) / d;
        }

        //-------------------------------------------------------calc_line_point_u
        public static double calc_segment_point_u(double x1, double y1,
                                               double x2, double y2,
                                               double x, double y)
        {
            double dx = x2 - x1;
            double dy = y2 - y1;

            if (dx == 0 && dy == 0)
            {
                return 0;
            }

            double pdx = x - x1;
            double pdy = y - y1;

            return (pdx * dx + pdy * dy) / (dx * dx + dy * dy);
        }

        //---------------------------------------------calc_line_point_sq_distance
        public static double calc_segment_point_sq_distance(double x1, double y1,
                                                         double x2, double y2,
                                                         double x, double y,
                                                         double u)
        {
            if (u <= 0)
            {
                return calc_sq_distance(x, y, x1, y1);
            }
            else
                if (u >= 1)
                {
                    return calc_sq_distance(x, y, x2, y2);
                }
            return calc_sq_distance(x, y, x1 + u * (x2 - x1), y1 + u * (y2 - y1));
        }

        //---------------------------------------------calc_line_point_sq_distance
        public static double calc_segment_point_sq_distance(double x1, double y1,
                                                         double x2, double y2,
                                                         double x, double y)
        {
            return
                calc_segment_point_sq_distance(
                    x1, y1, x2, y2, x, y,
                    calc_segment_point_u(x1, y1, x2, y2, x, y));
        }

        //-------------------------------------------------------calc_intersection
        public static bool calc_intersection(double aX1, double aY1, double aX2, double aY2,
                                          double bX1, double bY1, double bX2, double bY2,
                                          out double x, out double y)
        {
            double num = (aY1 - bY1) * (bX2 - bX1) - (aX1 - bX1) * (bY2 - bY1);
            double den = (aX2 - aX1) * (bY2 - bY1) - (aY2 - aY1) * (bX2 - bX1);
            if (Math.Abs(den) < intersection_epsilon)
            {
                x = 0;
                y = 0;
                return false;
            }
            double r = num / den;
            x = aX1 + r * (aX2 - aX1);
            y = aY1 + r * (aY2 - aY1);
            return true;
        }

        //-----------------------------------------------------intersection_exists
        public static bool intersection_exists(double x1, double y1, double x2, double y2,
                                            double x3, double y3, double x4, double y4)
        {
            // It's less expensive but you can't control the 
            // boundary conditions: Less or LessEqual
            double dx1 = x2 - x1;
            double dy1 = y2 - y1;
            double dx2 = x4 - x3;
            double dy2 = y4 - y3;
            return ((x3 - x2) * dy1 - (y3 - y2) * dx1 < 0.0) !=
                   ((x4 - x2) * dy1 - (y4 - y2) * dx1 < 0.0) &&
                   ((x1 - x4) * dy2 - (y1 - y4) * dx2 < 0.0) !=
                   ((x2 - x4) * dy2 - (y2 - y4) * dx2 < 0.0);

            // It's is more expensive but more flexible 
            // in terms of boundary conditions.
            //--------------------
            //double den  = (x2-x1) * (y4-y3) - (y2-y1) * (x4-x3);
            //if(Math.Abs(den) < intersection_epsilon) return false;
            //double nom1 = (x4-x3) * (y1-y3) - (y4-y3) * (x1-x3);
            //double nom2 = (x2-x1) * (y1-y3) - (y2-y1) * (x1-x3);
            //double ua = nom1 / den;
            //double ub = nom2 / den;
            //return ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0;
        }

        //--------------------------------------------------------calc_orthogonal
        public static void calc_orthogonal(double thickness,
                                        double x1, double y1,
                                        double x2, double y2,
                                        out double x, out double y)
        {
            double dx = x2 - x1;
            double dy = y2 - y1;
            double d = Math.Sqrt(dx * dx + dy * dy);
            x = thickness * dy / d;
            y = -thickness * dx / d;
        }

        //--------------------------------------------------------dilate_triangle
        public static void dilate_triangle(double x1, double y1,
                                        double x2, double y2,
                                        double x3, double y3,
                                        double[] x, double[] y,
                                        double d)
        {
            double dx1 = 0.0;
            double dy1 = 0.0;
            double dx2 = 0.0;
            double dy2 = 0.0;
            double dx3 = 0.0;
            double dy3 = 0.0;
            double loc = cross_product(x1, y1, x2, y2, x3, y3);
            if (Math.Abs(loc) > intersection_epsilon)
            {
                if (cross_product(x1, y1, x2, y2, x3, y3) > 0.0)
                {
                    d = -d;
                }
                calc_orthogonal(d, x1, y1, x2, y2, out dx1, out dy1);
                calc_orthogonal(d, x2, y2, x3, y3, out dx2, out dy2);
                calc_orthogonal(d, x3, y3, x1, y1, out dx3, out dy3);
            }
            x[0] = x1 + dx1; y[0] = y1 + dy1;
            x[1] = x2 + dx1; y[1] = y2 + dy1;
            x[2] = x2 + dx2; y[2] = y2 + dy2;
            x[3] = x3 + dx2; y[3] = y3 + dy2;
            x[4] = x3 + dx3; y[4] = y3 + dy3;
            x[5] = x1 + dx3; y[5] = y1 + dy3;
        }

        //------------------------------------------------------calc_triangle_area
        public static double calc_triangle_area(double x1, double y1,
                                             double x2, double y2,
                                             double x3, double y3)
        {
            return (x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3) * 0.5;
        }

        //-------------------------------------------------------calc_polygon_area
        public static double calc_polygon_area(VertexSequence st)
        {
            int i;
            double sum = 0.0;
            double x = st[0].x;
            double y = st[0].y;
            double xs = x;
            double ys = y;

            for (i = 1; i < st.size(); i++)
            {
                VertexDistance v = st[i];
                sum += x * v.y - y * v.x;
                x = v.x;
                y = v.y;
            }
            return (sum + x * ys - y * xs) * 0.5;
        }

        //------------------------------------------------------------------------
        // Tables for fast sqrt
        public static ushort[] g_sqrt_table =                       //----------g_sqrt_table
        {
            0,
            2048,2896,3547,4096,4579,5017,5418,5793,6144,6476,6792,7094,7384,7663,7932,8192,8444,
            8689,8927,9159,9385,9606,9822,10033,10240,10443,10642,10837,11029,11217,11403,11585,
            11765,11942,12116,12288,12457,12625,12790,12953,13114,13273,13430,13585,13738,13890,
            14040,14189,14336,14482,14626,14768,14910,15050,15188,15326,15462,15597,15731,15864,
            15995,16126,16255,16384,16512,16638,16764,16888,17012,17135,17257,17378,17498,17618,
            17736,17854,17971,18087,18203,18318,18432,18545,18658,18770,18882,18992,19102,19212,
            19321,19429,19537,19644,19750,19856,19961,20066,20170,20274,20377,20480,20582,20684,
            20785,20886,20986,21085,21185,21283,21382,21480,21577,21674,21771,21867,21962,22058,
            22153,22247,22341,22435,22528,22621,22713,22806,22897,22989,23080,23170,23261,23351,
            23440,23530,23619,23707,23796,23884,23971,24059,24146,24232,24319,24405,24491,24576,
            24661,24746,24831,24915,24999,25083,25166,25249,25332,25415,25497,25580,25661,25743,
            25824,25905,25986,26067,26147,26227,26307,26387,26466,26545,26624,26703,26781,26859,
            26937,27015,27092,27170,27247,27324,27400,27477,27553,27629,27705,27780,27856,27931,
            28006,28081,28155,28230,28304,28378,28452,28525,28599,28672,28745,28818,28891,28963,
            29035,29108,29180,29251,29323,29394,29466,29537,29608,29678,29749,29819,29890,29960,
            30030,30099,30169,30238,30308,30377,30446,30515,30583,30652,30720,30788,30856,30924,
            30992,31059,31127,31194,31261,31328,31395,31462,31529,31595,31661,31727,31794,31859,
            31925,31991,32056,32122,32187,32252,32317,32382,32446,32511,32575,32640,32704,32768,
            32832,32896,32959,33023,33086,33150,33213,33276,33339,33402,33465,33527,33590,33652,
            33714,33776,33839,33900,33962,34024,34086,34147,34208,34270,34331,34392,34453,34514,
            34574,34635,34695,34756,34816,34876,34936,34996,35056,35116,35176,35235,35295,35354,
            35413,35472,35531,35590,35649,35708,35767,35825,35884,35942,36001,36059,36117,36175,
            36233,36291,36348,36406,36464,36521,36578,36636,36693,36750,36807,36864,36921,36978,
            37034,37091,37147,37204,37260,37316,37372,37429,37485,37540,37596,37652,37708,37763,
            37819,37874,37929,37985,38040,38095,38150,38205,38260,38315,38369,38424,38478,38533,
            38587,38642,38696,38750,38804,38858,38912,38966,39020,39073,39127,39181,39234,39287,
            39341,39394,39447,39500,39553,39606,39659,39712,39765,39818,39870,39923,39975,40028,
            40080,40132,40185,40237,40289,40341,40393,40445,40497,40548,40600,40652,40703,40755,
            40806,40857,40909,40960,41011,41062,41113,41164,41215,41266,41317,41368,41418,41469,
            41519,41570,41620,41671,41721,41771,41821,41871,41922,41972,42021,42071,42121,42171,
            42221,42270,42320,42369,42419,42468,42518,42567,42616,42665,42714,42763,42813,42861,
            42910,42959,43008,43057,43105,43154,43203,43251,43300,43348,43396,43445,43493,43541,
            43589,43637,43685,43733,43781,43829,43877,43925,43972,44020,44068,44115,44163,44210,
            44258,44305,44352,44400,44447,44494,44541,44588,44635,44682,44729,44776,44823,44869,
            44916,44963,45009,45056,45103,45149,45195,45242,45288,45334,45381,45427,45473,45519,
            45565,45611,45657,45703,45749,45795,45840,45886,45932,45977,46023,46069,46114,46160,
            46205,46250,46296,46341,46386,46431,46477,46522,46567,46612,46657,46702,46746,46791,
            46836,46881,46926,46970,47015,47059,47104,47149,47193,47237,47282,47326,47370,47415,
            47459,47503,47547,47591,47635,47679,47723,47767,47811,47855,47899,47942,47986,48030,
            48074,48117,48161,48204,48248,48291,48335,48378,48421,48465,48508,48551,48594,48637,
            48680,48723,48766,48809,48852,48895,48938,48981,49024,49067,49109,49152,49195,49237,
            49280,49322,49365,49407,49450,49492,49535,49577,49619,49661,49704,49746,49788,49830,
            49872,49914,49956,49998,50040,50082,50124,50166,50207,50249,50291,50332,50374,50416,
            50457,50499,50540,50582,50623,50665,50706,50747,50789,50830,50871,50912,50954,50995,
            51036,51077,51118,51159,51200,51241,51282,51323,51364,51404,51445,51486,51527,51567,
            51608,51649,51689,51730,51770,51811,51851,51892,51932,51972,52013,52053,52093,52134,
            52174,52214,52254,52294,52334,52374,52414,52454,52494,52534,52574,52614,52654,52694,
            52734,52773,52813,52853,52892,52932,52972,53011,53051,53090,53130,53169,53209,53248,
            53287,53327,53366,53405,53445,53484,53523,53562,53601,53640,53679,53719,53758,53797,
            53836,53874,53913,53952,53991,54030,54069,54108,54146,54185,54224,54262,54301,54340,
            54378,54417,54455,54494,54532,54571,54609,54647,54686,54724,54762,54801,54839,54877,
            54915,54954,54992,55030,55068,55106,55144,55182,55220,55258,55296,55334,55372,55410,
            55447,55485,55523,55561,55599,55636,55674,55712,55749,55787,55824,55862,55900,55937,
            55975,56012,56049,56087,56124,56162,56199,56236,56273,56311,56348,56385,56422,56459,
            56497,56534,56571,56608,56645,56682,56719,56756,56793,56830,56867,56903,56940,56977,
            57014,57051,57087,57124,57161,57198,57234,57271,57307,57344,57381,57417,57454,57490,
            57527,57563,57599,57636,57672,57709,57745,57781,57817,57854,57890,57926,57962,57999,
            58035,58071,58107,58143,58179,58215,58251,58287,58323,58359,58395,58431,58467,58503,
            58538,58574,58610,58646,58682,58717,58753,58789,58824,58860,58896,58931,58967,59002,
            59038,59073,59109,59144,59180,59215,59251,59286,59321,59357,59392,59427,59463,59498,
            59533,59568,59603,59639,59674,59709,59744,59779,59814,59849,59884,59919,59954,59989,
            60024,60059,60094,60129,60164,60199,60233,60268,60303,60338,60373,60407,60442,60477,
            60511,60546,60581,60615,60650,60684,60719,60753,60788,60822,60857,60891,60926,60960,
            60995,61029,61063,61098,61132,61166,61201,61235,61269,61303,61338,61372,61406,61440,
            61474,61508,61542,61576,61610,61644,61678,61712,61746,61780,61814,61848,61882,61916,
            61950,61984,62018,62051,62085,62119,62153,62186,62220,62254,62287,62321,62355,62388,
            62422,62456,62489,62523,62556,62590,62623,62657,62690,62724,62757,62790,62824,62857,
            62891,62924,62957,62991,63024,63057,63090,63124,63157,63190,63223,63256,63289,63323,
            63356,63389,63422,63455,63488,63521,63554,63587,63620,63653,63686,63719,63752,63785,
            63817,63850,63883,63916,63949,63982,64014,64047,64080,64113,64145,64178,64211,64243,
            64276,64309,64341,64374,64406,64439,64471,64504,64536,64569,64601,64634,64666,64699,
            64731,64763,64796,64828,64861,64893,64925,64957,64990,65022,65054,65086,65119,65151,
            65183,65215,65247,65279,65312,65344,65376,65408,65440,65472,65504
        };

        public static byte[] g_elder_bit_table = //---------g_elder_bit_table
        {
            0,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,
            5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
            6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
            6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,
            7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
        };

        //---------------------------------------------------------------fast_sqrt
        //Fast integer Sqrt - really fast: no cycles, divisions or multiplications
        public static int fast_sqrt(int val)
        {
            //This code is actually pure C and portable to most 
            //architectures including 64bit ones. 
            int t = val;
            int bit = 0;
            int shift = 11;

            //The following piece of code is just an emulation of the
            //Ix86 assembler command "bsr" (see above). However on old
            //Intels (like Intel MMX 233MHz) this code is about twice 
            //as fast as just one "bsr". On PIII and PIV the
            //bsr is optimized quite well.
            bit = (int)t >> 24;
            if (bit != 0)
            {
                bit = g_elder_bit_table[bit] + 24;
            }
            else
            {
                bit = ((int)t >> 16) & 0xFF;
                if (bit != 0)
                {
                    bit = g_elder_bit_table[bit] + 16;
                }
                else
                {
                    bit = ((int)t >> 8) & 0xFF;
                    if (bit != 0)
                    {
                        bit = g_elder_bit_table[bit] + 8;
                    }
                    else
                    {
                        bit = g_elder_bit_table[t];
                    }
                }
            }

            //This code calculates the sqrt.
            bit -= 9;
            if (bit > 0)
            {
                bit = (bit >> 1) + (bit & 1);
                shift -= (int)bit;
                val >>= (bit << 1);
            }
            return (int)((int)g_sqrt_table[val] >> (int)shift);
        }

        //--------------------------------------------------------------------besj
        // Function BESJ calculates Bessel function of first kind of order n
        // Arguments:
        //     n - an integer (>=0), the order
        //     x - value at which the Bessel function is required
        //--------------------
        // C++ Mathematical Library
        // Converted from equivalent FORTRAN library
        // Converted by Gareth Walker for use by course 392 computational project
        // All functions tested and yield the same results as the corresponding
        // FORTRAN versions.
        //
        // If you have any problems using these functions please report them to
        // M.Muldoon@UMIST.ac.uk
        //
        // Documentation available on the web
        // http://www.ma.umist.ac.uk/mrm/Teaching/392/libs/392.html
        // Version 1.0   8/98
        // 29 October, 1999
        //--------------------
        // Adapted for use in AGG library by Andy Wilk (castor.vulgaris@gmail.com)
        //------------------------------------------------------------------------
        public static double besj(double x, int n)
        {
            if (n < 0)
            {
                return 0;
            }
            double d = 1E-6;
            double b = 0;
            if (Math.Abs(x) <= d)
            {
                if (n != 0) return 0;
                return 1;
            }
            double b1 = 0; // b1 is the value from the previous iteration
            // Set up a starting order for recurrence
            int m1 = (int)Math.Abs(x) + 6;
            if (Math.Abs(x) > 5)
            {
                m1 = (int)(Math.Abs(1.4 * x + 60 / x));
            }
            int m2 = (int)(n + 2 + Math.Abs(x) / 4);
            if (m1 > m2)
            {
                m2 = m1;
            }

            // Apply recurrence down from current max order
            for (; ; )
            {
                double c3 = 0;
                double c2 = 1E-30;
                double c4 = 0;
                int m8 = 1;
                if (m2 / 2 * 2 == m2)
                {
                    m8 = -1;
                }
                int imax = m2 - 2;
                for (int i = 1; i <= imax; i++)
                {
                    double c6t = 2 * (m2 - i) * c2 / x - c3;
                    c3 = c2;
                    c2 = c6t;
                    if (m2 - i - 1 == n)
                    {
                        b = c6t;
                    }
                    m8 = -1 * m8;
                    if (m8 > 0)
                    {
                        c4 = c4 + 2 * c6t;
                    }
                }
                double c6 = 2 * c2 / x - c3;
                if (n == 0)
                {
                    b = c6;
                }
                c4 += c6;
                b /= c4;
                if (Math.Abs(b - b1) < d)
                {
                    return b;
                }
                b1 = b;
                m2 += 3;
            }
        }
    }
}

#endregion //agg_math.cs
#region agg_pattern_filters_rgba.cs


//----------------------------------------------------------------------------
//using MatterHackers.Agg.Image;

namespace MatterHackers.Agg
{
    public interface IPatternFilter
    {
        int dilation();
        void pixel_high_res(ImageBuffer sourceImage, RGBA_Bytes[] destBuffer, int destBufferOffset, int x, int y);
    }

    //=======================================================pattern_filter_nn
    //template<class ColorT> 
    /*
    struct pattern_filter_nn
    {
        typedef ColorT RGBA_Bytes;
        static uint dilation() { return 0; }

        static void pixel_low_res(RGBA_Bytes** buf, 
                                             RGBA_Bytes* p, int x, int y)
        {
            *p = buf[y][x];
        }

        static void pixel_high_res(RGBA_Bytes** buf, 
                                              RGBA_Bytes* p, int x, int y)
        {
            *p = buf[y >> line_subpixel_shift]
                    [x >> line_subpixel_shift];
        }
    };
     */

    public struct pattern_filter_bilinear_RGBA_Bytes : IPatternFilter
    {
        public int dilation() { return 1; }

        public void pixel_low_res(RGBA_Bytes[][] buf, RGBA_Bytes[] p, int offset, int x, int y)
        {
            p[offset] = buf[y][x];
        }

        public void pixel_high_res(ImageBuffer sourceImage, RGBA_Bytes[] destBuffer, int destBufferOffset, int x, int y)
        {
            int r, g, b, a;
            r = g = b = a = LineAABasics.line_subpixel_scale * LineAABasics.line_subpixel_scale / 2;

            int weight;
            int x_lr = x >> LineAABasics.line_subpixel_shift;
            int y_lr = y >> LineAABasics.line_subpixel_shift;

            x &= LineAABasics.line_subpixel_mask;
            y &= LineAABasics.line_subpixel_mask;
            int sourceOffset;
            byte[] ptr = sourceImage.GetPixelPointerXY(x_lr, y_lr, out sourceOffset);

            weight = (LineAABasics.line_subpixel_scale - x) *
                     (LineAABasics.line_subpixel_scale - y);
            r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
            g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
            b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
            a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

            sourceOffset += sourceImage.GetBytesBetweenPixelsInclusive();

            weight = x * (LineAABasics.line_subpixel_scale - y);
            r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
            g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
            b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
            a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

            ptr = sourceImage.GetPixelPointerXY(x_lr, y_lr + 1, out sourceOffset);

            weight = (LineAABasics.line_subpixel_scale - x) * y;
            r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
            g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
            b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
            a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

            sourceOffset += sourceImage.GetBytesBetweenPixelsInclusive();

            weight = x * y;
            r += weight * ptr[sourceOffset + ImageBuffer.OrderR];
            g += weight * ptr[sourceOffset + ImageBuffer.OrderG];
            b += weight * ptr[sourceOffset + ImageBuffer.OrderB];
            a += weight * ptr[sourceOffset + ImageBuffer.OrderA];

            destBuffer[destBufferOffset].red = (byte)(r >> LineAABasics.line_subpixel_shift * 2);
            destBuffer[destBufferOffset].green = (byte)(g >> LineAABasics.line_subpixel_shift * 2);
            destBuffer[destBufferOffset].blue = (byte)(b >> LineAABasics.line_subpixel_shift * 2);
            destBuffer[destBufferOffset].alpha = (byte)(a >> LineAABasics.line_subpixel_shift * 2);
        }
    };
}

#endregion //agg_pattern_filters_rgba.cs
#region agg_rasterizer_cells_aa.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# Port port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// The author gratefully acknowleges the support of David Turner, 
// Robert Wilhelm, and Werner Lemberg - the authors of the FreeType 
// libray - in producing this work. See http://www.freetype.org for details.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------

//using System;
//using poly_subpixel_scale_e = MatterHackers.Agg.agg_basics.poly_subpixel_scale_e;

namespace MatterHackers.Agg
{
    //-----------------------------------------------------------------cell_aa
    // A pixel cell. There're no constructors defined and it was done 
    // intentionally in order to avoid extra overhead when allocating an 
    // array of cells.
    public struct cell_aa
    {
        public int x;
        public int y;
        public int cover;
        public int area;
        public int left, right;

        public void initial()
        {
            x = 0x7FFFFFFF;
            y = 0x7FFFFFFF;
            cover = 0;
            area = 0;
            left = -1;
            right = -1;
        }

        public void Set(cell_aa cellB)
        {
            x = cellB.x;
            y = cellB.y;
            cover = cellB.cover;
            area = cellB.area;
            left = cellB.left;
            right = cellB.right;
        }

        public void style(cell_aa cellB)
        {
            left = cellB.left;
            right = cellB.right;
        }

        public bool not_equal(int ex, int ey, cell_aa cell)
        {
            unchecked
            {
                return ((ex - x) | (ey - y) | (left - cell.left) | (right - cell.right)) != 0;
            }
        }
    };

    //-----------------------------------------------------rasterizer_cells_aa
    // An internal class that implements the main rasterization algorithm.
    // Used in the rasterizer. Should not be used directly.
    public sealed class rasterizer_cells_aa
    {
        private int m_num_used_cells;
        private VectorPOD<cell_aa> m_cells;
        private VectorPOD<cell_aa> m_sorted_cells;
        private VectorPOD<sorted_y> m_sorted_y;
        private QuickSort_cell_aa m_QSorter;

        cell_aa m_curr_cell;
        cell_aa m_style_cell;
        int m_min_x;
        int m_min_y;
        int m_max_x;
        int m_max_y;
        bool m_sorted;

        private enum cell_block_scale_e
        {
            cell_block_shift = 12,
            cell_block_size = 1 << cell_block_shift,
            cell_block_mask = cell_block_size - 1,
            cell_block_pool = 256,
            cell_block_limit = 1024 * cell_block_size
        };

        private struct sorted_y
        {
            internal int start;
            internal int num;
        };

        public rasterizer_cells_aa()
        {
            m_QSorter = new QuickSort_cell_aa();
            m_sorted_cells = new VectorPOD<cell_aa>();
            m_sorted_y = new VectorPOD<sorted_y>();
            m_min_x = (0x7FFFFFFF);
            m_min_y = (0x7FFFFFFF);
            m_max_x = (-0x7FFFFFFF);
            m_max_y = (-0x7FFFFFFF);
            m_sorted = (false);

            m_style_cell.initial();
            m_curr_cell.initial();
        }

        public void reset()
        {
            m_num_used_cells = 0;

            m_curr_cell.initial();
            m_style_cell.initial();
            m_sorted = false;
            m_min_x = 0x7FFFFFFF;
            m_min_y = 0x7FFFFFFF;
            m_max_x = -0x7FFFFFFF;
            m_max_y = -0x7FFFFFFF;
        }

        public void style(cell_aa style_cell)
        {
            m_style_cell.style(style_cell);
        }

        enum dx_limit_e { dx_limit = 16384 << agg_basics.poly_subpixel_scale_e.poly_subpixel_shift };

        public void line(int x1, int y1, int x2, int y2)
        {
            int poly_subpixel_shift = (int)agg_basics.poly_subpixel_scale_e.poly_subpixel_shift;
            int poly_subpixel_mask = (int)agg_basics.poly_subpixel_scale_e.poly_subpixel_mask;
            int poly_subpixel_scale = (int)agg_basics.poly_subpixel_scale_e.poly_subpixel_scale;
            int dx = x2 - x1;

            if (dx >= (int)dx_limit_e.dx_limit || dx <= -(int)dx_limit_e.dx_limit)
            {
                int cx = (x1 + x2) >> 1;
                int cy = (y1 + y2) >> 1;
                line(x1, y1, cx, cy);
                line(cx, cy, x2, y2);
            }

            int dy = y2 - y1;
            int ex1 = x1 >> poly_subpixel_shift;
            int ex2 = x2 >> poly_subpixel_shift;
            int ey1 = y1 >> poly_subpixel_shift;
            int ey2 = y2 >> poly_subpixel_shift;
            int fy1 = y1 & poly_subpixel_mask;
            int fy2 = y2 & poly_subpixel_mask;

            int x_from, x_to;
            int p, rem, mod, lift, delta, first, incr;

            if (ex1 < m_min_x) m_min_x = ex1;
            if (ex1 > m_max_x) m_max_x = ex1;
            if (ey1 < m_min_y) m_min_y = ey1;
            if (ey1 > m_max_y) m_max_y = ey1;
            if (ex2 < m_min_x) m_min_x = ex2;
            if (ex2 > m_max_x) m_max_x = ex2;
            if (ey2 < m_min_y) m_min_y = ey2;
            if (ey2 > m_max_y) m_max_y = ey2;

            set_curr_cell(ex1, ey1);

            //everything is on a single horizontal line
            if (ey1 == ey2)
            {
                render_hline(ey1, x1, fy1, x2, fy2);
                return;
            }

            //Vertical line - we have to calculate start and end cells,
            //and then - the common values of the area and coverage for
            //all cells of the line. We know exactly there's only one 
            //cell, so, we don't have to call render_hline().
            incr = 1;
            if (dx == 0)
            {
                int ex = x1 >> poly_subpixel_shift;
                int two_fx = (x1 - (ex << poly_subpixel_shift)) << 1;
                int area;

                first = poly_subpixel_scale;
                if (dy < 0)
                {
                    first = 0;
                    incr = -1;
                }

                x_from = x1;

                delta = first - fy1;
                m_curr_cell.cover += delta;
                m_curr_cell.area += two_fx * delta;

                ey1 += incr;
                set_curr_cell(ex, ey1);

                delta = first + first - poly_subpixel_scale;
                area = two_fx * delta;
                while (ey1 != ey2)
                {
                    m_curr_cell.cover = delta;
                    m_curr_cell.area = area;
                    ey1 += incr;
                    set_curr_cell(ex, ey1);
                }
                delta = fy2 - poly_subpixel_scale + first;
                m_curr_cell.cover += delta;
                m_curr_cell.area += two_fx * delta;
                return;
            }

            //ok, we have to render several hlines
            p = (poly_subpixel_scale - fy1) * dx;
            first = poly_subpixel_scale;

            if (dy < 0)
            {
                p = fy1 * dx;
                first = 0;
                incr = -1;
                dy = -dy;
            }

            delta = p / dy;
            mod = p % dy;

            if (mod < 0)
            {
                delta--;
                mod += dy;
            }

            x_from = x1 + delta;
            render_hline(ey1, x1, fy1, x_from, first);

            ey1 += incr;
            set_curr_cell(x_from >> poly_subpixel_shift, ey1);

            if (ey1 != ey2)
            {
                p = poly_subpixel_scale * dx;
                lift = p / dy;
                rem = p % dy;

                if (rem < 0)
                {
                    lift--;
                    rem += dy;
                }
                mod -= dy;

                while (ey1 != ey2)
                {
                    delta = lift;
                    mod += rem;
                    if (mod >= 0)
                    {
                        mod -= dy;
                        delta++;
                    }

                    x_to = x_from + delta;
                    render_hline(ey1, x_from, poly_subpixel_scale - first, x_to, first);
                    x_from = x_to;

                    ey1 += incr;
                    set_curr_cell(x_from >> poly_subpixel_shift, ey1);
                }
            }
            render_hline(ey1, x_from, poly_subpixel_scale - first, x2, fy2);
        }

        public int min_x() { return m_min_x; }
        public int min_y() { return m_min_y; }
        public int max_x() { return m_max_x; }
        public int max_y() { return m_max_y; }

        public void sort_cells()
        {
            if (m_sorted) return; //Perform sort only the first time.

            add_curr_cell();
            m_curr_cell.x = 0x7FFFFFFF;
            m_curr_cell.y = 0x7FFFFFFF;
            m_curr_cell.cover = 0;
            m_curr_cell.area = 0;

            if (m_num_used_cells == 0) return;

            // Allocate the array of cell pointers
            m_sorted_cells.Allocate(m_num_used_cells);

            // Allocate and zero the Y array
            m_sorted_y.Allocate((int)(m_max_y - m_min_y + 1));
            m_sorted_y.zero();
            cell_aa[] cells = m_cells.Array;
            sorted_y[] sortedYData = m_sorted_y.Array;
            cell_aa[] sortedCellsData = m_sorted_cells.Array;

            // Create the Y-histogram (count the numbers of cells for each Y)
            for (int i = 0; i < m_num_used_cells; i++)
            {
                int Index = cells[i].y - m_min_y;
                sortedYData[Index].start++;
            }

            // Convert the Y-histogram into the array of starting indexes
            int start = 0;
            int SortedYSize = m_sorted_y.size();
            for (int i = 0; i < SortedYSize; i++)
            {
                int v = sortedYData[i].start;
                sortedYData[i].start = start;
                start += v;
            }

            // Fill the cell pointer array sorted by Y
            for (int i = 0; i < m_num_used_cells; i++)
            {
                int SortedIndex = cells[i].y - m_min_y;
                int curr_y_start = sortedYData[SortedIndex].start;
                int curr_y_num = sortedYData[SortedIndex].num;
                sortedCellsData[curr_y_start + curr_y_num] = cells[i];
                ++sortedYData[SortedIndex].num;
            }

            // Finally arrange the X-arrays
            for (int i = 0; i < SortedYSize; i++)
            {
                if (sortedYData[i].num != 0)
                {
                    m_QSorter.Sort(sortedCellsData, sortedYData[i].start, sortedYData[i].start + sortedYData[i].num - 1);
                }
            }
            m_sorted = true;
        }

        public int total_cells()
        {
            return m_num_used_cells;
        }

        public int scanline_num_cells(int y)
        {
            return (int)m_sorted_y.data()[y - m_min_y].num;
        }

        public void scanline_cells(int y, out cell_aa[] CellData, out int Offset)
        {
            CellData = m_sorted_cells.data();
            Offset = m_sorted_y[y - m_min_y].start;
        }

        public bool sorted() { return m_sorted; }

        private void set_curr_cell(int x, int y)
        {
            if (m_curr_cell.not_equal(x, y, m_style_cell))
            {
                add_curr_cell();
                m_curr_cell.style(m_style_cell);
                m_curr_cell.x = x;
                m_curr_cell.y = y;
                m_curr_cell.cover = 0;
                m_curr_cell.area = 0;
            }
        }

        private void add_curr_cell()
        {
            if ((m_curr_cell.area | m_curr_cell.cover) != 0)
            {
                if (m_num_used_cells >= (int)cell_block_scale_e.cell_block_limit)
                {
                    return;
                }

                allocate_cells_if_required();
                m_cells.data()[m_num_used_cells].Set(m_curr_cell);
                m_num_used_cells++;

#if false
                if(m_num_used_cells == 281)
                {
                    int a = 12;
                }

                DebugFile.Print(m_num_used_cells.ToString() 
                    + ". x=" + m_curr_cell.m_x.ToString()
                    + " y=" + m_curr_cell.m_y.ToString()
                    + " area=" + m_curr_cell.m_area.ToString()
                    + " cover=" + m_curr_cell.m_cover.ToString()
                    + "\n");
#endif
            }
        }

        private void allocate_cells_if_required()
        {
            if (m_cells == null || (m_num_used_cells + 1) >= m_cells.Capacity())
            {
                if (m_num_used_cells >= (int)cell_block_scale_e.cell_block_limit)
                {
                    return;
                }

                int new_num_allocated_cells = m_num_used_cells + (int)cell_block_scale_e.cell_block_size;
                VectorPOD<cell_aa> new_cells = new VectorPOD<cell_aa>(new_num_allocated_cells);
                if (m_cells != null)
                {
                    new_cells.CopyFrom(m_cells);
                }
                m_cells = new_cells;
            }
        }

        private void render_hline(int ey, int x1, int y1, int x2, int y2)
        {
            int ex1 = x1 >> (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_shift;
            int ex2 = x2 >> (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_shift;
            int fx1 = x1 & (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_mask;
            int fx2 = x2 & (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_mask;

            int delta, p, first, dx;
            int incr, lift, mod, rem;

            //trivial case. Happens often
            if (y1 == y2)
            {
                set_curr_cell(ex2, ey);
                return;
            }

            //everything is located in a single cell.  That is easy!
            if (ex1 == ex2)
            {
                delta = y2 - y1;
                m_curr_cell.cover += delta;
                m_curr_cell.area += (fx1 + fx2) * delta;
                return;
            }

            //ok, we'll have to render a run of adjacent cells on the same hline...
            p = ((int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_scale - fx1) * (y2 - y1);
            first = (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_scale;
            incr = 1;

            dx = x2 - x1;

            if (dx < 0)
            {
                p = fx1 * (y2 - y1);
                first = 0;
                incr = -1;
                dx = -dx;
            }

            delta = p / dx;
            mod = p % dx;

            if (mod < 0)
            {
                delta--;
                mod += dx;
            }

            m_curr_cell.cover += delta;
            m_curr_cell.area += (fx1 + first) * delta;

            ex1 += incr;
            set_curr_cell(ex1, ey);
            y1 += delta;

            if (ex1 != ex2)
            {
                p = (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_scale * (y2 - y1 + delta);
                lift = p / dx;
                rem = p % dx;

                if (rem < 0)
                {
                    lift--;
                    rem += dx;
                }

                mod -= dx;

                while (ex1 != ex2)
                {
                    delta = lift;
                    mod += rem;
                    if (mod >= 0)
                    {
                        mod -= dx;
                        delta++;
                    }

                    m_curr_cell.cover += delta;
                    m_curr_cell.area += (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_scale * delta;
                    y1 += delta;
                    ex1 += incr;
                    set_curr_cell(ex1, ey);
                }
            }
            delta = y2 - y1;
            m_curr_cell.cover += delta;
            m_curr_cell.area += (fx2 + (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_scale - first) * delta;
        }

        static void swap_cells(cell_aa a, cell_aa b)
        {
            cell_aa temp = a;
            a = b;
            b = temp;
        }

        enum qsort { qsort_threshold = 9 };
    }

    //------------------------------------------------------scanline_hit_test
    public class scanline_hit_test : IScanlineCache
    {
        private int m_x;
        private bool m_hit;

        public scanline_hit_test(int x)
        {
            m_x = x;
            m_hit = false;
        }

        public void ResetSpans() { }
        public void finalize(int nothing) { }
        public void add_cell(int x, int nothing)
        {
            if (m_x == x) m_hit = true;
        }
        public void add_span(int x, int len, int nothing)
        {
            if (m_x >= x && m_x < x + len) m_hit = true;
        }
        public int num_spans() { return 1; }
        public bool hit() { return m_hit; }



        public void reset(int min_x, int max_x)
        {
            throw new System.NotImplementedException();
        }
        public ScanlineSpan begin()
        {
            throw new System.NotImplementedException();
        }
        public ScanlineSpan GetNextScanlineSpan()
        {
            throw new System.NotImplementedException();
        }
        public int y()
        {
            throw new System.NotImplementedException();
        }
        public byte[] GetCovers()
        {
            throw new System.NotImplementedException();
        }
    }
}

#endregion //agg_rasterizer_cells_aa.cs
#region agg_rasterizer_compound_aa.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.3
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# Port port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
//
// The author gratefully acknowleges the support of David Turner, 
// Robert Wilhelm, and Werner Lemberg - the authors of the FreeType 
// libray - in producing this work. See http://www.freetype.org for details.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//using System;
//using MatterHackers.Agg.VertexSource;

namespace MatterHackers.Agg
{
    //===========================================================layer_order_e
    public enum layer_order_e
    {
        layer_unsorted, //------layer_unsorted
        layer_direct,   //------layer_direct
        layer_inverse   //------layer_inverse
    };


    //==================================================rasterizer_compound_aa
    //template<class Clip=rasterizer_sl_clip_int> 
    sealed public class rasterizer_compound_aa : IRasterizer
    {
        rasterizer_cells_aa m_Rasterizer;
        VectorClipper m_VectorClipper;
        agg_basics.filling_rule_e m_filling_rule;
        layer_order_e m_layer_order;
        VectorPOD<style_info> m_styles;  // Active Styles
        VectorPOD<int> m_ast;     // Active Style Table (unique values)
        VectorPOD<byte> m_asm;     // Active Style Mask 
        VectorPOD<cell_aa> m_cells;
        VectorPOD<byte> m_cover_buf;
        VectorPOD<int> m_master_alpha;

        int m_min_style;
        int m_max_style;
        int m_start_x;
        int m_start_y;
        int m_scan_y;
        int m_sl_start;
        int m_sl_len;

        struct style_info
        {
            internal int start_cell;
            internal int num_cells;
            internal int last_x;
        };

        private const int aa_shift = 8;
        private const int aa_scale = 1 << aa_shift;
        private const int aa_mask = aa_scale - 1;
        private const int aa_scale2 = aa_scale * 2;
        private const int aa_mask2 = aa_scale2 - 1;

        private const int poly_subpixel_shift = (int)agg_basics.poly_subpixel_scale_e.poly_subpixel_shift;

        public rasterizer_compound_aa()
        {
            m_Rasterizer = new rasterizer_cells_aa();
            m_VectorClipper = new VectorClipper();
            m_filling_rule = agg_basics.filling_rule_e.fill_non_zero;
            m_layer_order = layer_order_e.layer_direct;
            m_styles = new VectorPOD<style_info>();  // Active Styles
            m_ast = new VectorPOD<int>();     // Active Style Table (unique values)
            m_asm = new VectorPOD<byte>();     // Active Style Mask 
            m_cells = new VectorPOD<cell_aa>();
            m_cover_buf = new VectorPOD<byte>();
            m_master_alpha = new VectorPOD<int>();
            m_min_style = (0x7FFFFFFF);
            m_max_style = (-0x7FFFFFFF);
            m_start_x = (0);
            m_start_y = (0);
            m_scan_y = (0x7FFFFFFF);
            m_sl_start = (0);
            m_sl_len = (0);
        }

        public void gamma(IGammaFunction gamma_function)
        {
            throw new System.NotImplementedException();
        }


        public void reset()
        {
            m_Rasterizer.reset();
            m_min_style = 0x7FFFFFFF;
            m_max_style = -0x7FFFFFFF;
            m_scan_y = 0x7FFFFFFF;
            m_sl_start = 0;
            m_sl_len = 0;
        }

        void filling_rule(agg_basics.filling_rule_e filling_rule)
        {
            m_filling_rule = filling_rule;
        }

        void layer_order(layer_order_e order)
        {
            m_layer_order = order;
        }

        void clip_box(double x1, double y1,
                                                    double x2, double y2)
        {
            reset();
            m_VectorClipper.clip_box(m_VectorClipper.upscale(x1), m_VectorClipper.upscale(y1),
                               m_VectorClipper.upscale(x2), m_VectorClipper.upscale(y2));
        }

        void reset_clipping()
        {
            reset();
            m_VectorClipper.reset_clipping();
        }

        public void styles(int left, int right)
        {
            cell_aa cell = new cell_aa();
            cell.initial();
            cell.left = (int)left;
            cell.right = (int)right;
            m_Rasterizer.style(cell);
            if (left >= 0 && left < m_min_style) m_min_style = left;
            if (left >= 0 && left > m_max_style) m_max_style = left;
            if (right >= 0 && right < m_min_style) m_min_style = right;
            if (right >= 0 && right > m_max_style) m_max_style = right;
        }

        public void move_to(int x, int y)
        {
            if (m_Rasterizer.sorted()) reset();
            m_VectorClipper.move_to(m_start_x = m_VectorClipper.downscale(x),
                              m_start_y = m_VectorClipper.downscale(y));
        }

        public void line_to(int x, int y)
        {
            m_VectorClipper.line_to(m_Rasterizer,
                              m_VectorClipper.downscale(x),
                              m_VectorClipper.downscale(y));
        }

        public void move_to_d(double x, double y)
        {
            if (m_Rasterizer.sorted()) reset();
            m_VectorClipper.move_to(m_start_x = m_VectorClipper.upscale(x),
                              m_start_y = m_VectorClipper.upscale(y));
        }

        public void line_to_d(double x, double y)
        {
            m_VectorClipper.line_to(m_Rasterizer,
                              m_VectorClipper.upscale(x),
                              m_VectorClipper.upscale(y));
        }

        void add_vertex(double x, double y, ShapePath.FlagsAndCommand cmd)
        {
            if (ShapePath.is_move_to(cmd))
            {
                move_to_d(x, y);
            }
            else
                if (ShapePath.is_vertex(cmd))
                {
                    line_to_d(x, y);
                }
                else
                    if (ShapePath.is_close(cmd))
                    {
                        m_VectorClipper.line_to(m_Rasterizer, m_start_x, m_start_y);
                    }
        }

        void edge(int x1, int y1, int x2, int y2)
        {
            if (m_Rasterizer.sorted()) reset();
            m_VectorClipper.move_to(m_VectorClipper.downscale(x1), m_VectorClipper.downscale(y1));
            m_VectorClipper.line_to(m_Rasterizer,
                              m_VectorClipper.downscale(x2),
                              m_VectorClipper.downscale(y2));
        }

        void edge_d(double x1, double y1,
                                                  double x2, double y2)
        {
            if (m_Rasterizer.sorted()) reset();
            m_VectorClipper.move_to(m_VectorClipper.upscale(x1), m_VectorClipper.upscale(y1));
            m_VectorClipper.line_to(m_Rasterizer,
                              m_VectorClipper.upscale(x2),
                              m_VectorClipper.upscale(y2));
        }

        void sort()
        {
            m_Rasterizer.sort_cells();
        }

        public bool rewind_scanlines()
        {
            m_Rasterizer.sort_cells();
            if (m_Rasterizer.total_cells() == 0)
            {
                return false;
            }
            if (m_max_style < m_min_style)
            {
                return false;
            }
            m_scan_y = m_Rasterizer.min_y();
            m_styles.Allocate((int)(m_max_style - m_min_style + 2), 128);
            allocate_master_alpha();
            return true;
        }

        // Returns the number of styles
        public int sweep_styles()
        {
            for (; ; )
            {
                if (m_scan_y > m_Rasterizer.max_y()) return 0;
                int num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);
                cell_aa[] cells;
                int cellOffset = 0;
                int curCellOffset;
                m_Rasterizer.scanline_cells(m_scan_y, out cells, out cellOffset);
                int num_styles = (int)(m_max_style - m_min_style + 2);
                int style_id;
                int styleOffset = 0;

                m_cells.Allocate((int)num_cells * 2, 256); // Each cell can have two styles
                m_ast.Capacity(num_styles, 64);
                m_asm.Allocate((num_styles + 7) >> 3, 8);
                m_asm.zero();

                if (num_cells > 0)
                {
                    // Pre-add zero (for no-fill style, that is, -1).
                    // We need that to ensure that the "-1 style" would go first.
                    m_asm.Array[0] |= 1;
                    m_ast.add(0);
                    m_styles.Array[styleOffset].start_cell = 0;
                    m_styles.Array[styleOffset].num_cells = 0;
                    m_styles.Array[styleOffset].last_x = -0x7FFFFFFF;

                    m_sl_start = cells[0].x;
                    m_sl_len = (int)(cells[num_cells - 1].x - m_sl_start + 1);
                    while (num_cells-- != 0)
                    {
                        curCellOffset = (int)cellOffset++;
                        add_style(cells[curCellOffset].left);
                        add_style(cells[curCellOffset].right);
                    }

                    // Convert the Y-histogram into the array of starting indexes
                    int i;
                    int start_cell = 0;
                    style_info[] stylesArray = m_styles.Array;
                    for (i = 0; i < m_ast.size(); i++)
                    {
                        int IndexToModify = (int)m_ast[i];
                        int v = stylesArray[IndexToModify].start_cell;
                        stylesArray[IndexToModify].start_cell = start_cell;
                        start_cell += v;
                    }

                    num_cells = (int)m_Rasterizer.scanline_num_cells(m_scan_y);
                    m_Rasterizer.scanline_cells(m_scan_y, out cells, out cellOffset);

                    while (num_cells-- > 0)
                    {
                        curCellOffset = (int)cellOffset++;
                        style_id = (int)((cells[curCellOffset].left < 0) ? 0 :
                                    cells[curCellOffset].left - m_min_style + 1);

                        styleOffset = (int)style_id;
                        if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)
                        {
                            cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;
                            unchecked
                            {
                                cells[cellOffset].area += cells[curCellOffset].area;
                                cells[cellOffset].cover += cells[curCellOffset].cover;
                            }
                        }
                        else
                        {
                            cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;
                            cells[cellOffset].x = cells[curCellOffset].x;
                            cells[cellOffset].area = cells[curCellOffset].area;
                            cells[cellOffset].cover = cells[curCellOffset].cover;
                            stylesArray[styleOffset].last_x = cells[curCellOffset].x;
                            stylesArray[styleOffset].num_cells++;
                        }

                        style_id = (int)((cells[curCellOffset].right < 0) ? 0 :
                                    cells[curCellOffset].right - m_min_style + 1);

                        styleOffset = (int)style_id;
                        if (cells[curCellOffset].x == stylesArray[styleOffset].last_x)
                        {
                            cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells - 1;
                            unchecked
                            {
                                cells[cellOffset].area -= cells[curCellOffset].area;
                                cells[cellOffset].cover -= cells[curCellOffset].cover;
                            }
                        }
                        else
                        {
                            cellOffset = stylesArray[styleOffset].start_cell + stylesArray[styleOffset].num_cells;
                            cells[cellOffset].x = cells[curCellOffset].x;
                            cells[cellOffset].area = -cells[curCellOffset].area;
                            cells[cellOffset].cover = -cells[curCellOffset].cover;
                            stylesArray[styleOffset].last_x = cells[curCellOffset].x;
                            stylesArray[styleOffset].num_cells++;
                        }
                    }
                }
                if (m_ast.size() > 1) break;
                ++m_scan_y;
            }
            ++m_scan_y;

            if (m_layer_order != layer_order_e.layer_unsorted)
            {
                VectorPOD_RangeAdaptor ra = new VectorPOD_RangeAdaptor(m_ast, 1, m_ast.size() - 1);
                if (m_layer_order == layer_order_e.layer_direct)
                {
                    QuickSort_range_adaptor_uint m_QSorter = new QuickSort_range_adaptor_uint();
                    m_QSorter.Sort(ra);
                    //quick_sort(ra, uint_greater);
                }
                else
                {
                    throw new System.NotImplementedException();
                    //QuickSort_range_adaptor_uint m_QSorter = new QuickSort_range_adaptor_uint();
                    //m_QSorter.Sort(ra);
                    //quick_sort(ra, uint_less);
                }
            }

            return m_ast.size() - 1;
        }

        // Returns style ID depending of the existing style index
        public int style(int style_idx)
        {
            return m_ast[style_idx + 1] + (int)m_min_style - 1;
        }

        bool navigate_scanline(int y)
        {
            m_Rasterizer.sort_cells();
            if (m_Rasterizer.total_cells() == 0)
            {
                return false;
            }
            if (m_max_style < m_min_style)
            {
                return false;
            }
            if (y < m_Rasterizer.min_y() || y > m_Rasterizer.max_y())
            {
                return false;
            }
            m_scan_y = y;
            m_styles.Allocate((int)(m_max_style - m_min_style + 2), 128);
            allocate_master_alpha();
            return true;
        }

        bool hit_test(int tx, int ty)
        {
            if (!navigate_scanline(ty))
            {
                return false;
            }

            int num_styles = sweep_styles();
            if (num_styles <= 0)
            {
                return false;
            }

            scanline_hit_test sl = new scanline_hit_test(tx);
            sweep_scanline(sl, -1);
            return sl.hit();
        }

        byte[] allocate_cover_buffer(int len)
        {
            m_cover_buf.Allocate(len, 256);
            return m_cover_buf.Array;
        }

        void master_alpha(int style, double alpha)
        {
            if (style >= 0)
            {
                while ((int)m_master_alpha.size() <= style)
                {
                    m_master_alpha.add(aa_mask);
                }
                m_master_alpha.Array[style] = agg_basics.uround(alpha * aa_mask);
            }
        }

        public void add_path(IVertexSource vs)
        {
            add_path(vs, 0);
        }

        public void add_path(IVertexSource vs, int path_id)
        {
            double x;
            double y;

            ShapePath.FlagsAndCommand cmd;
            vs.rewind(path_id);
            if (m_Rasterizer.sorted()) reset();
            while (!ShapePath.is_stop(cmd = vs.vertex(out x, out y)))
            {
                add_vertex(x, y, cmd);
            }
        }

        public int min_x() { return m_Rasterizer.min_x(); }
        public int min_y() { return m_Rasterizer.min_y(); }
        public int max_x() { return m_Rasterizer.max_x(); }
        public int max_y() { return m_Rasterizer.max_y(); }
        public int min_style() { return m_min_style; }
        public int max_style() { return m_max_style; }

        public int scanline_start() { return m_sl_start; }
        public int scanline_length() { return m_sl_len; }

        public int calculate_alpha(int area, int master_alpha)
        {
            int cover = area >> (poly_subpixel_shift * 2 + 1 - aa_shift);
            if (cover < 0) cover = -cover;
            if (m_filling_rule == agg_basics.filling_rule_e.fill_even_odd)
            {
                cover &= aa_mask2;
                if (cover > aa_scale)
                {
                    cover = aa_scale2 - cover;
                }
            }
            if (cover > aa_mask) cover = aa_mask;
            return (int)((cover * master_alpha + aa_mask) >> aa_shift);
        }

        public bool sweep_scanline(IScanlineCache sl)
        {
            throw new System.NotImplementedException();
        }

        // Sweeps one scanline with one style index. The style ID can be 
        // determined by calling style(). 
        //template<class Scanline> 
        public bool sweep_scanline(IScanlineCache sl, int style_idx)
        {
            int scan_y = m_scan_y - 1;
            if (scan_y > m_Rasterizer.max_y()) return false;

            sl.ResetSpans();

            int master_alpha = aa_mask;

            if (style_idx < 0)
            {
                style_idx = 0;
            }
            else
            {
                style_idx++;
                master_alpha = m_master_alpha[(int)(m_ast[(int)style_idx] + m_min_style - 1)];
            }

            style_info st = m_styles[m_ast[style_idx]];

            int num_cells = (int)st.num_cells;
            int CellOffset = st.start_cell;
            cell_aa cell = m_cells[CellOffset];

            int cover = 0;
            while (num_cells-- != 0)
            {
                int alpha;
                int x = cell.x;
                int area = cell.area;

                cover += cell.cover;

                cell = m_cells[++CellOffset];

                if (area != 0)
                {
                    alpha = calculate_alpha((cover << (poly_subpixel_shift + 1)) - area,
                                            master_alpha);
                    sl.add_cell(x, alpha);
                    x++;
                }

                if (num_cells != 0 && cell.x > x)
                {
                    alpha = calculate_alpha(cover << (poly_subpixel_shift + 1),
                                            master_alpha);
                    if (alpha != 0)
                    {
                        sl.add_span(x, cell.x - x, alpha);
                    }
                }
            }

            if (sl.num_spans() == 0) return false;
            sl.finalize(scan_y);
            return true;
        }

        private void add_style(int style_id)
        {
            if (style_id < 0) style_id = 0;
            else style_id -= m_min_style - 1;

            int nbyte = (int)((int)style_id >> 3);
            int mask = (int)(1 << (style_id & 7));

            style_info[] stylesArray = m_styles.Array;
            if ((m_asm[nbyte] & mask) == 0)
            {
                m_ast.add((int)style_id);
                m_asm.Array[nbyte] |= (byte)mask;
                stylesArray[style_id].start_cell = 0;
                stylesArray[style_id].num_cells = 0;
                stylesArray[style_id].last_x = -0x7FFFFFFF;
            }
            ++stylesArray[style_id].start_cell;
        }

        private void allocate_master_alpha()
        {
            while ((int)m_master_alpha.size() <= m_max_style)
            {
                m_master_alpha.add(aa_mask);
            }
        }
    };
}

#endregion //agg_rasterizer_compound_aa.cs
#region agg_rasterizer_outline_aa.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//using System;

//using MatterHackers.Agg.VertexSource;

namespace MatterHackers.Agg
{
    //-----------------------------------------------------------line_aa_vertex
    // Vertex (x, y) with the distance to the next one. The last vertex has 
    // the distance between the last and the first points
    public struct line_aa_vertex
    {
        public int x;
        public int y;
        public int len;

        public line_aa_vertex(int x_, int y_)
        {
            x = (x_);
            y = (y_);
            len = (0);
        }

        public bool Compare(line_aa_vertex val)
        {
            double dx = val.x - x;
            double dy = val.y - y;
            return (len = agg_basics.uround(Math.Sqrt(dx * dx + dy * dy))) >
                   (LineAABasics.line_subpixel_scale + LineAABasics.line_subpixel_scale / 2);
        }
    };

    public class line_aa_vertex_sequence : VectorPOD<line_aa_vertex>
    {
        public override void add(line_aa_vertex val)
        {
            if (base.size() > 1)
            {
                if (!Array[base.size() - 2].Compare(Array[base.size() - 1]))
                {
                    base.RemoveLast();
                }
            }
            base.add(val);
        }

        public void modify_last(line_aa_vertex val)
        {
            base.RemoveLast();
            add(val);
        }

        public void close(bool closed)
        {
            while (base.size() > 1)
            {
                if (Array[base.size() - 2].Compare(Array[base.size() - 1])) break;
                line_aa_vertex t = this[base.size() - 1];
                base.RemoveLast();
                modify_last(t);
            }

            if (closed)
            {
                while (base.size() > 1)
                {
                    if (Array[base.size() - 1].Compare(Array[0])) break;
                    base.RemoveLast();
                }
            }
        }

        internal line_aa_vertex prev(int idx)
        {
            return this[(idx + currentSize - 1) % currentSize];
        }

        internal line_aa_vertex curr(int idx)
        {
            return this[idx];
        }

        internal line_aa_vertex next(int idx)
        {
            return this[(idx + 1) % currentSize];
        }
    }

    //=======================================================rasterizer_outline_aa
    public class rasterizer_outline_aa
    {
        LineRenderer m_ren;
        line_aa_vertex_sequence m_src_vertices = new line_aa_vertex_sequence();
        outline_aa_join_e m_line_join;
        bool m_round_cap;
        int m_start_x;
        int m_start_y;

        public enum outline_aa_join_e
        {
            outline_no_join,             //-----outline_no_join
            outline_miter_join,          //-----outline_miter_join
            outline_round_join,          //-----outline_round_join
            outline_miter_accurate_join  //-----outline_accurate_join
        };

        public bool cmp_dist_start(int d) { return d > 0; }
        public bool cmp_dist_end(int d) { return d <= 0; }

        private struct draw_vars
        {
            public int idx;
            public int x1, y1, x2, y2;
            public line_parameters curr, next;
            public int lcurr, lnext;
            public int xb1, yb1, xb2, yb2;
            public int flags;
        };

        private void draw(ref draw_vars dv, int start, int end)
        {
            int i;

            for (i = start; i < end; i++)
            {
                if (m_line_join == outline_aa_join_e.outline_round_join)
                {
                    dv.xb1 = dv.curr.x1 + (dv.curr.y2 - dv.curr.y1);
                    dv.yb1 = dv.curr.y1 - (dv.curr.x2 - dv.curr.x1);
                    dv.xb2 = dv.curr.x2 + (dv.curr.y2 - dv.curr.y1);
                    dv.yb2 = dv.curr.y2 - (dv.curr.x2 - dv.curr.x1);
                }

                switch (dv.flags)
                {
                    case 0: m_ren.line3(dv.curr, dv.xb1, dv.yb1, dv.xb2, dv.yb2); break;
                    case 1: m_ren.line2(dv.curr, dv.xb2, dv.yb2); break;
                    case 2: m_ren.line1(dv.curr, dv.xb1, dv.yb1); break;
                    case 3: m_ren.line0(dv.curr); break;
                }

                if (m_line_join == outline_aa_join_e.outline_round_join && (dv.flags & 2) == 0)
                {
                    m_ren.pie(dv.curr.x2, dv.curr.y2,
                               dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
                               dv.curr.y2 - (dv.curr.x2 - dv.curr.x1),
                               dv.curr.x2 + (dv.next.y2 - dv.next.y1),
                               dv.curr.y2 - (dv.next.x2 - dv.next.x1));
                }

                dv.x1 = dv.x2;
                dv.y1 = dv.y2;
                dv.lcurr = dv.lnext;
                dv.lnext = m_src_vertices[dv.idx].len;

                ++dv.idx;
                if (dv.idx >= m_src_vertices.size()) dv.idx = 0;

                dv.x2 = m_src_vertices[dv.idx].x;
                dv.y2 = m_src_vertices[dv.idx].y;

                dv.curr = dv.next;
                dv.next = new line_parameters(dv.x1, dv.y1, dv.x2, dv.y2, dv.lnext);
                dv.xb1 = dv.xb2;
                dv.yb1 = dv.yb2;

                switch (m_line_join)
                {
                    case outline_aa_join_e.outline_no_join:
                        dv.flags = 3;
                        break;

                    case outline_aa_join_e.outline_miter_join:
                        dv.flags >>= 1;
                        dv.flags |= (dv.curr.diagonal_quadrant() ==
                            dv.next.diagonal_quadrant() ? 1 : 0);
                        if ((dv.flags & 2) == 0)
                        {
                            LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
                        }
                        break;

                    case outline_aa_join_e.outline_round_join:
                        dv.flags >>= 1;
                        dv.flags |= (((dv.curr.diagonal_quadrant() ==
                            dv.next.diagonal_quadrant()) ? 1 : 0) << 1);
                        break;

                    case outline_aa_join_e.outline_miter_accurate_join:
                        dv.flags = 0;
                        LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
                        break;
                }
            }
        }

        public rasterizer_outline_aa(LineRenderer ren)
        {
            m_ren = ren;
            m_line_join = (OutlineRenderer.accurate_join_only() ?
                            outline_aa_join_e.outline_miter_accurate_join :
                            outline_aa_join_e.outline_round_join);
            m_round_cap = (false);
            m_start_x = (0);
            m_start_y = (0);
        }

        public void attach(LineRenderer ren) { m_ren = ren; }

        public void line_join(outline_aa_join_e join)
        {
            m_line_join = OutlineRenderer.accurate_join_only() ?
                outline_aa_join_e.outline_miter_accurate_join :
                join;
        }
        public outline_aa_join_e line_join() { return m_line_join; }

        public void round_cap(bool v) { m_round_cap = v; }
        public bool round_cap() { return m_round_cap; }

        public void move_to(int x, int y)
        {
            m_src_vertices.modify_last(new line_aa_vertex(m_start_x = x, m_start_y = y));
        }

        public void line_to(int x, int y)
        {
            m_src_vertices.add(new line_aa_vertex(x, y));
        }

        public void move_to_d(double x, double y)
        {
            move_to(line_coord_sat.conv(x), line_coord_sat.conv(y));
        }

        public void line_to_d(double x, double y)
        {
            line_to(line_coord_sat.conv(x), line_coord_sat.conv(y));
        }

        public void render(bool close_polygon)
        {
            m_src_vertices.close(close_polygon);
            draw_vars dv = new draw_vars();
            line_aa_vertex v;
            int x1;
            int y1;
            int x2;
            int y2;
            int lprev;

            if (close_polygon)
            {
                if (m_src_vertices.size() >= 3)
                {
                    dv.idx = 2;

                    v = m_src_vertices[m_src_vertices.size() - 1];
                    x1 = v.x;
                    y1 = v.y;
                    lprev = v.len;

                    v = m_src_vertices[0];
                    x2 = v.x;
                    y2 = v.y;
                    dv.lcurr = v.len;
                    line_parameters prev = new line_parameters(x1, y1, x2, y2, lprev);

                    v = m_src_vertices[1];
                    dv.x1 = v.x;
                    dv.y1 = v.y;
                    dv.lnext = v.len;
                    dv.curr = new line_parameters(x2, y2, dv.x1, dv.y1, dv.lcurr);

                    v = m_src_vertices[dv.idx];
                    dv.x2 = v.x;
                    dv.y2 = v.y;
                    dv.next = new line_parameters(dv.x1, dv.y1, dv.x2, dv.y2, dv.lnext);

                    dv.xb1 = 0;
                    dv.yb1 = 0;
                    dv.xb2 = 0;
                    dv.yb2 = 0;

                    switch (m_line_join)
                    {
                        case outline_aa_join_e.outline_no_join:
                            dv.flags = 3;
                            break;

                        case outline_aa_join_e.outline_miter_join:
                        case outline_aa_join_e.outline_round_join:
                            dv.flags =
                                (prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |
                                    ((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);
                            break;

                        case outline_aa_join_e.outline_miter_accurate_join:
                            dv.flags = 0;
                            break;
                    }

                    if ((dv.flags & 1) == 0 && m_line_join != outline_aa_join_e.outline_round_join)
                    {
                        LineAABasics.bisectrix(prev, dv.curr, out dv.xb1, out dv.yb1);
                    }

                    if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)
                    {
                        LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
                    }
                    draw(ref dv, 0, m_src_vertices.size());
                }
            }
            else
            {
                switch (m_src_vertices.size())
                {
                    case 0:
                    case 1:
                        break;

                    case 2:
                        {
                            v = m_src_vertices[0];
                            x1 = v.x;
                            y1 = v.y;
                            lprev = v.len;
                            v = m_src_vertices[1];
                            x2 = v.x;
                            y2 = v.y;
                            line_parameters lp = new line_parameters(x1, y1, x2, y2, lprev);
                            if (m_round_cap)
                            {
                                m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
                            }
                            m_ren.line3(lp,
                                         x1 + (y2 - y1),
                                         y1 - (x2 - x1),
                                         x2 + (y2 - y1),
                                         y2 - (x2 - x1));
                            if (m_round_cap)
                            {
                                m_ren.semidot(cmp_dist_end, x2, y2, x2 + (y2 - y1), y2 - (x2 - x1));
                            }
                        }
                        break;

                    case 3:
                        {
                            int x3, y3;
                            int lnext;
                            v = m_src_vertices[0];
                            x1 = v.x;
                            y1 = v.y;
                            lprev = v.len;
                            v = m_src_vertices[1];
                            x2 = v.x;
                            y2 = v.y;
                            lnext = v.len;
                            v = m_src_vertices[2];
                            x3 = v.x;
                            y3 = v.y;
                            line_parameters lp1 = new line_parameters(x1, y1, x2, y2, lprev);
                            line_parameters lp2 = new line_parameters(x2, y2, x3, y3, lnext);

                            if (m_round_cap)
                            {
                                m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
                            }

                            if (m_line_join == outline_aa_join_e.outline_round_join)
                            {
                                m_ren.line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1),
                                                  x2 + (y2 - y1), y2 - (x2 - x1));

                                m_ren.pie(x2, y2, x2 + (y2 - y1), y2 - (x2 - x1),
                                                   x2 + (y3 - y2), y2 - (x3 - x2));

                                m_ren.line3(lp2, x2 + (y3 - y2), y2 - (x3 - x2),
                                                  x3 + (y3 - y2), y3 - (x3 - x2));
                            }
                            else
                            {
                                LineAABasics.bisectrix(lp1, lp2, out dv.xb1, out dv.yb1);
                                m_ren.line3(lp1, x1 + (y2 - y1), y1 - (x2 - x1),
                                                  dv.xb1, dv.yb1);

                                m_ren.line3(lp2, dv.xb1, dv.yb1,
                                                  x3 + (y3 - y2), y3 - (x3 - x2));
                            }
                            if (m_round_cap)
                            {
                                m_ren.semidot(cmp_dist_end, x3, y3, x3 + (y3 - y2), y3 - (x3 - x2));
                            }
                        }
                        break;

                    default:
                        {
                            dv.idx = 3;

                            v = m_src_vertices[0];
                            x1 = v.x;
                            y1 = v.y;
                            lprev = v.len;

                            v = m_src_vertices[1];
                            x2 = v.x;
                            y2 = v.y;
                            dv.lcurr = v.len;
                            line_parameters prev = new line_parameters(x1, y1, x2, y2, lprev);

                            v = m_src_vertices[2];
                            dv.x1 = v.x;
                            dv.y1 = v.y;
                            dv.lnext = v.len;
                            dv.curr = new line_parameters(x2, y2, dv.x1, dv.y1, dv.lcurr);

                            v = m_src_vertices[dv.idx];
                            dv.x2 = v.x;
                            dv.y2 = v.y;
                            dv.next = new line_parameters(dv.x1, dv.y1, dv.x2, dv.y2, dv.lnext);

                            dv.xb1 = 0;
                            dv.yb1 = 0;
                            dv.xb2 = 0;
                            dv.yb2 = 0;

                            switch (m_line_join)
                            {
                                case outline_aa_join_e.outline_no_join:
                                    dv.flags = 3;
                                    break;

                                case outline_aa_join_e.outline_miter_join:
                                case outline_aa_join_e.outline_round_join:
                                    dv.flags =
                                        (prev.diagonal_quadrant() == dv.curr.diagonal_quadrant() ? 1 : 0) |
                                            ((dv.curr.diagonal_quadrant() == dv.next.diagonal_quadrant() ? 1 : 0) << 1);
                                    break;

                                case outline_aa_join_e.outline_miter_accurate_join:
                                    dv.flags = 0;
                                    break;
                            }

                            if (m_round_cap)
                            {
                                m_ren.semidot(cmp_dist_start, x1, y1, x1 + (y2 - y1), y1 - (x2 - x1));
                            }
                            if ((dv.flags & 1) == 0)
                            {
                                if (m_line_join == outline_aa_join_e.outline_round_join)
                                {
                                    m_ren.line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
                                                       x2 + (y2 - y1), y2 - (x2 - x1));
                                    m_ren.pie(prev.x2, prev.y2,
                                               x2 + (y2 - y1), y2 - (x2 - x1),
                                               dv.curr.x1 + (dv.curr.y2 - dv.curr.y1),
                                               dv.curr.y1 - (dv.curr.x2 - dv.curr.x1));
                                }
                                else
                                {
                                    LineAABasics.bisectrix(prev, dv.curr, out dv.xb1, out dv.yb1);
                                    m_ren.line3(prev, x1 + (y2 - y1), y1 - (x2 - x1),
                                                       dv.xb1, dv.yb1);
                                }
                            }
                            else
                            {
                                m_ren.line1(prev,
                                             x1 + (y2 - y1),
                                             y1 - (x2 - x1));
                            }
                            if ((dv.flags & 2) == 0 && m_line_join != outline_aa_join_e.outline_round_join)
                            {
                                LineAABasics.bisectrix(dv.curr, dv.next, out dv.xb2, out dv.yb2);
                            }

                            draw(ref dv, 1, m_src_vertices.size() - 2);

                            if ((dv.flags & 1) == 0)
                            {
                                if (m_line_join == outline_aa_join_e.outline_round_join)
                                {
                                    m_ren.line3(dv.curr,
                                                 dv.curr.x1 + (dv.curr.y2 - dv.curr.y1),
                                                 dv.curr.y1 - (dv.curr.x2 - dv.curr.x1),
                                                 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
                                                 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                                }
                                else
                                {
                                    m_ren.line3(dv.curr, dv.xb1, dv.yb1,
                                                 dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
                                                 dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                                }
                            }
                            else
                            {
                                m_ren.line2(dv.curr,
                                             dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
                                             dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                            }
                            if (m_round_cap)
                            {
                                m_ren.semidot(cmp_dist_end, dv.curr.x2, dv.curr.y2,
                                               dv.curr.x2 + (dv.curr.y2 - dv.curr.y1),
                                               dv.curr.y2 - (dv.curr.x2 - dv.curr.x1));
                            }

                        }
                        break;
                }
            }
            m_src_vertices.remove_all();
        }

        public void add_vertex(double x, double y, ShapePath.FlagsAndCommand cmd)
        {
            if (ShapePath.is_move_to(cmd))
            {
                render(false);
                move_to_d(x, y);
            }
            else
            {
                if (ShapePath.is_end_poly(cmd))
                {
                    render(ShapePath.is_closed(cmd));
                    if (ShapePath.is_closed(cmd))
                    {
                        move_to(m_start_x, m_start_y);
                    }
                }
                else
                {
                    line_to_d(x, y);
                }
            }
        }

        public void add_path(IVertexSource vs)
        {
            add_path(vs, 0);
        }

        public void add_path(IVertexSource vs, int path_id)
        {
            double x;
            double y;

            ShapePath.FlagsAndCommand cmd;
            vs.rewind(path_id);

            //int index = 0;
            //int start = 851;
            //int num = 5;

            while (!ShapePath.is_stop(cmd = vs.vertex(out x, out y)))
            {
                //index++;
                //if (index == 0
                //  || (index > start && index < start + num))
                add_vertex(x, y, cmd);
            }
            render(false);
        }

        public void RenderAllPaths(IVertexSource vs,
                              RGBA_Bytes[] colors,
                              int[] path_id,
                              int num_paths)
        {
            for (int i = 0; i < num_paths; i++)
            {
                m_ren.color(colors[i]);
                add_path(vs, path_id[i]);
            }
        }

        /* // for debugging only
        public void render_path_index(IVertexSource vs,
                              RGBA_Bytes[] colors,
                              int[] path_id,
                              int pathIndex)
        {
            m_ren.color(colors[pathIndex]);
            add_path(vs, path_id[pathIndex]);
        }
         */
    };
}

#endregion //agg_rasterizer_outline_aa.cs
#region agg_scanline_bin.cs


//----------------------------------------------------------------------------
//
// Class scanline_bin - binary scanline.
//
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates (scanline32_bin) has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{

    //=============================================================scanline_bin
    // 
    // This is binary scaline container which supports the interface 
    // used in the rasterizer::render(). See description of agg_scanline_u8 
    // for details.
    // 
    //------------------------------------------------------------------------
    public sealed class scanline_bin : IScanlineCache
    {
        private int m_last_x;
        private int m_y;
        private ArrayPOD<ScanlineSpan> m_spans;
        private int m_span_index;
        private int m_interator_index;

        public ScanlineSpan GetNextScanlineSpan()
        {
            m_interator_index++;
            return m_spans.Array[m_interator_index - 1];
        }

        //--------------------------------------------------------------------
        public scanline_bin()
        {
            m_last_x = (0x7FFFFFF0);
            m_spans = new ArrayPOD<ScanlineSpan>(1000);
            m_span_index = 0;
        }

        //--------------------------------------------------------------------
        public void reset(int min_x, int max_x)
        {
            int max_len = max_x - min_x + 3;
            if (max_len > m_spans.Size())
            {
                m_spans.Resize(max_len);
            }
            m_last_x = 0x7FFFFFF0;
            m_span_index = 0;
        }

        //--------------------------------------------------------------------
        public void add_cell(int x, int cover)
        {
            if (x == m_last_x + 1)
            {
                m_spans.Array[m_span_index].len++;
            }
            else
            {
                m_span_index++;
                m_spans.Array[m_span_index].x = (int)x;
                m_spans.Array[m_span_index].len = 1;
            }
            m_last_x = x;
        }

        //--------------------------------------------------------------------
        public void add_span(int x, int len, int cover)
        {
            if (x == m_last_x + 1)
            {
                m_spans.Array[m_span_index].len += (int)len;
            }
            else
            {
                m_span_index++;
                m_spans.Array[m_span_index].x = x;
                m_spans.Array[m_span_index].len = (int)len;
            }
            m_last_x = x + len - 1;
        }

        /*
        //--------------------------------------------------------------------
        public void add_cells(int x, int len, void*)
        {
            add_span(x, len, 0);
        }
         */

        //--------------------------------------------------------------------
        public void finalize(int y)
        {
            m_y = y;
        }

        //--------------------------------------------------------------------
        public void ResetSpans()
        {
            m_last_x = 0x7FFFFFF0;
            m_span_index = 0;
        }

        //--------------------------------------------------------------------
        public int y() { return m_y; }
        public int num_spans() { return (int)m_span_index; }
        public ScanlineSpan begin()
        {
            m_interator_index = 1;
            return GetNextScanlineSpan();
        }

        public byte[] GetCovers()
        {
            return null;
        }
    };


    /*
//===========================================================scanline32_bin
class scanline32_bin
{
public:
    typedef int32 coord_type;

    //--------------------------------------------------------------------
    struct span
    {
        span() {}
        span(coord_type x_, coord_type len_) : x(x_), len(len_) {}

        coord_type x;
        coord_type len;
    };
    typedef pod_bvector<span, 4> span_array_type;


    //--------------------------------------------------------------------
    class_iterator
    {
    public:
       _iterator(span_array_type& spans) :
            m_spans(spans),
            m_span_idx(0)
        {}

        span& operator*()  { return m_spans[m_span_idx];  }
        span* operator->() { return &m_spans[m_span_idx]; }

        void operator ++ () { ++m_span_idx; }

    private:
        span_array_type& m_spans;
        int               m_span_idx;
    };


    //--------------------------------------------------------------------
    scanline32_bin() : m_max_len(0), m_last_x(0x7FFFFFF0) {}

    //--------------------------------------------------------------------
    void reset(int min_x, int max_x)
    {
        m_last_x = 0x7FFFFFF0;
        m_spans.remove_all();
    }

    //--------------------------------------------------------------------
    void add_cell(int x, int)
    {
        if(x == m_last_x+1)
        {
            m_spans.last().len++;
        }
        else
        {
            m_spans.add(span(coord_type(x), 1));
        }
        m_last_x = x;
    }

    //--------------------------------------------------------------------
    void add_span(int x, int len, int)
    {
        if(x == m_last_x+1)
        {
            m_spans.last().len += coord_type(len);
        }
        else
        {
            m_spans.add(span(coord_type(x), coord_type(len)));
        }
        m_last_x = x + len - 1;
    }

    //--------------------------------------------------------------------
    void add_cells(int x, int len, void*)
    {
        add_span(x, len, 0);
    }

    //--------------------------------------------------------------------
    void finalize(int y) 
    { 
        m_y = y; 
    }

    //--------------------------------------------------------------------
    void reset_spans()
    {
        m_last_x = 0x7FFFFFF0;
        m_spans.remove_all();
    }

    //--------------------------------------------------------------------
    int            y()         { return m_y; }
    int       num_spans() { return m_spans.size(); }
   _iterator begin()     { return_iterator(m_spans); }

private:
    scanline32_bin(scanline32_bin&);
    scanline32_bin operator = (scanline32_bin&);

    int        m_max_len;
    int             m_last_x;
    int             m_y;
    span_array_type m_spans;
};
     */
}

#endregion //agg_scanline_bin.cs
#region agg_scanline_p.cs


//----------------------------------------------------------------------------
//
// Class scanline_p - a general purpose scanline container with packed spans.
//
//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates (scanline32_p) has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg.RasterizerScanline
{
    //=============================================================scanline_p8
    // 
    // This is a general purpose scanline container which supports the interface 
    // used in the rasterizer::render(). See description of scanline_u8
    // for details.
    // 
    //------------------------------------------------------------------------
    public sealed class ScanlineCachePacked8 : IScanlineCache
    {
        private int m_last_x;
        private int m_y;
        private byte[] m_covers;
        private int m_cover_index;
        private ScanlineSpan[] m_spans;
        private int m_span_index;
        private int m_interator_index;

        public ScanlineSpan GetNextScanlineSpan()
        {
            m_interator_index++;
            return m_spans[m_interator_index - 1];
        }

        public ScanlineCachePacked8()
        {
            m_last_x = 0x7FFFFFF0;
            m_covers = new byte[1000];
            m_spans = new ScanlineSpan[1000];
        }

        //--------------------------------------------------------------------
        public void reset(int min_x, int max_x)
        {
            int max_len = max_x - min_x + 3;
            if (max_len > m_spans.Length)
            {
                m_spans = new ScanlineSpan[max_len];
                m_covers = new byte[max_len];
            }
            m_last_x = 0x7FFFFFF0;
            m_cover_index = 0;
            m_span_index = 0;
            m_spans[m_span_index].len = 0;
        }

        //--------------------------------------------------------------------
        public void add_cell(int x, int cover)
        {
            m_covers[m_cover_index] = (byte)cover;
            if (x == m_last_x + 1 && m_spans[m_span_index].len > 0)
            {
                m_spans[m_span_index].len++;
            }
            else
            {
                m_span_index++;
                m_spans[m_span_index].cover_index = m_cover_index;
                m_spans[m_span_index].x = (short)x;
                m_spans[m_span_index].len = 1;
            }
            m_last_x = x;
            m_cover_index++;
        }

        //--------------------------------------------------------------------
        public void add_cells(int x, int len, byte[] covers, int coversIndex)
        {
            for (int i = 0; i < len; i++)
            {
                m_covers[m_cover_index + i] = covers[i];
            }

            if (x == m_last_x + 1 && m_spans[m_span_index].len > 0)
            {
                m_spans[m_span_index].len += (short)len;
            }
            else
            {
                m_span_index++;
                m_spans[m_span_index].cover_index = m_cover_index;
                m_spans[m_span_index].x = (short)x;
                m_spans[m_span_index].len = (short)len;
            }

            m_cover_index += len;
            m_last_x = x + (int)len - 1;
        }

        //--------------------------------------------------------------------
        public void add_span(int x, int len, int cover)
        {
            if (x == m_last_x + 1
                && m_spans[m_span_index].len < 0
                && cover == m_spans[m_span_index].cover_index)
            {
                m_spans[m_span_index].len -= (short)len;
            }
            else
            {
                m_covers[m_cover_index] = (byte)cover;
                m_span_index++;
                m_spans[m_span_index].cover_index = m_cover_index++;
                m_spans[m_span_index].x = (short)x;
                m_spans[m_span_index].len = (short)(-(int)(len));
            }
            m_last_x = x + (int)len - 1;
        }

        //--------------------------------------------------------------------
        public void finalize(int y)
        {
            m_y = y;
        }

        //--------------------------------------------------------------------
        public void ResetSpans()
        {
            m_last_x = 0x7FFFFFF0;
            m_cover_index = 0;
            m_span_index = 0;
            m_spans[m_span_index].len = 0;
        }

        public int y() { return m_y; }
        public int num_spans() { return (int)m_span_index; }
        public ScanlineSpan begin()
        {
            m_interator_index = 1;
            return GetNextScanlineSpan();
        }

        public byte[] GetCovers()
        {
            return m_covers;
        }
    };
}

#endregion //agg_scanline_p.cs
#region agg_scanline_u.cs


//----------------------------------------------------------------------------
//
// Adaptation for 32-bit screen coordinates (scanline32_u) has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.RasterizerScanline
{
    //=============================================================scanline_u8
    //
    // Unpacked scanline container class
    //
    // This class is used to transfer data from a scanline rasterizer 
    // to the rendering buffer. It's organized very simple. The class stores 
    // information of horizontal spans to render it into a pixel-map buffer. 
    // Each span has staring X, length, and an array of bytes that determine the 
    // cover-values for each pixel. 
    // Before using this class you should know the minimal and maximal pixel 
    // coordinates of your scanline. The protocol of using is:
    // 1. reset(min_x, max_x)
    // 2. add_cell() / add_span() - accumulate scanline. 
    //    When forming one scanline the next X coordinate must be always greater
    //    than the last stored one, i.e. it works only with ordered coordinates.
    // 3. Call finalize(y) and render the scanline.
    // 3. Call reset_spans() to prepare for the new scanline.
    //    
    // 4. Rendering:
    // 
    // Scanline provides an iterator class that allows you to extract
    // the spans and the cover values for each pixel. Be aware that clipping
    // has not been done yet, so you should perform it yourself.
    // Use scanline_u8::iterator to render spans:
    //-------------------------------------------------------------------------
    //
    // int y = sl.y();                    // Y-coordinate of the scanline
    //
    // ************************************
    // ...Perform vertical clipping here...
    // ************************************
    //
    // scanline_u8::const_iterator span = sl.begin();
    // 
    // unsigned char* row = m_rbuf->row(y); // The the address of the beginning 
    //                                      // of the current row
    // 
    // unsigned num_spans = sl.num_spans(); // Number of spans. It's guaranteed that
    //                                      // num_spans is always greater than 0.
    //
    // do
    // {
    //     const scanline_u8::cover_type* covers =
    //         span->covers;                     // The array of the cover values
    //
    //     int num_pix = span->len;              // Number of pixels of the span.
    //                                           // Always greater than 0, still it's
    //                                           // better to use "int" instead of 
    //                                           // "unsigned" because it's more
    //                                           // convenient for clipping
    //     int x = span->x;
    //
    //     **************************************
    //     ...Perform horizontal clipping here...
    //     ...you have x, covers, and pix_count..
    //     **************************************
    //
    //     unsigned char* dst = row + x;  // Calculate the start address of the row.
    //                                    // In this case we assume a simple 
    //                                    // grayscale image 1-byte per pixel.
    //     do
    //     {
    //         *dst++ = *covers++;        // Hypotetical rendering. 
    //     }
    //     while(--num_pix);
    //
    //     ++span;
    // } 
    // while(--num_spans);  // num_spans cannot be 0, so this loop is quite safe
    //------------------------------------------------------------------------
    //
    // The question is: why should we accumulate the whole scanline when we
    // could render just separate spans when they're ready?
    // That's because using the scanline is generally faster. When is consists 
    // of more than one span the conditions for the processor cash system
    // are better, because switching between two different areas of memory 
    // (that can be very large) occurs less frequently.
    //------------------------------------------------------------------------
    public sealed class scanline_unpacked_8 : IScanlineCache
    {
        private int m_min_x;
        private int m_last_x;
        private int m_y;
        private ArrayPOD<byte> m_covers;
        private ArrayPOD<ScanlineSpan> m_spans;
        private int m_span_index;
        private int m_interator_index;

        public ScanlineSpan GetNextScanlineSpan()
        {
            m_interator_index++;
            return m_spans.Array[m_interator_index - 1];
        }

        //--------------------------------------------------------------------
        public scanline_unpacked_8()
        {
            m_last_x = (0x7FFFFFF0);
            m_covers = new ArrayPOD<byte>(1000);
            m_spans = new ArrayPOD<ScanlineSpan>(1000);
        }

        //--------------------------------------------------------------------
        public void reset(int min_x, int max_x)
        {
            int max_len = max_x - min_x + 2;
            if (max_len > m_spans.Size())
            {
                m_spans.Resize(max_len);
                m_covers.Resize(max_len);
            }
            m_last_x = 0x7FFFFFF0;
            m_min_x = min_x;
            m_span_index = 0;
        }

        //--------------------------------------------------------------------
        public void add_cell(int x, int cover)
        {
            x -= m_min_x;
            m_covers.Array[x] = (byte)cover;
            if (x == m_last_x + 1)
            {
                m_spans.Array[m_span_index].len++;
            }
            else
            {
                m_span_index++;
                m_spans.Array[m_span_index].x = x + m_min_x;
                m_spans.Array[m_span_index].len = 1;
                m_spans.Array[m_span_index].cover_index = (int)x;
            }
            m_last_x = x;
        }

        /*
        //--------------------------------------------------------------------
        unsafe public void add_cells(int x, int len, byte* covers)
        {
            x -= m_min_x;
            for (int i = 0; i < len; i++)
            {
                m_covers.Array[x + i] = covers[i];
            }
            if (x == m_last_x + 1)
            {
                m_spans.Array[m_span_index].len += (int)len;
            }
            else
            {
                m_span_index++;
                m_spans.Array[m_span_index].x = x + m_min_x;
                m_spans.Array[m_span_index].len = (int)len;
                m_spans.Array[m_span_index].cover_index = x;
            }
            m_last_x = x + (int)len - 1;
        }
         */

        //--------------------------------------------------------------------
        public void add_span(int x, int len, int cover)
        {
            x -= m_min_x;
            for (int i = 0; i < len; i++)
            {
                m_covers.Array[x + i] = (byte)cover;
            }

            if (x == m_last_x + 1)
            {
                m_spans.Array[m_span_index].len += (int)len;
            }
            else
            {
                m_span_index++;
                m_spans.Array[m_span_index].x = x + m_min_x;
                m_spans.Array[m_span_index].len = (int)len;
                m_spans.Array[m_span_index].cover_index = (int)x;
            }
            m_last_x = x + (int)len - 1;
        }

        //--------------------------------------------------------------------
        public void finalize(int y)
        {
            m_y = y;
        }

        //--------------------------------------------------------------------
        public void ResetSpans()
        {
            m_last_x = 0x7FFFFFF0;
            m_span_index = 0;
        }

        //--------------------------------------------------------------------
        public int y() { return m_y; }
        public int num_spans() { return (int)m_span_index; }
        public ScanlineSpan begin()
        {
            m_interator_index = 1;
            return GetNextScanlineSpan();
        }

        public byte[] GetCovers()
        {
            return m_covers.Array;
        }
    };
}

#endregion //agg_scanline_u.cs
#region agg_simul_eq.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Solving simultaneous equations
//
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{
    //============================================================matrix_pivot
    //template<uint Rows, uint Cols>
    public static class matrix_pivot
    {
        static void swap_arrays_index1(double[,] a1, uint a1Index0, double[,] a2, uint a2Index0)
        {
            int Cols = a1.GetLength(1);
            if (a2.GetLength(1) != Cols)
            {
                throw new System.FormatException("a1 and a2 must have the same second dimension.");
            }
            for (int i = 0; i < Cols; i++)
            {
                double tmp = a1[a1Index0, i];
                a1[a1Index0, i] = a2[a2Index0, i];
                a2[a2Index0, i] = tmp;
            }
        }

        public static int pivot(double[,] m, uint row)
        {
            int k = (int)(row);
            double max_val, tmp;

            max_val = -1.0;
            int i;
            int Rows = m.GetLength(0);
            for (i = (int)row; i < Rows; i++)
            {
                if ((tmp = Math.Abs(m[i, row])) > max_val && tmp != 0.0)
                {
                    max_val = tmp;
                    k = i;
                }
            }

            if (m[k, row] == 0.0)
            {
                return -1;
            }

            if (k != (int)(row))
            {
                swap_arrays_index1(m, (uint)k, m, row);
                return k;
            }
            return 0;
        }
    };



    //===============================================================simul_eq
    //template<uint Size, uint RightCols>
    struct simul_eq
    {
        public static bool solve(double[,] left,
                          double[,] right,
                          double[,] result)
        {
            if (left.GetLength(0) != 4
                || right.GetLength(0) != 4
                || left.GetLength(1) != 4
                || result.GetLength(0) != 4
                || right.GetLength(1) != 2
                || result.GetLength(1) != 2)
            {
                throw new System.FormatException("left right and result must all be the same size.");
            }
            double a1;
            int Size = right.GetLength(0);
            int RightCols = right.GetLength(1);

            double[,] tmp = new double[Size, Size + RightCols];

            for (int i = 0; i < Size; i++)
            {
                for (int j = 0; j < Size; j++)
                {
                    tmp[i, j] = left[i, j];
                }
                for (int j = 0; j < RightCols; j++)
                {
                    tmp[i, Size + j] = right[i, j];
                }
            }

            for (int k = 0; k < Size; k++)
            {
                if (matrix_pivot.pivot(tmp, (uint)k) < 0)
                {
                    return false; // Singularity....
                }

                a1 = tmp[k, k];

                for (int j = k; j < Size + RightCols; j++)
                {
                    tmp[k, j] /= a1;
                }

                for (int i = k + 1; i < Size; i++)
                {
                    a1 = tmp[i, k];
                    for (int j = k; j < Size + RightCols; j++)
                    {
                        tmp[i, j] -= a1 * tmp[k, j];
                    }
                }
            }


            for (int k = 0; k < RightCols; k++)
            {
                int m;
                for (m = (int)(Size - 1); m >= 0; m--)
                {
                    result[m, k] = tmp[m, Size + k];
                    for (int j = m + 1; j < Size; j++)
                    {
                        result[m, k] -= tmp[m, j] * result[j, k];
                    }
                }
            }
            return true;
        }

    };
}

#endregion //agg_simul_eq.cs
#region agg_span_allocator.cs


//----------------------------------------------------------------------------
namespace MatterHackers.Agg
{
    //----------------------------------------------------------span_allocator
    public class span_allocator
    {
        private ArrayPOD<RGBA_Bytes> m_span;

        public span_allocator()
        {
            m_span = new ArrayPOD<RGBA_Bytes>(255);
        }

        //--------------------------------------------------------------------
        public ArrayPOD<RGBA_Bytes> allocate(int span_len)
        {
            if (span_len > m_span.Size())
            {
                // To reduce the number of reallocs we align the 
                // span_len to 256 color elements. 
                // Well, I just like this number and it looks reasonable.
                //-----------------------
                m_span.Resize((((int)span_len + 255) >> 8) << 8);
            }
            return m_span;
        }

        public ArrayPOD<RGBA_Bytes> span() { return m_span; }
        public int max_span_len() { return m_span.Size(); }
    };
}

#endregion //agg_span_allocator.cs
#region agg_span_gouraud.cs


//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
    //============================================================span_gouraud
    public class span_gouraud : IVertexSource
    {
        coord_type[] m_coord = new coord_type[3];
        double[] m_x = new double[8];
        double[] m_y = new double[8];
        ShapePath.FlagsAndCommand[] m_cmd = new ShapePath.FlagsAndCommand[8];
        int m_vertex;

        public struct coord_type
        {
            public double x;
            public double y;
            public RGBA_Bytes color;
        };

        public span_gouraud()
        {
            m_vertex = (0);
            m_cmd[0] = ShapePath.FlagsAndCommand.CommandStop;
        }

        public span_gouraud(RGBA_Bytes c1,
                     RGBA_Bytes c2,
                     RGBA_Bytes c3,
                     double x1, double y1,
                     double x2, double y2,
                     double x3, double y3,
                     double d)
        {
            m_vertex = (0);
            colors(c1, c2, c3);
            triangle(x1, y1, x2, y2, x3, y3, d);
        }

        public void colors(IColorType c1, IColorType c2, IColorType c3)
        {
            m_coord[0].color = c1.GetAsRGBA_Bytes();
            m_coord[1].color = c2.GetAsRGBA_Bytes();
            m_coord[2].color = c3.GetAsRGBA_Bytes();
        }

        //--------------------------------------------------------------------
        // Sets the triangle and dilates it if needed.
        // The trick here is to calculate beveled joins in the vertices of the 
        // triangle and render it as a 6-vertex polygon. 
        // It's necessary to achieve numerical stability. 
        // However, the coordinates to interpolate colors are calculated
        // as miter joins (calc_intersection).
        public void triangle(double x1, double y1,
                      double x2, double y2,
                      double x3, double y3,
                      double d)
        {
            m_coord[0].x = m_x[0] = x1;
            m_coord[0].y = m_y[0] = y1;
            m_coord[1].x = m_x[1] = x2;
            m_coord[1].y = m_y[1] = y2;
            m_coord[2].x = m_x[2] = x3;
            m_coord[2].y = m_y[2] = y3;
            m_cmd[0] = ShapePath.FlagsAndCommand.CommandMoveTo;
            m_cmd[1] = ShapePath.FlagsAndCommand.CommandLineTo;
            m_cmd[2] = ShapePath.FlagsAndCommand.CommandLineTo;
            m_cmd[3] = ShapePath.FlagsAndCommand.CommandStop;

            if (d != 0.0)
            {
                agg_math.dilate_triangle(m_coord[0].x, m_coord[0].y,
                                m_coord[1].x, m_coord[1].y,
                                m_coord[2].x, m_coord[2].y,
                                m_x, m_y, d);

                agg_math.calc_intersection(m_x[4], m_y[4], m_x[5], m_y[5],
                                  m_x[0], m_y[0], m_x[1], m_y[1],
                                  out m_coord[0].x, out m_coord[0].y);

                agg_math.calc_intersection(m_x[0], m_y[0], m_x[1], m_y[1],
                                  m_x[2], m_y[2], m_x[3], m_y[3],
                                  out m_coord[1].x, out m_coord[1].y);

                agg_math.calc_intersection(m_x[2], m_y[2], m_x[3], m_y[3],
                                  m_x[4], m_y[4], m_x[5], m_y[5],
                                  out m_coord[2].x, out m_coord[2].y);
                m_cmd[3] = ShapePath.FlagsAndCommand.CommandLineTo;
                m_cmd[4] = ShapePath.FlagsAndCommand.CommandLineTo;
                m_cmd[5] = ShapePath.FlagsAndCommand.CommandLineTo;
                m_cmd[6] = ShapePath.FlagsAndCommand.CommandStop;
            }
        }

        public IEnumerable<VertexData> Vertices()
        {
            throw new NotImplementedException();
        }

        // Vertex Source Interface to feed the coordinates to the rasterizer
        public void rewind(int idx)
        {
            m_vertex = 0;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = m_x[m_vertex];
            y = m_y[m_vertex];
            return m_cmd[m_vertex++];
        }

        protected void arrange_vertices(coord_type[] coord)
        {
            coord[0] = m_coord[0];
            coord[1] = m_coord[1];
            coord[2] = m_coord[2];

            if (m_coord[0].y > m_coord[2].y)
            {
                coord[0] = m_coord[2];
                coord[2] = m_coord[0];
            }

            coord_type tmp;
            if (coord[0].y > coord[1].y)
            {
                tmp = coord[1];
                coord[1] = coord[0];
                coord[0] = tmp;
            }

            if (coord[1].y > coord[2].y)
            {
                tmp = coord[2];
                coord[2] = coord[1];
                coord[1] = tmp;
            }
        }
    }
}

#endregion //agg_span_gouraud.cs
#region agg_span_gouraud_rgba.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg.VertexSource
{

    //=======================================================span_gouraud_rgba
    public sealed class span_gouraud_rgba : span_gouraud, ISpanGenerator
    {
        bool m_swap;
        int m_y2;
        rgba_calc m_rgba1;
        rgba_calc m_rgba2;
        rgba_calc m_rgba3;

        public enum subpixel_scale_e
        {
            subpixel_shift = 4,
            subpixel_scale = 1 << subpixel_shift
        };

        //--------------------------------------------------------------------
        public struct rgba_calc
        {
            public void init(span_gouraud.coord_type c1, span_gouraud.coord_type c2)
            {
                m_x1 = c1.x - 0.5;
                m_y1 = c1.y - 0.5;
                m_dx = c2.x - c1.x;
                double dy = c2.y - c1.y;
                m_1dy = (dy < 1e-5) ? 1e5 : 1.0 / dy;
                m_r1 = (int)c1.color.red;
                m_g1 = (int)c1.color.green;
                m_b1 = (int)c1.color.blue;
                m_a1 = (int)c1.color.alpha;
                m_dr = (int)c2.color.red - m_r1;
                m_dg = (int)c2.color.green - m_g1;
                m_db = (int)c2.color.blue - m_b1;
                m_da = (int)c2.color.alpha - m_a1;
            }

            public void calc(double y)
            {
                double k = (y - m_y1) * m_1dy;
                if (k < 0.0) k = 0.0;
                if (k > 1.0) k = 1.0;
                m_r = m_r1 + agg_basics.iround(m_dr * k);
                m_g = m_g1 + agg_basics.iround(m_dg * k);
                m_b = m_b1 + agg_basics.iround(m_db * k);
                m_a = m_a1 + agg_basics.iround(m_da * k);
                m_x = agg_basics.iround((m_x1 + m_dx * k) * (double)subpixel_scale_e.subpixel_scale);
            }

            public double m_x1;
            public double m_y1;
            public double m_dx;
            public double m_1dy;
            public int m_r1;
            public int m_g1;
            public int m_b1;
            public int m_a1;
            public int m_dr;
            public int m_dg;
            public int m_db;
            public int m_da;
            public int m_r;
            public int m_g;
            public int m_b;
            public int m_a;
            public int m_x;
        };

        //--------------------------------------------------------------------
        public span_gouraud_rgba() { }
        public span_gouraud_rgba(RGBA_Bytes c1,
                          RGBA_Bytes c2,
                          RGBA_Bytes c3,
                          double x1, double y1,
                          double x2, double y2,
                          double x3, double y3)
            : this(c1, c2, c3, x1, y1, x2, y2, x3, y3, 0)
        { }

        public span_gouraud_rgba(RGBA_Bytes c1,
                          RGBA_Bytes c2,
                          RGBA_Bytes c3,
                          double x1, double y1,
                          double x2, double y2,
                          double x3, double y3,
                          double d)
            : base(c1, c2, c3, x1, y1, x2, y2, x3, y3, d)
        { }

        //--------------------------------------------------------------------
        public void prepare()
        {
            coord_type[] coord = new coord_type[3];
            base.arrange_vertices(coord);

            m_y2 = (int)(coord[1].y);

            m_swap = agg_math.cross_product(coord[0].x, coord[0].y,
                                   coord[2].x, coord[2].y,
                                   coord[1].x, coord[1].y) < 0.0;

            m_rgba1.init(coord[0], coord[2]);
            m_rgba2.init(coord[0], coord[1]);
            m_rgba3.init(coord[1], coord[2]);
        }

        public void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            m_rgba1.calc(y);//(m_rgba1.m_1dy > 2) ? m_rgba1.m_y1 : y);
            rgba_calc pc1 = m_rgba1;
            rgba_calc pc2 = m_rgba2;

            if (y <= m_y2)
            {
                // Bottom part of the triangle (first subtriangle)
                //-------------------------
                m_rgba2.calc(y + m_rgba2.m_1dy);
            }
            else
            {
                // Upper part (second subtriangle)
                m_rgba3.calc(y - m_rgba3.m_1dy);
                //-------------------------
                pc2 = m_rgba3;
            }

            if (m_swap)
            {
                // It means that the triangle is oriented clockwise, 
                // so that we need to swap the controlling structures
                //-------------------------
                rgba_calc t = pc2;
                pc2 = pc1;
                pc1 = t;
            }

            // Get the horizontal length with subpixel accuracy
            // and protect it from division by zero
            //-------------------------
            int nlen = Math.Abs(pc2.m_x - pc1.m_x);
            if (nlen <= 0) nlen = 1;

            dda_line_interpolator r = new dda_line_interpolator(pc1.m_r, pc2.m_r, nlen, 14);
            dda_line_interpolator g = new dda_line_interpolator(pc1.m_g, pc2.m_g, nlen, 14);
            dda_line_interpolator b = new dda_line_interpolator(pc1.m_b, pc2.m_b, nlen, 14);
            dda_line_interpolator a = new dda_line_interpolator(pc1.m_a, pc2.m_a, nlen, 14);

            // Calculate the starting point of the gradient with subpixel 
            // accuracy and correct (roll back) the interpolators.
            // This operation will also clip the beginning of the span
            // if necessary.
            //-------------------------
            int start = pc1.m_x - (x << (int)subpixel_scale_e.subpixel_shift);
            r.Prev(start);
            g.Prev(start);
            b.Prev(start);
            a.Prev(start);
            nlen += start;

            int vr, vg, vb, va;
            uint lim = 255;

            // Beginning part of the span. Since we rolled back the 
            // interpolators, the color values may have overflowed.
            // So that, we render the beginning part with checking 
            // for overflow. It lasts until "start" is positive;
            // typically it's 1-2 pixels, but may be more in some cases.
            //-------------------------
            while (len != 0 && start > 0)
            {
                vr = r.y();
                vg = g.y();
                vb = b.y();
                va = a.y();
                if (vr < 0) vr = 0; if (vr > lim) vr = (int)lim;
                if (vg < 0) vg = 0; if (vg > lim) vg = (int)lim;
                if (vb < 0) vb = 0; if (vb > lim) vb = (int)lim;
                if (va < 0) va = 0; if (va > lim) va = (int)lim;
                span[spanIndex].red = (byte)vr;
                span[spanIndex].green = (byte)vg;
                span[spanIndex].blue = (byte)vb;
                span[spanIndex].alpha = (byte)va;
                r.Next((int)subpixel_scale_e.subpixel_scale);
                g.Next((int)subpixel_scale_e.subpixel_scale);
                b.Next((int)subpixel_scale_e.subpixel_scale);
                a.Next((int)subpixel_scale_e.subpixel_scale);
                nlen -= (int)subpixel_scale_e.subpixel_scale;
                start -= (int)subpixel_scale_e.subpixel_scale;
                ++spanIndex;
                --len;
            }

            // Middle part, no checking for overflow.
            // Actual spans can be longer than the calculated length
            // because of anti-aliasing, thus, the interpolators can 
            // overflow. But while "nlen" is positive we are safe.
            //-------------------------
            while (len != 0 && nlen > 0)
            {
                span[spanIndex].red = ((byte)r.y());
                span[spanIndex].green = ((byte)g.y());
                span[spanIndex].blue = ((byte)b.y());
                span[spanIndex].alpha = ((byte)a.y());
                r.Next((int)subpixel_scale_e.subpixel_scale);
                g.Next((int)subpixel_scale_e.subpixel_scale);
                b.Next((int)subpixel_scale_e.subpixel_scale);
                a.Next((int)subpixel_scale_e.subpixel_scale);
                nlen -= (int)subpixel_scale_e.subpixel_scale;
                ++spanIndex;
                --len;
            }

            // Ending part; checking for overflow.
            // Typically it's 1-2 pixels, but may be more in some cases.
            //-------------------------
            while (len != 0)
            {
                vr = r.y();
                vg = g.y();
                vb = b.y();
                va = a.y();
                if (vr < 0) vr = 0; if (vr > lim) vr = (int)lim;
                if (vg < 0) vg = 0; if (vg > lim) vg = (int)lim;
                if (vb < 0) vb = 0; if (vb > lim) vb = (int)lim;
                if (va < 0) va = 0; if (va > lim) va = (int)lim;
                span[spanIndex].red = ((byte)vr);
                span[spanIndex].green = ((byte)vg);
                span[spanIndex].blue = ((byte)vb);
                span[spanIndex].alpha = ((byte)va);
                r.Next((int)subpixel_scale_e.subpixel_scale);
                g.Next((int)subpixel_scale_e.subpixel_scale);
                b.Next((int)subpixel_scale_e.subpixel_scale);
                a.Next((int)subpixel_scale_e.subpixel_scale);
                ++spanIndex;
                --len;
            }
        }
    };
}

#endregion //agg_span_gouraud_rgba.cs
#region agg_span_gradient.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{
    public interface IGradient
    {
        int calculate(int x, int y, int d);
    };

    public interface IColorFunction
    {
        int size();
        RGBA_Bytes this[int v]
        {
            get;
        }
    };

    //==========================================================span_gradient
    public class span_gradient : ISpanGenerator
    {
        public const int gradient_subpixel_shift = 4;                              //-----gradient_subpixel_shift
        public const int gradient_subpixel_scale = 1 << gradient_subpixel_shift;   //-----gradient_subpixel_scale
        public const int gradient_subpixel_mask = gradient_subpixel_scale - 1;    //-----gradient_subpixel_mask

        public const int subpixelShift = 8;

        public const int downscale_shift = subpixelShift - gradient_subpixel_shift;

        ISpanInterpolator m_interpolator;
        IGradient m_gradient_function;
        IColorFunction m_color_function;
        int m_d1;
        int m_d2;

        //--------------------------------------------------------------------
        public span_gradient() { }

        //--------------------------------------------------------------------
        public span_gradient(ISpanInterpolator inter,
                      IGradient gradient_function,
                      IColorFunction color_function,
                      double d1, double d2)
        {
            m_interpolator = inter;
            m_gradient_function = gradient_function;
            m_color_function = color_function;
            m_d1 = (agg_basics.iround(d1 * gradient_subpixel_scale));
            m_d2 = (agg_basics.iround(d2 * gradient_subpixel_scale));
        }

        //--------------------------------------------------------------------
        public ISpanInterpolator interpolator() { return m_interpolator; }
        public IGradient gradient_function() { return m_gradient_function; }
        public IColorFunction color_function() { return m_color_function; }
        public double d1() { return (double)(m_d1) / gradient_subpixel_scale; }
        public double d2() { return (double)(m_d2) / gradient_subpixel_scale; }

        //--------------------------------------------------------------------
        public void interpolator(ISpanInterpolator i) { m_interpolator = i; }
        public void gradient_function(IGradient gf) { m_gradient_function = gf; }
        public void color_function(IColorFunction cf) { m_color_function = cf; }
        public void d1(double v) { m_d1 = agg_basics.iround(v * gradient_subpixel_scale); }
        public void d2(double v) { m_d2 = agg_basics.iround(v * gradient_subpixel_scale); }

        //--------------------------------------------------------------------
        public void prepare() { }

        //--------------------------------------------------------------------
        public void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            int dd = m_d2 - m_d1;
            if (dd < 1) dd = 1;
            m_interpolator.begin(x + 0.5, y + 0.5, len);
            do
            {
                m_interpolator.coordinates(out x, out y);
                int d = m_gradient_function.calculate(x >> downscale_shift,
                                                       y >> downscale_shift, m_d2);
                d = ((d - m_d1) * (int)m_color_function.size()) / dd;
                if (d < 0) d = 0;
                if (d >= (int)m_color_function.size())
                {
                    d = m_color_function.size() - 1;
                }

                span[spanIndex++] = m_color_function[d];
                m_interpolator.Next();
            }
            while (--len != 0);
        }
    };

    //=====================================================gradient_linear_color
    public struct gradient_linear_color : IColorFunction
    {
        RGBA_Bytes m_c1;
        RGBA_Bytes m_c2;
        int m_size;

        public gradient_linear_color(RGBA_Bytes c1, RGBA_Bytes c2)
            : this(c1, c2, 256)
        {
        }

        public gradient_linear_color(RGBA_Bytes c1, RGBA_Bytes c2, int size)
        {
            m_c1 = c1;
            m_c2 = c2;
            m_size = size;
        }

        public int size() { return m_size; }
        public RGBA_Bytes this[int v]
        {
            get
            {
                return m_c1.gradient(m_c2, (double)(v) / (double)(m_size - 1));
            }
        }

        public void colors(RGBA_Bytes c1, RGBA_Bytes c2)
        {
            colors(c1, c2, 256);
        }

        public void colors(RGBA_Bytes c1, RGBA_Bytes c2, int size)
        {
            m_c1 = c1;
            m_c2 = c2;
            m_size = size;
        }
    };

    //==========================================================gradient_circle
    public class gradient_circle : IGradient
    {
        // Actually the same as radial. Just for compatibility
        public int calculate(int x, int y, int d)
        {
            return (int)(agg_math.fast_sqrt((int)(x * x + y * y)));
        }
    };


    //==========================================================gradient_radial
    public class gradient_radial : IGradient
    {
        public int calculate(int x, int y, int d)
        {
            return (int)(System.Math.Sqrt(x * x + y * y));
            //return (int)(agg_math.fast_sqrt((int)(x * x + y * y)));
        }
    }

    //========================================================gradient_radial_d
    public class gradient_radial_d : IGradient
    {
        public int calculate(int x, int y, int d)
        {
            return (int)agg_basics.uround(System.Math.Sqrt((double)(x) * (double)(x) + (double)(y) * (double)(y)));
        }
    };

    //====================================================gradient_radial_focus
    public class gradient_radial_focus : IGradient
    {
        int m_r;
        int m_fx;
        int m_fy;
        double m_r2;
        double m_fx2;
        double m_fy2;
        double m_mul;

        //---------------------------------------------------------------------
        public gradient_radial_focus()
        {
            m_r = (100 * span_gradient.gradient_subpixel_scale);
            m_fx = (0);
            m_fy = (0);
            update_values();
        }

        //---------------------------------------------------------------------
        public gradient_radial_focus(double r, double fx, double fy)
        {
            m_r = (agg_basics.iround(r * span_gradient.gradient_subpixel_scale));
            m_fx = (agg_basics.iround(fx * span_gradient.gradient_subpixel_scale));
            m_fy = (agg_basics.iround(fy * span_gradient.gradient_subpixel_scale));
            update_values();
        }

        //---------------------------------------------------------------------
        public void init(double r, double fx, double fy)
        {
            m_r = agg_basics.iround(r * span_gradient.gradient_subpixel_scale);
            m_fx = agg_basics.iround(fx * span_gradient.gradient_subpixel_scale);
            m_fy = agg_basics.iround(fy * span_gradient.gradient_subpixel_scale);
            update_values();
        }

        //---------------------------------------------------------------------
        public double radius() { return (double)(m_r) / span_gradient.gradient_subpixel_scale; }
        public double focus_x() { return (double)(m_fx) / span_gradient.gradient_subpixel_scale; }
        public double focus_y() { return (double)(m_fy) / span_gradient.gradient_subpixel_scale; }

        //---------------------------------------------------------------------
        public int calculate(int x, int y, int d)
        {
            double dx = x - m_fx;
            double dy = y - m_fy;
            double d2 = dx * m_fy - dy * m_fx;
            double d3 = m_r2 * (dx * dx + dy * dy) - d2 * d2;
            return agg_basics.iround((dx * m_fx + dy * m_fy + System.Math.Sqrt(System.Math.Abs(d3))) * m_mul);
        }

        //---------------------------------------------------------------------
        private void update_values()
        {
            // Calculate the invariant values. In case the focal center
            // lies exactly on the gradient circle the divisor degenerates
            // into zero. In this case we just move the focal center by
            // one subpixel unit possibly in the direction to the origin (0,0)
            // and calculate the values again.
            //-------------------------
            m_r2 = (double)(m_r) * (double)(m_r);
            m_fx2 = (double)(m_fx) * (double)(m_fx);
            m_fy2 = (double)(m_fy) * (double)(m_fy);
            double d = (m_r2 - (m_fx2 + m_fy2));
            if (d == 0)
            {
                if (m_fx != 0)
                {
                    if (m_fx < 0) ++m_fx; else --m_fx;
                }

                if (m_fy != 0)
                {
                    if (m_fy < 0) ++m_fy; else --m_fy;
                }

                m_fx2 = (double)(m_fx) * (double)(m_fx);
                m_fy2 = (double)(m_fy) * (double)(m_fy);
                d = (m_r2 - (m_fx2 + m_fy2));
            }
            m_mul = m_r / d;
        }
    };


    //==============================================================gradient_x
    public class gradient_x : IGradient
    {
        public int calculate(int x, int y, int d) { return x; }
    };


    //==============================================================gradient_y
    public class gradient_y : IGradient
    {
        public int calculate(int x, int y, int d) { return y; }
    };

    //========================================================gradient_diamond
    public class gradient_diamond : IGradient
    {
        public int calculate(int x, int y, int d)
        {
            int ax = System.Math.Abs(x);
            int ay = System.Math.Abs(y);
            return ax > ay ? ax : ay;
        }
    };

    //=============================================================gradient_xy
    public class gradient_xy : IGradient
    {
        public int calculate(int x, int y, int d)
        {
            return System.Math.Abs(x) * System.Math.Abs(y) / d;
        }
    };

    //========================================================gradient_sqrt_xy
    public class gradient_sqrt_xy : IGradient
    {
        public int calculate(int x, int y, int d)
        {
            //return (int)System.Math.Sqrt((int)(System.Math.Abs(x) * System.Math.Abs(y)));
            return (int)agg_math.fast_sqrt((int)(System.Math.Abs(x) * System.Math.Abs(y)));
        }
    };

    //==========================================================gradient_conic
    public class gradient_conic : IGradient
    {
        public int calculate(int x, int y, int d)
        {
            return (int)agg_basics.uround(System.Math.Abs(System.Math.Atan2((double)(y), (double)(x))) * (double)(d) / System.Math.PI);
        }
    };

    //=================================================gradient_repeat_adaptor
    public class gradient_repeat_adaptor : IGradient
    {
        IGradient m_gradient;

        public gradient_repeat_adaptor(IGradient gradient)
        {
            m_gradient = gradient;
        }


        public int calculate(int x, int y, int d)
        {
            int ret = m_gradient.calculate(x, y, d) % d;
            if (ret < 0) ret += d;
            return ret;
        }
    };

    //================================================gradient_reflect_adaptor
    public class gradient_reflect_adaptor : IGradient
    {
        IGradient m_gradient;

        public gradient_reflect_adaptor(IGradient gradient)
        {
            m_gradient = gradient;
        }

        public int calculate(int x, int y, int d)
        {
            int d2 = d << 1;
            int ret = m_gradient.calculate(x, y, d) % d2;
            if (ret < 0) ret += d2;
            if (ret >= d) ret = d2 - ret;
            return ret;
        }
    };

    public class gradient_clamp_adaptor : IGradient
    {
        IGradient m_gradient;

        public gradient_clamp_adaptor(IGradient gradient)
        {
            m_gradient = gradient;
        }

        public int calculate(int x, int y, int d)
        {
            int ret = m_gradient.calculate(x, y, d);
            if (ret < 0) ret = 0;
            if (ret > d) ret = d;
            return ret;
        }
    };
}

#endregion //agg_span_gradient.cs
#region agg_span_image_filter.cs


//----------------------------------------------------------------------------
//
// Image transformations with filtering. Span generator base class
//
//----------------------------------------------------------------------------
//using System;
//using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;

namespace MatterHackers.Agg
{
    public interface ISpanGenerator
    {
        void prepare();
        void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len);
    };

    public abstract class span_image_filter : ISpanGenerator
    {
        private IImageBufferAccessor imageBufferAccessor;
        protected ISpanInterpolator m_interpolator;
        protected ImageFilterLookUpTable m_filter;
        private double m_dx_dbl;
        private double m_dy_dbl;
        private int m_dx_int;
        private int m_dy_int;

        public span_image_filter() { }
        public span_image_filter(IImageBufferAccessor src,
            ISpanInterpolator interpolator)
            : this(src, interpolator, null)
        {

        }

        public span_image_filter(IImageBufferAccessor src,
            ISpanInterpolator interpolator, ImageFilterLookUpTable filter)
        {
            imageBufferAccessor = src;
            m_interpolator = interpolator;
            m_filter = (filter);
            m_dx_dbl = (0.5);
            m_dy_dbl = (0.5);
            m_dx_int = ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2);
            m_dy_int = ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2);
        }
        public void attach(IImageBufferAccessor v) { imageBufferAccessor = v; }

        public abstract void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len);

        public IImageBufferAccessor GetImageBufferAccessor() { return imageBufferAccessor; }
        public ImageFilterLookUpTable filter() { return m_filter; }
        public int filter_dx_int() { return (int)m_dx_int; }
        public int filter_dy_int() { return (int)m_dy_int; }
        public double filter_dx_dbl() { return m_dx_dbl; }
        public double filter_dy_dbl() { return m_dy_dbl; }

        public void interpolator(ISpanInterpolator v) { m_interpolator = v; }
        public void filter(ImageFilterLookUpTable v) { m_filter = v; }
        public void filter_offset(double dx, double dy)
        {
            m_dx_dbl = dx;
            m_dy_dbl = dy;
            m_dx_int = (int)agg_basics.iround(dx * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale);
            m_dy_int = (int)agg_basics.iround(dy * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale);
        }
        public void filter_offset(double d) { filter_offset(d, d); }

        public ISpanInterpolator interpolator() { return m_interpolator; }

        public void prepare() { }
    }

    public interface ISpanGeneratorFloat
    {
        void prepare();
        void generate(RGBA_Floats[] span, int spanIndex, int x, int y, int len);
    };

    public abstract class span_image_filter_float : ISpanGeneratorFloat
    {
        private IImageBufferAccessorFloat m_ImageBufferAccessor;
        protected ISpanInterpolatorFloat m_interpolator;
        protected IImageFilterFunction m_filterFunction;
        private float m_dx_dbl;
        private float m_dy_dbl;

        public span_image_filter_float() { }
        public span_image_filter_float(IImageBufferAccessorFloat src,
            ISpanInterpolatorFloat interpolator)
            : this(src, interpolator, null)
        {

        }

        public span_image_filter_float(IImageBufferAccessorFloat src,
            ISpanInterpolatorFloat interpolator, IImageFilterFunction filterFunction)
        {
            m_ImageBufferAccessor = src;
            m_interpolator = interpolator;
            m_filterFunction = filterFunction;
            m_dx_dbl = (0.5f);
            m_dy_dbl = (0.5f);
        }
        public void attach(IImageBufferAccessorFloat v) { m_ImageBufferAccessor = v; }

        public abstract void generate(RGBA_Floats[] span, int spanIndex, int x, int y, int len);

        public IImageBufferAccessorFloat source() { return m_ImageBufferAccessor; }
        public IImageFilterFunction filterFunction() { return m_filterFunction; }
        public float filter_dx_dbl() { return m_dx_dbl; }
        public float filter_dy_dbl() { return m_dy_dbl; }

        public void interpolator(ISpanInterpolatorFloat v) { m_interpolator = v; }
        public void filterFunction(IImageFilterFunction v) { m_filterFunction = v; }
        public void filter_offset(float dx, float dy)
        {
            m_dx_dbl = dx;
            m_dy_dbl = dy;
        }
        public void filter_offset(float d) { filter_offset(d, d); }

        public ISpanInterpolatorFloat interpolator() { return m_interpolator; }

        public void prepare() { }
    }

    /*


    //==============================================span_image_resample_affine
    //template<class Source> 
    public class span_image_resample_affine : 
        span_image_filter//<Source, span_interpolator_linear<trans_affine> >
    {
        //typedef Source IImageAccessor;
        //typedef span_interpolator_linear<trans_affine> ISpanInterpolator;
        //typedef span_image_filter<source_type, ISpanInterpolator> base_type;

        //--------------------------------------------------------------------
        public span_image_resample_affine()
        {
            m_scale_limit=(200.0);
            m_blur_x=(1.0);
            m_blur_y=(1.0);
        }

        //--------------------------------------------------------------------
        public span_image_resample_affine(IImageAccessor src, 
                                   ISpanInterpolator inter,
                                   ImageFilterLookUpTable filter) : base(src, inter, filter)
        {
            m_scale_limit(200.0);
            m_blur_x(1.0);
            m_blur_y(1.0);
        }


        //--------------------------------------------------------------------
        public int  scale_limit() { return uround(m_scale_limit); }
        public void scale_limit(int v)  { m_scale_limit = v; }

        //--------------------------------------------------------------------
        public double blur_x() { return m_blur_x; }
        public double blur_y() { return m_blur_y; }
        public void blur_x(double v) { m_blur_x = v; }
        public void blur_y(double v) { m_blur_y = v; }
        public void blur(double v) { m_blur_x = m_blur_y = v; }

        //--------------------------------------------------------------------
        public void prepare() 
        {
            double scale_x;
            double scale_y;

            base_type::interpolator().transformer().scaling_abs(&scale_x, &scale_y);

            if(scale_x * scale_y > m_scale_limit)
            {
                scale_x = scale_x * m_scale_limit / (scale_x * scale_y);
                scale_y = scale_y * m_scale_limit / (scale_x * scale_y);
            }

            if(scale_x < 1) scale_x = 1;
            if(scale_y < 1) scale_y = 1;

            if(scale_x > m_scale_limit) scale_x = m_scale_limit;
            if(scale_y > m_scale_limit) scale_y = m_scale_limit;

            scale_x *= m_blur_x;
            scale_y *= m_blur_y;

            if(scale_x < 1) scale_x = 1;
            if(scale_y < 1) scale_y = 1;

            m_rx     = uround(    scale_x * (double)(image_subpixel_scale));
            m_rx_inv = uround(1.0/scale_x * (double)(image_subpixel_scale));

            m_ry     = uround(    scale_y * (double)(image_subpixel_scale));
            m_ry_inv = uround(1.0/scale_y * (double)(image_subpixel_scale));
        }

        protected int m_rx;
        protected int m_ry;
        protected int m_rx_inv;
        protected int m_ry_inv;

        private double m_scale_limit;
        private double m_blur_x;
        private double m_blur_y;
    };

     */


    //=====================================================span_image_resample
    public abstract class span_image_resample
        : span_image_filter
    {
        public span_image_resample(IImageBufferAccessor src,
                            ISpanInterpolator inter,
                            ImageFilterLookUpTable filter)
            : base(src, inter, filter)
        {
            m_scale_limit = (20);
            m_blur_x = ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale);
            m_blur_y = ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale);
        }

        //public abstract void prepare();
        //public abstract unsafe void generate(rgba8* span, int x, int y, int len);

        //--------------------------------------------------------------------
        int scale_limit() { return m_scale_limit; }
        void scale_limit(int v) { m_scale_limit = v; }

        //--------------------------------------------------------------------
        double blur_x() { return (double)(m_blur_x) / (double)((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale); }
        double blur_y() { return (double)(m_blur_y) / (double)((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale); }
        void blur_x(double v) { m_blur_x = (int)agg_basics.uround(v * (double)((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale)); }
        void blur_y(double v) { m_blur_y = (int)agg_basics.uround(v * (double)((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale)); }
        public void blur(double v)
        {
            m_blur_x = m_blur_y = (int)agg_basics.uround(v * (double)((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale));
        }

        protected void adjust_scale(ref int rx, ref int ry)
        {
            if (rx < (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale) rx = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
            if (ry < (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale) ry = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
            if (rx > (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * m_scale_limit)
            {
                rx = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * m_scale_limit;
            }
            if (ry > (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * m_scale_limit)
            {
                ry = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * m_scale_limit;
            }
            rx = (rx * m_blur_x) >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            ry = (ry * m_blur_y) >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            if (rx < (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale) rx = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
            if (ry < (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale) ry = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
        }

        int m_scale_limit;
        int m_blur_x;
        int m_blur_y;
    }
}

#endregion //agg_span_image_filter.cs
#region agg_span_image_filter_gray.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# Port port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//#define USE_UNSAFE_CODE

//using System;

//using MatterHackers.Agg.Image;

//using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;
//using image_filter_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e;

namespace MatterHackers.Agg
{
    // it should be easy to write a 90 rotating or mirroring filter too. LBB 2012/01/14
    public class span_image_filter_gray_nn_stepXby1 : span_image_filter
    {
        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        public span_image_filter_gray_nn_stepXby1(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
            : base(sourceAccessor, spanInterpolator, null)
        {
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
            int bytesBetweenPixelsInclusive = SourceRenderingBuffer.GetBytesBetweenPixelsInclusive();
            if (SourceRenderingBuffer.BitDepth != 8)
            {
                throw new NotSupportedException("The source is expected to be 32 bit.");
            }
            ISpanInterpolator spanInterpolator = interpolator();
            spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
            int x_hr;
            int y_hr;
            spanInterpolator.coordinates(out x_hr, out y_hr);
            int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            int bufferIndex;
            bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

            byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
#if USE_UNSAFE_CODE
            unsafe
            {
                fixed (byte* pSource = fg_ptr)
                {
                    do
                    {
                        span[spanIndex].red = pSource[bufferIndex];
                        span[spanIndex].green = pSource[bufferIndex];
                        span[spanIndex].blue = pSource[bufferIndex];
                        span[spanIndex].alpha = 255;
                        spanIndex++;
                        bufferIndex += bytesBetweenPixelsInclusive;
                    } while (--len != 0);
                }
            }
#else
            //do
            //{
            //    throw new Exception("this code is for 32 bit");
            //    color.m_B = fg_ptr[bufferIndex++];
            //    color.m_G = fg_ptr[bufferIndex++];
            //    color.m_R = fg_ptr[bufferIndex++];
            //    color.m_A = fg_ptr[bufferIndex++];
            //    span[spanIndex++] = color;
            //} while (--len != 0);
#endif
        }
    }

    /*
        //==============================================span_image_filter_gray_nn
        //template<class Source, class Interpolator> 
        public class span_image_filter_gray_nn : span_image_filter // <Source, Interpolator>
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef Interpolator interpolator_type;
            //typedef span_image_filter<source_type, interpolator_type> base_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::calc_type calc_type;
            enum base_scale_e
            {
                base_shift = 8,//color_type::base_shift,
                base_mask  = 255//color_type::base_mask
            };

            //--------------------------------------------------------------------
            public span_image_filter_gray_nn() {}
            public span_image_filter_gray_nn(source_type src, interpolator_type inter) :
                base(src, inter, 0) 
            {}

            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                                y + base_type::filter_dy_dbl(), len);
                do
                {
                    base_type::interpolator().coordinates(&x, &y);
                    span->v = *(value_type*)
                        base_type::source().span(x >> image_subpixel_shift, 
                                                 y >> image_subpixel_shift, 
                                                 1);
                    span->a = base_mask;
                    ++span;
                    ++base_type::interpolator();
                } while(--len);
            }
        };



        //=========================================span_image_filter_gray_bilinear
        //template<class Source, class Interpolator> 
        public class span_image_filter_gray_bilinear : span_image_filter // <Source, Interpolator>
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef Interpolator interpolator_type;
            //typedef span_image_filter<source_type, interpolator_type> base_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::calc_type calc_type;
            enum base_scale_e
            {
                base_shift = 8,//color_type::base_shift,
                base_mask  = 255//color_type::base_mask
            };

            //--------------------------------------------------------------------
            public span_image_filter_gray_bilinear() {}
            public span_image_filter_gray_bilinear(source_type src, 
                                            interpolator_type inter) :
                base(src, inter, 0) 
            {}


            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                                y + base_type::filter_dy_dbl(), len);
                calc_type fg;
                value_type *fg_ptr;
                do
                {
                    int x_hr;
                    int y_hr;

                    base_type::interpolator().coordinates(&x_hr, &y_hr);

                    x_hr -= base_type::filter_dx_int();
                    y_hr -= base_type::filter_dy_int();

                    int x_lr = x_hr >> image_subpixel_shift;
                    int y_lr = y_hr >> image_subpixel_shift;

                    fg = image_subpixel_scale * image_subpixel_scale / 2;

                    x_hr &= image_subpixel_mask;
                    y_hr &= image_subpixel_mask;

                    fg_ptr = (value_type*)base_type::source().span(x_lr, y_lr, 2);
                    fg    += *fg_ptr * (image_subpixel_scale - x_hr) * (image_subpixel_scale - y_hr);

                    fg_ptr = (value_type*)base_type::source().next_x();
                    fg    += *fg_ptr * x_hr * (image_subpixel_scale - y_hr);

                    fg_ptr = (value_type*)base_type::source().next_y();
                    fg    += *fg_ptr * (image_subpixel_scale - x_hr) * y_hr;

                    fg_ptr = (value_type*)base_type::source().next_x();
                    fg    += *fg_ptr * x_hr * y_hr;

                    span->v = value_type(fg >> (image_subpixel_shift * 2));
                    span->a = base_mask;
                    ++span;
                    ++base_type::interpolator();

                } while(--len);
            }
        };


        //====================================span_image_filter_gray_bilinear_clip
        //template<class Source, class Interpolator> 
        public class span_image_filter_gray_bilinear_clip : span_image_filter // <Source, Interpolator>
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef Interpolator interpolator_type;
            //typedef span_image_filter<source_type, interpolator_type> base_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::calc_type calc_type;
            enum base_scale_e
            {
                base_shift = 8,//color_type::base_shift,
                base_mask  = 255//color_type::base_mask
            };

            //--------------------------------------------------------------------
            public span_image_filter_gray_bilinear_clip() {}
            public span_image_filter_gray_bilinear_clip(source_type src, 
                                                 color_type back_color,
                                                 interpolator_type inter) :
                base(src, inter, 0)
            {
                m_back_color = (back_color);
            }
            public color_type background_color() { return m_back_color; }
            public void background_color(color_type v)   { m_back_color = v; }

            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                                y + base_type::filter_dy_dbl(), len);
                calc_type fg;
                calc_type src_alpha;
                value_type back_v = m_back_color.v;
                value_type back_a = m_back_color.a;

                value_type *fg_ptr;

                int maxx = base_type::source().width() - 1;
                int maxy = base_type::source().height() - 1;

                do
                {
                    int x_hr;
                    int y_hr;
                
                    base_type::interpolator().coordinates(&x_hr, &y_hr);

                    x_hr -= base_type::filter_dx_int();
                    y_hr -= base_type::filter_dy_int();

                    int x_lr = x_hr >> image_subpixel_shift;
                    int y_lr = y_hr >> image_subpixel_shift;

                    if(x_lr >= 0    && y_lr >= 0 &&
                       x_lr <  maxx && y_lr <  maxy) 
                    {
                        fg = image_subpixel_scale * image_subpixel_scale / 2;

                        x_hr &= image_subpixel_mask;
                        y_hr &= image_subpixel_mask;
                        fg_ptr = (value_type*)base_type::source().row_ptr(y_lr) + x_lr;

                        fg += *fg_ptr++ * (image_subpixel_scale - x_hr) * (image_subpixel_scale - y_hr);
                        fg += *fg_ptr++ * (image_subpixel_scale - y_hr) * x_hr;

                        ++y_lr;
                        fg_ptr = (value_type*)base_type::source().row_ptr(y_lr) + x_lr;

                        fg += *fg_ptr++ * (image_subpixel_scale - x_hr) * y_hr;
                        fg += *fg_ptr++ * x_hr * y_hr;

                        fg >>= image_subpixel_shift * 2;
                        src_alpha = base_mask;
                    }
                    else
                    {
                        unsigned weight;
                        if(x_lr < -1   || y_lr < -1 ||
                           x_lr > maxx || y_lr > maxy)
                        {
                            fg        = back_v;
                            src_alpha = back_a;
                        }
                        else
                        {
                            fg = 
                            src_alpha = image_subpixel_scale * image_subpixel_scale / 2;

                            x_hr &= image_subpixel_mask;
                            y_hr &= image_subpixel_mask;

                            weight = (image_subpixel_scale - x_hr) * 
                                     (image_subpixel_scale - y_hr);
                            if(x_lr >= 0    && y_lr >= 0 &&
                               x_lr <= maxx && y_lr <= maxy)
                            {
                                fg += weight * 
                                    *((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
                                src_alpha += weight * base_mask;
                            }
                            else
                            {
                                fg        += back_v * weight;
                                src_alpha += back_a * weight;
                            }

                            x_lr++;

                            weight = x_hr * (image_subpixel_scale - y_hr);
                            if(x_lr >= 0    && y_lr >= 0 &&
                               x_lr <= maxx && y_lr <= maxy)
                            {
                                fg += weight * 
                                    *((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
                                src_alpha += weight * base_mask;
                            }
                            else
                            {
                                fg        += back_v * weight;
                                src_alpha += back_a * weight;
                            }

                            x_lr--;
                            y_lr++;

                            weight = (image_subpixel_scale - x_hr) * y_hr;
                            if(x_lr >= 0    && y_lr >= 0 &&
                               x_lr <= maxx && y_lr <= maxy)
                            {
                                fg += weight * 
                                    *((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
                                src_alpha += weight * base_mask;
                            }
                            else
                            {
                                fg        += back_v * weight;
                                src_alpha += back_a * weight;
                            }

                            x_lr++;

                            weight = x_hr * y_hr;
                            if(x_lr >= 0    && y_lr >= 0 &&
                               x_lr <= maxx && y_lr <= maxy)
                            {
                                fg += weight * 
                                    *((value_type*)base_type::source().row_ptr(y_lr) + x_lr);
                                src_alpha += weight * base_mask;
                            }
                            else
                            {
                                fg        += back_v * weight;
                                src_alpha += back_a * weight;
                            }

                            fg        >>= image_subpixel_shift * 2;
                            src_alpha >>= image_subpixel_shift * 2;
                        }
                    }

                    span->v = (value_type)fg;
                    span->a = (value_type)src_alpha;
                    ++span;
                    ++base_type::interpolator();

                } while(--len);
            }

            color_type m_back_color;
        };



        //==============================================span_image_filter_gray_2x2
        //template<class Source, class Interpolator> 
        public class span_image_filter_gray_2x2 : span_image_filter//<Source, Interpolator>
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef Interpolator interpolator_type;
            //typedef span_image_filter<source_type, interpolator_type> base_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::calc_type calc_type;
            enum base_scale_e
            {
                base_shift = 8,//color_type::base_shift,
                base_mask  = 255//color_type::base_mask
            };

            //--------------------------------------------------------------------
            public span_image_filter_gray_2x2() {}
            public span_image_filter_gray_2x2(source_type src, 
                                       interpolator_type inter,
                                       image_filter_lut filter) :
                base(src, inter, &filter) 
            {}


            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                                y + base_type::filter_dy_dbl(), len);

                calc_type fg;

                value_type *fg_ptr;
                int16* weight_array = base_type::filter().weight_array() + 
                                            ((base_type::filter().diameter()/2 - 1) << 
                                              image_subpixel_shift);
                do
                {
                    int x_hr;
                    int y_hr;

                    base_type::interpolator().coordinates(&x_hr, &y_hr);

                    x_hr -= base_type::filter_dx_int();
                    y_hr -= base_type::filter_dy_int();

                    int x_lr = x_hr >> image_subpixel_shift;
                    int y_lr = y_hr >> image_subpixel_shift;

                    unsigned weight;
                    fg = image_filter_scale / 2;

                    x_hr &= image_subpixel_mask;
                    y_hr &= image_subpixel_mask;

                    fg_ptr = (value_type*)base_type::source().span(x_lr, y_lr, 2);
                    weight = (weight_array[x_hr + image_subpixel_scale] * 
                              weight_array[y_hr + image_subpixel_scale] + 
                              image_filter_scale / 2) >> 
                              image_filter_shift;
                    fg += weight * *fg_ptr;

                    fg_ptr = (value_type*)base_type::source().next_x();
                    weight = (weight_array[x_hr] * 
                              weight_array[y_hr + image_subpixel_scale] + 
                              image_filter_scale / 2) >> 
                              image_filter_shift;
                    fg += weight * *fg_ptr;

                    fg_ptr = (value_type*)base_type::source().next_y();
                    weight = (weight_array[x_hr + image_subpixel_scale] * 
                              weight_array[y_hr] + 
                              image_filter_scale / 2) >> 
                              image_filter_shift;
                    fg += weight * *fg_ptr;

                    fg_ptr = (value_type*)base_type::source().next_x();
                    weight = (weight_array[x_hr] * 
                              weight_array[y_hr] + 
                              image_filter_scale / 2) >> 
                              image_filter_shift;
                    fg += weight * *fg_ptr;

                    fg >>= image_filter_shift;
                    if(fg > base_mask) fg = base_mask;

                    span->v = (value_type)fg;
                    span->a = base_mask;
                    ++span;
                    ++base_type::interpolator();
                } while(--len);
            }
        };



        //==================================================span_image_filter_gray
        //template<class Source, class Interpolator> 
        public class span_image_filter_gray : span_image_filter//<Source, Interpolator>
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef Interpolator interpolator_type;
            //typedef span_image_filter<source_type, interpolator_type> base_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::calc_type calc_type;
            enum base_scale_e
            {
                base_shift = 8,//color_type::base_shift,
                base_mask  = 255//color_type::base_mask
            };

            //--------------------------------------------------------------------
            public span_image_filter_gray() {}
            public span_image_filter_gray(source_type src, 
                                   interpolator_type inter,
                                   image_filter_lut filter) :
                base(src, inter, filter) 
            {}

            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                                y + base_type::filter_dy_dbl(), len);

                int fg;
                value_type *fg_ptr;

                unsigned     diameter     = base_type::filter().diameter();
                int          start        = base_type::filter().start();
                int16* weight_array = base_type::filter().weight_array();

                int x_count; 
                int weight_y;

                do
                {
                    base_type::interpolator().coordinates(&x, &y);

                    x -= base_type::filter_dx_int();
                    y -= base_type::filter_dy_int();

                    int x_hr = x; 
                    int y_hr = y; 

                    int x_lr = x_hr >> image_subpixel_shift;
                    int y_lr = y_hr >> image_subpixel_shift;

                    fg = image_filter_scale / 2;

                    int x_fract = x_hr & image_subpixel_mask;
                    unsigned y_count = diameter;

                    y_hr = image_subpixel_mask - (y_hr & image_subpixel_mask);
                    fg_ptr = (value_type*)base_type::source().span(x_lr + start, 
                                                                         y_lr + start, 
                                                                         diameter);
                    for(;;)
                    {
                        x_count  = diameter;
                        weight_y = weight_array[y_hr];
                        x_hr = image_subpixel_mask - x_fract;
                        for(;;)
                        {
                            fg += *fg_ptr * 
                                  ((weight_y * weight_array[x_hr] + 
                                    image_filter_scale / 2) >> 
                                    image_filter_shift);
                            if(--x_count == 0) break;
                            x_hr  += image_subpixel_scale;
                            fg_ptr = (value_type*)base_type::source().next_x();
                        }

                        if(--y_count == 0) break;
                        y_hr  += image_subpixel_scale;
                        fg_ptr = (value_type*)base_type::source().next_y();
                    }

                    fg >>= image_filter_shift;
                    if(fg < 0) fg = 0;
                    if(fg > base_mask) fg = base_mask;
                    span->v = (value_type)fg;
                    span->a = base_mask;

                    ++span;
                    ++base_type::interpolator();

                } while(--len);
            }
        };

        //=========================================span_image_resample_gray_affine
        //template<class Source> 
        public class span_image_resample_gray_affine : span_image_resample_affine//<Source>
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef span_image_resample_affine<source_type> base_type;
            //typedef typename base_type::interpolator_type interpolator_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::long_type long_type;
            enum base_scale_e
            {
                base_shift      = 8,//color_type::base_shift,
                base_mask       = 255,//color_type::base_mask,
                downscale_shift = image_filter_shift
            };

            //--------------------------------------------------------------------
            public span_image_resample_gray_affine() {}
            public span_image_resample_gray_affine(source_type src, 
                                            interpolator_type inter,
                                            image_filter_lut filter) :
                base(src, inter, filter) 
            {}


            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                                y + base_type::filter_dy_dbl(), len);

                long_type fg;

                int diameter     = base_type::filter().diameter();
                int filter_scale = diameter << image_subpixel_shift;
                int radius_x     = (diameter * base_type::m_rx) >> 1;
                int radius_y     = (diameter * base_type::m_ry) >> 1;
                int len_x_lr     = 
                    (diameter * base_type::m_rx + image_subpixel_mask) >> 
                        image_subpixel_shift;

                int16* weight_array = base_type::filter().weight_array();

                do
                {
                    base_type::interpolator().coordinates(&x, &y);

                    x += base_type::filter_dx_int() - radius_x;
                    y += base_type::filter_dy_int() - radius_y;

                    fg = image_filter_scale / 2;

                    int y_lr = y >> image_subpixel_shift;
                    int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) * 
                                    base_type::m_ry_inv) >> 
                                        image_subpixel_shift;
                    int total_weight = 0;
                    int x_lr = x >> image_subpixel_shift;
                    int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) * 
                                    base_type::m_rx_inv) >> 
                                        image_subpixel_shift;

                    int x_hr2 = x_hr;
                    value_type* fg_ptr = 
                        (value_type*)base_type::source().span(x_lr, y_lr, len_x_lr);
                    for(;;)
                    {
                        int weight_y = weight_array[y_hr];
                        x_hr = x_hr2;
                        for(;;)
                        {
                            int weight = (weight_y * weight_array[x_hr] + 
                                         image_filter_scale / 2) >> 
                                         downscale_shift;

                            fg += *fg_ptr * weight;
                            total_weight += weight;
                            x_hr  += base_type::m_rx_inv;
                            if(x_hr >= filter_scale) break;
                            fg_ptr = (value_type*)base_type::source().next_x();
                        }
                        y_hr += base_type::m_ry_inv;
                        if(y_hr >= filter_scale) break;
                        fg_ptr = (value_type*)base_type::source().next_y();
                    }

                    fg /= total_weight;
                    if(fg < 0) fg = 0;
                    if(fg > base_mask) fg = base_mask;

                    span->v = (value_type)fg;
                    span->a = base_mask;

                    ++span;
                    ++base_type::interpolator();
                } while(--len);
            }
        };



        //================================================span_image_resample_gray
        //template<class Source, class Interpolator>
        public class span_image_resample_gray : span_image_resample//<Source, Interpolator>
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef Interpolator interpolator_type;
            //typedef span_image_resample<source_type, interpolator_type> base_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::long_type long_type;
            enum base_scale_e
            {
                base_shift = 8,//color_type::base_shift,
                base_mask  = 255,//color_type::base_mask,
                downscale_shift = image_filter_shift
            };

            //--------------------------------------------------------------------
            public span_image_resample_gray() {}
            public span_image_resample_gray(source_type src, 
                                     interpolator_type inter,
                                     image_filter_lut filter) :
                base(src, inter, filter)
            {}

            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                                y + base_type::filter_dy_dbl(), len);
                long_type fg;

                int diameter = base_type::filter().diameter();
                int filter_scale = diameter << image_subpixel_shift;

                int16* weight_array = base_type::filter().weight_array();
                do
                {
                    int rx;
                    int ry;
                    int rx_inv = image_subpixel_scale;
                    int ry_inv = image_subpixel_scale;
                    base_type::interpolator().coordinates(&x,  &y);
                    base_type::interpolator().local_scale(&rx, &ry);
                    base_type::adjust_scale(&rx, &ry);

                    rx_inv = image_subpixel_scale * image_subpixel_scale / rx;
                    ry_inv = image_subpixel_scale * image_subpixel_scale / ry;

                    int radius_x = (diameter * rx) >> 1;
                    int radius_y = (diameter * ry) >> 1;
                    int len_x_lr = 
                        (diameter * rx + image_subpixel_mask) >> 
                            image_subpixel_shift;

                    x += base_type::filter_dx_int() - radius_x;
                    y += base_type::filter_dy_int() - radius_y;

                    fg = image_filter_scale / 2;

                    int y_lr = y >> image_subpixel_shift;
                    int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) * 
                                   ry_inv) >> 
                                       image_subpixel_shift;
                    int total_weight = 0;
                    int x_lr = x >> image_subpixel_shift;
                    int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) * 
                                   rx_inv) >> 
                                       image_subpixel_shift;
                    int x_hr2 = x_hr;
                    value_type* fg_ptr = 
                        (value_type*)base_type::source().span(x_lr, y_lr, len_x_lr);

                    for(;;)
                    {
                        int weight_y = weight_array[y_hr];
                        x_hr = x_hr2;
                        for(;;)
                        {
                            int weight = (weight_y * weight_array[x_hr] + 
                                         image_filter_scale / 2) >> 
                                         downscale_shift;
                            fg += *fg_ptr * weight;
                            total_weight += weight;
                            x_hr  += rx_inv;
                            if(x_hr >= filter_scale) break;
                            fg_ptr = (value_type*)base_type::source().next_x();
                        }
                        y_hr += ry_inv;
                        if(y_hr >= filter_scale) break;
                        fg_ptr = (value_type*)base_type::source().next_y();
                    }

                    fg /= total_weight;
                    if(fg < 0) fg = 0;
                    if(fg > base_mask) fg = base_mask;

                    span->v = (value_type)fg;
                    span->a = base_mask;

                    ++span;
                    ++base_type::interpolator();
                } while(--len);
            }
        };
         */
}

#endregion //agg_span_image_filter_gray.cs
#region agg_span_image_filter_rgb.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// C# Port port by: Lars Brubaker
//                  larsbrubaker@gmail.com
// Copyright (C) 2007
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//using System;
//using MatterHackers.Agg.Image;

//using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;
//using image_filter_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e;

namespace MatterHackers.Agg
{
    // it should be easy to write a 90 rotating or mirroring filter too. LBB 2012/01/14
    public class span_image_filter_rgb_nn_stepXby1 : span_image_filter
    {
        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        public span_image_filter_rgb_nn_stepXby1(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
            : base(sourceAccessor, spanInterpolator, null)
        {
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
            if (SourceRenderingBuffer.BitDepth != 24)
            {
                throw new NotSupportedException("The source is expected to be 32 bit.");
            }
            ISpanInterpolator spanInterpolator = interpolator();
            spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
            int x_hr;
            int y_hr;
            spanInterpolator.coordinates(out x_hr, out y_hr);
            int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            int bufferIndex;
            bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

            byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
#if USE_UNSAFE_CODE
            unsafe
            {
                fixed (byte* pSource = fg_ptr)
                {
                    do
                    {
                        span[spanIndex++] = *(RGBA_Bytes*)&(pSource[bufferIndex]);
                        bufferIndex += 4;
                    } while (--len != 0);
                }
            }
#else
            RGBA_Bytes color = RGBA_Bytes.White;
            do
            {
                color.blue = fg_ptr[bufferIndex++];
                color.green = fg_ptr[bufferIndex++];
                color.red = fg_ptr[bufferIndex++];
                span[spanIndex++] = color;
            } while (--len != 0);
#endif
        }
    }

    //===============================================span_image_filter_rgb_nn
    public class span_image_filter_rgb_nn : span_image_filter
    {
        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        //--------------------------------------------------------------------
        public span_image_filter_rgb_nn(IImageBufferAccessor src, ISpanInterpolator inter)
            : base(src, inter, null)
        {
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
            if (SourceRenderingBuffer.BitDepth != 24)
            {
                throw new NotSupportedException("The source is expected to be 32 bit.");
            }
            ISpanInterpolator spanInterpolator = interpolator();
            spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
            int offset;
            byte[] fg_ptr = SourceRenderingBuffer.GetBuffer(out offset);
            do
            {
                int x_hr;
                int y_hr;
                spanInterpolator.coordinates(out x_hr, out y_hr);
                int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int bufferIndex;
                bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);
                RGBA_Bytes color;
                color.blue = fg_ptr[bufferIndex++];
                color.green = fg_ptr[bufferIndex++];
                color.red = fg_ptr[bufferIndex++];
                color.alpha = 255;
                span[spanIndex] = color;
                spanIndex++;
                spanInterpolator.Next();
            } while (--len != 0);
        }
    };

    //==========================================span_image_filter_rgb_bilinear
    public class span_image_filter_rgb_bilinear : span_image_filter
    {
        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        //--------------------------------------------------------------------
        public span_image_filter_rgb_bilinear(IImageBufferAccessor src,
                                            ISpanInterpolator inter)
            : base(src, inter, null)
        {
            if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 3)
            {
                throw new System.NotSupportedException("span_image_filter_rgb must have a 24 bit DestImage");
            }
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
            ISpanInterpolator spanInterpolator = base.interpolator();
            int bufferIndex;
            byte[] fg_ptr = SourceRenderingBuffer.GetBuffer(out bufferIndex);

            unchecked
            {
                do
                {
                    int tempR;
                    int tempG;
                    int tempB;

                    int x_hr;
                    int y_hr;

                    spanInterpolator.coordinates(out x_hr, out y_hr);

                    x_hr -= base.filter_dx_int();
                    y_hr -= base.filter_dy_int();

                    int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int weight;

                    tempR =
                    tempG =
                    tempB = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2;

                    x_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                    y_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;

                    bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

                    weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                             ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    bufferIndex += 3;

                    weight = (x_hr * ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                    y_lr++;
                    bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

                    weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    bufferIndex += 3;

                    weight = (x_hr * y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                    tempR >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                    tempG >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                    tempB >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;

                    RGBA_Bytes color;
                    color.red = (byte)tempR;
                    color.green = (byte)tempG;
                    color.blue = (byte)tempB;
                    color.alpha = 255;
                    span[spanIndex] = color;
                    spanIndex++;
                    spanInterpolator.Next();

                } while (--len != 0);
            }
        }

        private void BlendInFilterPixel(int[] fg, ref int src_alpha, int back_r, int back_g, int back_b, int back_a, ImageBuffer SourceRenderingBuffer, int maxx, int maxy, int x_lr, int y_lr, int weight)
        {
            throw new NotImplementedException(); /*
            int[] fg_ptr;
            int bufferIndex;
            unchecked
            {
                if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)
                {
                    fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

                    fg[0] += (weight * (fg_ptr[bufferIndex] & (int)RGBA_Bytes.m_R) >> (int)RGBA_Bytes.Shift.R);
                    fg[1] += (weight * (fg_ptr[bufferIndex] & (int)RGBA_Bytes.m_G) >> (int)RGBA_Bytes.Shift.G);
                    fg[2] += (weight * (fg_ptr[bufferIndex] & (int)RGBA_Bytes.m_G) >> (int)RGBA_Bytes.Shift.B);
                    src_alpha += weight * base_mask;
                }
                else
                {
                    fg[0] += (weight * back_r);
                    fg[1] += (weight * back_g);
                    fg[2] += (weight * back_b);
                    src_alpha += back_a * weight;
                }
            }
                                                      */
        }
    };

    //=====================================span_image_filter_rgb_bilinear_clip
    public class span_image_filter_rgb_bilinear_clip : span_image_filter
    {
        private RGBA_Bytes m_OutsideSourceColor;

        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        //--------------------------------------------------------------------
        public span_image_filter_rgb_bilinear_clip(IImageBufferAccessor src,
                                            IColorType back_color,
                                            ISpanInterpolator inter)
            : base(src, inter, null)
        {
            m_OutsideSourceColor = back_color.GetAsRGBA_Bytes();
        }
        public IColorType background_color() { return m_OutsideSourceColor; }
        public void background_color(IColorType v) { m_OutsideSourceColor = v.GetAsRGBA_Bytes(); }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int[] accumulatedColor = new int[3];
            int sourceAlpha;

            int back_r = m_OutsideSourceColor.red;
            int back_g = m_OutsideSourceColor.green;
            int back_b = m_OutsideSourceColor.blue;
            int back_a = m_OutsideSourceColor.alpha;

            int bufferIndex;
            byte[] fg_ptr;

            ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
            int maxx = (int)SourceRenderingBuffer.Width - 1;
            int maxy = (int)SourceRenderingBuffer.Height - 1;
            ISpanInterpolator spanInterpolator = base.interpolator();

            unchecked
            {
                do
                {
                    int x_hr;
                    int y_hr;

                    spanInterpolator.coordinates(out x_hr, out y_hr);

                    x_hr -= base.filter_dx_int();
                    y_hr -= base.filter_dy_int();

                    int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int weight;

                    if (x_lr >= 0 && y_lr >= 0 &&
                       x_lr < maxx && y_lr < maxy)
                    {
                        accumulatedColor[0] =
                        accumulatedColor[1] =
                        accumulatedColor[2] = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2;

                        x_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                        y_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;

                        fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

                        weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                                 ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                        accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                        accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                        accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                        bufferIndex += 3;
                        weight = (x_hr * ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                        accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                        accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                        accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                        y_lr++;
                        fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

                        weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                        accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                        accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                        accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                        bufferIndex += 3;
                        weight = (x_hr * y_hr);
                        accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                        accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                        accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                        accumulatedColor[0] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                        accumulatedColor[1] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                        accumulatedColor[2] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;

                        sourceAlpha = base_mask;
                    }
                    else
                    {
                        if (x_lr < -1 || y_lr < -1 ||
                           x_lr > maxx || y_lr > maxy)
                        {
                            accumulatedColor[0] = back_r;
                            accumulatedColor[1] = back_g;
                            accumulatedColor[2] = back_b;
                            sourceAlpha = back_a;
                        }
                        else
                        {
                            accumulatedColor[0] =
                            accumulatedColor[1] =
                            accumulatedColor[2] = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2;
                            sourceAlpha = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2;

                            x_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                            y_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;

                            weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                                     ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                            BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

                            x_lr++;

                            weight = (x_hr * ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                            BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

                            x_lr--;
                            y_lr++;

                            weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                            BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

                            x_lr++;

                            weight = (x_hr * y_hr);
                            BlendInFilterPixel(accumulatedColor, ref sourceAlpha, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);

                            accumulatedColor[0] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                            accumulatedColor[1] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                            accumulatedColor[2] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                            sourceAlpha >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                        }
                    }

                    span[spanIndex].red = (byte)accumulatedColor[0];
                    span[spanIndex].green = (byte)accumulatedColor[1];
                    span[spanIndex].blue = (byte)accumulatedColor[2];
                    span[spanIndex].alpha = (byte)sourceAlpha;
                    spanIndex++;
                    spanInterpolator.Next();
                } while (--len != 0);
            }
        }

        private void BlendInFilterPixel(int[] accumulatedColor, ref int sourceAlpha, int back_r, int back_g, int back_b, int back_a, ImageBuffer SourceRenderingBuffer, int maxx, int maxy, int x_lr, int y_lr, int weight)
        {
            byte[] fg_ptr;
            unchecked
            {
                if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)
                {
                    int bufferIndex;
                    fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

                    accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    sourceAlpha += weight * base_mask;
                }
                else
                {
                    accumulatedColor[0] += back_r * weight;
                    accumulatedColor[1] += back_g * weight;
                    accumulatedColor[2] += back_b * weight;
                    sourceAlpha += back_a * weight;
                }
            }
        }
    };

    //===================================================span_image_filter_rgb
    public class span_image_filter_rgb : span_image_filter
    {
        const int base_mask = 255;

        //--------------------------------------------------------------------
        public span_image_filter_rgb(IImageBufferAccessor src, ISpanInterpolator inter, ImageFilterLookUpTable filter)
            : base(src, inter, filter)
        {
            if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 3)
            {
                throw new System.NotSupportedException("span_image_filter_rgb must have a 24 bit DestImage");
            }
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int f_r, f_g, f_b;

            byte[] fg_ptr;

            int diameter = m_filter.diameter();
            int start = m_filter.start();
            int[] weight_array = m_filter.weight_array();

            int x_count;
            int weight_y;

            ISpanInterpolator spanInterpolator = base.interpolator();

            do
            {
                spanInterpolator.coordinates(out x, out y);

                x -= base.filter_dx_int();
                y -= base.filter_dy_int();

                int x_hr = x;
                int y_hr = y;

                int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;

                f_b = f_g = f_r = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2;

                int x_fract = x_hr & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                int y_count = diameter;

                y_hr = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask);

                int bufferIndex;
                fg_ptr = GetImageBufferAccessor().span(x_lr + start, y_lr + start, diameter, out bufferIndex);
                for (; ; )
                {
                    x_count = (int)diameter;
                    weight_y = weight_array[y_hr];
                    x_hr = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - x_fract;
                    for (; ; )
                    {
                        int weight = (weight_y * weight_array[x_hr] +
                                     (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2) >>
                                     (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

                        f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                        f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                        f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                        if (--x_count == 0) break;
                        x_hr += (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                        GetImageBufferAccessor().next_x(out bufferIndex);
                    }

                    if (--y_count == 0) break;
                    y_hr += (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                    fg_ptr = GetImageBufferAccessor().next_y(out bufferIndex);
                }

                f_b >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;
                f_g >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;
                f_r >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

                unchecked
                {
                    if ((uint)f_b > base_mask)
                    {
                        if (f_b < 0) f_b = 0;
                        if (f_b > base_mask) f_b = (int)base_mask;
                    }

                    if ((uint)f_g > base_mask)
                    {
                        if (f_g < 0) f_g = 0;
                        if (f_g > base_mask) f_g = (int)base_mask;
                    }

                    if ((uint)f_r > base_mask)
                    {
                        if (f_r < 0) f_r = 0;
                        if (f_r > base_mask) f_r = (int)base_mask;
                    }
                }

                span[spanIndex].alpha = (byte)base_mask;
                span[spanIndex].red = (byte)f_b;
                span[spanIndex].green = (byte)f_g;
                span[spanIndex].blue = (byte)f_r;

                spanIndex++;
                spanInterpolator.Next();

            } while (--len != 0);
        }
    };

    //===============================================span_image_filter_rgb_2x2
    public class span_image_filter_rgb_2x2 : span_image_filter
    {
        private const int base_mask = 255;

        //--------------------------------------------------------------------
        public span_image_filter_rgb_2x2(IImageBufferAccessor src, ISpanInterpolator inter, ImageFilterLookUpTable filter)
            : base(src, inter, filter)
        {
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            throw new NotImplementedException(); /*
            ISpanInterpolator spanInterpolator = base.interpolator();
            spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int[] fg = new int[3];

            int[] fg_ptr;
            int bufferIndex;
            int[] weight_array = filter().weight_array();
            int weightArrayIndex = ((filter().diameter() / 2 - 1) << (int)image_subpixel_scale_e.image_subpixel_shift);

            do
            {
                int x_hr;
                int y_hr;

                spanInterpolator.coordinates(out x_hr, out y_hr);

                x_hr -= filter_dx_int();
                y_hr -= filter_dy_int();

                int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
                int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;

                int weight;
                fg[0] = fg[1] = fg[2] = (int)image_filter_scale_e.image_filter_scale / 2;

                x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
                y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

                fg_ptr = source().span(x_lr, y_lr, 2, out bufferIndex);
                weight = ((weight_array[x_hr + (int)image_subpixel_scale_e.image_subpixel_scale] *
                          weight_array[y_hr + (int)image_subpixel_scale_e.image_subpixel_scale] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg_ptr = source().next_x(out bufferIndex);
                weight = ((weight_array[x_hr] *
                          weight_array[y_hr + (int)image_subpixel_scale_e.image_subpixel_scale] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg_ptr = source().next_y(out bufferIndex);
                weight = ((weight_array[x_hr + (int)image_subpixel_scale_e.image_subpixel_scale] *
                          weight_array[y_hr] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg_ptr = source().next_x(out bufferIndex);
                weight = ((weight_array[x_hr] *
                          weight_array[y_hr] +
                          (int)image_filter_scale_e.image_filter_scale / 2) >>
                          (int)image_filter_scale_e.image_filter_shift);
                fg[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                fg[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                fg[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];

                fg[0] >>= (int)image_filter_scale_e.image_filter_shift;
                fg[1] >>= (int)image_filter_scale_e.image_filter_shift;
                fg[2] >>= (int)image_filter_scale_e.image_filter_shift;

                if (fg[0] > base_mask) fg[0] = (int)base_mask;
                if (fg[1] > base_mask) fg[1] = (int)base_mask;
                if (fg[2] > base_mask) fg[2] = (int)base_mask;

                span[spanIndex].m_ARGBData = base_mask << (int)RGBA_Bytes.Shift.A | fg[0] << (int)RGBA_Bytes.Shift.R | fg[1] << (int)RGBA_Bytes.Shift.G | fg[2] << (int)RGBA_Bytes.Shift.B;

                spanIndex++;
                spanInterpolator.Next();

            } while (--len != 0);
                                                      */
        }
    };

    /*
    //==========================================span_image_resample_rgb_affine
    template<class Source> 
    class span_image_resample_rgb_affine : 
    public span_image_resample_affine<Source>
    {
    public:
        typedef Source source_type;
        typedef typename source_type::color_type color_type;
        typedef typename source_type::order_type order_type;
        typedef span_image_resample_affine<source_type> base_type;
        typedef typename base_type::interpolator_type interpolator_type;
        typedef typename color_type::value_type value_type;
        typedef typename color_type::long_type long_type;
        enum base_scale_e
        {
            base_shift      = 8,//color_type::base_shift,
            base_mask       = 255,//color_type::base_mask,
            downscale_shift = image_filter_shift
        };

        //--------------------------------------------------------------------
        span_image_resample_rgb_affine() {}
        span_image_resample_rgb_affine(source_type& src, 
                                       interpolator_type& inter,
                                       const ImageFilterLookUpTable& filter) :
            base(src, inter, filter) 
        {}


        //--------------------------------------------------------------------
        void generate(color_type* span, int x, int y, unsigned len)
        {
            base_type::interpolator().begin(x + base_type::filter_dx_dbl(), 
                                            y + base_type::filter_dy_dbl(), len);

            long_type fg[3];

            int diameter     = base_type::filter().diameter();
            int filter_scale = diameter << image_subpixel_shift;
            int radius_x     = (diameter * base_type::m_rx) >> 1;
            int radius_y     = (diameter * base_type::m_ry) >> 1;
            int len_x_lr     = 
                (diameter * base_type::m_rx + image_subpixel_mask) >> 
                    image_subpixel_shift;

            const int16* weight_array = base_type::filter().weight_array();

            do
            {
                base_type::interpolator().coordinates(&x, &y);

                x += base_type::filter_dx_int() - radius_x;
                y += base_type::filter_dy_int() - radius_y;

                fg[0] = fg[1] = fg[2] = image_filter_scale / 2;

                int y_lr = y >> image_subpixel_shift;
                int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) * 
                                base_type::m_ry_inv) >> 
                                    image_subpixel_shift;
                int total_weight = 0;
                int x_lr = x >> image_subpixel_shift;
                int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) * 
                                base_type::m_rx_inv) >> 
                                    image_subpixel_shift;

                int x_hr2 = x_hr;
                const value_type* fg_ptr = 
                    source().pix_ptr(x_lr, y_lr, len_x_lr);
                for(;;)
                {
                    int weight_y = weight_array[y_hr];
                    x_hr = x_hr2;
                    for(;;)
                    {
                        int weight = (weight_y * weight_array[x_hr] + 
                                     image_filter_scale / 2) >> 
                                     downscale_shift;

                        fg[0] += *fg_ptr++ * weight;
                        fg[1] += *fg_ptr++ * weight;
                        fg[2] += *fg_ptr   * weight;
                        total_weight += weight;
                        x_hr  += base_type::m_rx_inv;
                        if(x_hr >= filter_scale) break;
                        fg_ptr = SourceRenderingBuffer.next_x();
                    }
                    y_hr += base_type::m_ry_inv;
                    if(y_hr >= filter_scale) break;
                    fg_ptr = SourceRenderingBuffer.next_y();
                }

                fg[0] /= total_weight;
                fg[1] /= total_weight;
                fg[2] /= total_weight;

                if(fg[0] < 0) fg[0] = 0;
                if(fg[1] < 0) fg[1] = 0;
                if(fg[2] < 0) fg[2] = 0;

                if(fg[order_type::R] > base_mask) fg[order_type::R] = base_mask;
                if(fg[order_type::G] > base_mask) fg[order_type::G] = base_mask;
                if(fg[order_type::B] > base_mask) fg[order_type::B] = base_mask;

                span->r = (value_type)fg[order_type::R];
                span->g = (value_type)fg[order_type::G];
                span->b = (value_type)fg[order_type::B];
                span->a = base_mask;

                span++;
                ++base_type::interpolator();
            } while(--len);
        }
    };
     */


    //=================================================span_image_resample_rgb
    public class span_image_resample_rgb
        : span_image_resample
    {
        private const int base_mask = 255;
        private const int downscale_shift = (int)ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

        //--------------------------------------------------------------------
        public span_image_resample_rgb(IImageBufferAccessor src,
                            ISpanInterpolator inter,
                            ImageFilterLookUpTable filter) :
            base(src, inter, filter)
        {
            if (src.SourceImage.GetRecieveBlender().NumPixelBits != 24)
            {
                throw new System.FormatException("You have to use a rgb blender with span_image_resample_rgb");
            }
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ISpanInterpolator spanInterpolator = base.interpolator();
            spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int[] fg = new int[3];

            byte[] fg_ptr;
            int[] weightArray = filter().weight_array();
            int diameter = (int)base.filter().diameter();
            int filter_scale = diameter << (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;

            int[] weight_array = weightArray;

            do
            {
                int rx;
                int ry;
                int rx_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                int ry_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                spanInterpolator.coordinates(out x, out y);
                spanInterpolator.local_scale(out rx, out ry);
                base.adjust_scale(ref rx, ref ry);

                rx_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / rx;
                ry_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / ry;

                int radius_x = (diameter * rx) >> 1;
                int radius_y = (diameter * ry) >> 1;
                int len_x_lr =
                    (diameter * rx + (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask) >>
                        (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;

                x += base.filter_dx_int() - radius_x;
                y += base.filter_dy_int() - radius_y;

                fg[0] = fg[1] = fg[2] = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2;

                int y_lr = y >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int y_hr = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - (y & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask)) *
                               ry_inv) >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int total_weight = 0;
                int x_lr = x >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int x_hr = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - (x & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask)) *
                               rx_inv) >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int x_hr2 = x_hr;
                int sourceIndex;
                fg_ptr = base.GetImageBufferAccessor().span(x_lr, y_lr, len_x_lr, out sourceIndex);

                for (; ; )
                {
                    int weight_y = weight_array[y_hr];
                    x_hr = x_hr2;
                    for (; ; )
                    {
                        int weight = (weight_y * weight_array[x_hr] +
                                     (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2) >>
                                     downscale_shift;
                        fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;
                        fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;
                        fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;
                        total_weight += weight;
                        x_hr += rx_inv;
                        if (x_hr >= filter_scale) break;
                        fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);
                    }
                    y_hr += ry_inv;
                    if (y_hr >= filter_scale)
                    {
                        break;
                    }

                    fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);
                }

                fg[0] /= total_weight;
                fg[1] /= total_weight;
                fg[2] /= total_weight;

                if (fg[0] < 0) fg[0] = 0;
                if (fg[1] < 0) fg[1] = 0;
                if (fg[2] < 0) fg[2] = 0;

                if (fg[0] > base_mask) fg[0] = base_mask;
                if (fg[1] > base_mask) fg[1] = base_mask;
                if (fg[2] > base_mask) fg[2] = base_mask;

                span[spanIndex].alpha = base_mask;
                span[spanIndex].red = (byte)fg[0];
                span[spanIndex].green = (byte)fg[1];
                span[spanIndex].blue = (byte)fg[2];

                spanIndex++;
                interpolator().Next();
            } while (--len != 0);
        }
    }
}

#endregion //agg_span_image_filter_rgb.cs
#region agg_span_image_filter_rgba.cs


//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//#define USE_UNSAFE_CODE

//using System;

//using MatterHackers.Agg.Image;
//using MatterHackers.VectorMath;

//using image_subpixel_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e;
//using image_filter_scale_e = MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e;


namespace MatterHackers.Agg
{
    // it should be easy to write a 90 rotating or mirroring filter too. LBB 2012/01/14
    public class span_image_filter_rgba_nn_stepXby1 : span_image_filter
    {
        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        public span_image_filter_rgba_nn_stepXby1(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
            : base(sourceAccessor, spanInterpolator, null)
        {
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
            if (SourceRenderingBuffer.BitDepth != 32)
            {
                throw new NotSupportedException("The source is expected to be 32 bit.");
            }
            ISpanInterpolator spanInterpolator = interpolator();
            spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
            int x_hr;
            int y_hr;
            spanInterpolator.coordinates(out x_hr, out y_hr);
            int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
            int bufferIndex;
            bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

            byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
#if USE_UNSAFE_CODE
            unsafe
            {
                fixed (byte* pSource = fg_ptr)
                {
                    do
                    {
                        span[spanIndex++] = *(RGBA_Bytes*)&(pSource[bufferIndex]);
                        bufferIndex += 4;
                    } while (--len != 0);
                }
            }
#else
            RGBA_Bytes color = new RGBA_Bytes();
            do
            {
                color.blue = fg_ptr[bufferIndex++];
                color.green = fg_ptr[bufferIndex++];
                color.red = fg_ptr[bufferIndex++];
                color.alpha = fg_ptr[bufferIndex++];
                span[spanIndex++] = color;
            } while (--len != 0);
#endif
        }
    }


    //==============================================span_image_filter_rgba_nn
    public class span_image_filter_rgba_nn : span_image_filter
    {
        const int baseShift = 8;
        const int baseScale = (int)(1 << baseShift);
        const int baseMask = baseScale - 1;

        public span_image_filter_rgba_nn(IImageBufferAccessor sourceAccessor, ISpanInterpolator spanInterpolator)
            : base(sourceAccessor, spanInterpolator, null)
        {
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ImageBuffer SourceRenderingBuffer = (ImageBuffer)GetImageBufferAccessor().SourceImage;
            if (SourceRenderingBuffer.BitDepth != 32)
            {
                throw new NotSupportedException("The source is expected to be 32 bit.");
            }
            ISpanInterpolator spanInterpolator = interpolator();
            spanInterpolator.begin(x + filter_dx_dbl(), y + filter_dy_dbl(), len);
            byte[] fg_ptr = SourceRenderingBuffer.GetBuffer();
            do
            {
                int x_hr;
                int y_hr;
                spanInterpolator.coordinates(out x_hr, out y_hr);
                int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int bufferIndex;
                bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);
                RGBA_Bytes color;
                color.blue = fg_ptr[bufferIndex++];
                color.green = fg_ptr[bufferIndex++];
                color.red = fg_ptr[bufferIndex++];
                color.alpha = fg_ptr[bufferIndex++];
                span[spanIndex] = color;
                spanIndex++;
                spanInterpolator.Next();
            } while (--len != 0);
        }
    };

    public class span_image_filter_rgba_bilinear : span_image_filter
    {
        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        public span_image_filter_rgba_bilinear(IImageBufferAccessor src, ISpanInterpolator inter)
            : base(src, inter, null)
        {
        }

#if false
            public void generate(out RGBA_Bytes destPixel, int x, int y)
            {
                base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), 1);

                int* fg = stackalloc int[4];

                byte* fg_ptr;

                IImage imageSource = base.source().DestImage;
                int maxx = (int)imageSource.Width() - 1;
                int maxy = (int)imageSource.Height() - 1;
                ISpanInterpolator spanInterpolator = base.interpolator();

                unchecked
                {
                    int x_hr;
                    int y_hr;

                    spanInterpolator.coordinates(out x_hr, out y_hr);

                    x_hr -= base.filter_dx_int();
                    y_hr -= base.filter_dy_int();

                    int x_lr = x_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;
                    int y_lr = y_hr >> (int)image_subpixel_scale_e.image_subpixel_shift;

                    int weight;

                    fg[0] = fg[1] = fg[2] = fg[3] = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / 2;

                    x_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;
                    y_hr &= (int)image_subpixel_scale_e.image_subpixel_mask;

                    fg_ptr = imageSource.GetPixelPointerY(y_lr) + (x_lr * 4);

                    weight = (int)(((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                             ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    fg[0] += weight * fg_ptr[0];
                    fg[1] += weight * fg_ptr[1];
                    fg[2] += weight * fg_ptr[2];
                    fg[3] += weight * fg_ptr[3];

                    weight = (int)(x_hr * ((int)image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    fg[0] += weight * fg_ptr[4];
                    fg[1] += weight * fg_ptr[5];
                    fg[2] += weight * fg_ptr[6];
                    fg[3] += weight * fg_ptr[7];

                    ++y_lr;
                    fg_ptr = imageSource.GetPixelPointerY(y_lr) + (x_lr * 4);

                    weight = (int)(((int)image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                    fg[0] += weight * fg_ptr[0];
                    fg[1] += weight * fg_ptr[1];
                    fg[2] += weight * fg_ptr[2];
                    fg[3] += weight * fg_ptr[3];

                    weight = (int)(x_hr * y_hr);
                    fg[0] += weight * fg_ptr[4];
                    fg[1] += weight * fg_ptr[5];
                    fg[2] += weight * fg_ptr[6];
                    fg[3] += weight * fg_ptr[7];

                    fg[0] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
                    fg[1] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
                    fg[2] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;
                    fg[3] >>= (int)image_subpixel_scale_e.image_subpixel_shift * 2;

                    destPixel.m_R = (byte)fg[OrderR];
                    destPixel.m_G = (byte)fg[OrderG];
                    destPixel.m_B = (byte)fg[ImageBuffer.OrderB];
                    destPixel.m_A = (byte)fg[OrderA];
                }
            }
#endif

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
            ISpanInterpolator spanInterpolator = base.interpolator();
            int bufferIndex;
            byte[] fg_ptr = SourceRenderingBuffer.GetBuffer(out bufferIndex);

            unchecked
            {
                do
                {
                    int tempR;
                    int tempG;
                    int tempB;
                    int tempA;

                    int x_hr;
                    int y_hr;

                    spanInterpolator.coordinates(out x_hr, out y_hr);

                    x_hr -= base.filter_dx_int();
                    y_hr -= base.filter_dy_int();

                    int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int weight;

                    tempR =
                    tempG =
                    tempB =
                    tempA = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2;

                    x_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                    y_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;

                    bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

                    weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                             ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                    bufferIndex += 4;

                    weight = (x_hr * ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

                    y_lr++;
                    bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

                    weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                    bufferIndex += 4;

                    weight = (x_hr * y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

                    tempR >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                    tempG >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                    tempB >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                    tempA >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;

                    RGBA_Bytes color;
                    color.red = (byte)tempR;
                    color.green = (byte)tempG;
                    color.blue = (byte)tempB;
                    color.alpha = (byte)255;// tempA;
                    span[spanIndex] = color;
                    spanIndex++;
                    spanInterpolator.Next();

                } while (--len != 0);
            }
        }
    }

    public class span_image_filter_rgba_bilinear_float : span_image_filter_float
    {
        public span_image_filter_rgba_bilinear_float(IImageBufferAccessorFloat src, ISpanInterpolatorFloat inter)
            : base(src, inter, null)
        {
        }

        public override void generate(RGBA_Floats[] span, int spanIndex, int x, int y, int len)
        {
            base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            ImageBufferFloat SourceRenderingBuffer = (ImageBufferFloat)base.source().SourceImage;
            ISpanInterpolatorFloat spanInterpolator = base.interpolator();
            int bufferIndex;
            float[] fg_ptr = SourceRenderingBuffer.GetBuffer(out bufferIndex);

            unchecked
            {
                do
                {
                    float tempR;
                    float tempG;
                    float tempB;
                    float tempA;

                    float x_hr;
                    float y_hr;

                    spanInterpolator.coordinates(out x_hr, out y_hr);

                    x_hr -= base.filter_dx_dbl();
                    y_hr -= base.filter_dy_dbl();

                    int x_lr = (int)x_hr;
                    int y_lr = (int)y_hr;
                    float weight;

                    tempR = tempG = tempB = tempA = 0;

                    x_hr -= x_lr;
                    y_hr -= y_lr;

                    bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

#if false
                    unsafe
                    {
                        fixed (float* pSource = fg_ptr)
                        {
                            Vector4f tempFinal = new Vector4f(0.0f, 0.0f, 0.0f, 0.0f);
                            
                            Vector4f color0 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);
                            weight = (1.0f - x_hr) * (1.0f - y_hr);
                            Vector4f weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color0;

                            Vector4f color1 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);
                            weight = (x_hr) * (1.0f - y_hr);
                            weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color1;

                            y_lr++;
                            bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

                            Vector4f color2 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 0]);
                            weight = (1.0f - x_hr) * (y_hr);
                            weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color2;

                            Vector4f color3 = Vector4f.LoadAligned((Vector4f*)&pSource[bufferIndex + 4]);
                            weight = (x_hr) * (y_hr);
                            weight4f = new Vector4f(weight, weight, weight, weight);
                            tempFinal = tempFinal + weight4f * color3;

                            RGBA_Floats color;
                            color.m_B = tempFinal.X;
                            color.m_G = tempFinal.Y;
                            color.m_R = tempFinal.Z;
                            color.m_A = tempFinal.W;
                            span[spanIndex] = color;
                        }
                    }
#else
                    weight = (1.0f - x_hr) * (1.0f - y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                    bufferIndex += 4;

                    weight = (x_hr) * (1.0f - y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

                    y_lr++;
                    bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);

                    weight = (1.0f - x_hr) * (y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                    bufferIndex += 4;

                    weight = (x_hr) * (y_hr);
                    tempR += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    tempG += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    tempB += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    tempA += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

                    RGBA_Floats color;
                    color.red = tempR;
                    color.green = tempG;
                    color.blue = tempB;
                    color.alpha = tempA;
                    span[spanIndex] = color;
#endif
                    spanIndex++;
                    spanInterpolator.Next();
                } while (--len != 0);
            }
        }
    };

    //====================================span_image_filter_rgba_bilinear_clip
    public class span_image_filter_rgba_bilinear_clip : span_image_filter
    {
        private RGBA_Bytes m_OutsideSourceColor;

        const int base_shift = 8;
        const int base_scale = (int)(1 << base_shift);
        const int base_mask = base_scale - 1;

        public span_image_filter_rgba_bilinear_clip(IImageBufferAccessor src,
            IColorType back_color, ISpanInterpolator inter)
            : base(src, inter, null)
        {
            m_OutsideSourceColor = back_color.GetAsRGBA_Bytes();
        }

        public IColorType background_color() { return m_OutsideSourceColor; }
        public void background_color(IColorType v) { m_OutsideSourceColor = v.GetAsRGBA_Bytes(); }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ImageBuffer SourceRenderingBuffer = (ImageBuffer)base.GetImageBufferAccessor().SourceImage;
            int bufferIndex;
            byte[] fg_ptr;

            if (base.m_interpolator.GetType() == typeof(MatterHackers.Agg.span_interpolator_linear)
                && ((MatterHackers.Agg.span_interpolator_linear)base.m_interpolator).transformer().GetType() == typeof(MatterHackers.Agg.Transform.Affine)
            && ((MatterHackers.Agg.Transform.Affine)((MatterHackers.Agg.span_interpolator_linear)base.m_interpolator).transformer()).is_identity())
            {
                fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x, y, out bufferIndex);
                //unsafe
                {
#if true
                    do
                    {
                        span[spanIndex].blue = (byte)fg_ptr[bufferIndex++];
                        span[spanIndex].green = (byte)fg_ptr[bufferIndex++];
                        span[spanIndex].red = (byte)fg_ptr[bufferIndex++];
                        span[spanIndex].alpha = (byte)fg_ptr[bufferIndex++];
                        ++spanIndex;
                    } while (--len != 0);
#else
                        fixed (byte* pSource = &fg_ptr[bufferIndex])
                        {
                            int* pSourceInt = (int*)pSource;
                            fixed (RGBA_Bytes* pDest = &span[spanIndex])
                            {
                                int* pDestInt = (int*)pDest;
                                do
                                {
                                    *pDestInt++ = *pSourceInt++;
                                } while (--len != 0);
                            }
                        }
#endif
                }

                return;
            }

            base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int[] accumulatedColor = new int[4];

            int back_r = m_OutsideSourceColor.red;
            int back_g = m_OutsideSourceColor.green;
            int back_b = m_OutsideSourceColor.blue;
            int back_a = m_OutsideSourceColor.alpha;

            int distanceBetweenPixelsInclusive = base.GetImageBufferAccessor().SourceImage.GetBytesBetweenPixelsInclusive();
            int maxx = (int)SourceRenderingBuffer.Width - 1;
            int maxy = (int)SourceRenderingBuffer.Height - 1;
            ISpanInterpolator spanInterpolator = base.interpolator();

            unchecked
            {
                do
                {
                    int x_hr;
                    int y_hr;

                    spanInterpolator.coordinates(out x_hr, out y_hr);

                    x_hr -= base.filter_dx_int();
                    y_hr -= base.filter_dy_int();

                    int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                    int weight;

                    if (x_lr >= 0 && y_lr >= 0 &&
                       x_lr < maxx && y_lr < maxy)
                    {
                        accumulatedColor[0] =
                        accumulatedColor[1] =
                        accumulatedColor[2] =
                        accumulatedColor[3] = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2;

                        x_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                        y_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;

                        fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);

                        weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                                 ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                        if (weight > base_mask)
                        {
                            accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                            accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                            accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                            accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                        }

                        weight = (x_hr * ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                        if (weight > base_mask)
                        {
                            bufferIndex += distanceBetweenPixelsInclusive;
                            accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                            accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                            accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                            accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                        }

                        weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                        if (weight > base_mask)
                        {
                            ++y_lr;
                            fg_ptr = SourceRenderingBuffer.GetPixelPointerXY(x_lr, y_lr, out bufferIndex);
                            accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                            accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                            accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                            accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                        }
                        weight = (x_hr * y_hr);
                        if (weight > base_mask)
                        {
                            bufferIndex += distanceBetweenPixelsInclusive;
                            accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                            accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                            accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                            accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                        }
                        accumulatedColor[0] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                        accumulatedColor[1] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                        accumulatedColor[2] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                        accumulatedColor[3] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                    }
                    else
                    {
                        if (x_lr < -1 || y_lr < -1 ||
                           x_lr > maxx || y_lr > maxy)
                        {
                            accumulatedColor[0] = back_r;
                            accumulatedColor[1] = back_g;
                            accumulatedColor[2] = back_b;
                            accumulatedColor[3] = back_a;
                        }
                        else
                        {
                            accumulatedColor[0] =
                            accumulatedColor[1] =
                            accumulatedColor[2] =
                            accumulatedColor[3] = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / 2;

                            x_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                            y_hr &= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;

                            weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) *
                                     ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                            if (weight > base_mask)
                            {
                                BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
                            }

                            x_lr++;

                            weight = (x_hr * ((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - y_hr));
                            if (weight > base_mask)
                            {
                                BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
                            }

                            x_lr--;
                            y_lr++;

                            weight = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale - x_hr) * y_hr);
                            if (weight > base_mask)
                            {
                                BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
                            }

                            x_lr++;

                            weight = (x_hr * y_hr);
                            if (weight > base_mask)
                            {
                                BlendInFilterPixel(accumulatedColor, back_r, back_g, back_b, back_a, SourceRenderingBuffer, maxx, maxy, x_lr, y_lr, weight);
                            }

                            accumulatedColor[0] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                            accumulatedColor[1] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                            accumulatedColor[2] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                            accumulatedColor[3] >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift * 2;
                        }
                    }

                    span[spanIndex].red = (byte)accumulatedColor[0];
                    span[spanIndex].green = (byte)accumulatedColor[1];
                    span[spanIndex].blue = (byte)accumulatedColor[2];
                    span[spanIndex].alpha = (byte)accumulatedColor[3];
                    ++spanIndex;
                    spanInterpolator.Next();
                } while (--len != 0);
            }
        }

        private void BlendInFilterPixel(int[] accumulatedColor, int back_r, int back_g, int back_b, int back_a, IImageByte SourceRenderingBuffer, int maxx, int maxy, int x_lr, int y_lr, int weight)
        {
            byte[] fg_ptr;
            unchecked
            {
                if ((uint)x_lr <= (uint)maxx && (uint)y_lr <= (uint)maxy)
                {
                    int bufferIndex = SourceRenderingBuffer.GetBufferOffsetXY(x_lr, y_lr);
                    fg_ptr = SourceRenderingBuffer.GetBuffer();

                    accumulatedColor[0] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                    accumulatedColor[1] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                    accumulatedColor[2] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                    accumulatedColor[3] += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];
                }
                else
                {
                    accumulatedColor[0] += back_r * weight;
                    accumulatedColor[1] += back_g * weight;
                    accumulatedColor[2] += back_b * weight;
                    accumulatedColor[3] += back_a * weight;
                }
            }
        }
    };

    /*


    //==============================================span_image_filter_rgba_2x2
    //template<class Source, class Interpolator> 
    public class span_image_filter_rgba_2x2 : span_image_filter//<Source, Interpolator>
    {
        //typedef Source source_type;
        //typedef typename source_type::color_type color_type;
        //typedef typename source_type::order_type order_type;
        //typedef Interpolator interpolator_type;
        //typedef span_image_filter<source_type, interpolator_type> base_type;
        //typedef typename color_type::value_type value_type;
        //typedef typename color_type::calc_type calc_type;
        enum base_scale_e
        {
            base_shift = 8, //color_type::base_shift,
            base_mask  = 255,//color_type::base_mask
        };

        //--------------------------------------------------------------------
        public span_image_filter_rgba_2x2() {}
        public span_image_filter_rgba_2x2(pixfmt_alpha_blend_bgra32 src, 
                                   interpolator_type inter,
                                   ImageFilterLookUpTable filter) :
            base(src, inter, filter) 
        {}


        //--------------------------------------------------------------------
        public void generate(color_type* span, int x, int y, unsigned len)
        {
            base.interpolator().begin(x + base.filter_dx_dbl(), 
                                            y + base.filter_dy_dbl(), len);

            calc_type fg[4];

            byte *fg_ptr;
            int16* weight_array = base.filter().weight_array() + 
                                        ((base.filter().diameter()/2 - 1) << 
                                          image_subpixel_shift);

            do
            {
                int x_hr;
                int y_hr;

                base.interpolator().coordinates(&x_hr, &y_hr);

                x_hr -= base.filter_dx_int();
                y_hr -= base.filter_dy_int();

                int x_lr = x_hr >> image_subpixel_shift;
                int y_lr = y_hr >> image_subpixel_shift;

                unsigned weight;
                fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;

                x_hr &= image_subpixel_mask;
                y_hr &= image_subpixel_mask;

                fg_ptr = base.source().span(x_lr, y_lr, 2);
                weight = (weight_array[x_hr + image_subpixel_scale] * 
                          weight_array[y_hr + image_subpixel_scale] + 
                          (int)image_filter_scale_e.image_filter_scale / 2) >> 
                          image_filter_shift;
                fg[0] += weight * *fg_ptr++;
                fg[1] += weight * *fg_ptr++;
                fg[2] += weight * *fg_ptr++;
                fg[3] += weight * *fg_ptr;

                fg_ptr = base.source().next_x();
                weight = (weight_array[x_hr] * 
                          weight_array[y_hr + image_subpixel_scale] + 
                          (int)image_filter_scale_e.image_filter_scale / 2) >> 
                          image_filter_shift;
                fg[0] += weight * *fg_ptr++;
                fg[1] += weight * *fg_ptr++;
                fg[2] += weight * *fg_ptr++;
                fg[3] += weight * *fg_ptr;

                fg_ptr = base.source().next_y();
                weight = (weight_array[x_hr + image_subpixel_scale] * 
                          weight_array[y_hr] + 
                          (int)image_filter_scale_e.image_filter_scale / 2) >> 
                          image_filter_shift;
                fg[0] += weight * *fg_ptr++;
                fg[1] += weight * *fg_ptr++;
                fg[2] += weight * *fg_ptr++;
                fg[3] += weight * *fg_ptr;

                fg_ptr = base.source().next_x();
                weight = (weight_array[x_hr] * 
                          weight_array[y_hr] + 
                          (int)image_filter_scale_e.image_filter_scale / 2) >> 
                          image_filter_shift;
                fg[0] += weight * *fg_ptr++;
                fg[1] += weight * *fg_ptr++;
                fg[2] += weight * *fg_ptr++;
                fg[3] += weight * *fg_ptr;

                fg[0] >>= image_filter_shift;
                fg[1] >>= image_filter_shift;
                fg[2] >>= image_filter_shift;
                fg[3] >>= image_filter_shift;

                if(fg[ImageBuffer.OrderA] > base_mask)         fg[ImageBuffer.OrderA] = base_mask;
                if(fg[ImageBuffer.OrderR] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderR] = fg[ImageBuffer.OrderA];
                if(fg[ImageBuffer.OrderG] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderG] = fg[ImageBuffer.OrderA];
                if(fg[ImageBuffer.OrderB] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderB] = fg[ImageBuffer.OrderA];

                span->r = (byte)fg[ImageBuffer.OrderR];
                span->g = (byte)fg[ImageBuffer.OrderG];
                span->b = (byte)fg[ImageBuffer.OrderB];
                span->a = (byte)fg[ImageBuffer.OrderA];
                ++span;
                ++base.interpolator();

            } while(--len);
        }
    };
*/

    public class span_image_filter_rgba : span_image_filter
    {
        const int base_mask = 255;

        //--------------------------------------------------------------------
        public span_image_filter_rgba(IImageBufferAccessor src, ISpanInterpolator inter, ImageFilterLookUpTable filter)
            : base(src, inter, filter)
        {
            if (src.SourceImage.GetBytesBetweenPixelsInclusive() != 4)
            {
                throw new System.NotSupportedException("span_image_filter_rgba must have a 32 bit DestImage");
            }
        }

        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            base.interpolator().begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int f_r, f_g, f_b, f_a;

            byte[] fg_ptr;

            int diameter = m_filter.diameter();
            int start = m_filter.start();
            int[] weight_array = m_filter.weight_array();

            int x_count;
            int weight_y;

            ISpanInterpolator spanInterpolator = base.interpolator();
            IImageBufferAccessor sourceAccessor = GetImageBufferAccessor();

            do
            {
                spanInterpolator.coordinates(out x, out y);

                x -= base.filter_dx_int();
                y -= base.filter_dy_int();

                int x_hr = x;
                int y_hr = y;

                int x_lr = x_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int y_lr = y_hr >> (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;

                f_b = f_g = f_r = f_a = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2;

                int x_fract = x_hr & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask;
                int y_count = diameter;

                y_hr = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - (y_hr & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask);

                int bufferIndex;
                fg_ptr = sourceAccessor.span(x_lr + start, y_lr + start, diameter, out bufferIndex);
                for (; ; )
                {
                    x_count = (int)diameter;
                    weight_y = weight_array[y_hr];
                    x_hr = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - x_fract;
                    for (; ; )
                    {
                        int weight = (weight_y * weight_array[x_hr] +
                                     (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2) >>
                                     (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

                        f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                        f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                        f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                        f_a += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

                        if (--x_count == 0) break;
                        x_hr += (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                        sourceAccessor.next_x(out bufferIndex);
                    }

                    if (--y_count == 0) break;
                    y_hr += (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                    fg_ptr = sourceAccessor.next_y(out bufferIndex);
                }

                f_b >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;
                f_g >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;
                f_r >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;
                f_a >>= (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

                unchecked
                {
                    if ((uint)f_b > base_mask)
                    {
                        if (f_b < 0) f_b = 0;
                        if (f_b > base_mask) f_b = (int)base_mask;
                    }

                    if ((uint)f_g > base_mask)
                    {
                        if (f_g < 0) f_g = 0;
                        if (f_g > base_mask) f_g = (int)base_mask;
                    }

                    if ((uint)f_r > base_mask)
                    {
                        if (f_r < 0) f_r = 0;
                        if (f_r > base_mask) f_r = (int)base_mask;
                    }

                    if ((uint)f_a > base_mask)
                    {
                        if (f_a < 0) f_a = 0;
                        if (f_a > base_mask) f_a = (int)base_mask;
                    }
                }

                span[spanIndex].red = (byte)f_b;
                span[spanIndex].green = (byte)f_g;
                span[spanIndex].blue = (byte)f_r;
                span[spanIndex].alpha = (byte)f_a;

                spanIndex++;
                spanInterpolator.Next();

            } while (--len != 0);
        }
    };

    public class span_image_filter_rgba_float : span_image_filter_float
    {
        public span_image_filter_rgba_float(IImageBufferAccessorFloat src, ISpanInterpolatorFloat inter, IImageFilterFunction filterFunction)
            : base(src, inter, filterFunction)
        {
            if (src.SourceImage.GetFloatsBetweenPixelsInclusive() != 4)
            {
                throw new System.NotSupportedException("span_image_filter_rgba must have a 32 bit DestImage");
            }
        }

        public override void generate(RGBA_Floats[] span, int spanIndex, int xInt, int yInt, int len)
        {
            base.interpolator().begin(xInt + base.filter_dx_dbl(), yInt + base.filter_dy_dbl(), len);

            float f_r, f_g, f_b, f_a;

            float[] fg_ptr;

            int radius = (int)m_filterFunction.radius();
            int diameter = radius * 2;
            int start = -(int)(diameter / 2 - 1);

            int x_count;

            ISpanInterpolatorFloat spanInterpolator = base.interpolator();
            IImageBufferAccessorFloat sourceAccessor = source();

            do
            {
                float x = xInt;
                float y = yInt;
                spanInterpolator.coordinates(out x, out y);
                //x -= (float)base.filter_dx_dbl();
                //y -= (float)base.filter_dy_dbl();
                int sourceXInt = (int)x;
                int sourceYInt = (int)y;
                Vector2 sourceOrigin = new Vector2(x, y);
                Vector2 sourceSample = new Vector2(sourceXInt + start, sourceYInt + start);

                f_b = f_g = f_r = f_a = 0;

                int y_count = diameter;

                int bufferIndex;
                fg_ptr = sourceAccessor.span(sourceXInt + start, sourceYInt + start, diameter, out bufferIndex);
                float totalWeight = 0.0f;
                for (; ; )
                {
                    float yweight = (float)m_filterFunction.calc_weight(System.Math.Sqrt((sourceSample.y - sourceOrigin.y) * (sourceSample.y - sourceOrigin.y)));
                    x_count = (int)diameter;
                    for (; ; )
                    {
                        float xweight = (float)m_filterFunction.calc_weight(System.Math.Sqrt((sourceSample.x - sourceOrigin.x) * (sourceSample.x - sourceOrigin.x)));
                        float weight = xweight * yweight;

                        f_r += weight * fg_ptr[bufferIndex + ImageBuffer.OrderR];
                        f_g += weight * fg_ptr[bufferIndex + ImageBuffer.OrderG];
                        f_b += weight * fg_ptr[bufferIndex + ImageBuffer.OrderB];
                        f_a += weight * fg_ptr[bufferIndex + ImageBuffer.OrderA];

                        totalWeight += weight;
                        sourceSample.x += 1;
                        if (--x_count == 0) break;
                        sourceAccessor.next_x(out bufferIndex);
                    }

                    sourceSample.x -= diameter;

                    if (--y_count == 0) break;
                    sourceSample.y += 1;
                    fg_ptr = sourceAccessor.next_y(out bufferIndex);
                }

                if (f_b < 0) f_b = 0; if (f_b > 1) f_b = 1;
                if (f_r < 0) f_r = 0; if (f_r > 1) f_r = 1;
                if (f_g < 0) f_g = 0; if (f_g > 1) f_g = 1;

                span[spanIndex].red = f_r;
                span[spanIndex].green = f_g;
                span[spanIndex].blue = f_b;
                span[spanIndex].alpha = 1;// f_a;

                spanIndex++;
                spanInterpolator.Next();

            } while (--len != 0);
        }
    };
    /*

        //========================================span_image_resample_rgba_affine
        public class span_image_resample_rgba_affine : span_image_resample_affine
        {
            //typedef Source source_type;
            //typedef typename source_type::color_type color_type;
            //typedef typename source_type::order_type order_type;
            //typedef span_image_resample_affine<source_type> base_type;
            //typedef typename base.interpolator_type interpolator_type;
            //typedef typename color_type::value_type value_type;
            //typedef typename color_type::long_type long_type;
            enum base_scale_e
            {
                base_shift      = 8, //color_type::base_shift,
                base_mask       = 255,//color_type::base_mask,
                downscale_shift = image_filter_shift
            };

            //--------------------------------------------------------------------
            public span_image_resample_rgba_affine() {}
            public span_image_resample_rgba_affine(pixfmt_alpha_blend_bgra32 src, 
                                            interpolator_type inter,
                                            ImageFilterLookUpTable filter) :
                base(src, inter, filter) 
            {}


            //--------------------------------------------------------------------
            public void generate(color_type* span, int x, int y, unsigned len)
            {
                base.interpolator().begin(x + base.filter_dx_dbl(), 
                                                y + base.filter_dy_dbl(), len);

                long_type fg[4];

                int diameter     = base.filter().diameter();
                int filter_scale = diameter << image_subpixel_shift;
                int radius_x     = (diameter * base.m_rx) >> 1;
                int radius_y     = (diameter * base.m_ry) >> 1;
                int len_x_lr     = 
                    (diameter * base.m_rx + image_subpixel_mask) >> 
                        image_subpixel_shift;

                int16* weight_array = base.filter().weight_array();

                do
                {
                    base.interpolator().coordinates(&x, &y);

                    x += base.filter_dx_int() - radius_x;
                    y += base.filter_dy_int() - radius_y;

                    fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;

                    int y_lr = y >> image_subpixel_shift;
                    int y_hr = ((image_subpixel_mask - (y & image_subpixel_mask)) * 
                                    base.m_ry_inv) >> 
                                        image_subpixel_shift;
                    int total_weight = 0;
                    int x_lr = x >> image_subpixel_shift;
                    int x_hr = ((image_subpixel_mask - (x & image_subpixel_mask)) * 
                                    base.m_rx_inv) >> 
                                        image_subpixel_shift;

                    int x_hr2 = x_hr;
                    byte* fg_ptr = base.source().span(x_lr, y_lr, len_x_lr);
                    for(;;)
                    {
                        int weight_y = weight_array[y_hr];
                        x_hr = x_hr2;
                        for(;;)
                        {
                            int weight = (weight_y * weight_array[x_hr] + 
                                         (int)image_filter_scale_e.image_filter_scale / 2) >> 
                                         downscale_shift;

                            fg[0] += *fg_ptr++ * weight;
                            fg[1] += *fg_ptr++ * weight;
                            fg[2] += *fg_ptr++ * weight;
                            fg[3] += *fg_ptr++ * weight;
                            total_weight += weight;
                            x_hr  += base.m_rx_inv;
                            if(x_hr >= filter_scale) break;
                            fg_ptr = base.source().next_x();
                        }
                        y_hr += base.m_ry_inv;
                        if(y_hr >= filter_scale) break;
                        fg_ptr = base.source().next_y();
                    }

                    fg[0] /= total_weight;
                    fg[1] /= total_weight;
                    fg[2] /= total_weight;
                    fg[3] /= total_weight;

                    if(fg[0] < 0) fg[0] = 0;
                    if(fg[1] < 0) fg[1] = 0;
                    if(fg[2] < 0) fg[2] = 0;
                    if(fg[3] < 0) fg[3] = 0;

                    if(fg[ImageBuffer.OrderA] > base_mask)         fg[ImageBuffer.OrderA] = base_mask;
                    if(fg[ImageBuffer.OrderR] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderR] = fg[ImageBuffer.OrderA];
                    if(fg[ImageBuffer.OrderG] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderG] = fg[ImageBuffer.OrderA];
                    if(fg[ImageBuffer.OrderB] > fg[ImageBuffer.OrderA]) fg[ImageBuffer.OrderB] = fg[ImageBuffer.OrderA];

                    span->r = (byte)fg[ImageBuffer.OrderR];
                    span->g = (byte)fg[ImageBuffer.OrderG];
                    span->b = (byte)fg[ImageBuffer.OrderB];
                    span->a = (byte)fg[ImageBuffer.OrderA];

                    ++span;
                    ++base.interpolator();
                } while(--len);
            }
        };
         */

    //==============================================span_image_resample_rgba
    public class span_image_resample_rgba
        : span_image_resample
    {
        private const int base_mask = 255;
        private const int downscale_shift = (int)ImageFilterLookUpTable.image_filter_scale_e.image_filter_shift;

        //--------------------------------------------------------------------
        public span_image_resample_rgba(IImageBufferAccessor src,
                            ISpanInterpolator inter,
                            ImageFilterLookUpTable filter) :
            base(src, inter, filter)
        {
            if (src.SourceImage.GetRecieveBlender().NumPixelBits != 32)
            {
                throw new System.FormatException("You have to use a rgba blender with span_image_resample_rgba");
            }
        }

        //--------------------------------------------------------------------
        public override void generate(RGBA_Bytes[] span, int spanIndex, int x, int y, int len)
        {
            ISpanInterpolator spanInterpolator = base.interpolator();
            spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

            int[] fg = new int[4];

            byte[] fg_ptr;
            int[] weightArray = filter().weight_array();
            int diameter = (int)base.filter().diameter();
            int filter_scale = diameter << (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;

            int[] weight_array = weightArray;

            do
            {
                int rx;
                int ry;
                int rx_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                int ry_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale;
                spanInterpolator.coordinates(out x, out y);
                spanInterpolator.local_scale(out rx, out ry);
                base.adjust_scale(ref rx, ref ry);

                rx_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / rx;
                ry_inv = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale * (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_scale / ry;

                int radius_x = (diameter * rx) >> 1;
                int radius_y = (diameter * ry) >> 1;
                int len_x_lr =
                    (diameter * rx + (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask) >>
                        (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;

                x += base.filter_dx_int() - radius_x;
                y += base.filter_dy_int() - radius_y;

                fg[0] = fg[1] = fg[2] = fg[3] = (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2;

                int y_lr = y >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int y_hr = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - (y & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask)) *
                               ry_inv) >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int total_weight = 0;
                int x_lr = x >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int x_hr = (((int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask - (x & (int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_mask)) *
                               rx_inv) >> (int)(int)MatterHackers.Agg.ImageFilterLookUpTable.image_subpixel_scale_e.image_subpixel_shift;
                int x_hr2 = x_hr;
                int sourceIndex;
                fg_ptr = base.GetImageBufferAccessor().span(x_lr, y_lr, len_x_lr, out sourceIndex);

                for (; ; )
                {
                    int weight_y = weight_array[y_hr];
                    x_hr = x_hr2;
                    for (; ; )
                    {
                        int weight = (weight_y * weight_array[x_hr] +
                                     (int)MatterHackers.Agg.ImageFilterLookUpTable.image_filter_scale_e.image_filter_scale / 2) >>
                                     downscale_shift;
                        fg[0] += fg_ptr[sourceIndex + ImageBuffer.OrderR] * weight;
                        fg[1] += fg_ptr[sourceIndex + ImageBuffer.OrderG] * weight;
                        fg[2] += fg_ptr[sourceIndex + ImageBuffer.OrderB] * weight;
                        fg[3] += fg_ptr[sourceIndex + ImageBuffer.OrderA] * weight;
                        total_weight += weight;
                        x_hr += rx_inv;
                        if (x_hr >= filter_scale) break;
                        fg_ptr = base.GetImageBufferAccessor().next_x(out sourceIndex);
                    }
                    y_hr += ry_inv;
                    if (y_hr >= filter_scale)
                    {
                        break;
                    }

                    fg_ptr = base.GetImageBufferAccessor().next_y(out sourceIndex);
                }

                fg[0] /= total_weight;
                fg[1] /= total_weight;
                fg[2] /= total_weight;
                fg[3] /= total_weight;

                if (fg[0] < 0) fg[0] = 0;
                if (fg[1] < 0) fg[1] = 0;
                if (fg[2] < 0) fg[2] = 0;
                if (fg[3] < 0) fg[3] = 0;

                if (fg[0] > base_mask) fg[0] = base_mask;
                if (fg[1] > base_mask) fg[1] = base_mask;
                if (fg[2] > base_mask) fg[2] = base_mask;
                if (fg[3] > base_mask) fg[3] = base_mask;

                span[spanIndex].red = (byte)fg[0];
                span[spanIndex].green = (byte)fg[1];
                span[spanIndex].blue = (byte)fg[2];
                span[spanIndex].alpha = (byte)fg[3];

                spanIndex++;
                interpolator().Next();
            } while (--len != 0);
        }
        /*
                    ISpanInterpolator spanInterpolator = base.interpolator();
                    spanInterpolator.begin(x + base.filter_dx_dbl(), y + base.filter_dy_dbl(), len);

                    int* fg = stackalloc int[4];

                    byte* fg_ptr;
                    fixed (int* pWeightArray = filter().weight_array())
                    {
                        int diameter = (int)base.filter().diameter();
                        int filter_scale = diameter << (int)image_subpixel_scale_e.image_subpixel_shift;

                        int* weight_array = pWeightArray;

                        do
                        {
                            int rx;
                            int ry;
                            int rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
                            int ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale;
                            spanInterpolator.coordinates(out x, out y);
                            spanInterpolator.local_scale(out rx, out ry);
                            base.adjust_scale(ref rx, ref ry);

                            rx_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / rx;
                            ry_inv = (int)image_subpixel_scale_e.image_subpixel_scale * (int)image_subpixel_scale_e.image_subpixel_scale / ry;

                            int radius_x = (diameter * rx) >> 1;
                            int radius_y = (diameter * ry) >> 1;
                            int len_x_lr =
                                (diameter * rx + (int)image_subpixel_scale_e.image_subpixel_mask) >>
                                    (int)(int)image_subpixel_scale_e.image_subpixel_shift;

                            x += base.filter_dx_int() - radius_x;
                            y += base.filter_dy_int() - radius_y;

                            fg[0] = fg[1] = fg[2] = fg[3] = (int)image_filter_scale_e.image_filter_scale / 2;

                            int y_lr = y >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
                            int y_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (y & (int)image_subpixel_scale_e.image_subpixel_mask)) * 
                                           ry_inv) >>
                                               (int)(int)image_subpixel_scale_e.image_subpixel_shift;
                            int total_weight = 0;
                            int x_lr = x >> (int)(int)image_subpixel_scale_e.image_subpixel_shift;
                            int x_hr = (((int)image_subpixel_scale_e.image_subpixel_mask - (x & (int)image_subpixel_scale_e.image_subpixel_mask)) * 
                                           rx_inv) >>
                                               (int)(int)image_subpixel_scale_e.image_subpixel_shift;
                            int x_hr2 = x_hr;
                            fg_ptr = base.source().span(x_lr, y_lr, (int)len_x_lr);

                            for(;;)
                            {
                                int weight_y = weight_array[y_hr];
                                x_hr = x_hr2;
                                for(;;)
                                {
                                    int weight = (weight_y * weight_array[x_hr] +
                                                 (int)image_filter_scale_e.image_filter_scale / 2) >> 
                                                 downscale_shift;
                                    fg[0] += *fg_ptr++ * weight;
                                    fg[1] += *fg_ptr++ * weight;
                                    fg[2] += *fg_ptr++ * weight;
                                    fg[3] += *fg_ptr++ * weight;
                                    total_weight += weight;
                                    x_hr  += rx_inv;
                                    if(x_hr >= filter_scale) break;
                                    fg_ptr = base.source().next_x();
                                }
                                y_hr += ry_inv;
                                if (y_hr >= filter_scale)
                                {
                                    break;
                                }

                                fg_ptr = base.source().next_y();
                            }

                            fg[0] /= total_weight;
                            fg[1] /= total_weight;
                            fg[2] /= total_weight;
                            fg[3] /= total_weight;

                            if(fg[0] < 0) fg[0] = 0;
                            if(fg[1] < 0) fg[1] = 0;
                            if(fg[2] < 0) fg[2] = 0;
                            if(fg[3] < 0) fg[3] = 0;

                            if(fg[0] > fg[0]) fg[0] = fg[0];
                            if(fg[1] > fg[1]) fg[1] = fg[1];
                            if(fg[2] > fg[2]) fg[2] = fg[2];
                            if (fg[3] > base_mask) fg[3] = base_mask;

                            span->R_Byte = (byte)fg[ImageBuffer.OrderR];
                            span->G_Byte = (byte)fg[ImageBuffer.OrderG];
                            span->B_Byte = (byte)fg[ImageBuffer.OrderB];
                            span->A_Byte = (byte)fg[ImageBuffer.OrderA];

                            ++span;
                            interpolator().Next();
                        } while(--len != 0);
                    }
                                                              */
    };
}


//#endif




#endregion //agg_span_image_filter_rgba.cs
#region agg_span_interpolator_linear.cs


//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{

    public interface ISpanInterpolator
    {
        void begin(double x, double y, int len);
        void coordinates(out int x, out int y);
        void Next();

        Transform.ITransform transformer();
        void transformer(Transform.ITransform trans);
        void resynchronize(double xe, double ye, int len);
        void local_scale(out int x, out int y);
    };

    //================================================span_interpolator_linear
    public sealed class span_interpolator_linear : ISpanInterpolator
    {
        private Transform.ITransform m_trans;
        private dda2_line_interpolator m_li_x;
        private dda2_line_interpolator m_li_y;

        public enum subpixel_scale_e
        {
            SubpixelShift = 8,
            subpixel_shift = SubpixelShift,
            subpixel_scale = 1 << subpixel_shift
        };

        //--------------------------------------------------------------------
        public span_interpolator_linear() { }
        public span_interpolator_linear(Transform.ITransform trans)
        {
            m_trans = trans;
        }

        public span_interpolator_linear(Transform.ITransform trans, double x, double y, int len)
        {
            m_trans = trans;
            begin(x, y, len);
        }

        //----------------------------------------------------------------
        public Transform.ITransform transformer() { return m_trans; }
        public void transformer(Transform.ITransform trans) { m_trans = trans; }

        public void local_scale(out int x, out int y)
        {
            throw new System.NotImplementedException();
        }

        //----------------------------------------------------------------
        public void begin(double x, double y, int len)
        {
            double tx;
            double ty;

            tx = x;
            ty = y;
            m_trans.transform(ref tx, ref ty);
            int x1 = agg_basics.iround(tx * (double)subpixel_scale_e.subpixel_scale);
            int y1 = agg_basics.iround(ty * (double)subpixel_scale_e.subpixel_scale);

            tx = x + len;
            ty = y;
            m_trans.transform(ref tx, ref ty);
            int x2 = agg_basics.iround(tx * (double)subpixel_scale_e.subpixel_scale);
            int y2 = agg_basics.iround(ty * (double)subpixel_scale_e.subpixel_scale);

            m_li_x = new dda2_line_interpolator(x1, x2, (int)len);
            m_li_y = new dda2_line_interpolator(y1, y2, (int)len);
        }

        //----------------------------------------------------------------
        public void resynchronize(double xe, double ye, int len)
        {
            m_trans.transform(ref xe, ref ye);
            m_li_x = new dda2_line_interpolator(m_li_x.y(), agg_basics.iround(xe * (double)subpixel_scale_e.subpixel_scale), (int)len);
            m_li_y = new dda2_line_interpolator(m_li_y.y(), agg_basics.iround(ye * (double)subpixel_scale_e.subpixel_scale), (int)len);
        }

        //----------------------------------------------------------------
        //public void operator++()
        public void Next()
        {
            m_li_x.Next();
            m_li_y.Next();
        }

        //----------------------------------------------------------------
        public void coordinates(out int x, out int y)
        {
            x = m_li_x.y();
            y = m_li_y.y();
        }
    };

    public interface ISpanInterpolatorFloat
    {
        void begin(double x, double y, int len);
        void coordinates(out float x, out float y);
        void Next();

        Transform.ITransform transformer();
        void transformer(Transform.ITransform trans);
        void resynchronize(double xe, double ye, int len);
        void local_scale(out double x, out double y);
    };

    //================================================span_interpolator_linear
    public sealed class span_interpolator_linear_float : ISpanInterpolatorFloat
    {
        private Transform.ITransform m_trans;
        private float currentX;
        private float stepX;
        private float currentY;
        private float stepY;

        public span_interpolator_linear_float() { }
        public span_interpolator_linear_float(Transform.ITransform trans)
        {
            m_trans = trans;
        }

        public span_interpolator_linear_float(Transform.ITransform trans, double x, double y, int len)
        {
            m_trans = trans;
            begin(x, y, len);
        }

        //----------------------------------------------------------------
        public Transform.ITransform transformer() { return m_trans; }
        public void transformer(Transform.ITransform trans) { m_trans = trans; }

        public void local_scale(out double x, out double y)
        {
            throw new System.NotImplementedException();
        }

        //----------------------------------------------------------------
        public void begin(double x, double y, int len)
        {
            double tx;
            double ty;

            tx = x;
            ty = y;
            m_trans.transform(ref tx, ref ty);
            currentX = (float)tx;
            currentY = (float)ty;

            tx = x + len;
            ty = y;
            m_trans.transform(ref tx, ref ty);
            stepX = (float)((tx - currentX) / len);
            stepY = (float)((ty - currentY) / len);
        }

        //----------------------------------------------------------------
        public void resynchronize(double xe, double ye, int len)
        {
            throw new NotImplementedException();
            //m_trans.transform(ref xe, ref ye);
            //m_li_x = new dda2_line_interpolator(m_li_x.y(), agg_basics.iround(xe * (double)subpixel_scale_e.subpixel_scale), (int)len);
            //m_li_y = new dda2_line_interpolator(m_li_y.y(), agg_basics.iround(ye * (double)subpixel_scale_e.subpixel_scale), (int)len);
        }

        //----------------------------------------------------------------
        //public void operator++()
        public void Next()
        {
            currentX += stepX;
            currentY += stepY;
        }

        //----------------------------------------------------------------
        public void coordinates(out float x, out float y)
        {
            x = (float)currentX;
            y = (float)currentY;
        }
    };
    /*
        //=====================================span_interpolator_linear_subdiv
        template<class Transformer = ITransformer, int SubpixelShift = 8> 
        class span_interpolator_linear_subdiv
        {
        public:
            typedef Transformer trans_type;

            enum subpixel_scale_e
            {
                subpixel_shift = SubpixelShift,
                subpixel_scale = 1 << subpixel_shift
            };


            //----------------------------------------------------------------
            span_interpolator_linear_subdiv() :
                m_subdiv_shift(4),
                m_subdiv_size(1 << m_subdiv_shift),
                m_subdiv_mask(m_subdiv_size - 1) {}

            span_interpolator_linear_subdiv(const trans_type& trans, 
                                            int subdiv_shift = 4) : 
                m_subdiv_shift(subdiv_shift),
                m_subdiv_size(1 << m_subdiv_shift),
                m_subdiv_mask(m_subdiv_size - 1),
                m_trans(&trans) {}

            span_interpolator_linear_subdiv(const trans_type& trans,
                                            double x, double y, int len,
                                            int subdiv_shift = 4) :
                m_subdiv_shift(subdiv_shift),
                m_subdiv_size(1 << m_subdiv_shift),
                m_subdiv_mask(m_subdiv_size - 1),
                m_trans(&trans)
            {
                begin(x, y, len);
            }

            //----------------------------------------------------------------
            const trans_type& transformer() const { return *m_trans; }
            void transformer(const trans_type& trans) { m_trans = &trans; }

            //----------------------------------------------------------------
            int subdiv_shift() const { return m_subdiv_shift; }
            void subdiv_shift(int shift) 
            {
                m_subdiv_shift = shift;
                m_subdiv_size = 1 << m_subdiv_shift;
                m_subdiv_mask = m_subdiv_size - 1;
            }

            //----------------------------------------------------------------
            void begin(double x, double y, int len)
            {
                double tx;
                double ty;
                m_pos   = 1;
                m_src_x = iround(x * subpixel_scale) + subpixel_scale;
                m_src_y = y;
                m_len   = len;

                if(len > m_subdiv_size) len = m_subdiv_size;
                tx = x;
                ty = y;
                m_trans->transform(&tx, &ty);
                int x1 = iround(tx * subpixel_scale);
                int y1 = iround(ty * subpixel_scale);

                tx = x + len;
                ty = y;
                m_trans->transform(&tx, &ty);

                m_li_x = dda2_line_interpolator(x1, iround(tx * subpixel_scale), len);
                m_li_y = dda2_line_interpolator(y1, iround(ty * subpixel_scale), len);
            }

            //----------------------------------------------------------------
            void operator++()
            {
                ++m_li_x;
                ++m_li_y;
                if(m_pos >= m_subdiv_size)
                {
                    int len = m_len;
                    if(len > m_subdiv_size) len = m_subdiv_size;
                    double tx = double(m_src_x) / double(subpixel_scale) + len;
                    double ty = m_src_y;
                    m_trans->transform(&tx, &ty);
                    m_li_x = dda2_line_interpolator(m_li_x.y(), iround(tx * subpixel_scale), len);
                    m_li_y = dda2_line_interpolator(m_li_y.y(), iround(ty * subpixel_scale), len);
                    m_pos = 0;
                }
                m_src_x += subpixel_scale;
                ++m_pos;
                --m_len;
            }

            //----------------------------------------------------------------
            void coordinates(int* x, int* y) const
            {
                *x = m_li_x.y();
                *y = m_li_y.y();
            }

        private:
            int m_subdiv_shift;
            int m_subdiv_size;
            int m_subdiv_mask;
            const trans_type* m_trans;
            dda2_line_interpolator m_li_x;
            dda2_line_interpolator m_li_y;
            int      m_src_x;
            double   m_src_y;
            int m_pos;
            int m_len;
        };

     */
}

#endregion //agg_span_interpolator_linear.cs
#region agg_span_interpolator_persp.cs


//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{
    /*
    //===========================================span_interpolator_persp_exact
    //template<int SubpixelShift = 8> 
    class span_interpolator_persp_exact
    {
    public:
        typedef trans_perspective trans_type;
        typedef trans_perspective::iterator_x iterator_type;
        enum subpixel_scale_e
        {
            subpixel_shift = SubpixelShift,
            subpixel_scale = 1 << subpixel_shift
        };

        //--------------------------------------------------------------------
        span_interpolator_persp_exact() {}

        //--------------------------------------------------------------------
        // Arbitrary quadrangle transformations
        span_interpolator_persp_exact(double[] src, double[] dst) 
        {
            quad_to_quad(src, dst);
        }

        //--------------------------------------------------------------------
        // Direct transformations 
        span_interpolator_persp_exact(double x1, double y1, 
                                      double x2, double y2, 
                                      double[] quad)
        {
            rect_to_quad(x1, y1, x2, y2, quad);
        }

        //--------------------------------------------------------------------
        // Reverse transformations 
        span_interpolator_persp_exact(double[] quad, 
                                      double x1, double y1, 
                                      double x2, double y2)
        {
            quad_to_rect(quad, x1, y1, x2, y2);
        }

        //--------------------------------------------------------------------
        // Set the transformations using two arbitrary quadrangles.
        void quad_to_quad(double[] src, double[] dst)
        {
            m_trans_dir.quad_to_quad(src, dst);
            m_trans_inv.quad_to_quad(dst, src);
        }

        //--------------------------------------------------------------------
        // Set the direct transformations, i.e., rectangle -> quadrangle
        void rect_to_quad(double x1, double y1, double x2, double y2, 
                          double[] quad)
        {
            double src[8];
            src[0] = src[6] = x1;
            src[2] = src[4] = x2;
            src[1] = src[3] = y1;
            src[5] = src[7] = y2;
            quad_to_quad(src, quad);
        }


        //--------------------------------------------------------------------
        // Set the reverse transformations, i.e., quadrangle -> rectangle
        void quad_to_rect(double[] quad, 
                          double x1, double y1, double x2, double y2)
        {
            double dst[8];
            dst[0] = dst[6] = x1;
            dst[2] = dst[4] = x2;
            dst[1] = dst[3] = y1;
            dst[5] = dst[7] = y2;
            quad_to_quad(quad, dst);
        }

        //--------------------------------------------------------------------
        // Check if the equations were solved successfully
        bool is_valid() { return m_trans_dir.is_valid(); }

        //----------------------------------------------------------------
        void begin(double x, double y, int len)
        {
            m_iterator = m_trans_dir.begin(x, y, 1.0);
            double xt = m_iterator.x;
            double yt = m_iterator.y;

            double dx;
            double dy;
            double delta = 1/(double)subpixel_scale;
            dx = xt + delta;
            dy = yt;
            m_trans_inv.transform(&dx, &dy);
            dx -= x;
            dy -= y;
            int sx1 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;
            dx = xt;
            dy = yt + delta;
            m_trans_inv.transform(&dx, &dy);
            dx -= x;
            dy -= y;
            int sy1 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

            x += len;
            xt = x;
            yt = y;
            m_trans_dir.transform(&xt, &yt);

            dx = xt + delta;
            dy = yt;
            m_trans_inv.transform(&dx, &dy);
            dx -= x;
            dy -= y;
            int sx2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;
            dx = xt;
            dy = yt + delta;
            m_trans_inv.transform(&dx, &dy);
            dx -= x;
            dy -= y;
            int sy2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

            m_scale_x = dda2_line_interpolator(sx1, sx2, len);
            m_scale_y = dda2_line_interpolator(sy1, sy2, len);
        }


        //----------------------------------------------------------------
        void resynchronize(double xe, double ye, int len)
        {
            // Assume x1,y1 are equal to the ones at the previous end point 
            int sx1 = m_scale_x.y();
            int sy1 = m_scale_y.y();

            // Calculate transformed coordinates at x2,y2 
            double xt = xe;
            double yt = ye;
            m_trans_dir.transform(&xt, &yt);

            double delta = 1/(double)subpixel_scale;
            double dx;
            double dy;

            // Calculate scale by X at x2,y2
            dx = xt + delta;
            dy = yt;
            m_trans_inv.transform(&dx, &dy);
            dx -= xe;
            dy -= ye;
            int sx2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

            // Calculate scale by Y at x2,y2
            dx = xt;
            dy = yt + delta;
            m_trans_inv.transform(&dx, &dy);
            dx -= xe;
            dy -= ye;
            int sy2 = agg_basics.uround(subpixel_scale/Math.Sqrt(dx*dx + dy*dy)) >> subpixel_shift;

            // Initialize the interpolators
            m_scale_x = dda2_line_interpolator(sx1, sx2, len);
            m_scale_y = dda2_line_interpolator(sy1, sy2, len);
        }



        //----------------------------------------------------------------
        void operator++()
        {
            ++m_iterator;
            ++m_scale_x;
            ++m_scale_y;
        }

        //----------------------------------------------------------------
        void coordinates(int* x, int* y)
        {
            *x = agg_basics.iround(m_iterator.x * subpixel_scale);
            *y = agg_basics.iround(m_iterator.y * subpixel_scale);
        }

        //----------------------------------------------------------------
        void local_scale(int* x, int* y)
        {
            *x = m_scale_x.y();
            *y = m_scale_y.y();
        }

        //----------------------------------------------------------------
        void transform(double[] x, double[] y)
        {
            m_trans_dir.transform(x, y);
        }
        
    private:
        trans_type             m_trans_dir;
        trans_type             m_trans_inv;
        iterator_type          m_iterator;
        dda2_line_interpolator m_scale_x;
        dda2_line_interpolator m_scale_y;
    };
     */


    //============================================span_interpolator_persp_lerp
    //template<int SubpixelShift = 8> 
    public class span_interpolator_persp_lerp : ISpanInterpolator
    {
        Transform.Perspective m_trans_dir;
        Transform.Perspective m_trans_inv;
        dda2_line_interpolator m_coord_x;
        dda2_line_interpolator m_coord_y;
        dda2_line_interpolator m_scale_x;
        dda2_line_interpolator m_scale_y;

        const int subpixel_shift = 8;
        const int subpixel_scale = 1 << subpixel_shift;

        //--------------------------------------------------------------------
        public span_interpolator_persp_lerp()
        {
            m_trans_dir = new Transform.Perspective();
            m_trans_inv = new Transform.Perspective();
        }

        //--------------------------------------------------------------------
        // Arbitrary quadrangle transformations
        public span_interpolator_persp_lerp(double[] src, double[] dst)
            : this()
        {
            quad_to_quad(src, dst);
        }

        //--------------------------------------------------------------------
        // Direct transformations 
        public span_interpolator_persp_lerp(double x1, double y1,
                                     double x2, double y2,
                                     double[] quad)
            : this()
        {
            rect_to_quad(x1, y1, x2, y2, quad);
        }

        //--------------------------------------------------------------------
        // Reverse transformations 
        public span_interpolator_persp_lerp(double[] quad,
                                     double x1, double y1,
                                     double x2, double y2)
            : this()
        {
            quad_to_rect(quad, x1, y1, x2, y2);
        }

        //--------------------------------------------------------------------
        // Set the transformations using two arbitrary quadrangles.
        public void quad_to_quad(double[] src, double[] dst)
        {
            m_trans_dir.quad_to_quad(src, dst);
            m_trans_inv.quad_to_quad(dst, src);
        }

        //--------------------------------------------------------------------
        // Set the direct transformations, i.e., rectangle -> quadrangle
        public void rect_to_quad(double x1, double y1, double x2, double y2, double[] quad)
        {
            double[] src = new double[8];
            src[0] = src[6] = x1;
            src[2] = src[4] = x2;
            src[1] = src[3] = y1;
            src[5] = src[7] = y2;
            quad_to_quad(src, quad);
        }


        //--------------------------------------------------------------------
        // Set the reverse transformations, i.e., quadrangle -> rectangle
        public void quad_to_rect(double[] quad,
                          double x1, double y1, double x2, double y2)
        {
            double[] dst = new double[8];
            dst[0] = dst[6] = x1;
            dst[2] = dst[4] = x2;
            dst[1] = dst[3] = y1;
            dst[5] = dst[7] = y2;
            quad_to_quad(quad, dst);
        }

        //--------------------------------------------------------------------
        // Check if the equations were solved successfully
        public bool is_valid() { return m_trans_dir.is_valid(); }

        //----------------------------------------------------------------
        public void begin(double x, double y, int len)
        {
            // Calculate transformed coordinates at x1,y1 
            double xt = x;
            double yt = y;
            m_trans_dir.transform(ref xt, ref yt);
            int x1 = agg_basics.iround(xt * subpixel_scale);
            int y1 = agg_basics.iround(yt * subpixel_scale);

            double dx;
            double dy;
            double delta = 1 / (double)subpixel_scale;

            // Calculate scale by X at x1,y1
            dx = xt + delta;
            dy = yt;
            m_trans_inv.transform(ref dx, ref dy);
            dx -= x;
            dy -= y;
            int sx1 = (int)agg_basics.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

            // Calculate scale by Y at x1,y1
            dx = xt;
            dy = yt + delta;
            m_trans_inv.transform(ref dx, ref dy);
            dx -= x;
            dy -= y;
            int sy1 = (int)agg_basics.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

            // Calculate transformed coordinates at x2,y2 
            x += len;
            xt = x;
            yt = y;
            m_trans_dir.transform(ref xt, ref yt);
            int x2 = agg_basics.iround(xt * subpixel_scale);
            int y2 = agg_basics.iround(yt * subpixel_scale);

            // Calculate scale by X at x2,y2
            dx = xt + delta;
            dy = yt;
            m_trans_inv.transform(ref dx, ref dy);
            dx -= x;
            dy -= y;
            int sx2 = (int)agg_basics.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

            // Calculate scale by Y at x2,y2
            dx = xt;
            dy = yt + delta;
            m_trans_inv.transform(ref dx, ref dy);
            dx -= x;
            dy -= y;
            int sy2 = (int)agg_basics.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

            // Initialize the interpolators
            m_coord_x = new dda2_line_interpolator(x1, x2, (int)len);
            m_coord_y = new dda2_line_interpolator(y1, y2, (int)len);
            m_scale_x = new dda2_line_interpolator(sx1, sx2, (int)len);
            m_scale_y = new dda2_line_interpolator(sy1, sy2, (int)len);
        }


        //----------------------------------------------------------------
        public void resynchronize(double xe, double ye, int len)
        {
            // Assume x1,y1 are equal to the ones at the previous end point 
            int x1 = m_coord_x.y();
            int y1 = m_coord_y.y();
            int sx1 = m_scale_x.y();
            int sy1 = m_scale_y.y();

            // Calculate transformed coordinates at x2,y2 
            double xt = xe;
            double yt = ye;
            m_trans_dir.transform(ref xt, ref yt);
            int x2 = agg_basics.iround(xt * subpixel_scale);
            int y2 = agg_basics.iround(yt * subpixel_scale);

            double delta = 1 / (double)subpixel_scale;
            double dx;
            double dy;

            // Calculate scale by X at x2,y2
            dx = xt + delta;
            dy = yt;
            m_trans_inv.transform(ref dx, ref dy);
            dx -= xe;
            dy -= ye;
            int sx2 = (int)agg_basics.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

            // Calculate scale by Y at x2,y2
            dx = xt;
            dy = yt + delta;
            m_trans_inv.transform(ref dx, ref dy);
            dx -= xe;
            dy -= ye;
            int sy2 = (int)agg_basics.uround(subpixel_scale / Math.Sqrt(dx * dx + dy * dy)) >> subpixel_shift;

            // Initialize the interpolators
            m_coord_x = new dda2_line_interpolator(x1, x2, (int)len);
            m_coord_y = new dda2_line_interpolator(y1, y2, (int)len);
            m_scale_x = new dda2_line_interpolator(sx1, sx2, (int)len);
            m_scale_y = new dda2_line_interpolator(sy1, sy2, (int)len);
        }

        public Transform.ITransform transformer()
        {
            throw new System.NotImplementedException();
        }

        public void transformer(Transform.ITransform trans)
        {
            throw new System.NotImplementedException();
        }

        //----------------------------------------------------------------
        public void Next()
        {
            m_coord_x.Next();
            m_coord_y.Next();
            m_scale_x.Next();
            m_scale_y.Next();
        }

        //----------------------------------------------------------------
        public void coordinates(out int x, out int y)
        {
            x = m_coord_x.y();
            y = m_coord_y.y();
        }

        //----------------------------------------------------------------
        public void local_scale(out int x, out int y)
        {
            x = m_scale_x.y();
            y = m_scale_y.y();
        }

        //----------------------------------------------------------------
        public void transform(ref double x, ref double y)
        {
            m_trans_dir.transform(ref x, ref y);
        }
    };
}

#endregion //agg_span_interpolator_persp.cs
#region agg_span_subdiv_adaptor.cs


//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg
{

    //=================================================span_subdiv_adaptor
    public class span_subdiv_adaptor : ISpanInterpolator
    {
        int m_subdiv_shift;
        int m_subdiv_size;
        int m_subdiv_mask;
        ISpanInterpolator m_interpolator;
        int m_src_x;
        double m_src_y;
        int m_pos;
        int m_len;

        const int subpixel_shift = 8;
        const int subpixel_scale = 1 << subpixel_shift;


        //----------------------------------------------------------------
        public span_subdiv_adaptor(ISpanInterpolator interpolator)
            : this(interpolator, 4)
        {
        }

        public span_subdiv_adaptor(ISpanInterpolator interpolator, int subdiv_shift)
        {
            m_subdiv_shift = subdiv_shift;
            m_subdiv_size = 1 << m_subdiv_shift;
            m_subdiv_mask = m_subdiv_size - 1;
            m_interpolator = interpolator;
        }

        public span_subdiv_adaptor(ISpanInterpolator interpolator,
                             double x, double y, int len,
                             int subdiv_shift)
            : this(interpolator, subdiv_shift)
        {
            begin(x, y, len);
        }

        public void resynchronize(double xe, double ye, int len)
        {
            throw new System.NotImplementedException();
        }

        //----------------------------------------------------------------
        public ISpanInterpolator interpolator() { return m_interpolator; }
        public void interpolator(ISpanInterpolator intr) { m_interpolator = intr; }

        //----------------------------------------------------------------
        public Transform.ITransform transformer()
        {
            return m_interpolator.transformer();
        }
        public void transformer(Transform.ITransform trans)
        {
            m_interpolator.transformer(trans);
        }

        //----------------------------------------------------------------
        public int subdiv_shift() { return m_subdiv_shift; }
        public void subdiv_shift(int shift)
        {
            m_subdiv_shift = shift;
            m_subdiv_size = 1 << m_subdiv_shift;
            m_subdiv_mask = m_subdiv_size - 1;
        }

        //----------------------------------------------------------------
        public void begin(double x, double y, int len)
        {
            m_pos = 1;
            m_src_x = agg_basics.iround(x * subpixel_scale) + subpixel_scale;
            m_src_y = y;
            m_len = len;
            if (len > m_subdiv_size) len = (int)m_subdiv_size;
            m_interpolator.begin(x, y, len);
        }

        //----------------------------------------------------------------
        public void Next()
        {
            m_interpolator.Next();
            if (m_pos >= m_subdiv_size)
            {
                int len = m_len;
                if (len > m_subdiv_size) len = (int)m_subdiv_size;
                m_interpolator.resynchronize((double)m_src_x / (double)subpixel_scale + len,
                                              m_src_y,
                                              len);
                m_pos = 0;
            }
            m_src_x += subpixel_scale;
            ++m_pos;
            --m_len;
        }

        //----------------------------------------------------------------
        public void coordinates(out int x, out int y)
        {
            m_interpolator.coordinates(out x, out y);
        }

        //----------------------------------------------------------------
        public void local_scale(out int x, out int y)
        {
            m_interpolator.local_scale(out x, out y);
        }
    };
}

#endregion //agg_span_subdiv_adaptor.cs
#region agg_VertexSequence.cs


//----------------------------------------------------------------------------
//
// vertex_sequence container and vertex_dist struct
//
//----------------------------------------------------------------------------

//using MatterHackers.Agg.VertexSource;
namespace MatterHackers.Agg
{

    //----------------------------------------------------------vertex_sequence
    // Modified agg::pod_vector. The data is interpreted as a sequence 
    // of vertices. It means that the type T must expose:
    //
    // bool T::operator() (const T& val)
    // 
    // that is called every time a new vertex is being added. The main purpose
    // of this operator is the possibility to calculate some values during 
    // adding and to return true if the vertex fits some criteria or false if
    // it doesn't. In the last case the new vertex is not added. 
    // 
    // The simple example is filtering coinciding vertices with calculation 
    // of the distance between the current and previous ones:
    //
    //    struct vertex_dist
    //    {
    //        double   x;
    //        double   y;
    //        double   dist;
    //
    //        vertex_dist() {}
    //        vertex_dist(double x_, double y_) :
    //            x(x_),
    //            y(y_),
    //            dist(0.0)
    //        {
    //        }
    //
    //        bool operator () (const vertex_dist& val)
    //        {
    //            return (dist = calc_distance(x, y, val.x, val.y)) > EPSILON;
    //        }
    //    };
    //
    // Function close() calls this operator and removes the last vertex if 
    // necessary.
    //------------------------------------------------------------------------
    public class VertexSequence : VectorPOD<VertexDistance>
    {
        public override void add(VertexDistance val)
        {
            if (base.size() > 1)
            {
                if (!Array[base.size() - 2].IsEqual(Array[base.size() - 1]))
                {
                    base.RemoveLast();
                }
            }
            base.add(val);
        }

        public void modify_last(VertexDistance val)
        {
            base.RemoveLast();
            add(val);
        }

        public void close(bool closed)
        {
            while (base.size() > 1)
            {
                if (Array[base.size() - 2].IsEqual(Array[base.size() - 1])) break;
                VertexDistance t = this[base.size() - 1];
                base.RemoveLast();
                modify_last(t);
            }

            if (closed)
            {
                while (base.size() > 1)
                {
                    if (Array[base.size() - 1].IsEqual(Array[0])) break;
                    base.RemoveLast();
                }
            }
        }

        internal VertexDistance prev(int idx)
        {
            return this[(idx + currentSize - 1) % currentSize];
        }

        internal VertexDistance curr(int idx)
        {
            return this[idx];
        }

        internal VertexDistance next(int idx)
        {
            return this[(idx + 1) % currentSize];
        }
    }

    //-------------------------------------------------------------vertex_dist
    // Vertex (x, y) with the distance to the next one. The last vertex has 
    // distance between the last and the first points if the polygon is closed
    // and 0.0 if it's a polyline.
    public struct VertexDistance
    {
        public double x;
        public double y;
        public double dist;

        public VertexDistance(double x_, double y_)
        {
            x = x_;
            y = y_;
            dist = 0.0;
        }

        public bool IsEqual(VertexDistance val)
        {
            bool ret = (dist = agg_math.calc_distance(x, y, val.x, val.y)) > agg_math.vertex_dist_epsilon;
            if (!ret) dist = 1.0 / agg_math.vertex_dist_epsilon;
            return ret;
        }
    }


    /*
    //--------------------------------------------------------vertex_dist_cmd
    // Save as the above but with additional "command" value
    struct vertex_dist_cmd : vertex_dist
    {
        unsigned cmd;

        vertex_dist_cmd() {}
        vertex_dist_cmd(double x_, double y_, unsigned cmd_) :
            base (x_, y_)
            
        {
            cmd = cmd;
        }
    };
     */
}

//#endif

#endregion //agg_VertexSequence.cs
#region AlphaMaskAdaptor.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//using System;
//using MatterHackers.Agg;

namespace MatterHackers.Agg.Image
{
    //==================================================pixfmt_amask_adaptor
    public sealed class AlphaMaskAdaptor : ImageProxy
    {
        IAlphaMask m_mask;
        ArrayPOD<byte> m_span;

        enum span_extra_tail_e { span_extra_tail = 256 };
        static readonly byte cover_full = 255;

        void realloc_span(int len)
        {
            if (len > m_span.Size())
            {
                m_span.Resize(len + (int)span_extra_tail_e.span_extra_tail);
            }
        }

        void init_span(int len)
        {
            init_span(len, cover_full);
        }

        void init_span(int len, byte cover)
        {
            realloc_span(len);
            agg_basics.memset(m_span.Array, 0, cover, len);
        }

        void init_span(int len, byte[] covers, int coversIndex)
        {
            realloc_span(len);
            byte[] array = m_span.Array;
            for (int i = 0; i < (int)len; i++)
            {
                array[i] = covers[coversIndex + i];
            }
        }

        public AlphaMaskAdaptor(IImageByte image, IAlphaMask mask)
            : base(image)
        {
            linkedImage = image;
            m_mask = mask;
            m_span = new ArrayPOD<byte>(255);
        }

        public void AttachImage(IImageByte image)
        {
            linkedImage = image;
        }
        public void attach_alpha_mask(IAlphaMask mask)
        {
            m_mask = mask;
        }

        public void copy_pixel(int x, int y, RGBA_Bytes c)
        {
            linkedImage.BlendPixel(x, y, c, m_mask.pixel(x, y));
        }

        public override void copy_hline(int x, int y, int len, RGBA_Bytes c)
        {
            throw new NotImplementedException();
            /*
                        realloc_span((int)len);
                        unsafe
                        {
                            fixed (byte* pBuffer = m_span.Array)
                            {
                                m_mask.fill_hspan(x, y, pBuffer, (int)len);
                                m_LinkedImage.blend_solid_hspan(x, y, len, c, pBuffer);
                            }
                        }
             */
        }

        public override void blend_hline(int x1, int y, int x2, RGBA_Bytes c, byte cover)
        {
            int len = x2 - x1 + 1;
            if (cover == cover_full)
            {
                realloc_span(len);
                m_mask.combine_hspanFullCover(x1, y, m_span.Array, 0, (int)len);
                linkedImage.blend_solid_hspan(x1, y, (int)len, c, m_span.Array, 0);
            }
            else
            {
                init_span(len, cover);
                m_mask.combine_hspan(x1, y, m_span.Array, 0, (int)len);
                linkedImage.blend_solid_hspan(x1, y, (int)len, c, m_span.Array, 0);
            }
        }

        public override void copy_vline(int x, int y, int len, RGBA_Bytes c)
        {
            throw new NotImplementedException(); /*
            realloc_span((int)len);
            unsafe
            {
                fixed (byte* pBuffer = m_span.Array)
                {
                    m_mask.fill_vspan(x, y, pBuffer, (int)len);
                    m_LinkedImage.blend_solid_vspan(x, y, len, c, pBuffer);
                }
            }
                                                  */
        }

        public override void blend_vline(int x, int y1, int y2, RGBA_Bytes c, byte cover)
        {
            throw new NotImplementedException(); /*
            int len = y2 - y1 + 1;
            init_span(len, cover);
            unsafe
            {
                fixed (byte* pBuffer = m_span.Array)
                {
                    m_mask.combine_vspan(x, y1, pBuffer, len);
                    throw new System.NotImplementedException("blend_solid_vspan does not take a y2 yet");
                    //m_pixf.blend_solid_vspan(x, y1, y2, c, pBuffer);
                }
            }
                                                  */
        }

        public override void blend_solid_hspan(int x, int y, int len, RGBA_Bytes color, byte[] covers, int coversIndex)
        {
            byte[] buffer = m_span.Array;
            m_mask.combine_hspan(x, y, covers, coversIndex, len);
            linkedImage.blend_solid_hspan(x, y, len, color, covers, coversIndex);
        }

        public override void blend_solid_vspan(int x, int y, int len, RGBA_Bytes c, byte[] covers, int coversIndex)
        {
            throw new System.NotImplementedException();
#if false
            init_span((int)len, covers);
            unsafe
            {
                fixed (byte* pBuffer = m_span.Array)
                {
                    m_mask.combine_vspan(x, y, pBuffer, (int)len);
                    m_LinkedImage.blend_solid_vspan(x, y, len, c, pBuffer);
                }
            }
#endif
        }

        public override void copy_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            throw new System.NotImplementedException();
#if false
            realloc_span((int)len);
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    m_mask.fill_hspan(x, y, pBuffer, (int)len);
                    m_pixf.blend_color_hspan(x, y, len, colors, pBuffer, cover_full);
                }
            }
#endif
        }

        public override void copy_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            throw new System.NotImplementedException();
#if false
            realloc_span((int)len);
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    m_mask.fill_vspan(x, y, pBuffer, (int)len);
                    m_pixf.blend_color_vspan(x, y, len, colors, pBuffer, cover_full);
                }
            }
#endif
        }

        public override void blend_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            throw new System.NotImplementedException();
#if false
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    if (covers != null)
                    {
                        init_span((int)len, covers);
                        m_mask.combine_hspan(x, y, pBuffer, (int)len);
                    }
                    else
                    {
                        realloc_span((int)len);
                        m_mask.fill_hspan(x, y, pBuffer, (int)len);
                    }
                    m_pixf.blend_color_hspan(x, y, len, colors, pBuffer, cover);
                }
            }
#endif
        }

        public override void blend_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            throw new System.NotImplementedException();
#if false
            unsafe
            {
                fixed (byte* pBuffer = m_span.GetArray())
                {
                    if (covers != null)
                    {
                        init_span((int)len, covers);
                        m_mask.combine_vspan(x, y, pBuffer, (int)len);
                    }
                    else
                    {
                        realloc_span((int)len);
                        m_mask.fill_vspan(x, y, pBuffer, (int)len);
                    }
                    m_pixf.blend_color_vspan(x, y, len, colors, pBuffer, cover);
                }
            }
#endif
        }
    };
}

#endregion //AlphaMaskAdaptor.cs
#region ApplyTransform.cs


//----------------------------------------------------------------------------
//using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
    // in the original agg this was conv_transform
    public class VertexSourceApplyTransform : IVertexSourceProxy
    {
        private Transform.ITransform transformToApply;

        public IVertexSource VertexSource
        {
            get;
            set;
        }

        public VertexSourceApplyTransform(Transform.ITransform newTransformeToApply)
            : this(null, newTransformeToApply)
        {
        }

        public VertexSourceApplyTransform(IVertexSource vertexSource, Transform.ITransform newTransformeToApply)
        {
            VertexSource = vertexSource;
            transformToApply = newTransformeToApply;
        }

        public void attach(IVertexSource vertexSource) { VertexSource = vertexSource; }

        public IEnumerable<VertexData> Vertices()
        {
            foreach (VertexData vertexData in VertexSource.Vertices())
            {
                VertexData transformedVertex = vertexData;
                if (ShapePath.is_vertex(transformedVertex.command))
                {
                    transformToApply.transform(ref transformedVertex.position.x, ref transformedVertex.position.y);
                }
                yield return transformedVertex;
            }
        }

        public void rewind(int path_id)
        {
            VertexSource.rewind(path_id);
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            ShapePath.FlagsAndCommand cmd = VertexSource.vertex(out x, out y);
            if (ShapePath.is_vertex(cmd))
            {
                transformToApply.transform(ref x, ref y);
            }
            return cmd;
        }

        public void SetTransformToApply(Transform.ITransform newTransformeToApply)
        {
            transformToApply = newTransformeToApply;
        }
    }
}

#endregion //ApplyTransform.cs
#region Arc.cs


//----------------------------------------------------------------------------
//
// Arc vertex generator
//
//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;
//using MatterHackers.Agg;
//using MatterHackers.VectorMath;

//using FlagsAndCommand = MatterHackers.Agg.ShapePath.FlagsAndCommand;

namespace MatterHackers.Agg.VertexSource
{
    //=====================================================================arc
    //
    // See Implementation agg_arc.cpp 
    //
    public class arc : IVertexSource
    {
        double originX;
        double originY;

        double radiusX;
        double radiusY;

        double startAngle;
        double endAngle;
        double m_Scale = 1.0;
        bool moveToStart = true;
        EDirection m_Direction;

        double m_CurrentFlatenAngle;
        double flatenDeltaAngle;

        bool m_IsInitialized = false;
        ShapePath.FlagsAndCommand m_NextPathCommand;

        public enum EDirection
        {
            ClockWise,
            CounterClockWise,
        }

        public arc()
        {
        }

        public arc(double OriginX, double OriginY,
             double RadiusX, double RadiusY,
             double Angle1, double Angle2,
             EDirection Direction = EDirection.CounterClockWise,
             double Scale = 1.0,
             bool moveToStart = true)
        {
            init(OriginX, OriginY, RadiusX, RadiusY, Angle1, Angle2, Direction: Direction, Scale: Scale, moveToStart: moveToStart);
        }

        public void init(double OriginX, double OriginY,
                   double RadiusX, double RadiusY,
                   double Angle1, double Angle2,
                   EDirection Direction = EDirection.CounterClockWise,
                   double Scale = 1.0,
                   bool moveToStart = true)
        {
            originX = OriginX;
            originY = OriginY;
            radiusX = RadiusX;
            radiusY = RadiusY;
            m_Scale = Scale;
            this.moveToStart = moveToStart;
            normalize(Angle1, Angle2, Direction);
        }

        public void approximation_scale(double s)
        {
            m_Scale = s;
            m_IsInitialized = false; // force recalc
        }

        public double approximation_scale() { return m_Scale; }

        public IEnumerable<VertexData> Vertices()
        {
            if (!m_IsInitialized)
            {
                normalize(startAngle, endAngle, m_Direction);
            }

            // go to the start
            VertexData vertexData = new VertexData();
            vertexData.command = moveToStart ? MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandMoveTo : MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandLineTo;
            vertexData.position.x = originX + Math.Cos(startAngle) * radiusX;
            vertexData.position.y = originY + Math.Sin(startAngle) * radiusY;
            yield return vertexData;

            double angle = startAngle;
            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandLineTo;
            while ((angle < endAngle - flatenDeltaAngle / 4) == (((int)EDirection.CounterClockWise) == 1))
            {
                angle += flatenDeltaAngle;

                vertexData.position.x = originX + Math.Cos(angle) * radiusX;
                vertexData.position.y = originY + Math.Sin(angle) * radiusY;
                yield return vertexData;
            }

            vertexData.position.x = originX + Math.Cos(endAngle) * radiusX;
            vertexData.position.y = originY + Math.Sin(endAngle) * radiusY;
            yield return vertexData;

            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandStop;
            yield return vertexData;
        }

        public void rewind(int unused)
        {
            m_NextPathCommand = ShapePath.FlagsAndCommand.CommandMoveTo;
            m_CurrentFlatenAngle = startAngle;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = 0;
            y = 0;

            if (ShapePath.is_stop(m_NextPathCommand))
            {
                return ShapePath.FlagsAndCommand.CommandStop;
            }

            if ((m_CurrentFlatenAngle < endAngle - flatenDeltaAngle / 4) != ((int)EDirection.CounterClockWise == 1))
            {
                x = originX + Math.Cos(endAngle) * radiusX;
                y = originY + Math.Sin(endAngle) * radiusY;
                m_NextPathCommand = ShapePath.FlagsAndCommand.CommandStop;

                return ShapePath.FlagsAndCommand.CommandLineTo;
            }

            x = originX + Math.Cos(m_CurrentFlatenAngle) * radiusX;
            y = originY + Math.Sin(m_CurrentFlatenAngle) * radiusY;

            m_CurrentFlatenAngle += flatenDeltaAngle;

            ShapePath.FlagsAndCommand CurrentPathCommand = m_NextPathCommand;
            m_NextPathCommand = ShapePath.FlagsAndCommand.CommandLineTo;
            return CurrentPathCommand;
        }

        private void normalize(double Angle1, double Angle2, EDirection Direction)
        {
            double ra = (Math.Abs(radiusX) + Math.Abs(radiusY)) / 2;
            flatenDeltaAngle = Math.Acos(ra / (ra + 0.125 / m_Scale)) * 2;
            if (Direction == EDirection.CounterClockWise)
            {
                while (Angle2 < Angle1)
                {
                    Angle2 += Math.PI * 2.0;
                }
            }
            else
            {
                while (Angle1 < Angle2)
                {
                    Angle1 += Math.PI * 2.0;
                }
                flatenDeltaAngle = -flatenDeltaAngle;
            }

            m_Direction = Direction;
            startAngle = Angle1;
            endAngle = Angle2;
            m_IsInitialized = true;
        }
    }
}

#endregion //Arc.cs
#region Array2D.cs

//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Text;

namespace MatterHackers.Agg
{
    public class Array2D<dataType>
    {
        dataType[][] internalArray;

        public Array2D(int width, int height)
        {
            internalArray = new dataType[height][];
            for (int column = 0; column < height; column++)
            {
                internalArray[column] = new dataType[width];
            }
        }

        public int Width { get { return GetRow(0).Length; } }

        public int Height { get { return internalArray.Length; } }

        public dataType[] GetRow(int y)
        {
            return internalArray[y];
        }

        public void Fill(dataType valueToFillWith)
        {
            for (int y = 0; y < Height; y++)
            {
                dataType[] row = GetRow(y);
                for (int x = 0; x < Width; x++)
                {
                    row[x] = valueToFillWith;
                }
            }
        }

        public dataType GetValue(int x, int y)
        {
            return GetRow(y)[x];
        }

        public void SetValue(int x, int y, dataType value)
        {
            GetRow(y)[x] = value;
        }
    }
}

#endregion //Array2D.cs
#region AxisAlignedBoundingBox.cs
namespace MatterHackers.VectorMath
{
    public class AxisAlignedBoundingBox
    {
        public Vector3 minXYZ;
        public Vector3 maxXYZ;

        public AxisAlignedBoundingBox(Vector3 minXYZ, Vector3 maxXYZ)
        {
            if (maxXYZ.x < minXYZ.x || maxXYZ.y < minXYZ.y || maxXYZ.z < minXYZ.z)
            {
                throw new ArgumentException("All values of min must be less than all values in max.");
            }

            this.minXYZ = minXYZ;
            this.maxXYZ = maxXYZ;
        }

        public Vector3 Size
        {
            get
            {
                return maxXYZ - minXYZ;
            }
        }

        public double XSize
        {
            get
            {
                return maxXYZ.x - minXYZ.x;
            }
        }

        public double YSize
        {
            get
            {
                return maxXYZ.y - minXYZ.y;
            }
        }

        public double ZSize
        {
            get
            {
                return maxXYZ.z - minXYZ.z;
            }
        }

        public AxisAlignedBoundingBox NewTransformed(Matrix4X4 transform)
        {
            Vector3[] boundsVerts = new Vector3[8];
            boundsVerts[0] = new Vector3(this[0][0], this[0][1], this[0][2]);
            boundsVerts[1] = new Vector3(this[0][0], this[0][1], this[1][2]);
            boundsVerts[2] = new Vector3(this[0][0], this[1][1], this[0][2]);
            boundsVerts[3] = new Vector3(this[0][0], this[1][1], this[1][2]);
            boundsVerts[4] = new Vector3(this[1][0], this[0][1], this[0][2]);
            boundsVerts[5] = new Vector3(this[1][0], this[0][1], this[1][2]);
            boundsVerts[6] = new Vector3(this[1][0], this[1][1], this[0][2]);
            boundsVerts[7] = new Vector3(this[1][0], this[1][1], this[1][2]);

            Vector3.Transform(boundsVerts, transform);

            Vector3 newMin = new Vector3(double.MaxValue, double.MaxValue, double.MaxValue);
            Vector3 newMax = new Vector3(double.MinValue, double.MinValue, double.MinValue);

            for (int i = 0; i < 8; i++)
            {
                newMin.x = Math.Min(newMin.x, boundsVerts[i].x);
                newMin.y = Math.Min(newMin.y, boundsVerts[i].y);
                newMin.z = Math.Min(newMin.z, boundsVerts[i].z);

                newMax.x = Math.Max(newMax.x, boundsVerts[i].x);
                newMax.y = Math.Max(newMax.y, boundsVerts[i].y);
                newMax.z = Math.Max(newMax.z, boundsVerts[i].z);
            }

            return new AxisAlignedBoundingBox(newMin, newMax);
        }

        public Vector3 Center
        {
            get
            {
                return (minXYZ + maxXYZ) / 2;
            }
        }

        /// <summary>
        /// This is the computation cost of doing an intersection with the given type.
        /// Attempt to give it in average CPU cycles for the intersecton.
        /// </summary>
        /// <returns></returns>
        public static double GetIntersectCost()
        {
            // it would be great to try and measure this more accurately.  This is a guess from looking at the intersect function.
            return 132;
        }

        public Vector3 GetCenter()
        {
            return (minXYZ + maxXYZ) * .5;
        }

        public double GetCenterX()
        {
            return (minXYZ.x + maxXYZ.x) * .5;
        }

        double volumeCache = 0;
        public double GetVolume()
        {
            if (volumeCache == 0)
            {
                volumeCache = (maxXYZ.x - minXYZ.x) * (maxXYZ.y - minXYZ.y) * (maxXYZ.z - minXYZ.z);
            }

            return volumeCache;
        }

        double surfaceAreaCache = 0;
        public double GetSurfaceArea()
        {
            if (surfaceAreaCache == 0)
            {
                double frontAndBack = (maxXYZ.x - minXYZ.x) * (maxXYZ.z - minXYZ.z) * 2;
                double leftAndRight = (maxXYZ.y - minXYZ.y) * (maxXYZ.z - minXYZ.z) * 2;
                double topAndBottom = (maxXYZ.x - minXYZ.x) * (maxXYZ.y - minXYZ.y) * 2;
                surfaceAreaCache = frontAndBack + leftAndRight + topAndBottom;
            }

            return surfaceAreaCache;
        }

        public Vector3 this[int index]
        {
            get
            {
                if (index == 0)
                {
                    return minXYZ;
                }
                else if (index == 1)
                {
                    return maxXYZ;
                }
                else
                {
                    throw new IndexOutOfRangeException();
                }
            }
        }

        public static AxisAlignedBoundingBox operator +(AxisAlignedBoundingBox A, AxisAlignedBoundingBox B)
        {
            Vector3 calcMinXYZ = new Vector3();
            calcMinXYZ.x = Math.Min(A.minXYZ.x, B.minXYZ.x);
            calcMinXYZ.y = Math.Min(A.minXYZ.y, B.minXYZ.y);
            calcMinXYZ.z = Math.Min(A.minXYZ.z, B.minXYZ.z);

            Vector3 calcMaxXYZ = new Vector3();
            calcMaxXYZ.x = Math.Max(A.maxXYZ.x, B.maxXYZ.x);
            calcMaxXYZ.y = Math.Max(A.maxXYZ.y, B.maxXYZ.y);
            calcMaxXYZ.z = Math.Max(A.maxXYZ.z, B.maxXYZ.z);

            AxisAlignedBoundingBox combinedBounds = new AxisAlignedBoundingBox(calcMinXYZ, calcMaxXYZ);

            return combinedBounds;
        }

        public static AxisAlignedBoundingBox Union(AxisAlignedBoundingBox boundsA, AxisAlignedBoundingBox boundsB)
        {
            Vector3 minXYZ = Vector3.Zero;
            minXYZ.x = Math.Min(boundsA.minXYZ.x, boundsB.minXYZ.x);
            minXYZ.y = Math.Min(boundsA.minXYZ.y, boundsB.minXYZ.y);
            minXYZ.z = Math.Min(boundsA.minXYZ.z, boundsB.minXYZ.z);

            Vector3 maxXYZ = Vector3.Zero;
            maxXYZ.x = Math.Max(boundsA.maxXYZ.x, boundsB.maxXYZ.x);
            maxXYZ.y = Math.Max(boundsA.maxXYZ.y, boundsB.maxXYZ.y);
            maxXYZ.z = Math.Max(boundsA.maxXYZ.z, boundsB.maxXYZ.z);

            return new AxisAlignedBoundingBox(minXYZ, maxXYZ);
        }

        public static AxisAlignedBoundingBox Intersection(AxisAlignedBoundingBox boundsA, AxisAlignedBoundingBox boundsB)
        {
            Vector3 minXYZ = Vector3.Zero;
            minXYZ.x = Math.Max(boundsA.minXYZ.x, boundsB.minXYZ.x);
            minXYZ.y = Math.Max(boundsA.minXYZ.y, boundsB.minXYZ.y);
            minXYZ.z = Math.Max(boundsA.minXYZ.z, boundsB.minXYZ.z);

            Vector3 maxXYZ = Vector3.Zero;
            maxXYZ.x = Math.Max(minXYZ.x, Math.Min(boundsA.maxXYZ.x, boundsB.maxXYZ.x));
            maxXYZ.y = Math.Max(minXYZ.y, Math.Min(boundsA.maxXYZ.y, boundsB.maxXYZ.y));
            maxXYZ.z = Math.Max(minXYZ.z, Math.Min(boundsA.maxXYZ.z, boundsB.maxXYZ.z));

            return new AxisAlignedBoundingBox(minXYZ, maxXYZ);
        }

        public static AxisAlignedBoundingBox Union(AxisAlignedBoundingBox bounds, Vector3 vertex)
        {
            Vector3 minXYZ = Vector3.Zero;
            minXYZ.x = Math.Min(bounds.minXYZ.x, vertex.x);
            minXYZ.y = Math.Min(bounds.minXYZ.y, vertex.y);
            minXYZ.z = Math.Min(bounds.minXYZ.z, vertex.z);

            Vector3 maxXYZ = Vector3.Zero;
            maxXYZ.x = Math.Max(bounds.maxXYZ.x, vertex.x);
            maxXYZ.y = Math.Max(bounds.maxXYZ.y, vertex.y);
            maxXYZ.z = Math.Max(bounds.maxXYZ.z, vertex.z);

            return new AxisAlignedBoundingBox(minXYZ, maxXYZ);
        }

        public void Clamp(ref Vector3 positionToClamp)
        {
            if (positionToClamp.x < minXYZ.x)
            {
                positionToClamp.x = minXYZ.x;
            }
            else if (positionToClamp.x > maxXYZ.x)
            {
                positionToClamp.x = maxXYZ.x;
            }

            if (positionToClamp.y < minXYZ.y)
            {
                positionToClamp.y = minXYZ.y;
            }
            else if (positionToClamp.y > maxXYZ.y)
            {
                positionToClamp.y = maxXYZ.y;
            }

            if (positionToClamp.z < minXYZ.z)
            {
                positionToClamp.z = minXYZ.z;
            }
            else if (positionToClamp.z > maxXYZ.z)
            {
                positionToClamp.z = maxXYZ.z;
            }
        }

        public bool Contains(AxisAlignedBoundingBox bounds)
        {
            if (this.minXYZ.x <= bounds.minXYZ.x
                && this.maxXYZ.x >= bounds.maxXYZ.x
                && this.minXYZ.y <= bounds.minXYZ.y
                && this.maxXYZ.y >= bounds.maxXYZ.y
                && this.minXYZ.z <= bounds.minXYZ.z
                && this.maxXYZ.z >= bounds.maxXYZ.z)
            {
                return true;
            }

            return false;
        }

        public override string ToString()
        {
            return string.Format("min {0} - max {1}", minXYZ, maxXYZ);
        }
    }
}

#endregion //AxisAlignedBoundingBox.cs
#region Bilinear.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Bilinear 2D transformations
//
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg.Transform
{

    //==========================================================trans_bilinear
    public sealed class Bilinear : ITransform
    {
        double[,] m_mtx = new double[4, 2];
        bool m_valid;

        //--------------------------------------------------------------------
        public Bilinear()
        {
            m_valid = (false);
        }

        //--------------------------------------------------------------------
        // Arbitrary quadrangle transformations
        public Bilinear(double[] src, double[] dst)
        {
            quad_to_quad(src, dst);
        }


        //--------------------------------------------------------------------
        // Direct transformations 
        public Bilinear(double x1, double y1, double x2, double y2, double[] quad)
        {
            rect_to_quad(x1, y1, x2, y2, quad);
        }


        //--------------------------------------------------------------------
        // Reverse transformations 
        public Bilinear(double[] quad,
                       double x1, double y1, double x2, double y2)
        {
            quad_to_rect(quad, x1, y1, x2, y2);
        }


        //--------------------------------------------------------------------
        // Set the transformations using two arbitrary quadrangles.
        public void quad_to_quad(double[] src, double[] dst)
        {
            double[,] left = new double[4, 4];
            double[,] right = new double[4, 2];

            uint i;
            for (i = 0; i < 4; i++)
            {
                uint ix = i * 2;
                uint iy = ix + 1;
                left[i, 0] = 1.0;
                left[i, 1] = src[ix] * src[iy];
                left[i, 2] = src[ix];
                left[i, 3] = src[iy];

                right[i, 0] = dst[ix];
                right[i, 1] = dst[iy];
            }
            m_valid = simul_eq.solve(left, right, m_mtx);
        }


        //--------------------------------------------------------------------
        // Set the direct transformations, i.e., rectangle -> quadrangle
        public void rect_to_quad(double x1, double y1, double x2, double y2,
                          double[] quad)
        {
            double[] src = new double[8];
            src[0] = src[6] = x1;
            src[2] = src[4] = x2;
            src[1] = src[3] = y1;
            src[5] = src[7] = y2;
            quad_to_quad(src, quad);
        }


        //--------------------------------------------------------------------
        // Set the reverse transformations, i.e., quadrangle -> rectangle
        public void quad_to_rect(double[] quad,
                          double x1, double y1, double x2, double y2)
        {
            double[] dst = new double[8];
            dst[0] = dst[6] = x1;
            dst[2] = dst[4] = x2;
            dst[1] = dst[3] = y1;
            dst[5] = dst[7] = y2;
            quad_to_quad(quad, dst);
        }

        //--------------------------------------------------------------------
        // Check if the equations were solved successfully
        public bool is_valid() { return m_valid; }

        //--------------------------------------------------------------------
        // Transform a point (x, y)
        public void transform(ref double x, ref double y)
        {
            double tx = x;
            double ty = y;
            double xy = tx * ty;
            x = m_mtx[0, 0] + m_mtx[1, 0] * xy + m_mtx[2, 0] * tx + m_mtx[3, 0] * ty;
            y = m_mtx[0, 1] + m_mtx[1, 1] * xy + m_mtx[2, 1] * tx + m_mtx[3, 1] * ty;
        }


        //--------------------------------------------------------------------
        public sealed class iterator_x
        {
            double inc_x;
            double inc_y;

            public double x;
            public double y;

            public iterator_x() { }
            public iterator_x(double tx, double ty, double step, double[,] m)
            {
                inc_x = (m[1, 0] * step * ty + m[2, 0] * step);
                inc_y = (m[1, 1] * step * ty + m[2, 1] * step);
                x = (m[0, 0] + m[1, 0] * tx * ty + m[2, 0] * tx + m[3, 0] * ty);
                y = (m[0, 1] + m[1, 1] * tx * ty + m[2, 1] * tx + m[3, 1] * ty);
            }

            public static iterator_x operator ++(iterator_x a)
            {
                a.x += a.inc_x;
                a.y += a.inc_y;

                return a;
            }
        };

        public iterator_x begin(double x, double y, double step)
        {
            return new iterator_x(x, y, step, m_mtx);
        }
    };
}

#endregion //Bilinear.cs
#region BorderDouble.cs

//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Text;

namespace MatterHackers.Agg
{
    /// <summary>
    /// BorderDouble is used to represent the border around (Margin) on inside (Padding) of a rectangular area.
    /// </summary>
    public struct BorderDouble
    {
        public double Left, Bottom, Right, Top;

        public BorderDouble(double valueForAll)
            : this(valueForAll, valueForAll, valueForAll, valueForAll)
        {
        }

        public BorderDouble(double leftRight, double bottomTop)
            : this(leftRight, bottomTop, leftRight, bottomTop)
        {
        }

        public BorderDouble(double left = 0, double bottom = 0, double right = 0, double top = 0)
        {
            this.Left = left;
            this.Bottom = bottom;
            this.Right = right;
            this.Top = top;
        }

        public static bool operator ==(BorderDouble a, BorderDouble b)
        {
            if (a.Left == b.Left && a.Bottom == b.Bottom && a.Right == b.Right && a.Top == b.Top)
            {
                return true;
            }

            return false;
        }

        public static bool operator !=(BorderDouble a, BorderDouble b)
        {
            if (a.Left != b.Left || a.Bottom != b.Bottom || a.Right != b.Right || a.Top != b.Top)
            {
                return true;
            }

            return false;
        }

        static public BorderDouble operator *(BorderDouble a, double b)
        {
            return new BorderDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
        }

        static public BorderDouble operator *(double b, BorderDouble a)
        {
            return new BorderDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
        }

        public static BorderDouble operator +(BorderDouble left, BorderDouble right)
        {
            left.Left += right.Left;
            left.Bottom += right.Bottom;
            left.Right += right.Right;
            left.Top += right.Top;
            return left;
        }


        public override int GetHashCode()
        {
            return new { x1 = Left, x2 = Right, y1 = Bottom, y2 = Top }.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() == typeof(BorderDouble))
            {
                return this == (BorderDouble)obj;
            }
            return false;
        }

        public double Width
        {
            get
            {
                return Left + Right;
            }
        }

        // This function assumes the rect is normalized
        public double Height
        {
            get
            {
                return Bottom + Top;
            }
        }

        public override string ToString()
        {
            return string.Format("L:{0}, B:{1}, R:{2}, T:{3}", Left, Bottom, Right, Top);
        }
    }
}

#endregion //BorderDouble.cs
#region ClippingProxy.cs


//----------------------------------------------------------------------------
//
// class ClippingPixelFormtProxy
//
//----------------------------------------------------------------------------
//using System;
//using System.IO;
//using MatterHackers.Agg;

namespace MatterHackers.Agg.Image
{
    public class ImageClippingProxy : ImageProxy
    {
        private RectangleInt m_ClippingRect;

        public const byte cover_full = 255;

        public ImageClippingProxy(IImageByte ren)
            : base(ren)
        {
            m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
        }

        public override void LinkToImage(IImageByte ren)
        {
            base.LinkToImage(ren);
            m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
        }

        public bool SetClippingBox(int x1, int y1, int x2, int y2)
        {
            RectangleInt cb = new RectangleInt(x1, y1, x2, y2);
            cb.normalize();
            if (cb.clip(new RectangleInt(0, 0, (int)Width - 1, (int)Height - 1)))
            {
                m_ClippingRect = cb;
                return true;
            }
            m_ClippingRect.Left = 1;
            m_ClippingRect.Bottom = 1;
            m_ClippingRect.Right = 0;
            m_ClippingRect.Top = 0;
            return false;
        }

        public void reset_clipping(bool visibility)
        {
            if (visibility)
            {
                m_ClippingRect.Left = 0;
                m_ClippingRect.Bottom = 0;
                m_ClippingRect.Right = (int)Width - 1;
                m_ClippingRect.Top = (int)Height - 1;
            }
            else
            {
                m_ClippingRect.Left = 1;
                m_ClippingRect.Bottom = 1;
                m_ClippingRect.Right = 0;
                m_ClippingRect.Top = 0;
            }
        }

        public void clip_box_naked(int x1, int y1, int x2, int y2)
        {
            m_ClippingRect.Left = x1;
            m_ClippingRect.Bottom = y1;
            m_ClippingRect.Right = x2;
            m_ClippingRect.Top = y2;
        }

        public bool inbox(int x, int y)
        {
            return x >= m_ClippingRect.Left && y >= m_ClippingRect.Bottom &&
                   x <= m_ClippingRect.Right && y <= m_ClippingRect.Top;
        }

        public RectangleInt clip_box() { return m_ClippingRect; }
        int xmin() { return m_ClippingRect.Left; }
        int ymin() { return m_ClippingRect.Bottom; }
        int xmax() { return m_ClippingRect.Right; }
        int ymax() { return m_ClippingRect.Top; }

        public RectangleInt bounding_clip_box() { return m_ClippingRect; }
        public int bounding_xmin() { return m_ClippingRect.Left; }
        public int bounding_ymin() { return m_ClippingRect.Bottom; }
        public int bounding_xmax() { return m_ClippingRect.Right; }
        public int bounding_ymax() { return m_ClippingRect.Top; }

        public void clear(IColorType in_c)
        {
            int y;
            RGBA_Bytes c = new RGBA_Bytes(in_c.Red0To255, in_c.Green0To255, in_c.Blue0To255, in_c.Alpha0To255);
            if (Width != 0)
            {
                for (y = 0; y < Height; y++)
                {
                    base.copy_hline(0, (int)y, (int)Width, c);
                }
            }
        }

        public override void copy_pixel(int x, int y, byte[] c, int ByteOffset)
        {
            if (inbox(x, y))
            {
                base.copy_pixel(x, y, c, ByteOffset);
            }
        }

        public override RGBA_Bytes GetPixel(int x, int y)
        {
            return inbox(x, y) ? base.GetPixel(x, y) : new RGBA_Bytes();
        }

        public override void copy_hline(int x1, int y, int x2, RGBA_Bytes c)
        {
            if (x1 > x2) { int t = (int)x2; x2 = (int)x1; x1 = t; }
            if (y > ymax()) return;
            if (y < ymin()) return;
            if (x1 > xmax()) return;
            if (x2 < xmin()) return;

            if (x1 < xmin()) x1 = xmin();
            if (x2 > xmax()) x2 = (int)xmax();

            base.copy_hline(x1, y, (int)(x2 - x1 + 1), c);
        }

        public override void copy_vline(int x, int y1, int y2, RGBA_Bytes c)
        {
            if (y1 > y2) { int t = (int)y2; y2 = (int)y1; y1 = t; }
            if (x > xmax()) return;
            if (x < xmin()) return;
            if (y1 > ymax()) return;
            if (y2 < ymin()) return;

            if (y1 < ymin()) y1 = ymin();
            if (y2 > ymax()) y2 = (int)ymax();

            base.copy_vline(x, y1, (int)(y2 - y1 + 1), c);
        }

        public override void blend_hline(int x1, int y, int x2, RGBA_Bytes c, byte cover)
        {
            if (x1 > x2)
            {
                int t = (int)x2;
                x2 = x1;
                x1 = t;
            }
            if (y > ymax())
                return;
            if (y < ymin())
                return;
            if (x1 > xmax())
                return;
            if (x2 < xmin())
                return;

            if (x1 < xmin())
                x1 = xmin();
            if (x2 > xmax())
                x2 = xmax();

            base.blend_hline(x1, y, x2, c, cover);
        }

        public override void blend_vline(int x, int y1, int y2, RGBA_Bytes c, byte cover)
        {
            if (y1 > y2) { int t = y2; y2 = y1; y1 = t; }
            if (x > xmax()) return;
            if (x < xmin()) return;
            if (y1 > ymax()) return;
            if (y2 < ymin()) return;

            if (y1 < ymin()) y1 = ymin();
            if (y2 > ymax()) y2 = ymax();

            base.blend_vline(x, y1, y2, c, cover);
        }

        public override void blend_solid_hspan(int x, int y, int len, RGBA_Bytes c, byte[] covers, int coversIndex)
        {
#if false
            FileStream file = new FileStream("pixels.txt", FileMode.Append, FileAccess.Write);
            StreamWriter sw = new StreamWriter(file);
            sw.Write("h-x=" + x.ToString() + ",y=" + y.ToString() + ",len=" + len.ToString() + "\n");
            sw.Close();
            file.Close();
#endif

            if (y > ymax()) return;
            if (y < ymin()) return;

            if (x < xmin())
            {
                len -= xmin() - x;
                if (len <= 0) return;
                coversIndex += xmin() - x;
                x = xmin();
            }
            if (x + len > xmax())
            {
                len = xmax() - x + 1;
                if (len <= 0) return;
            }
            base.blend_solid_hspan(x, y, len, c, covers, coversIndex);
        }

        public override void blend_solid_vspan(int x, int y, int len, RGBA_Bytes c, byte[] covers, int coversIndex)
        {
#if false
            FileStream file = new FileStream("pixels.txt", FileMode.Append, FileAccess.Write);
            StreamWriter sw = new StreamWriter(file);
            sw.Write("v-x=" + x.ToString() + ",y=" + y.ToString() + ",len=" + len.ToString() + "\n");
            sw.Close();
            file.Close();
#endif

            if (x > xmax()) return;
            if (x < xmin()) return;

            if (y < ymin())
            {
                len -= (ymin() - y);
                if (len <= 0) return;
                coversIndex += ymin() - y;
                y = ymin();
            }
            if (y + len > ymax())
            {
                len = (ymax() - y + 1);
                if (len <= 0) return;
            }
            base.blend_solid_vspan(x, y, len, c, covers, coversIndex);
        }

        public override void copy_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            if (y > ymax()) return;
            if (y < ymin()) return;

            if (x < xmin())
            {
                int d = xmin() - x;
                len -= d;
                if (len <= 0) return;
                colorsIndex += d;
                x = xmin();
            }
            if (x + len > xmax())
            {
                len = (xmax() - x + 1);
                if (len <= 0) return;
            }
            base.copy_color_hspan(x, y, len, colors, colorsIndex);
        }

        public override void copy_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            if (x > xmax()) return;
            if (x < xmin()) return;

            if (y < ymin())
            {
                int d = ymin() - y;
                len -= d;
                if (len <= 0) return;
                colorsIndex += d;
                y = ymin();
            }
            if (y + len > ymax())
            {
                len = (ymax() - y + 1);
                if (len <= 0) return;
            }
            base.copy_color_vspan(x, y, len, colors, colorsIndex);
        }

        public override void blend_color_hspan(int x, int y, int in_len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            int len = (int)in_len;
            if (y > ymax())
                return;
            if (y < ymin())
                return;

            if (x < xmin())
            {
                int d = xmin() - x;
                len -= d;
                if (len <= 0) return;
                if (covers != null) coversIndex += d;
                colorsIndex += d;
                x = xmin();
            }
            if (x + len - 1 > xmax())
            {
                len = xmax() - x + 1;
                if (len <= 0) return;
            }

            base.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }

        public void copy_from(IImageByte src)
        {
            CopyFrom(src, new RectangleInt(0, 0, (int)src.Width, (int)src.Height), 0, 0);
        }

        public override void SetPixel(int x, int y, RGBA_Bytes color)
        {
            if ((uint)x < Width && (uint)y < Height)
            {
                base.SetPixel(x, y, color);
            }
        }

        public override void CopyFrom(IImageByte sourceImage,
                       RectangleInt sourceImageRect,
                       int destXOffset,
                       int destYOffset)
        {
            RectangleInt destRect = sourceImageRect;
            destRect.Offset(destXOffset, destYOffset);

            RectangleInt clippedSourceRect = new RectangleInt();
            if (clippedSourceRect.IntersectRectangles(destRect, m_ClippingRect))
            {
                // move it back relative to the source
                clippedSourceRect.Offset(-destXOffset, -destYOffset);

                base.CopyFrom(sourceImage, clippedSourceRect, destXOffset, destYOffset);
            }
        }

        public RectangleInt clip_rect_area(ref RectangleInt destRect, ref RectangleInt sourceRect, int sourceWidth, int sourceHeight)
        {
            RectangleInt rc = new RectangleInt(0, 0, 0, 0);
            RectangleInt cb = clip_box();
            ++cb.Right;
            ++cb.Top;

            if (sourceRect.Left < 0)
            {
                destRect.Left -= sourceRect.Left;
                sourceRect.Left = 0;
            }
            if (sourceRect.Bottom < 0)
            {
                destRect.Bottom -= sourceRect.Bottom;
                sourceRect.Bottom = 0;
            }

            if (sourceRect.Right > sourceWidth) sourceRect.Right = sourceWidth;
            if (sourceRect.Top > sourceHeight) sourceRect.Top = sourceHeight;

            if (destRect.Left < cb.Left)
            {
                sourceRect.Left += cb.Left - destRect.Left;
                destRect.Left = cb.Left;
            }
            if (destRect.Bottom < cb.Bottom)
            {
                sourceRect.Bottom += cb.Bottom - destRect.Bottom;
                destRect.Bottom = cb.Bottom;
            }

            if (destRect.Right > cb.Right) destRect.Right = cb.Right;
            if (destRect.Top > cb.Top) destRect.Top = cb.Top;

            rc.Right = destRect.Right - destRect.Left;
            rc.Top = destRect.Top - destRect.Bottom;

            if (rc.Right > sourceRect.Right - sourceRect.Left) rc.Right = sourceRect.Right - sourceRect.Left;
            if (rc.Top > sourceRect.Top - sourceRect.Bottom) rc.Top = sourceRect.Top - sourceRect.Bottom;
            return rc;
        }

        public override void blend_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            if (x > xmax()) return;
            if (x < xmin()) return;

            if (y < ymin())
            {
                int d = ymin() - y;
                len -= d;
                if (len <= 0) return;
                if (covers != null) coversIndex += d;
                colorsIndex += d;
                y = ymin();
            }
            if (y + len > ymax())
            {
                len = (ymax() - y + 1);
                if (len <= 0) return;
            }
            base.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }
    }

    public class ImageClippingProxyFloat : ImageProxyFloat
    {
        private RectangleInt m_ClippingRect;

        public const byte cover_full = 255;

        public ImageClippingProxyFloat(IImageFloat ren)
            : base(ren)
        {
            m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
        }

        public override void LinkToImage(IImageFloat ren)
        {
            base.LinkToImage(ren);
            m_ClippingRect = new RectangleInt(0, 0, (int)ren.Width - 1, (int)ren.Height - 1);
        }

        public bool SetClippingBox(int x1, int y1, int x2, int y2)
        {
            RectangleInt cb = new RectangleInt(x1, y1, x2, y2);
            cb.normalize();
            if (cb.clip(new RectangleInt(0, 0, (int)Width - 1, (int)Height - 1)))
            {
                m_ClippingRect = cb;
                return true;
            }
            m_ClippingRect.Left = 1;
            m_ClippingRect.Bottom = 1;
            m_ClippingRect.Right = 0;
            m_ClippingRect.Top = 0;
            return false;
        }

        public void reset_clipping(bool visibility)
        {
            if (visibility)
            {
                m_ClippingRect.Left = 0;
                m_ClippingRect.Bottom = 0;
                m_ClippingRect.Right = (int)Width - 1;
                m_ClippingRect.Top = (int)Height - 1;
            }
            else
            {
                m_ClippingRect.Left = 1;
                m_ClippingRect.Bottom = 1;
                m_ClippingRect.Right = 0;
                m_ClippingRect.Top = 0;
            }
        }

        public void clip_box_naked(int x1, int y1, int x2, int y2)
        {
            m_ClippingRect.Left = x1;
            m_ClippingRect.Bottom = y1;
            m_ClippingRect.Right = x2;
            m_ClippingRect.Top = y2;
        }

        public bool inbox(int x, int y)
        {
            return x >= m_ClippingRect.Left && y >= m_ClippingRect.Bottom &&
                   x <= m_ClippingRect.Right && y <= m_ClippingRect.Top;
        }

        public RectangleInt clip_box() { return m_ClippingRect; }
        int xmin() { return m_ClippingRect.Left; }
        int ymin() { return m_ClippingRect.Bottom; }
        int xmax() { return m_ClippingRect.Right; }
        int ymax() { return m_ClippingRect.Top; }

        public RectangleInt bounding_clip_box() { return m_ClippingRect; }
        public int bounding_xmin() { return m_ClippingRect.Left; }
        public int bounding_ymin() { return m_ClippingRect.Bottom; }
        public int bounding_xmax() { return m_ClippingRect.Right; }
        public int bounding_ymax() { return m_ClippingRect.Top; }

        public void clear(IColorType in_c)
        {
            int y;
            RGBA_Floats colorFloat = in_c.GetAsRGBA_Floats();
            if (Width != 0)
            {
                for (y = 0; y < Height; y++)
                {
                    base.copy_hline(0, (int)y, (int)Width, colorFloat);
                }
            }
        }

        public override void copy_pixel(int x, int y, float[] c, int ByteOffset)
        {
            if (inbox(x, y))
            {
                base.copy_pixel(x, y, c, ByteOffset);
            }
        }

        public override RGBA_Floats GetPixel(int x, int y)
        {
            return inbox(x, y) ? base.GetPixel(x, y) : new RGBA_Floats();
        }

        public override void copy_hline(int x1, int y, int x2, RGBA_Floats c)
        {
            if (x1 > x2) { int t = (int)x2; x2 = (int)x1; x1 = t; }
            if (y > ymax()) return;
            if (y < ymin()) return;
            if (x1 > xmax()) return;
            if (x2 < xmin()) return;

            if (x1 < xmin()) x1 = xmin();
            if (x2 > xmax()) x2 = (int)xmax();

            base.copy_hline(x1, y, (int)(x2 - x1 + 1), c);
        }

        public override void copy_vline(int x, int y1, int y2, RGBA_Floats c)
        {
            if (y1 > y2) { int t = (int)y2; y2 = (int)y1; y1 = t; }
            if (x > xmax()) return;
            if (x < xmin()) return;
            if (y1 > ymax()) return;
            if (y2 < ymin()) return;

            if (y1 < ymin()) y1 = ymin();
            if (y2 > ymax()) y2 = (int)ymax();

            base.copy_vline(x, y1, (int)(y2 - y1 + 1), c);
        }

        public override void blend_hline(int x1, int y, int x2, RGBA_Floats c, byte cover)
        {
            if (x1 > x2)
            {
                int t = (int)x2;
                x2 = x1;
                x1 = t;
            }
            if (y > ymax())
                return;
            if (y < ymin())
                return;
            if (x1 > xmax())
                return;
            if (x2 < xmin())
                return;

            if (x1 < xmin())
                x1 = xmin();
            if (x2 > xmax())
                x2 = xmax();

            base.blend_hline(x1, y, x2, c, cover);
        }

        public override void blend_vline(int x, int y1, int y2, RGBA_Floats c, byte cover)
        {
            if (y1 > y2) { int t = y2; y2 = y1; y1 = t; }
            if (x > xmax()) return;
            if (x < xmin()) return;
            if (y1 > ymax()) return;
            if (y2 < ymin()) return;

            if (y1 < ymin()) y1 = ymin();
            if (y2 > ymax()) y2 = ymax();

            base.blend_vline(x, y1, y2, c, cover);
        }

        public override void blend_solid_hspan(int x, int y, int in_len, RGBA_Floats c, byte[] covers, int coversIndex)
        {
            int len = (int)in_len;
            if (y > ymax()) return;
            if (y < ymin()) return;

            if (x < xmin())
            {
                len -= xmin() - x;
                if (len <= 0) return;
                coversIndex += xmin() - x;
                x = xmin();
            }
            if (x + len > xmax())
            {
                len = xmax() - x + 1;
                if (len <= 0) return;
            }
            base.blend_solid_hspan(x, y, len, c, covers, coversIndex);
        }

        public override void blend_solid_vspan(int x, int y, int len, RGBA_Floats c, byte[] covers, int coversIndex)
        {
            if (x > xmax()) return;
            if (x < xmin()) return;

            if (y < ymin())
            {
                len -= (ymin() - y);
                if (len <= 0) return;
                coversIndex += ymin() - y;
                y = ymin();
            }
            if (y + len > ymax())
            {
                len = (ymax() - y + 1);
                if (len <= 0) return;
            }
            base.blend_solid_vspan(x, y, len, c, covers, coversIndex);
        }

        public override void copy_color_hspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex)
        {
            if (y > ymax()) return;
            if (y < ymin()) return;

            if (x < xmin())
            {
                int d = xmin() - x;
                len -= d;
                if (len <= 0) return;
                colorsIndex += d;
                x = xmin();
            }
            if (x + len > xmax())
            {
                len = (xmax() - x + 1);
                if (len <= 0) return;
            }
            base.copy_color_hspan(x, y, len, colors, colorsIndex);
        }

        public override void copy_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex)
        {
            if (x > xmax()) return;
            if (x < xmin()) return;

            if (y < ymin())
            {
                int d = ymin() - y;
                len -= d;
                if (len <= 0) return;
                colorsIndex += d;
                y = ymin();
            }
            if (y + len > ymax())
            {
                len = (ymax() - y + 1);
                if (len <= 0) return;
            }
            base.copy_color_vspan(x, y, len, colors, colorsIndex);
        }

        public override void blend_color_hspan(int x, int y, int in_len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            int len = (int)in_len;
            if (y > ymax())
                return;
            if (y < ymin())
                return;

            if (x < xmin())
            {
                int d = xmin() - x;
                len -= d;
                if (len <= 0) return;
                if (covers != null) coversIndex += d;
                colorsIndex += d;
                x = xmin();
            }
            if (x + len - 1 > xmax())
            {
                len = xmax() - x + 1;
                if (len <= 0) return;
            }

            base.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }

        public void copy_from(IImageFloat src)
        {
            CopyFrom(src, new RectangleInt(0, 0, (int)src.Width, (int)src.Height), 0, 0);
        }

        public override void SetPixel(int x, int y, RGBA_Floats color)
        {
            if ((uint)x < Width && (uint)y < Height)
            {
                base.SetPixel(x, y, color);
            }
        }

        public override void CopyFrom(IImageFloat sourceImage,
                       RectangleInt sourceImageRect,
                       int destXOffset,
                       int destYOffset)
        {
            RectangleInt destRect = sourceImageRect;
            destRect.Offset(destXOffset, destYOffset);

            RectangleInt clippedSourceRect = new RectangleInt();
            if (clippedSourceRect.IntersectRectangles(destRect, m_ClippingRect))
            {
                // move it back relative to the source
                clippedSourceRect.Offset(-destXOffset, -destYOffset);

                base.CopyFrom(sourceImage, clippedSourceRect, destXOffset, destYOffset);
            }
        }

        public RectangleInt clip_rect_area(ref RectangleInt destRect, ref RectangleInt sourceRect, int sourceWidth, int sourceHeight)
        {
            RectangleInt rc = new RectangleInt(0, 0, 0, 0);
            RectangleInt cb = clip_box();
            ++cb.Right;
            ++cb.Top;

            if (sourceRect.Left < 0)
            {
                destRect.Left -= sourceRect.Left;
                sourceRect.Left = 0;
            }
            if (sourceRect.Bottom < 0)
            {
                destRect.Bottom -= sourceRect.Bottom;
                sourceRect.Bottom = 0;
            }

            if (sourceRect.Right > sourceWidth) sourceRect.Right = sourceWidth;
            if (sourceRect.Top > sourceHeight) sourceRect.Top = sourceHeight;

            if (destRect.Left < cb.Left)
            {
                sourceRect.Left += cb.Left - destRect.Left;
                destRect.Left = cb.Left;
            }
            if (destRect.Bottom < cb.Bottom)
            {
                sourceRect.Bottom += cb.Bottom - destRect.Bottom;
                destRect.Bottom = cb.Bottom;
            }

            if (destRect.Right > cb.Right) destRect.Right = cb.Right;
            if (destRect.Top > cb.Top) destRect.Top = cb.Top;

            rc.Right = destRect.Right - destRect.Left;
            rc.Top = destRect.Top - destRect.Bottom;

            if (rc.Right > sourceRect.Right - sourceRect.Left) rc.Right = sourceRect.Right - sourceRect.Left;
            if (rc.Top > sourceRect.Top - sourceRect.Bottom) rc.Top = sourceRect.Top - sourceRect.Bottom;
            return rc;
        }

        public override void blend_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            if (x > xmax()) return;
            if (x < xmin()) return;

            if (y < ymin())
            {
                int d = ymin() - y;
                len -= d;
                if (len <= 0) return;
                if (covers != null) coversIndex += d;
                colorsIndex += d;
                y = ymin();
            }
            if (y + len > ymax())
            {
                len = (ymax() - y + 1);
                if (len <= 0) return;
            }
            base.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }
    }
}

#endregion //ClippingProxy.cs
#region Contour.cs


//----------------------------------------------------------------------------
//
// conv_stroke
//
//----------------------------------------------------------------------------
namespace MatterHackers.Agg.VertexSource
{
    public sealed class Contour : VertexSourceAdapter
    {
        public Contour(IVertexSource vertexSource) :
            base(vertexSource, new ContourGenerator())
        {
        }

        public void line_join(LineJoin lj) { base.GetGenerator().line_join(lj); }
        public void inner_join(InnerJoin ij) { base.GetGenerator().inner_join(ij); }
        public void width(double w) { base.GetGenerator().width(w); }
        public void miter_limit(double ml) { base.GetGenerator().miter_limit(ml); }
        public void miter_limit_theta(double t) { base.GetGenerator().miter_limit_theta(t); }
        public void inner_miter_limit(double ml) { base.GetGenerator().inner_miter_limit(ml); }
        public void approximation_scale(double approxScale) { base.GetGenerator().approximation_scale(approxScale); }
        public void auto_detect_orientation(bool v) { base.GetGenerator().auto_detect_orientation(v); }

        public LineJoin line_join() { return base.GetGenerator().line_join(); }
        public InnerJoin inner_join() { return base.GetGenerator().inner_join(); }
        public double width() { return base.GetGenerator().width(); }
        public double miter_limit() { return base.GetGenerator().miter_limit(); }
        public double inner_miter_limit() { return base.GetGenerator().inner_miter_limit(); }
        public double approximation_scale() { return base.GetGenerator().approximation_scale(); }
        public bool auto_detect_orientation() { return base.GetGenerator().auto_detect_orientation(); }
    }
}

#endregion //Contour.cs
#region ContourGenerator.cs

//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Text;

//using MatterHackers.VectorMath;

namespace MatterHackers.Agg.VertexSource
{
    class ContourGenerator : IGenerator
    {
        StrokeMath m_stroker;
        double m_width;
        VertexSequence m_src_vertices;
        Vector2Container m_out_vertices;
        StrokeMath.status_e m_status;
        int m_src_vertex;
        int m_out_vertex;
        bool m_closed;
        ShapePath.FlagsAndCommand m_orientation;
        bool m_auto_detect;
        double m_shorten;

        public ContourGenerator()
        {
            m_stroker = new StrokeMath();
            m_width = 1;
            m_src_vertices = new VertexSequence();
            m_out_vertices = new Vector2Container();
            m_status = StrokeMath.status_e.initial;
            m_src_vertex = 0;
            m_closed = false;
            m_orientation = 0;
            m_auto_detect = false;
        }

        public void line_cap(LineCap lc) { m_stroker.line_cap(lc); }
        public void line_join(LineJoin lj) { m_stroker.line_join(lj); }
        public void inner_join(InnerJoin ij) { m_stroker.inner_join(ij); }

        public LineCap line_cap() { return m_stroker.line_cap(); }
        public LineJoin line_join() { return m_stroker.line_join(); }
        public InnerJoin inner_join() { return m_stroker.inner_join(); }

        public void width(double w) { m_stroker.width(w); }
        public void miter_limit(double ml) { m_stroker.miter_limit(ml); }
        public void miter_limit_theta(double t) { m_stroker.miter_limit_theta(t); }
        public void inner_miter_limit(double ml) { m_stroker.inner_miter_limit(ml); }
        public void approximation_scale(double approx_scale) { m_stroker.approximation_scale(approx_scale); }

        public double width() { return m_stroker.width(); }
        public double miter_limit() { return m_stroker.miter_limit(); }
        public double inner_miter_limit() { return m_stroker.inner_miter_limit(); }
        public double approximation_scale() { return m_stroker.approximation_scale(); }

        public void shorten(double s) { m_shorten = s; }
        public double shorten() { return m_shorten; }

        public void auto_detect_orientation(bool v) { m_auto_detect = v; }
        public bool auto_detect_orientation() { return m_auto_detect; }

        // Generator interface
        public void RemoveAll()
        {
            m_src_vertices.remove_all();
            m_closed = false;
            m_status = StrokeMath.status_e.initial;
        }

        public void AddVertex(double x, double y, ShapePath.FlagsAndCommand cmd)
        {
            m_status = StrokeMath.status_e.initial;
            if (ShapePath.is_move_to(cmd))
            {
                m_src_vertices.modify_last(new VertexDistance(x, y));
            }
            else
            {
                if (ShapePath.is_vertex(cmd))
                {
                    m_src_vertices.add(new VertexDistance(x, y));
                }
                else
                {
                    if (ShapePath.is_end_poly(cmd))
                    {
                        m_closed = (ShapePath.get_close_flag(cmd) == ShapePath.FlagsAndCommand.FlagClose);
                        if (m_orientation == ShapePath.FlagsAndCommand.FlagNone)
                        {
                            m_orientation = ShapePath.get_orientation(cmd);
                        }
                    }
                }
            }
        }

        // Vertex Source Interface
        public void Rewind(int idx)
        {
            if (m_status == StrokeMath.status_e.initial)
            {
                m_src_vertices.close(true);
                if (m_auto_detect)
                {
                    if (!ShapePath.is_oriented(m_orientation))
                    {
                        m_orientation = (agg_math.calc_polygon_area(m_src_vertices) > 0.0) ?
                                        ShapePath.FlagsAndCommand.FlagCCW :
                                        ShapePath.FlagsAndCommand.FlagCW;
                    }
                }
                if (ShapePath.is_oriented(m_orientation))
                {
                    m_stroker.width(ShapePath.is_ccw(m_orientation) ? m_width : -m_width);
                }
            }
            m_status = StrokeMath.status_e.ready;
            m_src_vertex = 0;
        }

        public ShapePath.FlagsAndCommand Vertex(ref double x, ref double y)
        {
            ShapePath.FlagsAndCommand cmd = ShapePath.FlagsAndCommand.CommandLineTo;
            while (!ShapePath.is_stop(cmd))
            {
                switch (m_status)
                {
                    case StrokeMath.status_e.initial:
                        Rewind(0);
                        goto case StrokeMath.status_e.ready;

                    case StrokeMath.status_e.ready:
                        if (m_src_vertices.size() < 2 + (m_closed ? 1 : 0))
                        {
                            cmd = ShapePath.FlagsAndCommand.CommandStop;
                            break;
                        }
                        m_status = StrokeMath.status_e.outline1;
                        cmd = ShapePath.FlagsAndCommand.CommandMoveTo;
                        m_src_vertex = 0;
                        m_out_vertex = 0;
                        goto case StrokeMath.status_e.outline1;

                    case StrokeMath.status_e.outline1:
                        if (m_src_vertex >= m_src_vertices.size())
                        {
                            m_status = StrokeMath.status_e.end_poly1;
                            break;
                        }
                        m_stroker.calc_join(m_out_vertices,
                                            m_src_vertices.prev(m_src_vertex),
                                            m_src_vertices.curr(m_src_vertex),
                                            m_src_vertices.next(m_src_vertex),
                                            m_src_vertices.prev(m_src_vertex).dist,
                                            m_src_vertices.curr(m_src_vertex).dist);
                        ++m_src_vertex;
                        m_status = StrokeMath.status_e.out_vertices;
                        m_out_vertex = 0;
                        goto case StrokeMath.status_e.out_vertices;

                    case StrokeMath.status_e.out_vertices:
                        if (m_out_vertex >= m_out_vertices.size())
                        {
                            m_status = StrokeMath.status_e.outline1;
                        }
                        else
                        {
                            Vector2 c = m_out_vertices[m_out_vertex++];
                            x = c.x;
                            y = c.y;
                            return cmd;
                        }
                        break;

                    case StrokeMath.status_e.end_poly1:
                        if (!m_closed) return ShapePath.FlagsAndCommand.CommandStop;
                        m_status = StrokeMath.status_e.stop;
                        return ShapePath.FlagsAndCommand.CommandEndPoly | ShapePath.FlagsAndCommand.FlagClose | ShapePath.FlagsAndCommand.FlagCCW;

                    case StrokeMath.status_e.stop:
                        return ShapePath.FlagsAndCommand.CommandStop;
                }
            }
            return cmd;
        }
    }
}

#endregion //ContourGenerator.cs
#region Ellipse.cs


//----------------------------------------------------------------------------
//
// class ellipse
//
//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;
//using FlagsAndCommand = MatterHackers.Agg.ShapePath.FlagsAndCommand;

//using MatterHackers.VectorMath;

namespace MatterHackers.Agg.VertexSource
{
    public class Ellipse : IVertexSource
    {
        public double originX;
        public double originY;
        public double radiusX;
        public double radiusY;
        private double m_scale;
        private int numSteps;
        private int m_step;
        private bool m_cw;

        public Ellipse()
        {
            originX = 0.0;
            originY = 0.0;
            radiusX = 1.0;
            radiusY = 1.0;
            m_scale = 1.0;
            numSteps = 4;
            m_step = 0;
            m_cw = false;
        }

        public Ellipse(Vector2 origin, double Radius)
            : this(origin.x, origin.y, Radius, Radius, 0, false)
        {
        }

        public Ellipse(Vector2 origin, double RadiusX, double RadiusY, int num_steps = 0, bool cw = false)
            : this(origin.x, origin.y, RadiusX, RadiusY, num_steps, cw)
        {
        }

        public Ellipse(double OriginX, double OriginY, double RadiusX, double RadiusY, int num_steps = 0, bool cw = false)
        {
            this.originX = OriginX;
            this.originY = OriginY;
            this.radiusX = RadiusX;
            this.radiusY = RadiusY;
            m_scale = 1;
            numSteps = num_steps;
            m_step = 0;
            m_cw = cw;
            if (numSteps == 0)
            {
                calc_num_steps();
            }
        }

        public void init(double OriginX, double OriginY, double RadiusX, double RadiusY)
        {
            init(OriginX, OriginY, RadiusX, RadiusY, 0, false);
        }

        public void init(double OriginX, double OriginY, double RadiusX, double RadiusY, int num_steps)
        {
            init(OriginX, OriginY, RadiusX, RadiusY, num_steps, false);
        }

        public void init(double OriginX, double OriginY, double RadiusX, double RadiusY,
                  int num_steps, bool cw)
        {
            originX = OriginX;
            originY = OriginY;
            radiusX = RadiusX;
            radiusY = RadiusY;
            numSteps = num_steps;
            m_step = 0;
            m_cw = cw;
            if (numSteps == 0)
            {
                calc_num_steps();
            }
        }

        public void approximation_scale(double scale)
        {
            m_scale = scale;
            calc_num_steps();
        }

        public IEnumerable<VertexData> Vertices()
        {
            VertexData vertexData = new VertexData();
            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandMoveTo;
            vertexData.position.x = originX + radiusX;
            vertexData.position.y = originY;
            yield return vertexData;

            double anglePerStep = MathHelper.Tau / (double)numSteps;
            double angle = 0;
            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandLineTo;
            for (int i = 1; i < numSteps; i++)
            {
                angle += anglePerStep;

                if (m_cw)
                {
                    vertexData.position.x = originX + Math.Cos(MathHelper.Tau - angle) * radiusX;
                    vertexData.position.y = originY + Math.Sin(MathHelper.Tau - angle) * radiusY;
                    yield return vertexData;
                }
                else
                {
                    vertexData.position.x = originX + Math.Cos(angle) * radiusX;
                    vertexData.position.y = originY + Math.Sin(angle) * radiusY;
                    yield return vertexData;
                }
            }

            vertexData.position = new Vector2();
            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandEndPoly | MatterHackers.Agg.ShapePath.FlagsAndCommand.FlagClose | MatterHackers.Agg.ShapePath.FlagsAndCommand.FlagCCW;
            yield return vertexData;
            vertexData.command = MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandStop;
            yield return vertexData;
        }

        public void rewind(int path_id)
        {
            m_step = 0;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = 0;
            y = 0;
            if (m_step == numSteps)
            {
                ++m_step;
                return MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandEndPoly | MatterHackers.Agg.ShapePath.FlagsAndCommand.FlagClose | MatterHackers.Agg.ShapePath.FlagsAndCommand.FlagCCW;
            }

            if (m_step > numSteps)
            {
                return MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandStop;
            }

            double angle = (double)(m_step) / (double)(numSteps) * 2.0 * Math.PI;
            if (m_cw)
            {
                angle = 2.0 * Math.PI - angle;
            }

            x = originX + Math.Cos(angle) * radiusX;
            y = originY + Math.Sin(angle) * radiusY;
            m_step++;
            return ((m_step == 1) ? MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandMoveTo : MatterHackers.Agg.ShapePath.FlagsAndCommand.CommandLineTo);
        }

        private void calc_num_steps()
        {
            double ra = (Math.Abs(radiusX) + Math.Abs(radiusY)) / 2;
            double da = Math.Acos(ra / (ra + 0.125 / m_scale)) * 2;
            numSteps = (int)Math.Round(2 * Math.PI / da);
        }
    };
}

#endregion //Ellipse.cs
#region FlattenCurve.cs


//----------------------------------------------------------------------------
//
// classes conv_curve
//
//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;

namespace MatterHackers.Agg.VertexSource
{
    //---------------------------------------------------------------conv_curve
    // Curve converter class. Any path storage can have Bezier curves defined 
    // by their control points. There're two types of curves supported: curve3 
    // and curve4. Curve3 is a conic Bezier curve with 2 endpoints and 1 control
    // point. Curve4 has 2 control points (4 points in total) and can be used
    // to interpolate more complicated curves. Curve4, unlike curve3 can be used 
    // to approximate arcs, both circular and elliptical. Curves are approximated 
    // with straight lines and one of the approaches is just to store the whole 
    // sequence of vertices that approximate our curve. It takes additional 
    // memory, and at the same time the consecutive vertices can be calculated 
    // on demand. 
    //
    // Initially, path storages are not suppose to keep all the vertices of the
    // curves (although, nothing prevents us from doing so). Instead, path_storage
    // keeps only vertices, needed to calculate a curve on demand. Those vertices
    // are marked with special commands. So, if the path_storage contains curves 
    // (which are not real curves yet), and we render this storage directly, 
    // all we will see is only 2 or 3 straight line segments (for curve3 and 
    // curve4 respectively). If we need to see real curves drawn we need to 
    // include this class into the conversion pipeline. 
    //
    // Class conv_curve recognizes commands path_cmd_curve3 and path_cmd_curve4 
    // and converts these vertices into a move_to/line_to sequence. 
    //-----------------------------------------------------------------------
    public class FlattenCurves : IVertexSourceProxy
    {
        double lastX;
        double lastY;
        Curve3 m_curve3;
        Curve4 m_curve4;

        public IVertexSource VertexSource
        {
            get;
            set;
        }

        public FlattenCurves(IVertexSource vertexSource)
        {
            m_curve3 = new Curve3();
            m_curve4 = new Curve4();
            VertexSource = vertexSource;
            lastX = (0.0);
            lastY = (0.0);
        }

        public double ApproximationScale
        {
            get
            {
                return m_curve4.approximation_scale();
            }

            set
            {
                m_curve3.approximation_scale(value);
                m_curve4.approximation_scale(value);
            }
        }

        public void SetVertexSource(IVertexSource vertexSource) { VertexSource = vertexSource; }

        public Curves.CurveApproximationMethod ApproximationMethod
        {
            set
            {
                m_curve3.approximation_method(value);
                m_curve4.approximation_method(value);
            }

            get
            {
                return m_curve4.approximation_method();
            }
        }

        public double AngleTolerance
        {
            set
            {
                m_curve3.angle_tolerance(value);
                m_curve4.angle_tolerance(value);
            }

            get
            {
                return m_curve4.angle_tolerance();
            }
        }

        public double CuspLimit
        {
            set
            {
                m_curve3.cusp_limit(value);
                m_curve4.cusp_limit(value);
            }

            get
            {
                return m_curve4.cusp_limit();
            }
        }

        public IEnumerable<VertexData> Vertices()
        {
            VertexData lastPosition = new VertexData();

            IEnumerator<VertexData> vertexDataEnumerator = VertexSource.Vertices().GetEnumerator();
            while (vertexDataEnumerator.MoveNext())
            {
                VertexData vertexData = vertexDataEnumerator.Current;
                switch (vertexData.command)
                {
                    case ShapePath.FlagsAndCommand.CommandCurve3:
                        {
                            vertexDataEnumerator.MoveNext();
                            VertexData vertexDataEnd = vertexDataEnumerator.Current;
                            m_curve3.init(lastPosition.position.x, lastPosition.position.y, vertexData.position.x, vertexData.position.y, vertexDataEnd.position.x, vertexDataEnd.position.y);
                            IEnumerator<VertexData> curveIterator = m_curve3.Vertices().GetEnumerator();
                            curveIterator.MoveNext(); // First call returns path_cmd_move_to
                            do
                            {
                                curveIterator.MoveNext();
                                if (ShapePath.is_stop(curveIterator.Current.command))
                                {
                                    break;
                                }
                                vertexData = new VertexData(ShapePath.FlagsAndCommand.CommandLineTo, curveIterator.Current.position);
                                yield return vertexData;
                                lastPosition = vertexData;
                            } while (!ShapePath.is_stop(curveIterator.Current.command));
                        }
                        break;

                    case ShapePath.FlagsAndCommand.CommandCurve4:
                        {
                            vertexDataEnumerator.MoveNext();
                            VertexData vertexDataControl = vertexDataEnumerator.Current;
                            vertexDataEnumerator.MoveNext();
                            VertexData vertexDataEnd = vertexDataEnumerator.Current;
                            m_curve4.init(lastPosition.position.x, lastPosition.position.y, vertexData.position.x, vertexData.position.y, vertexDataControl.position.x, vertexDataControl.position.y, vertexDataEnd.position.x, vertexDataEnd.position.y);
                            IEnumerator<VertexData> curveIterator = m_curve4.Vertices().GetEnumerator();
                            curveIterator.MoveNext(); // First call returns path_cmd_move_to
                            while (!ShapePath.is_stop(vertexData.command))
                            {
                                curveIterator.MoveNext();
                                if (ShapePath.is_stop(curveIterator.Current.command))
                                {
                                    break;
                                }
                                vertexData = new VertexData(ShapePath.FlagsAndCommand.CommandLineTo, curveIterator.Current.position);
                                yield return vertexData;
                                lastPosition = vertexData;
                            }
                        }
                        break;

                    default:
                        yield return vertexData;
                        lastPosition = vertexData;
                        break;
                }
            }
        }

        public void rewind(int path_id)
        {
            VertexSource.rewind(path_id);
            lastX = 0.0;
            lastY = 0.0;
            m_curve3.reset();
            m_curve4.reset();
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (!ShapePath.is_stop(m_curve3.vertex(out x, out y)))
            {
                lastX = x;
                lastY = y;
                return ShapePath.FlagsAndCommand.CommandLineTo;
            }

            if (!ShapePath.is_stop(m_curve4.vertex(out x, out y)))
            {
                lastX = x;
                lastY = y;
                return ShapePath.FlagsAndCommand.CommandLineTo;
            }

            double ct2_x;
            double ct2_y;
            double end_x;
            double end_y;

            ShapePath.FlagsAndCommand cmd = VertexSource.vertex(out x, out y);
            switch (cmd)
            {
                case ShapePath.FlagsAndCommand.CommandCurve3:
                    VertexSource.vertex(out end_x, out end_y);

                    m_curve3.init(lastX, lastY, x, y, end_x, end_y);

                    m_curve3.vertex(out x, out y);    // First call returns path_cmd_move_to
                    m_curve3.vertex(out x, out y);    // This is the first vertex of the curve
                    cmd = ShapePath.FlagsAndCommand.CommandLineTo;
                    break;

                case ShapePath.FlagsAndCommand.CommandCurve4:
                    VertexSource.vertex(out ct2_x, out ct2_y);
                    VertexSource.vertex(out end_x, out end_y);

                    m_curve4.init(lastX, lastY, x, y, ct2_x, ct2_y, end_x, end_y);

                    m_curve4.vertex(out x, out y);    // First call returns path_cmd_move_to
                    m_curve4.vertex(out x, out y);    // This is the first vertex of the curve
                    cmd = ShapePath.FlagsAndCommand.CommandLineTo;
                    break;
            }
            lastX = x;
            lastY = y;
            return cmd;
        }
    }
}

#endregion //FlattenCurve.cs
#region FloodFiller.cs

//using System;
//using System.Collections.Generic;
//using System.Text;
//using System.Runtime.InteropServices;

//using MatterHackers.Agg.Image;

namespace MatterHackers.Agg
{
    public class FloodFill
    {
        public abstract class FillingRule
        {
            protected RGBA_Bytes startColor;
            protected RGBA_Bytes fillColor;

            protected FillingRule(RGBA_Bytes fillColor)
            {
                this.fillColor = fillColor;
            }

            public void SetStartColor(RGBA_Bytes startColor)
            {
                this.startColor = startColor;
            }

            public virtual void SetPixel(byte[] destBuffer, int bufferOffset)
            {
                destBuffer[bufferOffset] = fillColor.blue;
                destBuffer[bufferOffset + 1] = fillColor.green;
                destBuffer[bufferOffset + 2] = fillColor.red;
            }

            public abstract bool CheckPixel(byte[] destBuffer, int bufferOffset);
        }

        public class ExactMatch : FillingRule
        {
            public ExactMatch(RGBA_Bytes fillColor)
                : base(fillColor)
            {
            }

            public override bool CheckPixel(byte[] destBuffer, int bufferOffset)
            {
                return (destBuffer[bufferOffset] == startColor.red) &&
                    (destBuffer[bufferOffset + 1] == startColor.green) &&
                    (destBuffer[bufferOffset + 2] == startColor.blue);
            }
        }

        public class ToleranceMatch : FillingRule
        {
            int tolerance0To255;

            public ToleranceMatch(RGBA_Bytes fillColor, int tolerance0To255)
                : base(fillColor)
            {
                this.tolerance0To255 = tolerance0To255;
            }

            public override bool CheckPixel(byte[] destBuffer, int bufferOffset)
            {
                return (destBuffer[bufferOffset] >= (startColor.red - tolerance0To255)) && destBuffer[bufferOffset] <= (startColor.red + tolerance0To255) &&
                    (destBuffer[bufferOffset + 1] >= (startColor.green - tolerance0To255)) && destBuffer[bufferOffset + 1] <= (startColor.green + tolerance0To255) &&
                    (destBuffer[bufferOffset + 2] >= (startColor.blue - tolerance0To255)) && destBuffer[bufferOffset + 2] <= (startColor.blue + tolerance0To255);
            }
        }

        struct Range
        {
            public int startX;
            public int endX;
            public int y;

            public Range(int startX, int endX, int y)
            {
                this.startX = startX;
                this.endX = endX;
                this.y = y;
            }
        }

        ImageBuffer destImage;
        protected int imageStride = 0;
        protected byte[] destBuffer = null;

        protected bool[] pixelsChecked;
        FillingRule fillRule;

        FirstInFirstOutQueue<Range> ranges = new FirstInFirstOutQueue<Range>(9);

        public FloodFill(RGBA_Bytes fillColor)
        {
            fillRule = new ExactMatch(fillColor);
        }

        public FloodFill(RGBA_Bytes fillColor, int tolerance0To255)
        {
            if (tolerance0To255 > 0)
            {
                fillRule = new ToleranceMatch(fillColor, tolerance0To255);
            }
            else
            {
                fillRule = new ExactMatch(fillColor);
            }
        }

        public FloodFill(FillingRule fillRule)
        {
            this.fillRule = fillRule;
        }

        public void Fill(ImageBuffer bufferToFillOn, int x, int y)
        {
            unchecked // this way we can overflow the uint on negative and get a big number
            {
                if ((uint)x > bufferToFillOn.Width || (uint)y > bufferToFillOn.Height)
                {
                    return;
                }
            }

            destImage = bufferToFillOn;
            imageStride = destImage.StrideInBytes();
            destBuffer = destImage.GetBuffer();
            int imageWidth = destImage.Width;
            int imageHeight = destImage.Height;

            pixelsChecked = new bool[destImage.Width * destImage.Height];

            int startColorBufferOffset = destImage.GetBufferOffsetXY(x, y);

            fillRule.SetStartColor(new RGBA_Bytes(destImage.GetBuffer()[startColorBufferOffset + 2], destImage.GetBuffer()[startColorBufferOffset + 1], destImage.GetBuffer()[startColorBufferOffset]));

            LinearFill(x, y);

            while (ranges.Count > 0)
            {
                Range range = ranges.Dequeue();

                int downY = range.y - 1;
                int upY = range.y + 1;
                int downPixelOffset = (imageWidth * (range.y - 1)) + range.startX;
                int upPixelOffset = (imageWidth * (range.y + 1)) + range.startX;
                for (int rangeX = range.startX; rangeX <= range.endX; rangeX++)
                {
                    if (range.y > 0)
                    {
                        if (!pixelsChecked[downPixelOffset])
                        {
                            int bufferOffset = destImage.GetBufferOffsetXY(rangeX, downY);
                            if (fillRule.CheckPixel(destBuffer, bufferOffset))
                            {
                                LinearFill(rangeX, downY);
                            }
                        }
                    }

                    if (range.y < (imageHeight - 1))
                    {
                        if (!pixelsChecked[upPixelOffset])
                        {
                            int bufferOffset = destImage.GetBufferOffsetXY(rangeX, upY);
                            if (fillRule.CheckPixel(destBuffer, bufferOffset))
                            {
                                LinearFill(rangeX, upY);
                            }
                        }
                    }
                    upPixelOffset++;
                    downPixelOffset++;
                }
            }
        }

        void LinearFill(int x, int y)
        {
            int bytesPerPixel = destImage.GetBytesBetweenPixelsInclusive();
            int imageWidth = destImage.Width;

            int leftFillX = x;
            int bufferOffset = destImage.GetBufferOffsetXY(x, y);
            int pixelOffset = (imageWidth * y) + x;
            while (true)
            {
                fillRule.SetPixel(destBuffer, bufferOffset);
                pixelsChecked[pixelOffset] = true;
                leftFillX--;
                pixelOffset--;
                bufferOffset -= bytesPerPixel;
                if (leftFillX <= 0 || (pixelsChecked[pixelOffset]) || !fillRule.CheckPixel(destBuffer, bufferOffset))
                {
                    break;
                }
            }
            leftFillX++;

            int rightFillX = x;
            bufferOffset = destImage.GetBufferOffsetXY(x, y);
            pixelOffset = (imageWidth * y) + x;
            while (true)
            {
                fillRule.SetPixel(destBuffer, bufferOffset);
                pixelsChecked[pixelOffset] = true;
                rightFillX++;
                pixelOffset++;
                bufferOffset += bytesPerPixel;
                if (rightFillX >= imageWidth || pixelsChecked[pixelOffset] || !fillRule.CheckPixel(destBuffer, bufferOffset))
                {
                    break;
                }
            }
            rightFillX--;

            ranges.Enqueue(new Range(leftFillX, rightFillX, y));
        }
    }
}

#endregion //FloodFiller.cs
#region GammaLookUpTable.cs


//----------------------------------------------------------------------------

//#ifndef AGG_GAMMA_LUT_INCLUDED
//#define AGG_GAMMA_LUT_INCLUDED

//#include <math.h>
//#include "agg_basics.h"

//using System;

namespace MatterHackers.Agg
{
    public class GammaLookUpTable
    {
        private double m_gamma;
        private byte[] m_dir_gamma;
        private byte[] m_inv_gamma;

        enum gamma_scale_e
        {
            gamma_shift = 8,
            gamma_size = 1 << gamma_shift,
            gamma_mask = gamma_size - 1
        };

        public GammaLookUpTable()
        {
            m_gamma = (1.0);
            m_dir_gamma = new byte[(int)gamma_scale_e.gamma_size];
            m_inv_gamma = new byte[(int)gamma_scale_e.gamma_size];
        }

        public GammaLookUpTable(double gamma)
        {
            m_gamma = gamma;
            m_dir_gamma = new byte[(int)gamma_scale_e.gamma_size];
            m_inv_gamma = new byte[(int)gamma_scale_e.gamma_size];
            SetGamma(m_gamma);
        }

        public void SetGamma(double g)
        {
            m_gamma = g;

            for (uint i = 0; i < (uint)gamma_scale_e.gamma_size; i++)
            {
                m_dir_gamma[i] = (byte)agg_basics.uround(Math.Pow(i / (double)gamma_scale_e.gamma_mask, m_gamma) * (double)gamma_scale_e.gamma_mask);
            }

            double inv_g = 1.0 / g;
            for (uint i = 0; i < (uint)gamma_scale_e.gamma_size; i++)
            {
                m_inv_gamma[i] = (byte)agg_basics.uround(Math.Pow(i / (double)gamma_scale_e.gamma_mask, inv_g) * (double)gamma_scale_e.gamma_mask);
            }
        }

        public double GetGamma()
        {
            return m_gamma;
        }

        public byte dir(int v)
        {
            return m_dir_gamma[v];
        }

        public byte inv(int v)
        {
            return m_inv_gamma[v];
        }
    };
}


#endregion //GammaLookUpTable.cs
#region Graphics2D.cs


//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;

//using MatterHackers.Agg.Image;
//using MatterHackers.Agg.VertexSource;
//using MatterHackers.Agg.Transform;
//using MatterHackers.Agg.Font;
//using MatterHackers.VectorMath;

namespace MatterHackers.Agg
{
    public interface IStyleHandler
    {
        bool is_solid(int style);
        RGBA_Bytes color(int style);
        void generate_span(RGBA_Bytes[] span, int spanIndex, int x, int y, int len, int style);
    };

    public abstract class Graphics2D
    {
        const int cover_full = 255;
        protected IImageByte destImageByte;
        protected IImageFloat destImageFloat;
        protected Stroke StrockedText;
        protected Stack<Affine> affineTransformStack = new Stack<Affine>();
        protected ScanlineRasterizer rasterizer;

        public Graphics2D()
        {
            affineTransformStack.Push(Affine.NewIdentity());
        }

        public Graphics2D(IImageByte destImage, ScanlineRasterizer rasterizer)
            : this()
        {
            Initialize(destImage, rasterizer);
        }

        public void Initialize(IImageByte destImage, ScanlineRasterizer rasterizer)
        {
            destImageByte = destImage;
            destImageFloat = null;
            this.rasterizer = rasterizer;
        }

        public void Initialize(IImageFloat destImage, ScanlineRasterizer rasterizer)
        {
            destImageByte = null;
            destImageFloat = destImage;
            this.rasterizer = rasterizer;
        }

        public int TransformStackCount
        {
            get { return affineTransformStack.Count; }
        }

        public Affine PopTransform()
        {
            if (affineTransformStack.Count == 1)
            {
                throw new System.Exception("You cannot remove the last transform from the stack.");
            }

            return affineTransformStack.Pop();
        }

        public void PushTransform()
        {
            if (affineTransformStack.Count > 1000)
            {
                throw new System.Exception("You seem to be leaking transforms.  You should be poping some of them at some point.");
            }

            affineTransformStack.Push(affineTransformStack.Peek());
        }

        public Affine GetTransform()
        {
            return affineTransformStack.Peek();
        }

        public void SetTransform(Affine value)
        {
            affineTransformStack.Pop();
            affineTransformStack.Push(value);
        }

        public ScanlineRasterizer Rasterizer
        {
            get { return rasterizer; }
        }

        public abstract IScanlineCache ScanlineCache
        {
            get;
            set;
        }

        public IImageByte DestImage
        {
            get
            {
                return destImageByte;
            }
        }

        public IImageFloat DestImageFloat
        {
            get
            {
                return destImageFloat;
            }
        }

        public abstract void Render(IVertexSource vertexSource, int pathIndexToRender, RGBA_Bytes colorBytes);

        public void Render(IImageByte imageSource, Point2D position)
        {
            Render(imageSource, position.x, position.y);
        }

        public void Render(IImageByte imageSource, Vector2 position)
        {
            Render(imageSource, position.x, position.y);
        }

        public void Render(IImageByte imageSource, double x, double y)
        {
            Render(imageSource, x, y, 0, 1, 1);
        }

        public abstract void Render(IImageByte imageSource,
            double x, double y,
            double angleRadians,
            double scaleX, double ScaleY);

        public abstract void Render(IImageFloat imageSource,
            double x, double y,
            double angleRadians,
            double scaleX, double ScaleY);

        public void Render(IVertexSource vertexSource, RGBA_Bytes[] colorArray, int[] pathIdArray, int numPaths)
        {
            for (int i = 0; i < numPaths; i++)
            {
                Render(vertexSource, pathIdArray[i], colorArray[i]);
            }
        }

        public void Render(IVertexSource vertexSource, RGBA_Bytes color)
        {
            Render(vertexSource, 0, color);
        }

        public void Render(IVertexSource vertexSource, double x, double y, RGBA_Bytes color)
        {
            Render(new VertexSourceApplyTransform(vertexSource, Affine.NewTranslation(x, y)), 0, color);
        }

        public void Render(IVertexSource vertexSource, Vector2 position, RGBA_Bytes color)
        {
            Render(new VertexSourceApplyTransform(vertexSource, Affine.NewTranslation(position.x, position.y)), 0, color);
        }

        public abstract void Clear(IColorType color);

        public void DrawString(string Text, double x, double y, double pointSize = 12,
            Justification justification = Justification.Left, Baseline baseline = Baseline.Text,
            RGBA_Bytes color = new RGBA_Bytes(), bool drawFromHintedCach = false, RGBA_Bytes backgroundColor = new RGBA_Bytes())
        {
            TypeFacePrinter stringPrinter = new TypeFacePrinter(Text, pointSize, new Vector2(x, y), justification, baseline);
            if (color.Alpha0To255 == 0)
            {
                color = RGBA_Bytes.Black;
            }

            if (backgroundColor.Alpha0To255 != 0)
            {
                FillRectangle(stringPrinter.LocalBounds, backgroundColor);
            }

            stringPrinter.DrawFromHintedCache = drawFromHintedCach;
            stringPrinter.Render(this, color);
        }

        public void Circle(Vector2 origin, double radius, RGBA_Bytes color)
        {
            Circle(origin.x, origin.y, radius, color);
        }

        public void Circle(double x, double y, double radius, RGBA_Bytes color)
        {
            Ellipse elipse = new Ellipse(x, y, radius, radius);
            Render(elipse, color);
        }

        public void Line(Vector2 start, Vector2 end, RGBA_Bytes color)
        {
            Line(start.x, start.y, end.x, end.y, color);
        }

        public void Line(double x1, double y1, double x2, double y2, RGBA_Bytes color)
        {
            PathStorage m_LinesToDraw = new PathStorage();
            m_LinesToDraw.remove_all();
            m_LinesToDraw.MoveTo(x1, y1);
            m_LinesToDraw.LineTo(x2, y2);
            Stroke StrockedLineToDraw = new Stroke(m_LinesToDraw);
            Render(StrockedLineToDraw, color);
        }

        public abstract void SetClippingRect(RectangleDouble rect_d);
        public abstract RectangleDouble GetClippingRect();

        public void Rectangle(double left, double bottom, double right, double top, RGBA_Bytes color, double strokeWidth = 1)
        {
            RoundedRect rect = new RoundedRect(left + .5, bottom + .5, right - .5, top - .5, 0);
            Stroke rectOutline = new Stroke(rect, strokeWidth);

            Render(rectOutline, color);
        }

        public void Rectangle(RectangleDouble rect, RGBA_Bytes color, double strokeWidth = 1)
        {
            Rectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, color, strokeWidth);
        }

        public void Rectangle(RectangleInt rect, RGBA_Bytes color)
        {
            Rectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, color);
        }

        public void FillRectangle(RectangleDouble rect, IColorType fillColor)
        {
            FillRectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, fillColor);
        }

        public void FillRectangle(RectangleInt rect, IColorType fillColor)
        {
            FillRectangle(rect.Left, rect.Bottom, rect.Right, rect.Top, fillColor);
        }

        public void FillRectangle(Vector2 leftBottom, Vector2 rightTop, IColorType fillColor)
        {
            FillRectangle(leftBottom.x, leftBottom.y, rightTop.x, rightTop.y, fillColor);
        }

        public void FillRectangle(double left, double bottom, double right, double top, IColorType fillColor)
        {
            if (right < left || top < bottom)
            {
                throw new ArgumentException();
            }
            RoundedRect rect = new RoundedRect(left, bottom, right, top, 0);
            Render(rect, fillColor.GetAsRGBA_Bytes());
        }

        public static void AssertDebugNotDefined()
        {
#if DEBUG
            throw new Exception("DEBUG is defined and should not be!");
#endif
        }
    }
}

#endregion //Graphics2D.cs
#region Gray.cs


//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//using System;
//using MatterHackers.Agg;

namespace MatterHackers.Agg.Image
{
    public class blender_gray : IRecieveBlenderByte
    {
        public int NumPixelBits { get { return 8; } }

        public const byte base_mask = 255;
        const int base_shift = 8;

        static int[] m_Saturate9BitToByte = new int[1 << 9];

        private int bytesBetweenPixelsInclusive;

        public blender_gray(int bytesBetweenPixelsInclusive)
        {
            this.bytesBetweenPixelsInclusive = bytesBetweenPixelsInclusive;

            if (m_Saturate9BitToByte[2] == 0)
            {
                for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
                {
                    m_Saturate9BitToByte[i] = Math.Min(i, 255);
                }
            }
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            int value = buffer[bufferOffset];
            return new RGBA_Bytes(value, value, value, 255);
        }

        public void CopyPixels(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);
                int gray = (y >> 8);
                pDestBuffer[bufferOffset] = (byte)gray;
                bufferOffset += bytesBetweenPixelsInclusive;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            int OneOverAlpha = base_mask - sourceColor.alpha;
            unchecked
            {
                int y = (sourceColor.red * 77) + (sourceColor.green * 151) + (sourceColor.blue * 28);
                int gray = (y >> 8);
                gray = (byte)((((gray - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);
                pDestBuffer[bufferOffset] = (byte)gray;
            }
        }

        public void BlendPixels(byte[] destBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                int cover = covers[coversIndex];
                if (cover == 255)
                {
                    do
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
                        bufferOffset += bytesBetweenPixelsInclusive;
                    }
                    while (--count != 0);
                }
                else
                {
                    do
                    {
                        sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                        bufferOffset += bytesBetweenPixelsInclusive;
                        ++sourceColorsOffset;
                    }
                    while (--count != 0);
                }
            }
            else
            {
                do
                {
                    int cover = covers[coversIndex++];
                    if (cover == 255)
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                    }
                    else
                    {
                        RGBA_Bytes color = sourceColors[sourceColorsOffset];
                        color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, color);
                    }
                    bufferOffset += bytesBetweenPixelsInclusive;
                    ++sourceColorsOffset;
                }
                while (--count != 0);
            }
        }
    }

    public class blenderGrayFromRed : IRecieveBlenderByte
    {
        public int NumPixelBits { get { return 8; } }

        public const byte base_mask = 255;
        const int base_shift = 8;

        static int[] m_Saturate9BitToByte = new int[1 << 9];

        private int bytesBetweenPixelsInclusive;

        public blenderGrayFromRed(int bytesBetweenPixelsInclusive)
        {
            this.bytesBetweenPixelsInclusive = bytesBetweenPixelsInclusive;

            if (m_Saturate9BitToByte[2] == 0)
            {
                for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
                {
                    m_Saturate9BitToByte[i] = Math.Min(i, 255);
                }
            }
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            int value = buffer[bufferOffset];
            return new RGBA_Bytes(value, value, value, 255);
        }

        public void CopyPixels(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                pDestBuffer[bufferOffset] = sourceColor.red;
                bufferOffset += bytesBetweenPixelsInclusive;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            int OneOverAlpha = base_mask - sourceColor.alpha;
            unchecked
            {
                byte gray = (byte)((((sourceColor.red - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);
                pDestBuffer[bufferOffset] = (byte)gray;
            }
        }

        public void BlendPixels(byte[] destBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                int cover = covers[coversIndex];
                if (cover == 255)
                {
                    do
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
                        bufferOffset += bytesBetweenPixelsInclusive;
                    }
                    while (--count != 0);
                }
                else
                {
                    do
                    {
                        sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                        bufferOffset += bytesBetweenPixelsInclusive;
                        ++sourceColorsOffset;
                    }
                    while (--count != 0);
                }
            }
            else
            {
                do
                {
                    int cover = covers[coversIndex++];
                    if (cover == 255)
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                    }
                    else
                    {
                        RGBA_Bytes color = sourceColors[sourceColorsOffset];
                        color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, color);
                    }
                    bufferOffset += bytesBetweenPixelsInclusive;
                    ++sourceColorsOffset;
                }
                while (--count != 0);
            }
        }
    }

    public class blenderGrayClampedMax : IRecieveBlenderByte
    {
        public int NumPixelBits { get { return 8; } }

        public const byte base_mask = 255;
        const int base_shift = 8;

        static int[] m_Saturate9BitToByte = new int[1 << 9];

        private int bytesBetweenPixelsInclusive;

        public blenderGrayClampedMax(int bytesBetweenPixelsInclusive)
        {
            this.bytesBetweenPixelsInclusive = bytesBetweenPixelsInclusive;

            if (m_Saturate9BitToByte[2] == 0)
            {
                for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
                {
                    m_Saturate9BitToByte[i] = Math.Min(i, 255);
                }
            }
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            int value = buffer[bufferOffset];
            return new RGBA_Bytes(value, value, value, 255);
        }

        public void CopyPixels(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                byte clampedMax = Math.Min(Math.Max(sourceColor.red, Math.Max(sourceColor.green, sourceColor.blue)), (byte)255);
                pDestBuffer[bufferOffset] = clampedMax;
                bufferOffset += bytesBetweenPixelsInclusive;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            int OneOverAlpha = base_mask - sourceColor.alpha;
            unchecked
            {
                byte clampedMax = Math.Min(Math.Max(sourceColor.red, Math.Max(sourceColor.green, sourceColor.blue)), (byte)255);
                byte gray = (byte)((((clampedMax - (int)(pDestBuffer[bufferOffset])) * sourceColor.alpha) + ((int)(pDestBuffer[bufferOffset]) << base_shift)) >> base_shift);
                pDestBuffer[bufferOffset] = (byte)gray;
            }
        }

        public void BlendPixels(byte[] destBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                int cover = covers[coversIndex];
                if (cover == 255)
                {
                    do
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
                        bufferOffset += bytesBetweenPixelsInclusive;
                    }
                    while (--count != 0);
                }
                else
                {
                    do
                    {
                        sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                        bufferOffset += bytesBetweenPixelsInclusive;
                        ++sourceColorsOffset;
                    }
                    while (--count != 0);
                }
            }
            else
            {
                do
                {
                    int cover = covers[coversIndex++];
                    if (cover == 255)
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                    }
                    else
                    {
                        RGBA_Bytes color = sourceColors[sourceColorsOffset];
                        color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, color);
                    }
                    bufferOffset += bytesBetweenPixelsInclusive;
                    ++sourceColorsOffset;
                }
                while (--count != 0);
            }
        }
    }

    /*

    //======================================================blender_gray_pre
    //template<class ColorT> 
    struct blender_gray_pre
    {
        typedef ColorT color_type;
        typedef typename color_type::value_type value_type;
        typedef typename color_type::calc_type calc_type;
        enum base_scale_e { base_shift = color_type::base_shift };

        static void blend_pix(value_type* p, int cv,
                                         int alpha, int cover)
        {
            alpha = color_type::base_mask - alpha;
            cover = (cover + 1) << (base_shift - 8);
            *p = (value_type)((*p * alpha + cv * cover) >> base_shift);
        }

        static void blend_pix(value_type* p, int cv,
                                         int alpha)
        {
            *p = (value_type)(((*p * (color_type::base_mask - alpha)) >> base_shift) + cv);
        }
    };
    


    //=====================================================apply_gamma_dir_gray
    //template<class ColorT, class GammaLut> 
    class apply_gamma_dir_gray
    {
    public:
        typedef typename ColorT::value_type value_type;

        apply_gamma_dir_gray(GammaLut& gamma) : m_gamma(gamma) {}

        void operator () (byte* p)
        {
            *p = m_gamma.dir(*p);
        }

    private:
        GammaLut& m_gamma;
    };



    //=====================================================apply_gamma_inv_gray
    //template<class ColorT, class GammaLut> 
    class apply_gamma_inv_gray
    {
    public:
        typedef typename ColorT::value_type value_type;

        apply_gamma_inv_gray(GammaLut& gamma) : m_gamma(gamma) {}

        void operator () (byte* p)
        {
            *p = m_gamma.inv(*p);
        }

    private:
        GammaLut& m_gamma;
    };

     */
}

#endregion //Gray.cs
#region IColorType.cs

//----------------------------------------------------------------------------
// AGG-Sharp - Version 1
// Copyright (C) 2007 Lars Brubaker http://agg-sharp.sourceforge.net/
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: larsbrubaker@gmail.com
//          http://agg-sharp.sourceforge.net/
//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;
//using System.Text;

namespace MatterHackers.Agg
{
    public interface IColorType
    {
        RGBA_Floats GetAsRGBA_Floats();
        RGBA_Bytes GetAsRGBA_Bytes();

        RGBA_Bytes gradient(RGBA_Bytes c, double k);

        int Red0To255 { get; set; }
        int Green0To255 { get; set; }
        int Blue0To255 { get; set; }
        int Alpha0To255 { get; set; }

        float Red0To1 { get; set; }
        float Green0To1 { get; set; }
        float Blue0To1 { get; set; }
        float Alpha0To1 { get; set; }
    };
}

#endregion //IColorType.cs
#region IGenerator.cs


//----------------------------------------------------------------------------

namespace MatterHackers.Agg.VertexSource
{
    public interface IGenerator
    {
        void RemoveAll();
        void AddVertex(double x, double y, ShapePath.FlagsAndCommand unknown);
        void Rewind(int path_id);
        ShapePath.FlagsAndCommand Vertex(ref double x, ref double y);

        LineCap line_cap();
        LineJoin line_join();
        InnerJoin inner_join();

        void line_cap(LineCap lc);
        void line_join(LineJoin lj);
        void inner_join(InnerJoin ij);

        void width(double w);
        void miter_limit(double ml);
        void miter_limit_theta(double t);
        void inner_miter_limit(double ml);
        void approximation_scale(double approxScale);

        double width();
        double miter_limit();
        double inner_miter_limit();
        double approximation_scale();

        void auto_detect_orientation(bool v);
        bool auto_detect_orientation();

        void shorten(double s);
        double shorten();
    };
}

#endregion //IGenerator.cs
#region IImage.cs


//----------------------------------------------------------------------------
//using MatterHackers.Agg;
//using MatterHackers.VectorMath;

namespace MatterHackers.Agg.Image
{
    public interface IImage
    {
        Vector2 OriginOffset
        {
            get;
            set;
        }

        int BitDepth { get; }

        int Width { get; }
        int Height { get; }
        RectangleInt GetBounds();

        int GetBufferOffsetY(int y);
        int GetBufferOffsetXY(int x, int y);

        Graphics2D NewGraphics2D();

        void MarkImageChanged();
    }

    public interface IImageByte : IImage
    {
        int StrideInBytes();
        int StrideInBytesAbs();

        IRecieveBlenderByte GetRecieveBlender();
        void SetRecieveBlender(IRecieveBlenderByte value);
        int GetBytesBetweenPixelsInclusive();

        byte[] GetBuffer();

        RGBA_Bytes GetPixel(int x, int y);
        void copy_pixel(int x, int y, byte[] c, int ByteOffset);

        void CopyFrom(IImageByte sourceImage);
        void CopyFrom(IImageByte sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset);

        void SetPixel(int x, int y, RGBA_Bytes color);
        void BlendPixel(int x, int y, RGBA_Bytes sourceColor, byte cover);

        // line stuff
        void copy_hline(int x, int y, int len, RGBA_Bytes sourceColor);
        void copy_vline(int x, int y, int len, RGBA_Bytes sourceColor);

        void blend_hline(int x, int y, int x2, RGBA_Bytes sourceColor, byte cover);
        void blend_vline(int x, int y1, int y2, RGBA_Bytes sourceColor, byte cover);

        // color stuff
        void copy_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorIndex);
        void copy_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorIndex);

        void blend_solid_hspan(int x, int y, int len, RGBA_Bytes sourceColor, byte[] covers, int coversIndex);
        void blend_solid_vspan(int x, int y, int len, RGBA_Bytes sourceColor, byte[] covers, int coversIndex);

        void blend_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);
        void blend_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);
    }

    public interface IImageFloat : IImage
    {
        int StrideInFloats();
        int StrideInFloatsAbs();

        IRecieveBlenderFloat GetBlender();
        void SetBlender(IRecieveBlenderFloat value);
        int GetFloatsBetweenPixelsInclusive();

        float[] GetBuffer();

        RGBA_Floats GetPixel(int x, int y);
        void copy_pixel(int x, int y, float[] c, int floatOffset);

        void CopyFrom(IImageFloat sourceImage);
        void CopyFrom(IImageFloat sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset);

        void SetPixel(int x, int y, RGBA_Floats color);
        void BlendPixel(int x, int y, RGBA_Floats sourceColor, byte cover);

        // line stuff
        void copy_hline(int x, int y, int len, RGBA_Floats sourceColor);
        void copy_vline(int x, int y, int len, RGBA_Floats sourceColor);

        void blend_hline(int x, int y, int x2, RGBA_Floats sourceColor, byte cover);
        void blend_vline(int x, int y1, int y2, RGBA_Floats sourceColor, byte cover);

        // color stuff
        void copy_color_hspan(int x, int y, int len, RGBA_Floats[] colors, int colorIndex);
        void copy_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorIndex);

        void blend_solid_hspan(int x, int y, int len, RGBA_Floats sourceColor, byte[] covers, int coversIndex);
        void blend_solid_vspan(int x, int y, int len, RGBA_Floats sourceColor, byte[] covers, int coversIndex);

        void blend_color_hspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);
        void blend_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll);
    }
}

#endregion //IImage.cs
#region ImageBuffer.cs


//----------------------------------------------------------------------------
//using System;
//using System.Runtime;

//using MatterHackers.Agg;
//using MatterHackers.Agg.VertexSource;
//using MatterHackers.Agg.RasterizerScanline;
//using MatterHackers.VectorMath;

namespace MatterHackers.Agg.Image
{
    public class ImageBuffer : IImageByte
    {
        public const int OrderB = 0;
        public const int OrderG = 1;
        public const int OrderR = 2;
        public const int OrderA = 3;

        internal class InternalImageGraphics2D : ImageGraphics2D
        {
            internal InternalImageGraphics2D(ImageBuffer owner)
                : base()
            {
                ScanlineRasterizer rasterizer = new ScanlineRasterizer();
                ImageClippingProxy imageClippingProxy = new ImageClippingProxy(owner);

                Initialize(imageClippingProxy, rasterizer);
                ScanlineCache = new ScanlineCachePacked8();
            }
        }

        protected int[] yTableArray;
        protected int[] xTableArray;
        private byte[] m_ByteBuffer;
        int bufferOffset; // the beggining of the image in this buffer
        int bufferFirstPixel; // Pointer to first pixel depending on strideInBytes and image position

        int width;  // Width in pixels
        int height; // Height in pixels
        int strideInBytes; // Number of bytes per row. Can be < 0
        int m_DistanceInBytesBetweenPixelsInclusive;
        int bitDepth;
        Vector2 m_OriginOffset = new Vector2(0, 0);

        private IRecieveBlenderByte recieveBlender;

        const int base_mask = 255;

        public event EventHandler ImageChanged;

        int changedCount = 0;
        public int ChangedCount { get { return changedCount; } }
        public void MarkImageChanged()
        {
            // mark this unchecked as we don't want to throw an exception if this rolls over.
            unchecked
            {
                changedCount++;
                if (ImageChanged != null)
                {
                    ImageChanged(this, null);
                }
            }
        }

        public ImageBuffer()
        {
        }

        public ImageBuffer(IRecieveBlenderByte recieveBlender)
        {
            SetRecieveBlender(recieveBlender);
        }

        public ImageBuffer(IImageByte sourceImage, IRecieveBlenderByte recieveBlender)
        {
            SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInBytes(), sourceImage.BitDepth, sourceImage.GetBytesBetweenPixelsInclusive(), true);
            int offset = sourceImage.GetBufferOffsetXY(0, 0);
            byte[] buffer = sourceImage.GetBuffer();
            byte[] newBuffer = new byte[buffer.Length];
            agg_basics.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
            SetBuffer(newBuffer, offset);
            SetRecieveBlender(recieveBlender);
        }

        public ImageBuffer(ImageBuffer sourceImage)
        {
            SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInBytes(), sourceImage.BitDepth, sourceImage.GetBytesBetweenPixelsInclusive(), true);
            int offset = sourceImage.GetBufferOffsetXY(0, 0);
            byte[] buffer = sourceImage.GetBuffer();
            byte[] newBuffer = new byte[buffer.Length];
            agg_basics.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
            SetBuffer(newBuffer, offset);
            SetRecieveBlender(sourceImage.GetRecieveBlender());
        }

        public ImageBuffer(int width, int height, int bitsPerPixel, IRecieveBlenderByte recieveBlender)
        {
            Allocate(width, height, width * (bitsPerPixel / 8), bitsPerPixel);
            SetRecieveBlender(recieveBlender);
        }

        public void Allocate(int width, int height, int bitsPerPixel, IRecieveBlenderByte recieveBlender)
        {
            Allocate(width, height, width * (bitsPerPixel / 8), bitsPerPixel);
            SetRecieveBlender(recieveBlender);
        }

#if false
        public ImageBuffer(IImage image, IBlender blender, GammaLookUpTable gammaTable)
        {
            unsafe
            {
                AttachBuffer(image.GetBuffer(), image.Width(), image.Height(), image.StrideInBytes(), image.BitDepth, image.GetDistanceBetweenPixelsInclusive());
            }

            SetBlender(blender);
        }
#endif

        public ImageBuffer(IImageByte sourceImageToCopy, IRecieveBlenderByte blender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
        {
            SetDimmensionAndFormat(sourceImageToCopy.Width, sourceImageToCopy.Height, sourceImageToCopy.StrideInBytes(), bitsPerPixel, distanceBetweenPixelsInclusive, true);
            int offset = sourceImageToCopy.GetBufferOffsetXY(0, 0);
            byte[] buffer = sourceImageToCopy.GetBuffer();
            byte[] newBuffer = new byte[buffer.Length];
            agg_basics.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
            SetBuffer(newBuffer, offset + bufferOffset);
            SetRecieveBlender(blender);
        }

        /// <summary>
        /// This will create a new ImageBuffer that references the same memory as the image that you took the sub image from.
        /// It will modify the original main image when you draw to it.
        /// </summary>
        /// <param name="imageContainingSubImage"></param>
        /// <param name="subImageBounds"></param>
        /// <returns></returns>
        public static ImageBuffer NewSubImageReference(IImageByte imageContainingSubImage, RectangleDouble subImageBounds)
        {
            ImageBuffer subImage = new ImageBuffer();
            if (subImageBounds.Left < 0 || subImageBounds.Bottom < 0 || subImageBounds.Right > imageContainingSubImage.Width || subImageBounds.Top > imageContainingSubImage.Height
                || subImageBounds.Left >= subImageBounds.Right || subImageBounds.Bottom >= subImageBounds.Top)
            {
                throw new ArgumentException("The subImageBounds must be on the image and valid.");
            }
            int left = Math.Max(0, (int)Math.Floor(subImageBounds.Left));
            int bottom = Math.Max(0, (int)Math.Floor(subImageBounds.Bottom));
            int width = Math.Min(imageContainingSubImage.Width - left, (int)subImageBounds.Width);
            int height = Math.Min(imageContainingSubImage.Height - bottom, (int)subImageBounds.Height);
            int bufferOffsetToFirstPixel = imageContainingSubImage.GetBufferOffsetXY(left, bottom);
            subImage.AttachBuffer(imageContainingSubImage.GetBuffer(), bufferOffsetToFirstPixel, width, height, imageContainingSubImage.StrideInBytes(), imageContainingSubImage.BitDepth, imageContainingSubImage.GetBytesBetweenPixelsInclusive());
            subImage.SetRecieveBlender(imageContainingSubImage.GetRecieveBlender());

            return subImage;
        }

        public void AttachBuffer(byte[] buffer, int bufferOffset, int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive)
        {
            m_ByteBuffer = null;
            SetDimmensionAndFormat(width, height, strideInBytes, bitDepth, distanceInBytesBetweenPixelsInclusive, false);
            SetBuffer(buffer, bufferOffset);
        }

        public void Attach(IImageByte sourceImage, IRecieveBlenderByte recieveBlender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
        {
            SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInBytes(), bitsPerPixel, distanceBetweenPixelsInclusive, false);
            int offset = sourceImage.GetBufferOffsetXY(0, 0);
            byte[] buffer = sourceImage.GetBuffer();
            SetBuffer(buffer, offset + bufferOffset);
            SetRecieveBlender(recieveBlender);
        }

        public void Attach(IImageByte sourceImage, IRecieveBlenderByte recieveBlender)
        {
            Attach(sourceImage, recieveBlender, sourceImage.GetBytesBetweenPixelsInclusive(), 0, sourceImage.BitDepth);
        }

        public bool Attach(IImageByte sourceImage, int x1, int y1, int x2, int y2)
        {
            m_ByteBuffer = null;
            DettachBuffer();

            if (x1 > x2 || y1 > y2)
            {
                throw new Exception("You need to have your x1 and y1 be the lower left corner of your sub image.");
            }
            RectangleInt boundsRect = new RectangleInt(x1, y1, x2, y2);
            if (boundsRect.clip(new RectangleInt(0, 0, (int)sourceImage.Width - 1, (int)sourceImage.Height - 1)))
            {
                SetDimmensionAndFormat(boundsRect.Width, boundsRect.Height, sourceImage.StrideInBytes(), sourceImage.BitDepth, sourceImage.GetBytesBetweenPixelsInclusive(), false);
                int bufferOffset = sourceImage.GetBufferOffsetXY(boundsRect.Left, boundsRect.Bottom);
                byte[] buffer = sourceImage.GetBuffer();
                SetBuffer(buffer, bufferOffset);
                return true;
            }

            return false;
        }

        public void SetAlpha(byte value)
        {
            if (BitDepth != 32)
            {
                throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + ".");
            }
            int numPixels = Width * Height;
            int offset;
            byte[] buffer = GetBuffer(out offset);
            for (int i = 0; i < numPixels; i++)
            {
                buffer[offset + i * 4 + 3] = value;
            }
        }

        private void Deallocate()
        {
            if (m_ByteBuffer != null)
            {
                m_ByteBuffer = null;
                SetDimmensionAndFormat(0, 0, 0, 32, 4, true);
            }
        }

        public void Allocate(int inWidth, int inHeight, int inScanWidthInBytes, int bitsPerPixel)
        {
            if (inWidth < 1 || inHeight < 1)
            {
                throw new ArgumentOutOfRangeException("You must have a width and height > than 0.");
            }

            if (bitsPerPixel != 32 && bitsPerPixel != 24 && bitsPerPixel != 8)
            {
                throw new Exception("Unsupported bits per pixel.");
            }
            if (inScanWidthInBytes < inWidth * (bitsPerPixel / 8))
            {
                throw new Exception("Your scan width is not big enough to hold your width and height.");
            }
            SetDimmensionAndFormat(inWidth, inHeight, inScanWidthInBytes, bitsPerPixel, bitsPerPixel / 8, true);

            if (m_ByteBuffer == null || m_ByteBuffer.Length != strideInBytes * height)
            {
                m_ByteBuffer = new byte[strideInBytes * height];
                SetUpLookupTables();
            }

            if (yTableArray.Length != inHeight
                || xTableArray.Length != inWidth)
            {
                throw new Exception("The yTable and xTable should be allocated correctly at this point. Figure out what happend."); // LBB, don't fix this if you don't understand what it's trying to do.
            }
        }

        public MatterHackers.Agg.Graphics2D NewGraphics2D()
        {
            InternalImageGraphics2D imageRenderer = new InternalImageGraphics2D(this);

            imageRenderer.Rasterizer.SetVectorClipBox(0, 0, Width, Height);

            return imageRenderer;
        }

        public void CopyFrom(IImageByte sourceImage)
        {
            CopyFrom(sourceImage, sourceImage.GetBounds(), 0, 0);
        }

        protected void CopyFromNoClipping(IImageByte sourceImage, RectangleInt clippedSourceImageRect, int destXOffset, int destYOffset)
        {
            if (GetBytesBetweenPixelsInclusive() != BitDepth / 8
                || sourceImage.GetBytesBetweenPixelsInclusive() != sourceImage.BitDepth / 8)
            {
                throw new Exception("WIP we only support packed pixel formats at this time.");
            }

            if (BitDepth == sourceImage.BitDepth)
            {
                int lengthInBytes = clippedSourceImageRect.Width * GetBytesBetweenPixelsInclusive();

                int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom);
                byte[] sourceBuffer = sourceImage.GetBuffer();
                int destOffset;
                byte[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset, clippedSourceImageRect.Bottom + destYOffset, out destOffset);

                for (int i = 0; i < clippedSourceImageRect.Height; i++)
                {
                    agg_basics.memmove(destBuffer, destOffset, sourceBuffer, sourceOffset, lengthInBytes);
                    sourceOffset += sourceImage.StrideInBytes();
                    destOffset += StrideInBytes();
                }
            }
            else
            {
                bool haveConversion = true;
                switch (sourceImage.BitDepth)
                {
                    case 24:
                        switch (BitDepth)
                        {
                            case 32:
                                {
                                    int numPixelsToCopy = clippedSourceImageRect.Width;
                                    for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)
                                    {
                                        int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom + i);
                                        byte[] sourceBuffer = sourceImage.GetBuffer();
                                        int destOffset;
                                        byte[] destBuffer = GetPixelPointerXY(
                                            clippedSourceImageRect.Left + destXOffset,
                                            clippedSourceImageRect.Bottom + i + destYOffset,
                                            out destOffset);
                                        for (int x = 0; x < numPixelsToCopy; x++)
                                        {
                                            destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
                                            destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
                                            destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
                                            destBuffer[destOffset++] = 255;
                                        }
                                    }
                                }
                                break;

                            default:
                                haveConversion = false;
                                break;
                        }
                        break;

                    default:
                        haveConversion = false;
                        break;
                }

                if (!haveConversion)
                {
                    throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");
                }
            }
        }

        public void CopyFrom(IImageByte sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
        {
            RectangleInt sourceImageBounds = sourceImage.GetBounds();
            RectangleInt clippedSourceImageRect = new RectangleInt();
            if (clippedSourceImageRect.IntersectRectangles(sourceImageRect, sourceImageBounds))
            {
                RectangleInt destImageRect = clippedSourceImageRect;
                destImageRect.Offset(destXOffset, destYOffset);
                RectangleInt destImageBounds = GetBounds();
                RectangleInt clippedDestImageRect = new RectangleInt();
                if (clippedDestImageRect.IntersectRectangles(destImageRect, destImageBounds))
                {
                    // we need to make sure the source is also clipped to the dest. So, we'll copy this back to source and offset it.
                    clippedSourceImageRect = clippedDestImageRect;
                    clippedSourceImageRect.Offset(-destXOffset, -destYOffset);
                    CopyFromNoClipping(sourceImage, clippedSourceImageRect, destXOffset, destYOffset);
                }
            }
        }

        public Vector2 OriginOffset
        {
            get { return m_OriginOffset; }
            set { m_OriginOffset = value; }
        }

        public int Width
        {
            get
            {
                return width;
            }
        }

        public int Height
        {
            get
            {
                return height;
            }
        }

        public int StrideInBytes() { return strideInBytes; }
        public int StrideInBytesAbs() { return System.Math.Abs(strideInBytes); }
        public int GetBytesBetweenPixelsInclusive() { return m_DistanceInBytesBetweenPixelsInclusive; }
        public int BitDepth
        {
            get { return bitDepth; }
        }

        public virtual RectangleInt GetBounds()
        {
            return new RectangleInt(-(int)m_OriginOffset.x, -(int)m_OriginOffset.y, Width - (int)m_OriginOffset.x, Height - (int)m_OriginOffset.y);
        }

        public IRecieveBlenderByte GetRecieveBlender()
        {
            return recieveBlender;
        }

        public void SetRecieveBlender(IRecieveBlenderByte value)
        {
            if (BitDepth != 0 && value != null && value.NumPixelBits != BitDepth)
            {
                throw new NotSupportedException("The blender has to support the bit depth of this image.");
            }
            recieveBlender = value;
        }

        private void SetUpLookupTables()
        {
            yTableArray = new int[height];
            for (int i = 0; i < height; i++)
            {
                yTableArray[i] = i * strideInBytes;
            }

            xTableArray = new int[width];
            for (int i = 0; i < width; i++)
            {
                xTableArray[i] = i * m_DistanceInBytesBetweenPixelsInclusive;
            }
        }

        public void InvertYLookupTable()
        {
            strideInBytes *= -1;
            bufferFirstPixel = bufferOffset;
            if (strideInBytes < 0)
            {
                int addAmount = -((int)((int)height - 1) * strideInBytes);
                bufferFirstPixel = addAmount + bufferOffset;
            }

            SetUpLookupTables();
        }

        public void FlipY()
        {
            byte[] buffer = GetBuffer();
            for (int y = 0; y < Height / 2; y++)
            {
                int bottomBuffer = GetBufferOffsetY(y);
                int topBuffer = GetBufferOffsetY(Height - y - 1);
                for (int x = 0; x < StrideInBytes(); x++)
                {
                    byte hold = buffer[bottomBuffer + x];
                    buffer[bottomBuffer + x] = buffer[topBuffer + x];
                    buffer[topBuffer + x] = hold;
                }

            }
        }

        public void SetBuffer(byte[] byteBuffer, int bufferOffset)
        {
            if (byteBuffer.Length < height * strideInBytes)
            {
                throw new Exception("Your buffer does not have enough room it it for your height and strideInBytes.");
            }
            m_ByteBuffer = byteBuffer;
            this.bufferOffset = bufferFirstPixel = bufferOffset;
            if (strideInBytes < 0)
            {
                int addAmount = -((int)((int)height - 1) * strideInBytes);
                bufferFirstPixel = addAmount + bufferOffset;
            }
            SetUpLookupTables();
        }

        private void DeallocateOrClearBuffer(int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive)
        {
            if (this.width == width
                && this.height == height
                && this.strideInBytes == strideInBytes
                && this.bitDepth == bitDepth
                && m_DistanceInBytesBetweenPixelsInclusive == distanceInBytesBetweenPixelsInclusive
                && m_ByteBuffer != null)
            {
                for (int i = 0; i < m_ByteBuffer.Length; i++)
                {
                    m_ByteBuffer[i] = 0;
                }
                return;
            }
            else
            {
                Deallocate();
            }
        }

        private void SetDimmensionAndFormat(int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive, bool doDeallocateOrClearBuffer)
        {
            if (doDeallocateOrClearBuffer)
            {
                DeallocateOrClearBuffer(width, height, strideInBytes, bitDepth, distanceInBytesBetweenPixelsInclusive);
            }

            this.width = width;
            this.height = height;
            this.strideInBytes = strideInBytes;
            this.bitDepth = bitDepth;
            if (distanceInBytesBetweenPixelsInclusive > 4)
            {
                throw new System.Exception("It looks like you are passing bits per pixel rather than distance in bytes.");
            }
            if (distanceInBytesBetweenPixelsInclusive < (bitDepth / 8))
            {
                throw new Exception("You do not have enough room between pixels to support your bit depth.");
            }
            m_DistanceInBytesBetweenPixelsInclusive = distanceInBytesBetweenPixelsInclusive;
            if (strideInBytes < distanceInBytesBetweenPixelsInclusive * width)
            {
                throw new Exception("You do not have enough strideInBytes to hold the width and pixel distance you have described.");
            }
        }

        public void DettachBuffer()
        {
            m_ByteBuffer = null;
            width = height = strideInBytes = m_DistanceInBytesBetweenPixelsInclusive = 0;
        }

        public byte[] GetBuffer()
        {
            return m_ByteBuffer;
        }

        public byte[] GetBuffer(out int bufferOffset)
        {
            bufferOffset = this.bufferOffset;
            return m_ByteBuffer;
        }

        public byte[] GetPixelPointerY(int y, out int bufferOffset)
        {
            bufferOffset = bufferFirstPixel + yTableArray[y];
            //bufferOffset = GetBufferOffsetXY(0, y);
            return m_ByteBuffer;
        }

        public byte[] GetPixelPointerXY(int x, int y, out int bufferOffset)
        {
            bufferOffset = GetBufferOffsetXY(x, y);
            return m_ByteBuffer;
        }

        public RGBA_Bytes GetPixel(int x, int y)
        {
            return recieveBlender.PixelToColorRGBA_Bytes(m_ByteBuffer, GetBufferOffsetXY(x, y));
        }

        public int GetBufferOffsetY(int y)
        {
            return bufferFirstPixel + yTableArray[y] + xTableArray[0];
        }

        public int GetBufferOffsetXY(int x, int y)
        {
            return bufferFirstPixel + yTableArray[y] + xTableArray[x];
        }

        public void copy_pixel(int x, int y, byte[] c, int ByteOffset)
        {
            throw new System.NotImplementedException();
            //byte* p = GetPixelPointerXY(x, y);
            //((int*)p)[0] = ((int*)c)[0];
            //p[OrderR] = c.r;
            //p[OrderG] = c.g;
            //p[OrderB] = c.b;
            //p[OrderA] = c.a;
        }

        public void BlendPixel(int x, int y, RGBA_Bytes c, byte cover)
        {
            throw new System.NotImplementedException();
            /*
            cob_type::copy_or_blend_pix(
                (value_type*)m_rbuf->row_ptr(x, y, 1)  + x + x + x, 
                c.r, c.g, c.b, c.a, 
                cover);*/
        }

        public void SetPixel(int x, int y, RGBA_Bytes color)
        {
            x -= (int)m_OriginOffset.x;
            y -= (int)m_OriginOffset.y;
            recieveBlender.CopyPixels(GetBuffer(), GetBufferOffsetXY(x, y), color, 1);
        }

        public void copy_hline(int x, int y, int len, RGBA_Bytes sourceColor)
        {
            int bufferOffset;
            byte[] buffer = GetPixelPointerXY(x, y, out bufferOffset);

            recieveBlender.CopyPixels(buffer, bufferOffset, sourceColor, len);
        }

        public void copy_vline(int x, int y, int len, RGBA_Bytes sourceColor)
        {
            throw new NotImplementedException();
#if false
            int scanWidth = StrideInBytes();
            byte* pDestBuffer = GetPixelPointerXY(x, y);
            do
            {
                m_Blender.CopyPixel(pDestBuffer, sourceColor);
                pDestBuffer = &pDestBuffer[scanWidth];
            }
            while (--len != 0);
#endif
        }


        public void blend_hline(int x1, int y, int x2, RGBA_Bytes sourceColor, byte cover)
        {
            if (sourceColor.alpha != 0)
            {
                int len = x2 - x1 + 1;

                int bufferOffset;
                byte[] buffer = GetPixelPointerXY(x1, y, out bufferOffset);

                int alpha = (((int)(sourceColor.alpha) * (cover + 1)) >> 8);
                if (alpha == base_mask)
                {
                    recieveBlender.CopyPixels(buffer, bufferOffset, sourceColor, len);
                }
                else
                {
                    do
                    {
                        recieveBlender.BlendPixel(buffer, bufferOffset, new RGBA_Bytes(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
                        bufferOffset += m_DistanceInBytesBetweenPixelsInclusive;
                    }
                    while (--len != 0);
                }
            }
        }

        public void blend_vline(int x, int y1, int y2, RGBA_Bytes sourceColor, byte cover)
        {
            throw new NotImplementedException();
#if false
            int ScanWidth = StrideInBytes();
            if (sourceColor.m_A != 0)
            {
                unsafe
                {
                    int len = y2 - y1 + 1;
                    byte* p = GetPixelPointerXY(x, y1);
                    sourceColor.m_A = (byte)(((int)(sourceColor.m_A) * (cover + 1)) >> 8);
                    if (sourceColor.m_A == base_mask)
                    {
                        byte cr = sourceColor.m_R;
                        byte cg = sourceColor.m_G;
                        byte cb = sourceColor.m_B;
                        do
                        {
                            m_Blender.CopyPixel(p, sourceColor);
                            p = &p[ScanWidth];
                        }
                        while (--len != 0);
                    }
                    else
                    {
                        if (cover == 255)
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                        else
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                    }
                }
            }
#endif
        }

        public void blend_solid_hspan(int x, int y, int len, RGBA_Bytes sourceColor, byte[] covers, int coversIndex)
        {
            int colorAlpha = sourceColor.alpha;
            if (colorAlpha != 0)
            {
                unchecked
                {
                    int bufferOffset;
                    byte[] buffer = GetPixelPointerXY(x, y, out bufferOffset);

                    do
                    {
                        int alpha = ((colorAlpha) * ((covers[coversIndex]) + 1)) >> 8;
                        if (alpha == base_mask)
                        {
                            recieveBlender.CopyPixels(buffer, bufferOffset, sourceColor, 1);
                        }
                        else
                        {
                            recieveBlender.BlendPixel(buffer, bufferOffset, new RGBA_Bytes(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
                        }
                        bufferOffset += m_DistanceInBytesBetweenPixelsInclusive;
                        coversIndex++;
                    }
                    while (--len != 0);
                }
            }
        }

        public void blend_solid_vspan(int x, int y, int len, RGBA_Bytes sourceColor, byte[] covers, int coversIndex)
        {
            if (sourceColor.alpha != 0)
            {
                int ScanWidthInBytes = StrideInBytes();
                unchecked
                {
                    int bufferOffset = GetBufferOffsetXY(x, y);
                    do
                    {
                        byte oldAlpha = sourceColor.alpha;
                        sourceColor.alpha = (byte)(((int)(sourceColor.alpha) * ((int)(covers[coversIndex++]) + 1)) >> 8);
                        if (sourceColor.alpha == base_mask)
                        {
                            recieveBlender.CopyPixels(m_ByteBuffer, bufferOffset, sourceColor, 1);
                        }
                        else
                        {
                            recieveBlender.BlendPixel(m_ByteBuffer, bufferOffset, sourceColor);
                        }
                        bufferOffset += ScanWidthInBytes;
                        sourceColor.alpha = oldAlpha;
                    }
                    while (--len != 0);
                }
            }
        }

        public void copy_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);

            do
            {
                recieveBlender.CopyPixels(m_ByteBuffer, bufferOffset, colors[colorsIndex], 1);

                ++colorsIndex;
                bufferOffset += m_DistanceInBytesBetweenPixelsInclusive;
            }
            while (--len != 0);
        }

        public void copy_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);

            do
            {
                recieveBlender.CopyPixels(m_ByteBuffer, bufferOffset, colors[colorsIndex], 1);

                ++colorsIndex;
                bufferOffset += strideInBytes;
            }
            while (--len != 0);
        }

        public void blend_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);
            recieveBlender.BlendPixels(m_ByteBuffer, bufferOffset, colors, colorsIndex, covers, coversIndex, firstCoverForAll, len);
        }

        public void blend_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);

            int ScanWidth = StrideInBytesAbs();
            if (!firstCoverForAll)
            {
                do
                {
                    DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender, m_ByteBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex++]);
                    bufferOffset += ScanWidth;
                    ++colorsIndex;
                }
                while (--len != 0);
            }
            else
            {
                if (covers[coversIndex] == 255)
                {
                    do
                    {
                        DoCopyOrBlend.BasedOnAlpha(recieveBlender, m_ByteBuffer, bufferOffset, colors[colorsIndex]);
                        bufferOffset += ScanWidth;
                        ++colorsIndex;
                    }
                    while (--len != 0);
                }
                else
                {
                    do
                    {

                        DoCopyOrBlend.BasedOnAlphaAndCover(recieveBlender, m_ByteBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex]);
                        bufferOffset += ScanWidth;
                        ++colorsIndex;
                    }
                    while (--len != 0);
                }
            }
        }

        public void apply_gamma_inv(GammaLookUpTable g)
        {
            throw new System.NotImplementedException();
            //for_each_pixel(apply_gamma_inv_rgba<color_type, order_type, GammaLut>(g));
        }

        private bool IsPixelVisible(int x, int y)
        {
            RGBA_Bytes pixelValue = GetRecieveBlender().PixelToColorRGBA_Bytes(m_ByteBuffer, GetBufferOffsetXY(x, y));
            return (pixelValue.Alpha0To255 != 0 || pixelValue.Red0To255 != 0 || pixelValue.Green0To255 != 0 || pixelValue.Blue0To255 != 0);
        }

        public void GetVisibleBounds(out RectangleInt visibleBounds)
        {
            visibleBounds = new RectangleInt(0, 0, Width, Height);

            // trim the bottom
            bool aPixelsIsVisible = false;
            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Bottom = y;
                        y = height;
                        x = width;
                        aPixelsIsVisible = true;
                    }
                }
            }

            // if we don't run into any pixels set for the top trim than there are no pixels set at all
            if (!aPixelsIsVisible)
            {
                visibleBounds.SetRect(0, 0, 0, 0);
                return;
            }

            // trim the bottom
            for (int y = height - 1; y >= 0; y--)
            {
                for (int x = 0; x < width; x++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Top = y + 1;
                        y = -1;
                        x = width;
                    }
                }
            }

            // trim the left
            for (int x = 0; x < width; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Left = x;
                        y = height;
                        x = width;
                    }
                }
            }

            // trim the right
            for (int x = width - 1; x >= 0; x--)
            {
                for (int y = 0; y < height; y++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Right = x + 1;
                        y = height;
                        x = -1;
                    }
                }
            }
        }

        public void CropToVisible()
        {
            Vector2 OldOriginOffset = OriginOffset;

            //Move the HotSpot to 0, 0 so PPoint will work the way we want
            OriginOffset = new Vector2(0, 0);

            RectangleInt visibleBounds;
            GetVisibleBounds(out visibleBounds);

            if (visibleBounds.Width == Width
                && visibleBounds.Height == Height)
            {
                OriginOffset = OldOriginOffset;
                return;
            }

            // check if the Not0Rect has any size
            if (visibleBounds.Width > 0)
            {
                ImageBuffer TempImage = new ImageBuffer();

                // set TempImage equal to the Not0Rect
                TempImage.Initialize(this, visibleBounds);

                // set the frame equal to the TempImage
                Initialize(TempImage);

                OriginOffset = new Vector2(-visibleBounds.Left + OldOriginOffset.x, -visibleBounds.Bottom + OldOriginOffset.y);
            }
            else
            {
                Deallocate();
            }
        }

        public static bool operator ==(ImageBuffer a, ImageBuffer b)
        {
            if ((object)a == null || (object)b == null)
            {
                if ((object)a == null && (object)b == null)
                {
                    return true;
                }
                return false;
            }
            return a.Equals(b, 0);
        }

        public static bool operator !=(ImageBuffer a, ImageBuffer b)
        {
            bool areEqual = a == b;
            return !areEqual;
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() == typeof(ImageBuffer))
            {
                return this == (ImageBuffer)obj;
            }
            return false;
        }

        public bool Equals(ImageBuffer b, int maxError = 0)
        {
            if (Width == b.Width
                && Height == b.Height
                && BitDepth == b.BitDepth
                && StrideInBytes() == b.StrideInBytes()
                && m_OriginOffset == b.m_OriginOffset)
            {
                int bytesPerPixel = BitDepth / 8;
                int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();
                int bDistanceBetweenPixels = b.GetBytesBetweenPixelsInclusive();
                byte[] aBuffer = GetBuffer();
                byte[] bBuffer = b.GetBuffer();
                for (int y = 0; y < Height; y++)
                {
                    int aBufferOffset = GetBufferOffsetY(y);
                    int bBufferOffset = b.GetBufferOffsetY(y);
                    for (int x = 0; x < Width; x++)
                    {
                        for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)
                        {
                            byte aByte = aBuffer[aBufferOffset + byteIndex];
                            byte bByte = bBuffer[bBufferOffset + byteIndex];
                            if (aByte < (bByte - maxError) || aByte > (bByte + maxError))
                            {
                                return false;
                            }
                        }
                        aBufferOffset += aDistanceBetweenPixels;
                        bBufferOffset += bDistanceBetweenPixels;
                    }
                }
                return true;
            }

            return false;
        }

        public bool Contains(ImageBuffer imageToFind, int maxError = 0)
        {
            int matchX;
            int matchY;
            return Contains(imageToFind, out matchX, out matchY, maxError);
        }

        public bool Contains(ImageBuffer imageToFind, out int matchX, out int matchY, int maxError = 0)
        {
            matchX = 0;
            matchY = 0;
            if (Width >= imageToFind.Width
                && Height >= imageToFind.Height
                && BitDepth == imageToFind.BitDepth)
            {
                int bytesPerPixel = BitDepth / 8;
                int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();
                int bDistanceBetweenPixels = imageToFind.GetBytesBetweenPixelsInclusive();
                byte[] thisBuffer = GetBuffer();
                byte[] containedBuffer = imageToFind.GetBuffer();
                for (matchY = 0; matchY <= Height - imageToFind.Height; matchY++)
                {
                    for (matchX = 0; matchX <= Width - imageToFind.Width; matchX++)
                    {
                        bool foundBadMatch = false;
                        for (int imageToFindY = 0; imageToFindY < imageToFind.Height; imageToFindY++)
                        {
                            int thisBufferOffset = GetBufferOffsetXY(matchX, matchY + imageToFindY);
                            int imageToFindBufferOffset = imageToFind.GetBufferOffsetY(imageToFindY);
                            for (int imageToFindX = 0; imageToFindX < imageToFind.Width; imageToFindX++)
                            {
                                for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)
                                {
                                    byte aByte = thisBuffer[thisBufferOffset + byteIndex];
                                    byte bByte = containedBuffer[imageToFindBufferOffset + byteIndex];
                                    if (aByte < (bByte - maxError) || aByte > (bByte + maxError))
                                    {
                                        foundBadMatch = true;
                                        byteIndex = bytesPerPixel;
                                        imageToFindX = imageToFind.Width;
                                        imageToFindY = imageToFind.Height;
                                    }
                                }
                                thisBufferOffset += aDistanceBetweenPixels;
                                imageToFindBufferOffset += bDistanceBetweenPixels;
                            }
                        }
                        if (!foundBadMatch)
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        public bool FindLeastSquaresMatch(ImageBuffer imageToFind, double maxError)
        {
            Vector2 bestPosition;
            double bestLeastSquares;
            return FindLeastSquaresMatch(imageToFind, out bestPosition, out bestLeastSquares, maxError);
        }

        public bool FindLeastSquaresMatch(ImageBuffer imageToFind, out Vector2 bestPosition, out double bestLeastSquares, double maxError = double.MaxValue)
        {
            bestPosition = Vector2.Zero;
            bestLeastSquares = double.MaxValue;

            if (Width >= imageToFind.Width
                && Height >= imageToFind.Height
                && BitDepth == imageToFind.BitDepth)
            {
                int bytesPerPixel = BitDepth / 8;
                int aDistanceBetweenPixels = GetBytesBetweenPixelsInclusive();
                int bDistanceBetweenPixels = imageToFind.GetBytesBetweenPixelsInclusive();
                byte[] thisBuffer = GetBuffer();
                byte[] containedBuffer = imageToFind.GetBuffer();
                for (int matchY = 0; matchY <= Height - imageToFind.Height; matchY++)
                {
                    for (int matchX = 0; matchX <= Width - imageToFind.Width; matchX++)
                    {
                        double currentLeastSquares = 0;

                        for (int imageToFindY = 0; imageToFindY < imageToFind.Height; imageToFindY++)
                        {
                            int thisBufferOffset = GetBufferOffsetXY(matchX, matchY + imageToFindY);
                            int imageToFindBufferOffset = imageToFind.GetBufferOffsetY(imageToFindY);
                            for (int imageToFindX = 0; imageToFindX < imageToFind.Width; imageToFindX++)
                            {
                                for (int byteIndex = 0; byteIndex < bytesPerPixel; byteIndex++)
                                {
                                    byte aByte = thisBuffer[thisBufferOffset + byteIndex];
                                    byte bByte = containedBuffer[imageToFindBufferOffset + byteIndex];
                                    int difference = (int)aByte - (int)bByte;
                                    currentLeastSquares += difference * difference;
                                }
                                thisBufferOffset += aDistanceBetweenPixels;
                                imageToFindBufferOffset += bDistanceBetweenPixels;
                            }
                            if (currentLeastSquares > maxError)
                            {
                                // stop checking we have too much error.
                                imageToFindY = imageToFind.Height;
                            }
                        }
                        if (currentLeastSquares < bestLeastSquares)
                        {
                            bestPosition = new Vector2(matchX, matchY);
                            bestLeastSquares = currentLeastSquares;
                        }
                    }
                }
            }

            return bestLeastSquares <= maxError;
        }

        public override int GetHashCode()
        {
            // This might be hard to make fast and usefull.
            return m_ByteBuffer.GetHashCode() ^ bufferOffset.GetHashCode() ^ bufferFirstPixel.GetHashCode();
        }

        public RectangleInt GetBoundingRect()
        {
            RectangleInt boundingRect = new RectangleInt(0, 0, Width, Height);
            boundingRect.Offset((int)OriginOffset.x, (int)OriginOffset.y);
            return boundingRect;
        }

        private void Initialize(ImageBuffer sourceImage)
        {
            RectangleInt sourceBoundingRect = sourceImage.GetBoundingRect();

            Initialize(sourceImage, sourceBoundingRect);
            OriginOffset = sourceImage.OriginOffset;
        }

        private void Initialize(ImageBuffer sourceImage, RectangleInt boundsToCopyFrom)
        {
            if (sourceImage == this)
            {
                throw new Exception("We do not create a temp buffer for this to work.  You must have a source distinct from the dest.");
            }
            Deallocate();
            Allocate(boundsToCopyFrom.Width, boundsToCopyFrom.Height, boundsToCopyFrom.Width * sourceImage.BitDepth / 8, sourceImage.BitDepth);
            SetRecieveBlender(sourceImage.GetRecieveBlender());

            if (width != 0 && height != 0)
            {
                RectangleInt DestRect = new RectangleInt(0, 0, boundsToCopyFrom.Width, boundsToCopyFrom.Height);
                RectangleInt AbsoluteSourceRect = boundsToCopyFrom;
                // The first thing we need to do is make sure the frame is cleared. LBB [3/15/2004]
                MatterHackers.Agg.Graphics2D graphics2D = NewGraphics2D();
                graphics2D.Clear(new RGBA_Bytes(0, 0, 0, 0));

                int x = -boundsToCopyFrom.Left - (int)sourceImage.OriginOffset.x;
                int y = -boundsToCopyFrom.Bottom - (int)sourceImage.OriginOffset.y;

                graphics2D.Render(sourceImage, x, y, 0, 1, 1);
            }
        }

        public void SetPixel32(int p, int p_2, uint p_3)
        {
            throw new NotImplementedException();
        }

        public uint GetPixel32(double p, double p_2)
        {
            throw new NotImplementedException();
        }
    }

    public static class DoCopyOrBlend
    {
        const byte base_mask = 255;

        public static void BasedOnAlpha(IRecieveBlenderByte recieveBlender, byte[] destBuffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            //if (sourceColor.m_A != 0)
            {
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have addative and faster blending in one blender) LBB
                if (sourceColor.m_A == base_mask)
                {
                    Blender.CopyPixel(pDestBuffer, sourceColor);
                }
                else
#endif
                {
                    recieveBlender.BlendPixel(destBuffer, bufferOffset, sourceColor);
                }
            }
        }

        public static void BasedOnAlphaAndCover(IRecieveBlenderByte recieveBlender, byte[] destBuffer, int bufferOffset, RGBA_Bytes sourceColor, int cover)
        {
            if (cover == 255)
            {
                BasedOnAlpha(recieveBlender, destBuffer, bufferOffset, sourceColor);
            }
            else
            {
                //if (sourceColor.m_A != 0)
                {
                    sourceColor.alpha = (byte)((sourceColor.alpha * (cover + 1)) >> 8);
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have addative and faster blending in one blender) LBB
                    if (sourceColor.m_A == base_mask)
                    {
                        Blender.CopyPixel(pDestBuffer, sourceColor);
                    }
                    else
#endif
                    {
                        recieveBlender.BlendPixel(destBuffer, bufferOffset, sourceColor);
                    }
                }
            }
        }
    };
}

#endregion //ImageBuffer.cs
#region ImageBufferFloat.cs

namespace MatterHackers.Agg.Image
{
    public class ImageBufferFloat : IImageFloat
    {
        public const int OrderB = 0;
        public const int OrderG = 1;
        public const int OrderR = 2;
        public const int OrderA = 3;

        internal class InternalImageGraphics2D : ImageGraphics2D
        {
            ImageBufferFloat m_Owner;

            internal InternalImageGraphics2D(ImageBufferFloat owner)
                : base()
            {
                m_Owner = owner;

                ScanlineRasterizer rasterizer = new ScanlineRasterizer();
                ImageClippingProxyFloat imageClippingProxy = new ImageClippingProxyFloat(owner);

                Initialize(imageClippingProxy, rasterizer);
                ScanlineCache = new ScanlineCachePacked8();
            }
        };

        protected int[] m_yTable;
        protected int[] m_xTable;
        private float[] m_FloatBuffer;
        int m_BufferOffset; // the beggining of the image in this buffer
        int m_BufferFirstPixel; // Pointer to first pixel depending on strideInFloats and image position

        int m_Width;  // Width in pixels
        int m_Height; // Height in pixels
        int m_StrideInFloats; // Number of bytes per row. Can be < 0
        int m_DistanceInFloatsBetweenPixelsInclusive;
        int m_BitDepth;
        Vector2 m_OriginOffset = new Vector2(0, 0);

        private IRecieveBlenderFloat m_Blender;

        int changedCount = 0;
        public int ChangedCount { get { return changedCount; } }
        public void MarkImageChanged()
        {
            // mark this unchecked as we don't want to throw an exception if this rolls over.
            unchecked
            {
                changedCount++;
            }
        }

        public ImageBufferFloat()
        {
        }

        public ImageBufferFloat(IRecieveBlenderFloat blender)
        {
            SetBlender(blender);
        }

        public ImageBufferFloat(IImageFloat sourceImage, IRecieveBlenderFloat blender)
        {
            SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInFloats(), sourceImage.BitDepth, sourceImage.GetFloatsBetweenPixelsInclusive());
            int offset = sourceImage.GetBufferOffsetXY(0, 0);
            float[] buffer = sourceImage.GetBuffer();
            float[] newBuffer = new float[buffer.Length];
            agg_basics.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
            SetBuffer(newBuffer, offset);
            SetBlender(blender);
        }

        public ImageBufferFloat(int width, int height, int bitsPerPixel, IRecieveBlenderFloat blender)
        {
            Allocate(width, height, width * (bitsPerPixel / 32), bitsPerPixel);
            SetBlender(blender);
        }

#if false
        public ImageBuffer(IImageFloat image, IBlenderFloat blender, GammaLookUpTable gammaTable)
        {
            unsafe
            {
                AttachBuffer(image.GetBuffer(), image.Width, image.Height, image.StrideInBytes(), image.BitDepth, image.GetDistanceBetweenPixelsInclusive());
            }

            SetBlender(blender);
        }
#endif

        public ImageBufferFloat(IImageFloat sourceImageToCopy, IRecieveBlenderFloat blender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
        {
            SetDimmensionAndFormat(sourceImageToCopy.Width, sourceImageToCopy.Height, sourceImageToCopy.StrideInFloats(), bitsPerPixel, distanceBetweenPixelsInclusive);
            int offset = sourceImageToCopy.GetBufferOffsetXY(0, 0);
            float[] buffer = sourceImageToCopy.GetBuffer();
            float[] newBuffer = new float[buffer.Length];
            throw new NotImplementedException();
            //agg_basics.memcpy(newBuffer, offset, buffer, offset, buffer.Length - offset);
            //SetBuffer(newBuffer, offset + bufferOffset);
            //SetBlender(blender);
        }

        public void AttachBuffer(float[] buffer, int bufferOffset, int width, int height, int strideInBytes, int bitDepth, int distanceInBytesBetweenPixelsInclusive)
        {
            m_FloatBuffer = null;
            SetDimmensionAndFormat(width, height, strideInBytes, bitDepth, distanceInBytesBetweenPixelsInclusive);
            SetBuffer(buffer, bufferOffset);
        }

        public void Attach(IImageFloat sourceImage, IRecieveBlenderFloat blender, int distanceBetweenPixelsInclusive, int bufferOffset, int bitsPerPixel)
        {
            SetDimmensionAndFormat(sourceImage.Width, sourceImage.Height, sourceImage.StrideInFloats(), bitsPerPixel, distanceBetweenPixelsInclusive);
            int offset = sourceImage.GetBufferOffsetXY(0, 0);
            float[] buffer = sourceImage.GetBuffer();
            SetBuffer(buffer, offset + bufferOffset);
            SetBlender(blender);
        }

        public void Attach(IImageFloat sourceImage, IRecieveBlenderFloat blender)
        {
            Attach(sourceImage, blender, sourceImage.GetFloatsBetweenPixelsInclusive(), 0, sourceImage.BitDepth);
        }

        public bool Attach(IImageFloat sourceImage, int x1, int y1, int x2, int y2)
        {
            m_FloatBuffer = null;
            DettachBuffer();

            if (x1 > x2 || y1 > y2)
            {
                throw new Exception("You need to have your x1 and y1 be the lower left corner of your sub image.");
            }
            RectangleInt boundsRect = new RectangleInt(x1, y1, x2, y2);
            if (boundsRect.clip(new RectangleInt(0, 0, (int)sourceImage.Width - 1, (int)sourceImage.Height - 1)))
            {
                SetDimmensionAndFormat(boundsRect.Width, boundsRect.Height, sourceImage.StrideInFloats(), sourceImage.BitDepth, sourceImage.GetFloatsBetweenPixelsInclusive());
                int bufferOffset = sourceImage.GetBufferOffsetXY(boundsRect.Left, boundsRect.Bottom);
                float[] buffer = sourceImage.GetBuffer();
                SetBuffer(buffer, bufferOffset);
                return true;
            }

            return false;
        }

        public void SetAlpha(byte value)
        {
            if (BitDepth != 32)
            {
                throw new Exception("You don't have alpha channel to set.  Your image has a bit depth of " + BitDepth.ToString() + ".");
            }
            int numPixels = Width * Height;
            int offset;
            float[] buffer = GetBuffer(out offset);
            for (int i = 0; i < numPixels; i++)
            {
                buffer[offset + i * 4 + 3] = value;
            }
        }

        private void Deallocate()
        {
            m_FloatBuffer = null;
            SetDimmensionAndFormat(0, 0, 0, 32, 4);
        }

        public void Allocate(int inWidth, int inHeight, int inScanWidthInFloats, int bitsPerPixel)
        {
            if (bitsPerPixel != 128 && bitsPerPixel != 96 && bitsPerPixel != 32)
            {
                throw new Exception("Unsupported bits per pixel.");
            }
            if (inScanWidthInFloats < inWidth * (bitsPerPixel / 32))
            {
                throw new Exception("Your scan width is not big enough to hold your width and height.");
            }
            SetDimmensionAndFormat(inWidth, inHeight, inScanWidthInFloats, bitsPerPixel, bitsPerPixel / 32);

            m_FloatBuffer = new float[m_StrideInFloats * m_Height];

            SetUpLookupTables();
        }

        public Graphics2D NewGraphics2D()
        {
            InternalImageGraphics2D imageRenderer = new InternalImageGraphics2D(this);

            imageRenderer.Rasterizer.SetVectorClipBox(0, 0, Width, Height);

            return imageRenderer;
        }

        public void CopyFrom(IImageFloat sourceImage)
        {
            CopyFrom(sourceImage, sourceImage.GetBounds(), 0, 0);
        }

        protected void CopyFromNoClipping(IImageFloat sourceImage, RectangleInt clippedSourceImageRect, int destXOffset, int destYOffset)
        {
            if (GetFloatsBetweenPixelsInclusive() != BitDepth / 32
                || sourceImage.GetFloatsBetweenPixelsInclusive() != sourceImage.BitDepth / 32)
            {
                throw new Exception("WIP we only support packed pixel formats at this time.");
            }

            if (BitDepth == sourceImage.BitDepth)
            {
                int lengthInFloats = clippedSourceImageRect.Width * GetFloatsBetweenPixelsInclusive();

                int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom);
                float[] sourceBuffer = sourceImage.GetBuffer();
                int destOffset;
                float[] destBuffer = GetPixelPointerXY(clippedSourceImageRect.Left + destXOffset, clippedSourceImageRect.Bottom + destYOffset, out destOffset);

                for (int i = 0; i < clippedSourceImageRect.Height; i++)
                {
                    agg_basics.memmove(destBuffer, destOffset, sourceBuffer, sourceOffset, lengthInFloats);
                    sourceOffset += sourceImage.StrideInFloats();
                    destOffset += StrideInFloats();
                }
            }
            else
            {
                bool haveConversion = true;
                switch (sourceImage.BitDepth)
                {
                    case 24:
                        switch (BitDepth)
                        {
                            case 32:
                                {
                                    int numPixelsToCopy = clippedSourceImageRect.Width;
                                    for (int i = clippedSourceImageRect.Bottom; i < clippedSourceImageRect.Top; i++)
                                    {
                                        int sourceOffset = sourceImage.GetBufferOffsetXY(clippedSourceImageRect.Left, clippedSourceImageRect.Bottom + i);
                                        float[] sourceBuffer = sourceImage.GetBuffer();
                                        int destOffset;
                                        float[] destBuffer = GetPixelPointerXY(
                                            clippedSourceImageRect.Left + destXOffset,
                                            clippedSourceImageRect.Bottom + i + destYOffset,
                                            out destOffset);
                                        for (int x = 0; x < numPixelsToCopy; x++)
                                        {
                                            destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
                                            destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
                                            destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
                                            destBuffer[destOffset++] = 255;
                                        }
                                    }
                                }
                                break;

                            default:
                                haveConversion = false;
                                break;
                        }
                        break;

                    default:
                        haveConversion = false;
                        break;
                }

                if (!haveConversion)
                {
                    throw new NotImplementedException("You need to write the " + sourceImage.BitDepth.ToString() + " to " + BitDepth.ToString() + " conversion");
                }
            }
        }

        public void CopyFrom(IImageFloat sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
        {
            RectangleInt sourceImageBounds = sourceImage.GetBounds();
            RectangleInt clippedSourceImageRect = new RectangleInt();
            if (clippedSourceImageRect.IntersectRectangles(sourceImageRect, sourceImageBounds))
            {
                RectangleInt destImageRect = clippedSourceImageRect;
                destImageRect.Offset(destXOffset, destYOffset);
                RectangleInt destImageBounds = GetBounds();
                RectangleInt clippedDestImageRect = new RectangleInt();
                if (clippedDestImageRect.IntersectRectangles(destImageRect, destImageBounds))
                {
                    // we need to make sure the source is also clipped to the dest. So, we'll copy this back to source and offset it.
                    clippedSourceImageRect = clippedDestImageRect;
                    clippedSourceImageRect.Offset(-destXOffset, -destYOffset);
                    CopyFromNoClipping(sourceImage, clippedSourceImageRect, destXOffset, destYOffset);
                }
            }
        }

        public Vector2 OriginOffset
        {
            get { return m_OriginOffset; }
            set { m_OriginOffset = value; }
        }

        public int Width { get { return m_Width; } }
        public int Height { get { return m_Height; } }
        public int StrideInFloats() { return m_StrideInFloats; }
        public int StrideInFloatsAbs() { return System.Math.Abs(m_StrideInFloats); }
        public int GetFloatsBetweenPixelsInclusive() { return m_DistanceInFloatsBetweenPixelsInclusive; }
        public int BitDepth
        {
            get { return m_BitDepth; }
        }

        public virtual RectangleInt GetBounds()
        {
            return new RectangleInt(-(int)m_OriginOffset.x, -(int)m_OriginOffset.y, Width - (int)m_OriginOffset.x, Height - (int)m_OriginOffset.y);
        }

        public IRecieveBlenderFloat GetBlender()
        {
            return m_Blender;
        }

        public void SetBlender(IRecieveBlenderFloat value)
        {
            if (value != null && value.NumPixelBits != BitDepth)
            {
                throw new NotSupportedException("The blender has to support the bit depth of this image.");
            }
            m_Blender = value;
        }

        private void SetUpLookupTables()
        {
            m_yTable = new int[m_Height];
            for (int i = 0; i < m_Height; i++)
            {
                m_yTable[i] = i * m_StrideInFloats;
            }

            m_xTable = new int[m_Width];
            for (int i = 0; i < m_Width; i++)
            {
                m_xTable[i] = i * m_DistanceInFloatsBetweenPixelsInclusive;
            }
        }

        public void FlipY()
        {
            m_StrideInFloats *= -1;
            m_BufferFirstPixel = m_BufferOffset;
            if (m_StrideInFloats < 0)
            {
                int addAmount = -((int)((int)m_Height - 1) * m_StrideInFloats);
                m_BufferFirstPixel = addAmount + m_BufferOffset;
            }

            SetUpLookupTables();
        }

        public void SetBuffer(float[] floatBuffer, int bufferOffset)
        {
            if (floatBuffer.Length < m_Height * m_StrideInFloats)
            {
                throw new Exception("Your buffer does not have enough room it it for your height and strideInBytes.");
            }
            m_FloatBuffer = floatBuffer;
            m_BufferOffset = m_BufferFirstPixel = bufferOffset;
            if (m_StrideInFloats < 0)
            {
                int addAmount = -((int)((int)m_Height - 1) * m_StrideInFloats);
                m_BufferFirstPixel = addAmount + m_BufferOffset;
            }
            SetUpLookupTables();
        }

        private void SetDimmensionAndFormat(int width, int height, int strideInFloats, int bitDepth, int distanceInFloatsBetweenPixelsInclusive)
        {
            if (m_FloatBuffer != null)
            {
                throw new Exception("You already have a buffer set. You need to set dimmensoins before the buffer.  You may need to clear the buffer first.");
            }
            m_Width = width;
            m_Height = height;
            m_StrideInFloats = strideInFloats;
            m_BitDepth = bitDepth;
            if (distanceInFloatsBetweenPixelsInclusive > 4)
            {
                throw new System.Exception("It looks like you are passing bits per pixel rather than distance in Floats.");
            }
            if (distanceInFloatsBetweenPixelsInclusive < (bitDepth / 32))
            {
                throw new Exception("You do not have enough room between pixels to support your bit depth.");
            }
            m_DistanceInFloatsBetweenPixelsInclusive = distanceInFloatsBetweenPixelsInclusive;
            if (strideInFloats < distanceInFloatsBetweenPixelsInclusive * width)
            {
                throw new Exception("You do not have enough strideInFloats to hold the width and pixel distance you have described.");
            }
        }

        public void DettachBuffer()
        {
            m_FloatBuffer = null;
            m_Width = m_Height = m_StrideInFloats = m_DistanceInFloatsBetweenPixelsInclusive = 0;
        }

        public float[] GetBuffer()
        {
            return m_FloatBuffer;
        }

        public float[] GetBuffer(out int bufferOffset)
        {
            bufferOffset = m_BufferOffset;
            return m_FloatBuffer;
        }

        public float[] GetPixelPointerY(int y, out int bufferOffset)
        {
            bufferOffset = m_BufferFirstPixel + m_yTable[y];
            //bufferOffset = GetBufferOffsetXY(0, y);
            return m_FloatBuffer;
        }

        public float[] GetPixelPointerXY(int x, int y, out int bufferOffset)
        {
            bufferOffset = GetBufferOffsetXY(x, y);
            return m_FloatBuffer;
        }

        public RGBA_Floats GetPixel(int x, int y)
        {
            return m_Blender.PixelToColorRGBA_Floats(m_FloatBuffer, GetBufferOffsetXY(x, y));
        }

        public virtual void SetPixel(int x, int y, RGBA_Floats color)
        {
            x -= (int)m_OriginOffset.x;
            y -= (int)m_OriginOffset.y;
            m_Blender.CopyPixels(GetBuffer(), GetBufferOffsetXY(x, y), color, 1);
        }

        public int GetBufferOffsetY(int y)
        {
            return m_BufferFirstPixel + m_yTable[y];
        }

        public int GetBufferOffsetXY(int x, int y)
        {
            return m_BufferFirstPixel + m_yTable[y] + m_xTable[x];
        }

        public void copy_pixel(int x, int y, float[] c, int ByteOffset)
        {
            throw new System.NotImplementedException();
            //byte* p = GetPixelPointerXY(x, y);
            //((int*)p)[0] = ((int*)c)[0];
            //p[OrderR] = c.r;
            //p[OrderG] = c.g;
            //p[OrderB] = c.b;
            //p[OrderA] = c.a;
        }

        public void BlendPixel(int x, int y, RGBA_Floats c, byte cover)
        {
            throw new System.NotImplementedException();
            /*
            cob_type::copy_or_blend_pix(
                (value_type*)m_rbuf->row_ptr(x, y, 1)  + x + x + x, 
                c.r, c.g, c.b, c.a, 
                cover);*/
        }

        public void SetPixelFromColor(float[] destPixel, IColorType c)
        {
            throw new System.NotImplementedException();
            //pDestPixel[OrderR] = (byte)c.R_Byte;
            //pDestPixel[OrderG] = (byte)c.G_Byte;
            //pDestPixel[OrderB] = (byte)c.B_Byte;
        }

        public void copy_hline(int x, int y, int len, RGBA_Floats sourceColor)
        {
            int bufferOffset;
            float[] buffer = GetPixelPointerXY(x, y, out bufferOffset);

            m_Blender.CopyPixels(buffer, bufferOffset, sourceColor, len);
        }

        public void copy_vline(int x, int y, int len, RGBA_Floats sourceColor)
        {
            throw new NotImplementedException();
#if false
            int scanWidth = StrideInBytes();
            byte* pDestBuffer = GetPixelPointerXY(x, y);
            do
            {
                m_Blender.CopyPixel(pDestBuffer, sourceColor);
                pDestBuffer = &pDestBuffer[scanWidth];
            }
            while (--len != 0);
#endif
        }


        public void blend_hline(int x1, int y, int x2, RGBA_Floats sourceColor, byte cover)
        {
            if (sourceColor.alpha != 0)
            {
                int len = x2 - x1 + 1;

                int bufferOffset;
                float[] buffer = GetPixelPointerXY(x1, y, out bufferOffset);

                float alpha = sourceColor.alpha * (cover * (1.0f / 255.0f));
                if (alpha == 1)
                {
                    m_Blender.CopyPixels(buffer, bufferOffset, sourceColor, len);
                }
                else
                {
                    do
                    {
                        m_Blender.BlendPixel(buffer, bufferOffset, new RGBA_Floats(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
                        bufferOffset += m_DistanceInFloatsBetweenPixelsInclusive;
                    }
                    while (--len != 0);
                }
            }
        }

        public void blend_vline(int x, int y1, int y2, RGBA_Floats sourceColor, byte cover)
        {
            throw new NotImplementedException();
#if false
            int ScanWidth = StrideInBytes();
            if (sourceColor.m_A != 0)
            {
                unsafe
                {
                    int len = y2 - y1 + 1;
                    byte* p = GetPixelPointerXY(x, y1);
                    sourceColor.m_A = (byte)(((int)(sourceColor.m_A) * (cover + 1)) >> 8);
                    if (sourceColor.m_A == base_mask)
                    {
                        byte cr = sourceColor.m_R;
                        byte cg = sourceColor.m_G;
                        byte cb = sourceColor.m_B;
                        do
                        {
                            m_Blender.CopyPixel(p, sourceColor);
                            p = &p[ScanWidth];
                        }
                        while (--len != 0);
                    }
                    else
                    {
                        if (cover == 255)
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                        else
                        {
                            do
                            {
                                m_Blender.BlendPixel(p, sourceColor);
                                p = &p[ScanWidth];
                            }
                            while (--len != 0);
                        }
                    }
                }
            }
#endif
        }

        public void blend_solid_hspan(int x, int y, int len, RGBA_Floats sourceColor, byte[] covers, int coversIndex)
        {
            float colorAlpha = sourceColor.alpha;
            if (colorAlpha != 0)
            {
                unchecked
                {
                    int bufferOffset;
                    float[] buffer = GetPixelPointerXY(x, y, out bufferOffset);

                    do
                    {
                        float alpha = colorAlpha * (covers[coversIndex] * (1.0f / 255.0f));
                        if (alpha == 1)
                        {
                            m_Blender.CopyPixels(buffer, bufferOffset, sourceColor, 1);
                        }
                        else
                        {
                            m_Blender.BlendPixel(buffer, bufferOffset, new RGBA_Floats(sourceColor.red, sourceColor.green, sourceColor.blue, alpha));
                        }
                        bufferOffset += m_DistanceInFloatsBetweenPixelsInclusive;
                        coversIndex++;
                    }
                    while (--len != 0);
                }
            }
        }

        public void blend_solid_vspan(int x, int y, int len, RGBA_Floats c, byte[] covers, int coversIndex)
        {
            throw new NotImplementedException();
#if false
            if (sourceColor.m_A != 0)
            {
                int ScanWidth = StrideInBytes();
                unchecked
                {
                    byte* p = GetPixelPointerXY(x, y);
                    do
                    {
                        byte oldAlpha = sourceColor.m_A;
                        sourceColor.m_A = (byte)(((int)(sourceColor.m_A) * ((int)(*covers++) + 1)) >> 8);
                        if (sourceColor.m_A == base_mask)
                        {
                            m_Blender.CopyPixel(p, sourceColor);
                        }
                        else
                        {
                            m_Blender.BlendPixel(p, sourceColor);
                        }
                        p = &p[ScanWidth];
                        sourceColor.m_A = oldAlpha;
                    }
                    while (--len != 0);
                }
            }
#endif
        }

        public void copy_color_hspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);

            do
            {
                m_Blender.CopyPixels(m_FloatBuffer, bufferOffset, colors[colorsIndex], 1);

                ++colorsIndex;
                bufferOffset += m_DistanceInFloatsBetweenPixelsInclusive;
            }
            while (--len != 0);
        }

        public void copy_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);

            do
            {
                m_Blender.CopyPixels(m_FloatBuffer, bufferOffset, colors[colorsIndex], 1);

                ++colorsIndex;
                bufferOffset += m_StrideInFloats;
            }
            while (--len != 0);
        }

        public void blend_color_hspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);
            m_Blender.BlendPixels(m_FloatBuffer, bufferOffset, colors, colorsIndex, covers, coversIndex, firstCoverForAll, len);
        }

        public void blend_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            int bufferOffset = GetBufferOffsetXY(x, y);

            int ScanWidth = StrideInFloatsAbs();
            if (!firstCoverForAll)
            {
                do
                {
                    DoCopyOrBlendFloat.BasedOnAlphaAndCover(m_Blender, m_FloatBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex++]);
                    bufferOffset += ScanWidth;
                    ++colorsIndex;
                }
                while (--len != 0);
            }
            else
            {
                if (covers[coversIndex] == 1)
                {
                    do
                    {
                        DoCopyOrBlendFloat.BasedOnAlpha(m_Blender, m_FloatBuffer, bufferOffset, colors[colorsIndex]);
                        bufferOffset += ScanWidth;
                        ++colorsIndex;
                    }
                    while (--len != 0);
                }
                else
                {
                    do
                    {

                        DoCopyOrBlendFloat.BasedOnAlphaAndCover(m_Blender, m_FloatBuffer, bufferOffset, colors[colorsIndex], covers[coversIndex]);
                        bufferOffset += ScanWidth;
                        ++colorsIndex;
                    }
                    while (--len != 0);
                }
            }
        }

        public void apply_gamma_inv(GammaLookUpTable g)
        {
            throw new System.NotImplementedException();
            //for_each_pixel(apply_gamma_inv_rgba<color_type, order_type, GammaLut>(g));
        }

        private bool IsPixelVisible(int x, int y)
        {
            RGBA_Floats pixelValue = GetBlender().PixelToColorRGBA_Floats(m_FloatBuffer, GetBufferOffsetXY(x, y));
            return (pixelValue.Alpha0To255 != 0 || pixelValue.Red0To255 != 0 || pixelValue.Green0To255 != 0 || pixelValue.Blue0To255 != 0);
        }

        public void GetVisibleBounds(out RectangleInt visibleBounds)
        {
            visibleBounds = new RectangleInt(0, 0, Width, Height);

            // trim the bottom
            bool aPixelsIsVisible = false;
            for (int y = 0; y < m_Height; y++)
            {
                for (int x = 0; x < m_Width; x++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Bottom = y;
                        y = m_Height;
                        x = m_Width;
                        aPixelsIsVisible = true;
                    }
                }
            }

            // if we don't run into any pixels set for the top trim than there are no pixels set at all
            if (!aPixelsIsVisible)
            {
                visibleBounds.SetRect(0, 0, 0, 0);
                return;
            }

            // trim the bottom
            for (int y = m_Height - 1; y >= 0; y--)
            {
                for (int x = 0; x < m_Width; x++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Top = y + 1;
                        y = -1;
                        x = m_Width;
                    }
                }
            }

            // trim the left
            for (int x = 0; x < m_Width; x++)
            {
                for (int y = 0; y < m_Height; y++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Left = x;
                        y = m_Height;
                        x = m_Width;
                    }
                }
            }

            // trim the right
            for (int x = m_Width - 1; x >= 0; x--)
            {
                for (int y = 0; y < m_Height; y++)
                {
                    if (IsPixelVisible(x, y))
                    {
                        visibleBounds.Right = x + 1;
                        y = m_Height;
                        x = -1;
                    }
                }
            }
        }

        public void CropToVisible()
        {
            Vector2 OldOriginOffset = OriginOffset;

            //Move the HotSpot to 0, 0 so PPoint will work the way we want
            OriginOffset = new Vector2(0, 0);

            RectangleInt visibleBounds;
            GetVisibleBounds(out visibleBounds);

            if (visibleBounds.Width == Width
                && visibleBounds.Height == Height)
            {
                OriginOffset = OldOriginOffset;
                return;
            }

            // check if the Not0Rect has any size
            if (visibleBounds.Width > 0)
            {
                ImageBufferFloat TempImage = new ImageBufferFloat();

                // set TempImage equal to the Not0Rect
                TempImage.Initialize(this, visibleBounds);

                // set the frame equal to the TempImage
                Initialize(TempImage);

                OriginOffset = new Vector2(-visibleBounds.Left + OldOriginOffset.x, -visibleBounds.Bottom + OldOriginOffset.y);
            }
            else
            {
                Deallocate();
            }
        }

        public RectangleInt GetBoundingRect()
        {
            RectangleInt boundingRect = new RectangleInt(0, 0, Width, Height);
            boundingRect.Offset((int)OriginOffset.x, (int)OriginOffset.y);
            return boundingRect;
        }

        private void Initialize(ImageBufferFloat sourceImage)
        {
            RectangleInt sourceBoundingRect = sourceImage.GetBoundingRect();

            Initialize(sourceImage, sourceBoundingRect);
            OriginOffset = sourceImage.OriginOffset;
        }

        private void Initialize(ImageBufferFloat sourceImage, RectangleInt boundsToCopyFrom)
        {
            if (sourceImage == this)
            {
                throw new Exception("We do not create a temp buffer for this to work.  You must have a source distinct from the dest.");
            }
            Deallocate();
            Allocate(boundsToCopyFrom.Width, boundsToCopyFrom.Height, boundsToCopyFrom.Width * sourceImage.BitDepth / 8, sourceImage.BitDepth);
            SetBlender(sourceImage.GetBlender());

            if (m_Width != 0 && m_Height != 0)
            {
                RectangleInt DestRect = new RectangleInt(0, 0, boundsToCopyFrom.Width, boundsToCopyFrom.Height);
                RectangleInt AbsoluteSourceRect = boundsToCopyFrom;
                // The first thing we need to do is make sure the frame is cleared. LBB [3/15/2004]
                Graphics2D graphics2D = NewGraphics2D();
                graphics2D.Clear(new RGBA_Floats(0, 0, 0, 0));

                int x = -boundsToCopyFrom.Left - (int)sourceImage.OriginOffset.x;
                int y = -boundsToCopyFrom.Bottom - (int)sourceImage.OriginOffset.y;

                graphics2D.Render(sourceImage, x, y, 0, 1, 1);
            }
        }
    }

    public static class DoCopyOrBlendFloat
    {
        const byte base_mask = 255;

        public static void BasedOnAlpha(IRecieveBlenderFloat Blender, float[] destBuffer, int bufferOffset, RGBA_Floats sourceColor)
        {
            //if (sourceColor.m_A != 0)
            {
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have addative and faster blending in one blender) LBB
                if (sourceColor.m_A == base_mask)
                {
                    Blender.CopyPixel(pDestBuffer, sourceColor);
                }
                else
#endif
                {
                    Blender.BlendPixel(destBuffer, bufferOffset, sourceColor);
                }
            }
        }

        public static void BasedOnAlphaAndCover(IRecieveBlenderFloat Blender, float[] destBuffer, int bufferOffset, RGBA_Floats sourceColor, int cover)
        {
            if (cover == 255)
            {
                BasedOnAlpha(Blender, destBuffer, bufferOffset, sourceColor);
            }
            else
            {
                //if (sourceColor.m_A != 0)
                {
                    sourceColor.alpha = sourceColor.alpha * ((float)cover * (1 / 255));
#if false // we blend regardless of the alpha so that we can get Light Opacity working (used this way we have addative and faster blending in one blender) LBB
                    if (sourceColor.m_A == base_mask)
                    {
                        Blender.CopyPixel(pDestBuffer, sourceColor);
                    }
                    else
#endif
                    {
                        Blender.BlendPixel(destBuffer, bufferOffset, sourceColor);
                    }
                }
            }
        }
    };
}

#endregion //ImageBufferFloat.cs
#region ImageGraphics2D.cs

namespace MatterHackers.Agg
{
    public class ImageGraphics2D : Graphics2D
    {
        const int cover_full = 255;
        protected IScanlineCache m_ScanlineCache;
        PathStorage drawImageRectPath = new PathStorage();
        MatterHackers.Agg.span_allocator destImageSpanAllocatorCache = new span_allocator();
        ScanlineCachePacked8 drawImageScanlineCache = new ScanlineCachePacked8();
        ScanlineRenderer scanlineRenderer = new ScanlineRenderer();

        public ImageGraphics2D()
        {
        }

        public ImageGraphics2D(IImageByte destImage, ScanlineRasterizer rasterizer, IScanlineCache scanlineCache)
            : base(destImage, rasterizer)
        {
            m_ScanlineCache = scanlineCache;
        }

        public override IScanlineCache ScanlineCache
        {
            get { return m_ScanlineCache; }
            set { m_ScanlineCache = value; }
        }

        public override void SetClippingRect(RectangleDouble clippingRect)
        {
            Rasterizer.SetVectorClipBox(clippingRect);
        }

        public override RectangleDouble GetClippingRect()
        {
            return Rasterizer.GetVectorClipBox();
        }

        public override void Render(IVertexSource vertexSource, int pathIndexToRender, RGBA_Bytes colorBytes)
        {
            rasterizer.reset();
            Affine transform = GetTransform();
            if (!transform.is_identity())
            {
                vertexSource = new VertexSourceApplyTransform(vertexSource, transform);
            }
            rasterizer.add_path(vertexSource, pathIndexToRender);
            if (destImageByte != null)
            {
                scanlineRenderer.render_scanlines_aa_solid(destImageByte, rasterizer, m_ScanlineCache, colorBytes);
                DestImage.MarkImageChanged();
            }
            else
            {
                scanlineRenderer.RenderSolid(destImageFloat, rasterizer, m_ScanlineCache, colorBytes.GetAsRGBA_Floats());
                destImageFloat.MarkImageChanged();
            }
        }

        void DrawImageGetDestBounds(IImageByte sourceImage,
            double DestX, double DestY,
            double HotspotOffsetX, double HotspotOffsetY,
            double ScaleX, double ScaleY,
            double AngleRad, out Affine destRectTransform)
        {
            destRectTransform = Affine.NewIdentity();

            if (HotspotOffsetX != 0.0f || HotspotOffsetY != 0.0f)
            {
                destRectTransform *= Affine.NewTranslation(-HotspotOffsetX, -HotspotOffsetY);
            }

            if (ScaleX != 1 || ScaleY != 1)
            {
                destRectTransform *= Affine.NewScaling(ScaleX, ScaleY);
            }

            if (AngleRad != 0)
            {
                destRectTransform *= Affine.NewRotation(AngleRad);
            }

            if (DestX != 0 || DestY != 0)
            {
                destRectTransform *= Affine.NewTranslation(DestX, DestY);
            }

            int SourceBufferWidth = (int)sourceImage.Width;
            int SourceBufferHeight = (int)sourceImage.Height;

            drawImageRectPath.remove_all();

            drawImageRectPath.MoveTo(0, 0);
            drawImageRectPath.LineTo(SourceBufferWidth, 0);
            drawImageRectPath.LineTo(SourceBufferWidth, SourceBufferHeight);
            drawImageRectPath.LineTo(0, SourceBufferHeight);
            drawImageRectPath.ClosePolygon();
        }

        void DrawImage(IImageByte sourceImage, ISpanGenerator spanImageFilter, Affine destRectTransform)
        {
            if (destImageByte.OriginOffset.x != 0 || destImageByte.OriginOffset.y != 0)
            {
                destRectTransform *= Affine.NewTranslation(-destImageByte.OriginOffset.x, -destImageByte.OriginOffset.y);
            }

            VertexSourceApplyTransform transfromedRect = new VertexSourceApplyTransform(drawImageRectPath, destRectTransform);
            Rasterizer.add_path(transfromedRect);
            {
                ImageClippingProxy destImageWithClipping = new ImageClippingProxy(destImageByte);
                scanlineRenderer.GenerateAndRender(Rasterizer, drawImageScanlineCache, destImageWithClipping, destImageSpanAllocatorCache, spanImageFilter);
            }
        }

        public override void Render(IImageByte source,
            double destX, double destY,
            double angleRadians,
            double inScaleX, double inScaleY)
        {
            { // exit early if the dest and source bounds don't touch.
                // TODO: <BUG> make this do rotation and scalling
                RectangleInt sourceBounds = source.GetBounds();
                RectangleInt destBounds = this.destImageByte.GetBounds();
                sourceBounds.Offset((int)destX, (int)destY);

                if (!RectangleInt.DoIntersect(sourceBounds, destBounds))
                {
                    if (inScaleX != 1 || inScaleY != 1 || angleRadians != 0)
                    {
                        throw new NotImplementedException();
                    }
                    return;
                }
            }

            double scaleX = inScaleX;
            double scaleY = inScaleY;

            Affine graphicsTransform = GetTransform();
            if (!graphicsTransform.is_identity())
            {
                if (scaleX != 1 || scaleY != 1 || angleRadians != 0)
                {
                    throw new NotImplementedException();
                }
                graphicsTransform.transform(ref destX, ref destY);
            }

#if false // this is an optomization that eliminates the drawing of images that have their alpha set to all 0 (happens with generated images like explosions).
	        MaxAlphaFrameProperty maxAlphaFrameProperty = MaxAlphaFrameProperty::GetMaxAlphaFrameProperty(source);

	        if((maxAlphaFrameProperty.GetMaxAlpha() * color.A_Byte) / 256 <= ALPHA_CHANNEL_BITS_DIVISOR)
	        {
		        m_OutFinalBlitBounds.SetRect(0,0,0,0);
	        }
#endif
            bool IsScaled = (scaleX != 1 || scaleY != 1);

            bool IsRotated = true;
            if (Math.Abs(angleRadians) < (0.1 * MathHelper.Tau / 360))
            {
                IsRotated = false;
                angleRadians = 0;
            }

            //bool IsMipped = false;
            double sourceOriginOffsetX = source.OriginOffset.x;
            double sourceOriginOffsetY = source.OriginOffset.y;
            bool CanUseMipMaps = IsScaled;
            if (scaleX > 0.5 || scaleY > 0.5)
            {
                CanUseMipMaps = false;
            }

            bool renderRequriesSourceSampling = IsScaled || IsRotated || destX != (int)destX || destY != (int)destY;

            // this is the fast drawing path
            if (renderRequriesSourceSampling)
            {
#if false // if the scalling is small enough the results can be improved by using mip maps
	        if(CanUseMipMaps)
	        {
		        CMipMapFrameProperty* pMipMapFrameProperty = CMipMapFrameProperty::GetMipMapFrameProperty(source);
		        double OldScaleX = scaleX;
		        double OldScaleY = scaleY;
		        const CFrameInterface* pMippedFrame = pMipMapFrameProperty.GetMipMapFrame(ref scaleX, ref scaleY);
		        if(pMippedFrame != source)
		        {
			        IsMipped = true;
			        source = pMippedFrame;
			        sourceOriginOffsetX *= (OldScaleX / scaleX);
			        sourceOriginOffsetY *= (OldScaleY / scaleY);
		        }

			    HotspotOffsetX *= (inScaleX / scaleX);
			    HotspotOffsetY *= (inScaleY / scaleY);
	        }
#endif
                Affine destRectTransform;
                DrawImageGetDestBounds(source, destX, destY, sourceOriginOffsetX, sourceOriginOffsetY, scaleX, scaleY, angleRadians, out destRectTransform);

                Affine sourceRectTransform = new Affine(destRectTransform);
                // We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]
                sourceRectTransform.invert();

                span_image_filter spanImageFilter;
                span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);
                ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source, RGBA_Floats.rgba_pre(0, 0, 0, 0).GetAsRGBA_Bytes());

                spanImageFilter = new span_image_filter_rgba_bilinear_clip(sourceAccessor, RGBA_Floats.rgba_pre(0, 0, 0, 0), interpolator);

                DrawImage(source, spanImageFilter, destRectTransform);
#if false // this is some debug you can enable to visualize the dest bounding box
		        LineFloat(BoundingRect.left, BoundingRect.top, BoundingRect.right, BoundingRect.top, WHITE);
		        LineFloat(BoundingRect.right, BoundingRect.top, BoundingRect.right, BoundingRect.bottom, WHITE);
		        LineFloat(BoundingRect.right, BoundingRect.bottom, BoundingRect.left, BoundingRect.bottom, WHITE);
		        LineFloat(BoundingRect.left, BoundingRect.bottom, BoundingRect.left, BoundingRect.top, WHITE);
#endif
            }
            else // TODO: this can be even faster if we do not use an intermediat buffer
            {
                Affine destRectTransform;
                DrawImageGetDestBounds(source, destX, destY, sourceOriginOffsetX, sourceOriginOffsetY, scaleX, scaleY, angleRadians, out destRectTransform);

                Affine sourceRectTransform = new Affine(destRectTransform);
                // We invert it because it is the transform to make the image go to the same position as the polygon. LBB [2/24/2004]
                sourceRectTransform.invert();

                span_interpolator_linear interpolator = new span_interpolator_linear(sourceRectTransform);
                ImageBufferAccessorClip sourceAccessor = new ImageBufferAccessorClip(source, RGBA_Floats.rgba_pre(0, 0, 0, 0).GetAsRGBA_Bytes());

                span_image_filter spanImageFilter = null;
                switch (source.BitDepth)
                {
                    case 32:
                        spanImageFilter = new span_image_filter_rgba_nn_stepXby1(sourceAccessor, interpolator);
                        break;

                    case 24:
                        spanImageFilter = new span_image_filter_rgb_nn_stepXby1(sourceAccessor, interpolator);
                        break;

                    case 8:
                        spanImageFilter = new span_image_filter_gray_nn_stepXby1(sourceAccessor, interpolator);
                        break;

                    default:
                        throw new NotImplementedException();
                }
                //spanImageFilter = new span_image_filter_rgba_nn(sourceAccessor, interpolator);

                DrawImage(source, spanImageFilter, destRectTransform);
                DestImage.MarkImageChanged();
            }
        }

        public override void Render(IImageFloat source, double x, double y, double angleDegrees, double inScaleX, double inScaleY)
        {
            throw new NotImplementedException();
        }

        public override void Clear(IColorType iColor)
        {
            RectangleDouble clippingRect = GetClippingRect();
            RectangleInt clippingRectInt = new RectangleInt((int)clippingRect.Left, (int)clippingRect.Bottom, (int)clippingRect.Right, (int)clippingRect.Top);

            if (DestImage != null)
            {
                RGBA_Bytes color = iColor.GetAsRGBA_Bytes();
                int width = DestImage.Width;
                int height = DestImage.Height;
                byte[] buffer = DestImage.GetBuffer();
                switch (DestImage.BitDepth)
                {
                    case 8:
                        {
                            byte byteColor = (byte)iColor.Red0To255;
                            for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)
                            {
                                int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left, y);
                                int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();
                                for (int x = 0; x < clippingRectInt.Width; x++)
                                {
                                    buffer[bufferOffset] = color.blue;
                                    bufferOffset += bytesBetweenPixels;
                                }
                            }
                        }
                        break;

                    case 24:
                        for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)
                        {
                            int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left, y);
                            int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();
                            for (int x = 0; x < clippingRectInt.Width; x++)
                            {
                                buffer[bufferOffset + 0] = color.red;
                                buffer[bufferOffset + 1] = color.green;
                                buffer[bufferOffset + 2] = color.blue;
                                bufferOffset += bytesBetweenPixels;
                            }
                        }
                        break;

                    case 32:
                        {
                            for (int y = clippingRectInt.Bottom; y < clippingRectInt.Top; y++)
                            {
                                int bufferOffset = DestImage.GetBufferOffsetXY((int)clippingRect.Left, y);
                                int bytesBetweenPixels = DestImage.GetBytesBetweenPixelsInclusive();
                                for (int x = 0; x < clippingRectInt.Width; x++)
                                {
                                    buffer[bufferOffset + 0] = color.red;
                                    buffer[bufferOffset + 1] = color.green;
                                    buffer[bufferOffset + 2] = color.blue;
                                    buffer[bufferOffset + 3] = color.alpha;
                                    bufferOffset += bytesBetweenPixels;
                                }
                            }
                        }
                        break;

                    default:
                        throw new NotImplementedException();
                }
            }
            else // it is a float
            {
                if (DestImageFloat == null)
                {
                    throw new Exception("You have to have either a byte or float DestImage.");
                }

                RGBA_Floats color = iColor.GetAsRGBA_Floats();
                int width = DestImageFloat.Width;
                int height = DestImageFloat.Height;
                float[] buffer = DestImageFloat.GetBuffer();
                switch (DestImageFloat.BitDepth)
                {
                    case 128:
                        for (int y = 0; y < height; y++)
                        {
                            int bufferOffset = DestImageFloat.GetBufferOffsetXY(clippingRectInt.Left, y);
                            int bytesBetweenPixels = DestImageFloat.GetFloatsBetweenPixelsInclusive();
                            for (int x = 0; x < clippingRectInt.Width; x++)
                            {
                                buffer[bufferOffset + 0] = color.blue;
                                buffer[bufferOffset + 1] = color.green;
                                buffer[bufferOffset + 2] = color.red;
                                buffer[bufferOffset + 3] = color.alpha;
                                bufferOffset += bytesBetweenPixels;
                            }
                        }
                        break;

                    default:
                        throw new NotImplementedException();
                }
            }
        }
    }
}

#endregion //ImageGraphics2D.cs
#region ImageLineRenderer.cs

//----------------------------------------------------------------------------
#if true

namespace MatterHackers.Agg
{
    /*
    //========================================================line_image_scale
    public class line_image_scale
    {
        IImage m_source;
        double        m_height;
        double        m_scale;

        public line_image_scale(IImage src, double height)
        {
            m_source = (src);
            m_height = (height);
            m_scale = (src.height() / height);
        }

        public double width()  { return m_source.width(); }
        public double height() { return m_height; }

        public RGBA_Bytes pixel(int x, int y) 
        { 
            double src_y = (y + 0.5) * m_scale - 0.5;
            int h  = m_source.height() - 1;
            int y1 = ufloor(src_y);
            int y2 = y1 + 1;
            RGBA_Bytes pix1 = (y1 < 0) ? new no_color() : m_source.pixel(x, y1);
            RGBA_Bytes pix2 = (y2 > h) ? no_color() : m_source.pixel(x, y2);
            return pix1.gradient(pix2, src_y - y1);
        }
    };

     */

    //======================================================line_image_pattern
    public class line_image_pattern : ImageBuffer
    {
        IPatternFilter m_filter;
        int m_dilation;
        int m_dilation_hr;
        ImageBuffer m_buf = new ImageBuffer();
        byte[] m_data = null;
        int m_DataSizeInBytes = 0;
        int m_width;
        int m_height;
        int m_width_hr;
        int m_half_height_hr;
        int m_offset_y_hr;

        //--------------------------------------------------------------------
        public line_image_pattern(IPatternFilter filter)
        {
            m_filter = filter;
            m_dilation = (filter.dilation() + 1);
            m_dilation_hr = (m_dilation << LineAABasics.line_subpixel_shift);
            m_width = (0);
            m_height = (0);
            m_width_hr = (0);
            m_half_height_hr = (0);
            m_offset_y_hr = (0);
        }

        ~line_image_pattern()
        {
            if (m_DataSizeInBytes > 0)
            {
                m_data = null;
            }
        }

        // Create
        //--------------------------------------------------------------------
        public line_image_pattern(IPatternFilter filter, line_image_pattern src)
        {
            m_filter = (filter);
            m_dilation = (filter.dilation() + 1);
            m_dilation_hr = (m_dilation << LineAABasics.line_subpixel_shift);
            m_width = 0;
            m_height = 0;
            m_width_hr = 0;
            m_half_height_hr = 0;
            m_offset_y_hr = (0);

            create(src);
        }

        // Create
        //--------------------------------------------------------------------
        public void create(IImageByte src)
        {
            // we are going to create a dialated image for filtering
            // we add m_dilation pixels to every side of the image and then copy the image in the x
            // dirrection into each end so that we can sample into this image to get filtering on x repeating
            // if the original image look like this
            //
            // 123456 
            //
            // the new image would look like this
            //
            // 0000000000
            // 0000000000
            // 5612345612
            // 0000000000
            // 0000000000

            m_height = (int)agg_basics.uceil(src.Height);
            m_width = (int)agg_basics.uceil(src.Width);
            m_width_hr = (int)agg_basics.uround(src.Width * LineAABasics.line_subpixel_scale);
            m_half_height_hr = (int)agg_basics.uround(src.Height * LineAABasics.line_subpixel_scale / 2);
            m_offset_y_hr = m_dilation_hr + m_half_height_hr - LineAABasics.line_subpixel_scale / 2;
            m_half_height_hr += LineAABasics.line_subpixel_scale / 2;

            int bufferWidth = m_width + m_dilation * 2;
            int bufferHeight = m_height + m_dilation * 2;
            int bytesPerPixel = src.BitDepth / 8;
            int NewSizeInBytes = bufferWidth * bufferHeight * bytesPerPixel;
            if (m_DataSizeInBytes < NewSizeInBytes)
            {
                m_DataSizeInBytes = NewSizeInBytes;
                m_data = new byte[m_DataSizeInBytes];
            }

            m_buf.AttachBuffer(m_data, 0, bufferWidth, bufferHeight, bufferWidth * bytesPerPixel, src.BitDepth, bytesPerPixel);
            byte[] destBuffer = m_buf.GetBuffer();
            byte[] sourceBuffer = src.GetBuffer();

            // copy the image into the middle of the dest
            for (int y = 0; y < m_height; y++)
            {
                for (int x = 0; x < m_width; x++)
                {
                    int sourceOffset = src.GetBufferOffsetXY(x, y);
                    int destOffset = m_buf.GetBufferOffsetXY(m_dilation, y + m_dilation);
                    for (int channel = 0; channel < bytesPerPixel; channel++)
                    {
                        destBuffer[destOffset++] = sourceBuffer[sourceOffset++];
                    }
                }
            }

            // copy the first two pixels form the end into the begining and from the begining into the end
            for (int y = 0; y < m_height; y++)
            {
                int s1Offset = src.GetBufferOffsetXY(0, y);
                int d1Offset = m_buf.GetBufferOffsetXY(m_dilation + m_width, y);

                int s2Offset = src.GetBufferOffsetXY(m_width - m_dilation, y);
                int d2Offset = m_buf.GetBufferOffsetXY(0, y);

                for (int x = 0; x < m_dilation; x++)
                {
                    for (int channel = 0; channel < bytesPerPixel; channel++)
                    {
                        destBuffer[d1Offset++] = sourceBuffer[s1Offset++];
                        destBuffer[d2Offset++] = sourceBuffer[s2Offset++];
                    }
                }
            }
        }

        //--------------------------------------------------------------------
        public int pattern_width() { return m_width_hr; }
        public int line_width() { return m_half_height_hr; }
        public double width() { return m_height; }

        //--------------------------------------------------------------------
        public void pixel(RGBA_Bytes[] destBuffer, int destBufferOffset, int x, int y)
        {
            m_filter.pixel_high_res(m_buf, destBuffer, destBufferOffset, x % m_width_hr + m_dilation_hr, y + m_offset_y_hr);
        }

        //--------------------------------------------------------------------
        public IPatternFilter filter() { return m_filter; }
    };

    /*
    
    //=================================================line_image_pattern_pow2
    public class line_image_pattern_pow2 : 
        line_image_pattern<IPatternFilter>
    {
        uint m_mask;
	
        //--------------------------------------------------------------------
        public line_image_pattern_pow2(IPatternFilter filter) :
            line_image_pattern<IPatternFilter>(filter), m_mask(line_subpixel_mask) {}

        //--------------------------------------------------------------------
        public line_image_pattern_pow2(IPatternFilter filter, ImageBuffer src) :
            line_image_pattern<IPatternFilter>(filter), m_mask(line_subpixel_mask)
        {
            create(src);
        }
            
        //--------------------------------------------------------------------
        public void create(ImageBuffer src)
        {
            line_image_pattern<IPatternFilter>::create(src);
            m_mask = 1;
            while(m_mask < base_type::m_width) 
            {
                m_mask <<= 1;
                m_mask |= 1;
            }
            m_mask <<= line_subpixel_shift - 1;
            m_mask |=  line_subpixel_mask;
            base_type::m_width_hr = m_mask + 1;
        }

        //--------------------------------------------------------------------
        public void pixel(RGBA_Bytes* p, int x, int y)
        {
            base_type::m_filter->pixel_high_res(
                    base_type::m_buf.rows(), 
                    p,
                    (x & m_mask) + base_type::m_dilation_hr,
                    y + base_type::m_offset_y_hr);
        }
    };
     */

    //===================================================distance_interpolator4
    public class distance_interpolator4
    {
        int m_dx;
        int m_dy;
        int m_dx_start;
        int m_dy_start;
        int m_dx_pict;
        int m_dy_pict;
        int m_dx_end;
        int m_dy_end;

        int m_dist;
        int m_dist_start;
        int m_dist_pict;
        int m_dist_end;
        int m_len;

        //---------------------------------------------------------------------
        public distance_interpolator4() { }
        public distance_interpolator4(int x1, int y1, int x2, int y2,
                               int sx, int sy, int ex, int ey,
                               int len, double scale, int x, int y)
        {
            m_dx = (x2 - x1);
            m_dy = (y2 - y1);
            m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));
            m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));
            m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));
            m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));

            m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
                          (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

            m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -
                         (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);

            m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -
                       (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);
            m_len = (int)(agg_basics.uround(len / scale));

            double d = len * scale;
            int dx = agg_basics.iround(((x2 - x1) << LineAABasics.line_subpixel_shift) / d);
            int dy = agg_basics.iround(((y2 - y1) << LineAABasics.line_subpixel_shift) / d);
            m_dx_pict = -dy;
            m_dy_pict = dx;
            m_dist_pict = ((x + LineAABasics.line_subpixel_scale / 2 - (x1 - dy)) * m_dy_pict -
                            (y + LineAABasics.line_subpixel_scale / 2 - (y1 + dx)) * m_dx_pict) >>
                           LineAABasics.line_subpixel_shift;

            m_dx <<= LineAABasics.line_subpixel_shift;
            m_dy <<= LineAABasics.line_subpixel_shift;
            m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
            m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
            m_dx_end <<= LineAABasics.line_mr_subpixel_shift;
            m_dy_end <<= LineAABasics.line_mr_subpixel_shift;
        }

        //---------------------------------------------------------------------
        public void inc_x()
        {
            m_dist += m_dy;
            m_dist_start += m_dy_start;
            m_dist_pict += m_dy_pict;
            m_dist_end += m_dy_end;
        }

        //---------------------------------------------------------------------
        public void dec_x()
        {
            m_dist -= m_dy;
            m_dist_start -= m_dy_start;
            m_dist_pict -= m_dy_pict;
            m_dist_end -= m_dy_end;
        }

        //---------------------------------------------------------------------
        public void inc_y()
        {
            m_dist -= m_dx;
            m_dist_start -= m_dx_start;
            m_dist_pict -= m_dx_pict;
            m_dist_end -= m_dx_end;
        }

        //---------------------------------------------------------------------
        public void dec_y()
        {
            m_dist += m_dx;
            m_dist_start += m_dx_start;
            m_dist_pict += m_dx_pict;
            m_dist_end += m_dx_end;
        }

        //---------------------------------------------------------------------
        public void inc_x(int dy)
        {
            m_dist += m_dy;
            m_dist_start += m_dy_start;
            m_dist_pict += m_dy_pict;
            m_dist_end += m_dy_end;
            if (dy > 0)
            {
                m_dist -= m_dx;
                m_dist_start -= m_dx_start;
                m_dist_pict -= m_dx_pict;
                m_dist_end -= m_dx_end;
            }
            if (dy < 0)
            {
                m_dist += m_dx;
                m_dist_start += m_dx_start;
                m_dist_pict += m_dx_pict;
                m_dist_end += m_dx_end;
            }
        }

        //---------------------------------------------------------------------
        public void dec_x(int dy)
        {
            m_dist -= m_dy;
            m_dist_start -= m_dy_start;
            m_dist_pict -= m_dy_pict;
            m_dist_end -= m_dy_end;
            if (dy > 0)
            {
                m_dist -= m_dx;
                m_dist_start -= m_dx_start;
                m_dist_pict -= m_dx_pict;
                m_dist_end -= m_dx_end;
            }
            if (dy < 0)
            {
                m_dist += m_dx;
                m_dist_start += m_dx_start;
                m_dist_pict += m_dx_pict;
                m_dist_end += m_dx_end;
            }
        }

        //---------------------------------------------------------------------
        public void inc_y(int dx)
        {
            m_dist -= m_dx;
            m_dist_start -= m_dx_start;
            m_dist_pict -= m_dx_pict;
            m_dist_end -= m_dx_end;
            if (dx > 0)
            {
                m_dist += m_dy;
                m_dist_start += m_dy_start;
                m_dist_pict += m_dy_pict;
                m_dist_end += m_dy_end;
            }
            if (dx < 0)
            {
                m_dist -= m_dy;
                m_dist_start -= m_dy_start;
                m_dist_pict -= m_dy_pict;
                m_dist_end -= m_dy_end;
            }
        }

        //---------------------------------------------------------------------
        public void dec_y(int dx)
        {
            m_dist += m_dx;
            m_dist_start += m_dx_start;
            m_dist_pict += m_dx_pict;
            m_dist_end += m_dx_end;
            if (dx > 0)
            {
                m_dist += m_dy;
                m_dist_start += m_dy_start;
                m_dist_pict += m_dy_pict;
                m_dist_end += m_dy_end;
            }
            if (dx < 0)
            {
                m_dist -= m_dy;
                m_dist_start -= m_dy_start;
                m_dist_pict -= m_dy_pict;
                m_dist_end -= m_dy_end;
            }
        }

        //---------------------------------------------------------------------
        public int dist() { return m_dist; }
        public int dist_start() { return m_dist_start; }
        public int dist_pict() { return m_dist_pict; }
        public int dist_end() { return m_dist_end; }

        //---------------------------------------------------------------------
        public int dx() { return m_dx; }
        public int dy() { return m_dy; }
        public int dx_start() { return m_dx_start; }
        public int dy_start() { return m_dy_start; }
        public int dx_pict() { return m_dx_pict; }
        public int dy_pict() { return m_dy_pict; }
        public int dx_end() { return m_dx_end; }
        public int dy_end() { return m_dy_end; }
        public int len() { return m_len; }
    };

#if true
#if false
    //==================================================line_interpolator_image
    public class line_interpolator_image
    {
        line_parameters m_lp;
        dda2_line_interpolator m_li;
        distance_interpolator4 m_di; 
        IImageByte m_ren;
        int m_plen;
        int m_x;
        int m_y;
        int m_old_x;
        int m_old_y;
        int m_width;
        int m_max_extent;
        int m_start;
        int m_step;
        int[] m_dist_pos = new int[max_half_width + 1];
        RGBA_Bytes[] m_colors = new RGBA_Bytes[max_half_width * 2 + 4];

        //---------------------------------------------------------------------
        public const int max_half_width = 64;

        //---------------------------------------------------------------------
        public line_interpolator_image(renderer_outline_aa ren, line_parameters lp,
                                int sx, int sy, int ex, int ey, 
                                int pattern_start,
                                double scale_x)
        {
            throw new NotImplementedException();
/*
            m_lp=(lp);
            m_li = new dda2_line_interpolator(lp.vertical ? LineAABasics.line_dbl_hr(lp.x2 - lp.x1) :
                               LineAABasics.line_dbl_hr(lp.y2 - lp.y1),
                 lp.vertical ? Math.Abs(lp.y2 - lp.y1) :
                               Math.Abs(lp.x2 - lp.x1) + 1);
            m_di = new distance_interpolator4(lp.x1, lp.y1, lp.x2, lp.y2, sx, sy, ex, ey, lp.len, scale_x,
                 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);
            m_ren=ren;
            m_x = (lp.x1 >> LineAABasics.line_subpixel_shift);
            m_y = (lp.y1 >> LineAABasics.line_subpixel_shift);
            m_old_x=(m_x);
            m_old_y=(m_y);
            m_count = ((lp.vertical ? Math.Abs((lp.y2 >> LineAABasics.line_subpixel_shift) - m_y) :
                                   Math.Abs((lp.x2 >> LineAABasics.line_subpixel_shift) - m_x)));
            m_width=(ren.subpixel_width());
            //m_max_extent(m_width >> (LineAABasics.line_subpixel_shift - 2));
            m_max_extent = ((m_width + LineAABasics.line_subpixel_scale) >> LineAABasics.line_subpixel_shift);
            m_start=(pattern_start + (m_max_extent + 2) * ren.pattern_width());
            m_step=(0);

            dda2_line_interpolator li = new dda2_line_interpolator(0, lp.vertical ? 
                                              (lp.dy << LineAABasics.line_subpixel_shift) :
                                              (lp.dx << LineAABasics.line_subpixel_shift),
                                           lp.len);

            uint i;
            int stop = m_width + LineAABasics.line_subpixel_scale * 2;
            for(i = 0; i < max_half_width; ++i)
            {
                m_dist_pos[i] = li.y();
                if(m_dist_pos[i] >= stop) break;
                ++li;
            }
            m_dist_pos[i] = 0x7FFF0000;

            int dist1_start;
            int dist2_start;
            int npix = 1;

            if(lp.vertical)
            {
                do
                {
                    --m_li;
                    m_y -= lp.inc;
                    m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if(lp.inc > 0) m_di.dec_y(m_x - m_old_x);
                    else           m_di.inc_y(m_x - m_old_x);

                    m_old_x = m_x;

                    dist1_start = dist2_start = m_di.dist_start(); 

                    int dx = 0;
                    if(dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start += m_di.dy_start();
                        dist2_start -= m_di.dy_start();
                        if(dist1_start < 0) ++npix;
                        if(dist2_start < 0) ++npix;
                        ++dx;
                    }
                    while(m_dist_pos[dx] <= m_width);
                    if(npix == 0) break;

                    npix = 0;
                }
                while(--m_step >= -m_max_extent);
            }
            else
            {
                do
                {
                    --m_li;

                    m_x -= lp.inc;
                    m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if(lp.inc > 0) m_di.dec_x(m_y - m_old_y);
                    else           m_di.inc_x(m_y - m_old_y);

                    m_old_y = m_y;

                    dist1_start = dist2_start = m_di.dist_start(); 

                    int dy = 0;
                    if(dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start -= m_di.dx_start();
                        dist2_start += m_di.dx_start();
                        if(dist1_start < 0) ++npix;
                        if(dist2_start < 0) ++npix;
                        ++dy;
                    }
                    while(m_dist_pos[dy] <= m_width);
                    if(npix == 0) break;

                    npix = 0;
                }
                while(--m_step >= -m_max_extent);
            }
            m_li.adjust_forward();
            m_step -= m_max_extent;
 */
        }

        //---------------------------------------------------------------------
        public bool step_hor()
        {
            throw new NotImplementedException();
/*
            ++m_li;
            m_x += m_lp.inc;
            m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if(m_lp.inc > 0) m_di.inc_x(m_y - m_old_y);
            else             m_di.dec_x(m_y - m_old_y);

            m_old_y = m_y;

            int s1 = m_di.dist() / m_lp.len;
            int s2 = -s1;

            if(m_lp.inc < 0) s1 = -s1;

            int dist_start;
            int dist_pict;
            int dist_end;
            int dy;
            int dist;

            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            RGBA_Bytes* p0 = m_colors + max_half_width + 2;
            RGBA_Bytes* p1 = p0;

            int npix = 0;
            p1->clear();
            if(dist_end > 0)
            {
                if(dist_start <= 0)
                {
                    m_ren.pixel(p1, dist_pict, s2);
                }
                ++npix;
            }
            ++p1;

            dy = 1;
            while((dist = m_dist_pos[dy]) - s1 <= m_width)
            {
                dist_start -= m_di.dx_start();
                dist_pict  -= m_di.dx_pict();
                dist_end   -= m_di.dx_end();
                p1->clear();
                if(dist_end > 0 && dist_start <= 0)
                {   
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p1, dist_pict, s2 - dist);
                    ++npix;
                }
                ++p1;
                ++dy;
            }

            dy = 1;
            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            while((dist = m_dist_pos[dy]) + s1 <= m_width)
            {
                dist_start += m_di.dx_start();
                dist_pict  += m_di.dx_pict();
                dist_end   += m_di.dx_end();
                --p0;
                p0->clear();
                if(dist_end > 0 && dist_start <= 0)
                {   
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p0, dist_pict, s2 + dist);
                    ++npix;
                }
                ++dy;
            }
            m_ren.blend_color_vspan(m_x, 
                                    m_y - dy + 1, 
                                    (uint)(p1 - p0), 
                                    p0); 
            return npix && ++m_step < m_count;
 */
        }

        //---------------------------------------------------------------------
        public bool step_ver()
        {
            throw new NotImplementedException();
/*
            ++m_li;
            m_y += m_lp.inc;
            m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if(m_lp.inc > 0) m_di.inc_y(m_x - m_old_x);
            else             m_di.dec_y(m_x - m_old_x);

            m_old_x = m_x;

            int s1 = m_di.dist() / m_lp.len;
            int s2 = -s1;

            if(m_lp.inc > 0) s1 = -s1;

            int dist_start;
            int dist_pict;
            int dist_end;
            int dist;
            int dx;

            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            RGBA_Bytes* p0 = m_colors + max_half_width + 2;
            RGBA_Bytes* p1 = p0;

            int npix = 0;
            p1->clear();
            if(dist_end > 0)
            {
                if(dist_start <= 0)
                {
                    m_ren.pixel(p1, dist_pict, s2);
                }
                ++npix;
            }
            ++p1;

            dx = 1;
            while((dist = m_dist_pos[dx]) - s1 <= m_width)
            {
                dist_start += m_di.dy_start();
                dist_pict  += m_di.dy_pict();
                dist_end   += m_di.dy_end();
                p1->clear();
                if(dist_end > 0 && dist_start <= 0)
                {   
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p1, dist_pict, s2 + dist);
                    ++npix;
                }
                ++p1;
                ++dx;
            }

            dx = 1;
            dist_start = m_di.dist_start();
            dist_pict  = m_di.dist_pict() + m_start;
            dist_end   = m_di.dist_end();
            while((dist = m_dist_pos[dx]) + s1 <= m_width)
            {
                dist_start -= m_di.dy_start();
                dist_pict  -= m_di.dy_pict();
                dist_end   -= m_di.dy_end();
                --p0;
                p0->clear();
                if(dist_end > 0 && dist_start <= 0)
                {   
                    if(m_lp.inc > 0) dist = -dist;
                    m_ren.pixel(p0, dist_pict, s2 - dist);
                    ++npix;
                }
                ++dx;
            }
            m_ren.blend_color_hspan(m_x - dx + 1, 
                                    m_y, 
                                    (uint)(p1 - p0), 
                                    p0);
            return npix && ++m_step < m_count;
 */
        }


        //---------------------------------------------------------------------
        public int  pattern_end() { return m_start + m_di.len(); }

        //---------------------------------------------------------------------
        public bool vertical() { return m_lp.vertical; }
        public int  width() { return m_width; }
    }
#endif

    //===================================================renderer_outline_image
    //template<class BaseRenderer, class ImagePattern> 
    public class ImageLineRenderer : LineRenderer
    {
        IImageByte m_ren;
        line_image_pattern m_pattern;
        int m_start;
        double m_scale_x;
        RectangleInt m_clip_box;
        bool m_clipping;

        //---------------------------------------------------------------------
        //typedef renderer_outline_image<BaseRenderer, ImagePattern> self_type;

        //---------------------------------------------------------------------
        public ImageLineRenderer(IImageByte ren, line_image_pattern patt)
        {
            m_ren = ren;
            m_pattern = patt;
            m_start = (0);
            m_scale_x = (1.0);
            m_clip_box = new RectangleInt(0, 0, 0, 0);
            m_clipping = (false);
        }

        public void attach(IImageByte ren) { m_ren = ren; }

        //---------------------------------------------------------------------
        public void pattern(line_image_pattern p) { m_pattern = p; }
        public line_image_pattern pattern() { return m_pattern; }

        //---------------------------------------------------------------------
        public void reset_clipping() { m_clipping = false; }

        public void clip_box(double x1, double y1, double x2, double y2)
        {
            m_clip_box.Left = line_coord_sat.conv(x1);
            m_clip_box.Bottom = line_coord_sat.conv(y1);
            m_clip_box.Right = line_coord_sat.conv(x2);
            m_clip_box.Top = line_coord_sat.conv(y2);
            m_clipping = true;
        }

        //---------------------------------------------------------------------
        public void scale_x(double s) { m_scale_x = s; }
        public double scale_x() { return m_scale_x; }

        //---------------------------------------------------------------------
        public void start_x(double s) { m_start = agg_basics.iround(s * LineAABasics.line_subpixel_scale); }
        public double start_x() { return (double)(m_start) / LineAABasics.line_subpixel_scale; }

        //---------------------------------------------------------------------
        public int subpixel_width() { return m_pattern.line_width(); }
        public int pattern_width() { return m_pattern.pattern_width(); }
        public double width() { return (double)(subpixel_width()) / LineAABasics.line_subpixel_scale; }

        public void pixel(RGBA_Bytes[] p, int offset, int x, int y)
        {
            throw new NotImplementedException();

            //m_pattern.pixel(p, x, y);
        }

        public void blend_color_hspan(int x, int y, uint len, RGBA_Bytes[] colors, int colorsOffset)
        {
            throw new NotImplementedException();
            //            m_ren.blend_color_hspan(x, y, len, colors, null, 0);
        }

        public void blend_color_vspan(int x, int y, uint len, RGBA_Bytes[] colors, int colorsOffset)
        {
            throw new NotImplementedException();
            //            m_ren.blend_color_vspan(x, y, len, colors, null, 0);
        }

        public static bool accurate_join_only() { return true; }

        public override void semidot(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2)
        {
        }

        public override void semidot_hline(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2, int x1, int y1, int x2)
        {
        }

        public override void pie(int xc, int yc, int x1, int y1, int x2, int y2)
        {
        }

        public override void line0(line_parameters lp)
        {
        }

        public override void line1(line_parameters lp, int sx, int sy)
        {
        }

        public override void line2(line_parameters lp, int ex, int ey)
        {
        }

        public void line3_no_clip(line_parameters lp, int sx, int sy, int ex, int ey)
        {
            throw new NotImplementedException();
            /*
                        if(lp.len > LineAABasics.line_max_length)
                        {
                            line_parameters lp1, lp2;
                            lp.divide(lp1, lp2);
                            int mx = lp1.x2 + (lp1.y2 - lp1.y1);
                            int my = lp1.y2 - (lp1.x2 - lp1.x1);
                            line3_no_clip(lp1, (lp.x1 + sx) >> 1, (lp.y1 + sy) >> 1, mx, my);
                            line3_no_clip(lp2, mx, my, (lp.x2 + ex) >> 1, (lp.y2 + ey) >> 1);
                            return;
                        }
            
                        LineAABasics.fix_degenerate_bisectrix_start(lp, ref sx, ref sy);
                        LineAABasics.fix_degenerate_bisectrix_end(lp, ref ex, ref ey);
                        line_interpolator_image li = new line_interpolator_image(this, lp, 
                                                              sx, sy, 
                                                              ex, ey, 
                                                              m_start, m_scale_x);
                        if(li.vertical())
                        {
                            while(li.step_ver());
                        }
                        else
                        {
                            while(li.step_hor());
                        }
                        m_start += uround(lp.len / m_scale_x);
             */
        }

        public override void line3(line_parameters lp, int sx, int sy, int ex, int ey)
        {
            throw new NotImplementedException();
            /*
                        if(m_clipping)
                        {
                            int x1 = lp.x1;
                            int y1 = lp.y1;
                            int x2 = lp.x2;
                            int y2 = lp.y2;
                            uint flags = clip_line_segment(&x1, &y1, &x2, &y2, m_clip_box);
                            int start = m_start;
                            if((flags & 4) == 0)
                            {
                                if(flags)
                                {
                                    line_parameters lp2(x1, y1, x2, y2, 
                                                       uround(calc_distance(x1, y1, x2, y2)));
                                    if(flags & 1)
                                    {
                                        m_start += uround(calc_distance(lp.x1, lp.y1, x1, y1) / m_scale_x);
                                        sx = x1 + (y2 - y1); 
                                        sy = y1 - (x2 - x1);
                                    }
                                    else
                                    {
                                        while(Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)
                                        {
                                            sx = (lp.x1 + sx) >> 1;
                                            sy = (lp.y1 + sy) >> 1;
                                        }
                                    }
                                    if(flags & 2)
                                    {
                                        ex = x2 + (y2 - y1); 
                                        ey = y2 - (x2 - x1);
                                    }
                                    else
                                    {
                                        while(Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)
                                        {
                                            ex = (lp.x2 + ex) >> 1;
                                            ey = (lp.y2 + ey) >> 1;
                                        }
                                    }
                                    line3_no_clip(lp2, sx, sy, ex, ey);
                                }
                                else
                                {
                                    line3_no_clip(lp, sx, sy, ex, ey);
                                }
                            }
                            m_start = start + uround(lp.len / m_scale_x);
                        }
                        else
                        {
                            line3_no_clip(lp, sx, sy, ex, ey);
                        }
             */
        }
    };
#endif
}
#endif

#endregion //ImageLineRenderer.cs
#region ImageProxy.cs

namespace MatterHackers.Agg.Image
{
    public abstract class ImageProxy : IImageByte
    {
        protected IImageByte linkedImage;

        public IImageByte LinkedImage
        {
            get
            {
                return linkedImage;
            }
            set
            {
                linkedImage = value;
            }
        }

        public ImageProxy(IImageByte linkedImage)
        {
            this.linkedImage = linkedImage;
        }

        public virtual void LinkToImage(IImageByte linkedImage)
        {
            this.linkedImage = linkedImage;
        }

        public virtual Vector2 OriginOffset
        {
            get { return linkedImage.OriginOffset; }
            set { linkedImage.OriginOffset = value; }
        }

        public virtual int Width
        {
            get
            {
                return linkedImage.Width;
            }
        }

        public virtual int Height
        {
            get
            {
                return linkedImage.Height;
            }
        }

        public virtual int StrideInBytes()
        {
            return linkedImage.StrideInBytes();
        }

        public virtual int StrideInBytesAbs()
        {
            return linkedImage.StrideInBytesAbs();
        }

        public virtual RectangleInt GetBounds()
        {
            return linkedImage.GetBounds();
        }

        public Graphics2D NewGraphics2D()
        {
            return linkedImage.NewGraphics2D();
        }

        public IRecieveBlenderByte GetRecieveBlender()
        {
            return linkedImage.GetRecieveBlender();
        }

        public void SetRecieveBlender(IRecieveBlenderByte value)
        {
            linkedImage.SetRecieveBlender(value);
        }

        public virtual RGBA_Bytes GetPixel(int x, int y)
        {
            return linkedImage.GetPixel(x, y);
        }

        public virtual void copy_pixel(int x, int y, byte[] c, int ByteOffset)
        {
            linkedImage.copy_pixel(x, y, c, ByteOffset);
        }

        public virtual void CopyFrom(IImageByte sourceRaster)
        {
            linkedImage.CopyFrom(sourceRaster);
        }

        public virtual void CopyFrom(IImageByte sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
        {
            linkedImage.CopyFrom(sourceImage, sourceImageRect, destXOffset, destYOffset);
        }

        public virtual void SetPixel(int x, int y, RGBA_Bytes color)
        {
            linkedImage.SetPixel(x, y, color);
        }

        public virtual void BlendPixel(int x, int y, RGBA_Bytes sourceColor, byte cover)
        {
            linkedImage.BlendPixel(x, y, sourceColor, cover);
        }

        public virtual void copy_hline(int x, int y, int len, RGBA_Bytes sourceColor)
        {
            linkedImage.copy_hline(x, y, len, sourceColor);
        }

        public virtual void copy_vline(int x, int y, int len, RGBA_Bytes sourceColor)
        {
            linkedImage.copy_vline(x, y, len, sourceColor);
        }

        public virtual void blend_hline(int x1, int y, int x2, RGBA_Bytes sourceColor, byte cover)
        {
            linkedImage.blend_hline(x1, y, x2, sourceColor, cover);
        }

        public virtual void blend_vline(int x, int y1, int y2, RGBA_Bytes sourceColor, byte cover)
        {
            linkedImage.blend_vline(x, y1, y2, sourceColor, cover);
        }

        public virtual void blend_solid_hspan(int x, int y, int len, RGBA_Bytes c, byte[] covers, int coversIndex)
        {
            linkedImage.blend_solid_hspan(x, y, len, c, covers, coversIndex);
        }

        public virtual void copy_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorIndex)
        {
            linkedImage.copy_color_hspan(x, y, len, colors, colorIndex);
        }

        public virtual void copy_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorIndex)
        {
            linkedImage.copy_color_vspan(x, y, len, colors, colorIndex);
        }

        public virtual void blend_solid_vspan(int x, int y, int len, RGBA_Bytes c, byte[] covers, int coversIndex)
        {
            linkedImage.blend_solid_vspan(x, y, len, c, covers, coversIndex);
        }

        public virtual void blend_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            linkedImage.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }

        public virtual void blend_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            linkedImage.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }

        public byte[] GetBuffer()
        {
            return linkedImage.GetBuffer();
        }

        public int GetBufferOffsetXY(int x, int y)
        {
            return linkedImage.GetBufferOffsetXY(x, y);
        }

        public int GetBufferOffsetY(int y)
        {
            return linkedImage.GetBufferOffsetY(y);
        }

        public virtual int GetBytesBetweenPixelsInclusive()
        {
            return linkedImage.GetBytesBetweenPixelsInclusive();
        }

        public virtual int BitDepth
        {
            get
            {
                return linkedImage.BitDepth;
            }
        }

        public void MarkImageChanged()
        {
            linkedImage.MarkImageChanged();
        }
    }

    public abstract class ImageProxyFloat : IImageFloat
    {
        protected IImageFloat linkedImage;

        public ImageProxyFloat(IImageFloat linkedImage)
        {
            this.linkedImage = linkedImage;
        }

        public virtual void LinkToImage(IImageFloat linkedImage)
        {
            this.linkedImage = linkedImage;
        }

        public virtual Vector2 OriginOffset
        {
            get { return linkedImage.OriginOffset; }
            set { linkedImage.OriginOffset = value; }
        }

        public virtual int Width
        {
            get
            {
                return linkedImage.Width;
            }
        }

        public virtual int Height
        {
            get
            {
                return linkedImage.Height;
            }
        }

        public virtual int StrideInFloats()
        {
            return linkedImage.StrideInFloats();
        }

        public virtual int StrideInFloatsAbs()
        {
            return linkedImage.StrideInFloatsAbs();
        }

        public virtual RectangleInt GetBounds()
        {
            return linkedImage.GetBounds();
        }

        public Graphics2D NewGraphics2D()
        {
            return linkedImage.NewGraphics2D();
        }

        public IRecieveBlenderFloat GetBlender()
        {
            return linkedImage.GetBlender();
        }

        public void SetBlender(IRecieveBlenderFloat value)
        {
            linkedImage.SetBlender(value);
        }

        public virtual RGBA_Floats GetPixel(int x, int y)
        {
            return linkedImage.GetPixel(y, x);
        }

        public virtual void copy_pixel(int x, int y, float[] c, int FloatOffset)
        {
            linkedImage.copy_pixel(x, y, c, FloatOffset);
        }

        public virtual void CopyFrom(IImageFloat sourceRaster)
        {
            linkedImage.CopyFrom(sourceRaster);
        }

        public virtual void CopyFrom(IImageFloat sourceImage, RectangleInt sourceImageRect, int destXOffset, int destYOffset)
        {
            linkedImage.CopyFrom(sourceImage, sourceImageRect, destXOffset, destYOffset);
        }

        public virtual void SetPixel(int x, int y, RGBA_Floats color)
        {
            linkedImage.SetPixel(x, y, color);
        }

        public virtual void BlendPixel(int x, int y, RGBA_Floats sourceColor, byte cover)
        {
            linkedImage.BlendPixel(x, y, sourceColor, cover);
        }

        public virtual void copy_hline(int x, int y, int len, RGBA_Floats sourceColor)
        {
            linkedImage.copy_hline(x, y, len, sourceColor);
        }

        public virtual void copy_vline(int x, int y, int len, RGBA_Floats sourceColor)
        {
            linkedImage.copy_vline(x, y, len, sourceColor);
        }

        public virtual void blend_hline(int x1, int y, int x2, RGBA_Floats sourceColor, byte cover)
        {
            linkedImage.blend_hline(x1, y, x2, sourceColor, cover);
        }

        public virtual void blend_vline(int x, int y1, int y2, RGBA_Floats sourceColor, byte cover)
        {
            linkedImage.blend_vline(x, y1, y2, sourceColor, cover);
        }

        public virtual void blend_solid_hspan(int x, int y, int len, RGBA_Floats c, byte[] covers, int coversIndex)
        {
            linkedImage.blend_solid_hspan(x, y, len, c, covers, coversIndex);
        }

        public virtual void copy_color_hspan(int x, int y, int len, RGBA_Floats[] colors, int colorIndex)
        {
            linkedImage.copy_color_hspan(x, y, len, colors, colorIndex);
        }

        public virtual void copy_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorIndex)
        {
            linkedImage.copy_color_vspan(x, y, len, colors, colorIndex);
        }

        public virtual void blend_solid_vspan(int x, int y, int len, RGBA_Floats c, byte[] covers, int coversIndex)
        {
            linkedImage.blend_solid_vspan(x, y, len, c, covers, coversIndex);
        }

        public virtual void blend_color_hspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            linkedImage.blend_color_hspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }

        public virtual void blend_color_vspan(int x, int y, int len, RGBA_Floats[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            linkedImage.blend_color_vspan(x, y, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }

        public float[] GetBuffer()
        {
            return linkedImage.GetBuffer();
        }

        public int GetBufferOffsetY(int y)
        {
            return linkedImage.GetBufferOffsetY(y);
        }

        public int GetBufferOffsetXY(int x, int y)
        {
            return linkedImage.GetBufferOffsetXY(x, y);
        }

        public virtual int GetFloatsBetweenPixelsInclusive()
        {
            return linkedImage.GetFloatsBetweenPixelsInclusive();
        }

        public virtual int BitDepth
        {
            get
            {
                return linkedImage.BitDepth;
            }
        }

        public void MarkImageChanged()
        {
            linkedImage.MarkImageChanged();
        }
    }
}

#endregion //ImageProxy.cs
#region ImageSequence.cs

namespace MatterHackers.Agg.Image
{
    public class ImageSequence
    {
        double secondsPerFrame = 1.0 / 30.0;
        public double FramePerSecond
        {
            get { return 1 / secondsPerFrame; }
            set { secondsPerFrame = 1 / value; }
        }

        public double SecondsPerFrame
        {
            get { return secondsPerFrame; }
            set { secondsPerFrame = value; }
        }

        public int NumFrames
        {
            get { return imageList.Count; }
        }

        public int Width
        {
            get
            {
                RectangleInt bounds = new RectangleInt(int.MaxValue, int.MaxValue, int.MinValue, int.MinValue);
                foreach (ImageBuffer frame in imageList)
                {
                    bounds.ExpandToInclude(frame.GetBoundingRect());
                }

                return Math.Max(0, bounds.Width);
            }
        }

        public int Height
        {
            get
            {
                RectangleInt bounds = new RectangleInt(int.MaxValue, int.MaxValue, int.MinValue, int.MinValue);
                foreach (ImageBuffer frame in imageList)
                {
                    bounds.ExpandToInclude(frame.GetBoundingRect());
                }

                return Math.Max(0, bounds.Height);
            }
        }

        bool looping = false;

        List<ImageBuffer> imageList = new List<ImageBuffer>();

        public ImageSequence()
        {
        }

        public void SetAlpha(byte value)
        {
            foreach (ImageBuffer image in imageList)
            {
                image.SetAlpha(value);
            }
        }

        public void CenterOriginOffset()
        {
            foreach (ImageBuffer image in imageList)
            {
                image.OriginOffset = new Vector2(image.Width / 2, image.Height / 2);
            }
        }

        public void CropToVisible()
        {
            foreach (ImageBuffer image in imageList)
            {
                image.CropToVisible();
            }
        }

        public static ImageSequence LoadFromTgas(String pathName)
        {
            // First we load up the Data In the Serialization file.
            String gameDataObjectXMLPath = System.IO.Path.Combine(pathName, "ImageSequence");
            ImageSequence sequenceLoaded = new ImageSequence();

            // Now lets look for and load up any images that we find.
            String[] tgaFilesArray = System.IO.Directory.GetFiles(pathName, "*.tga");
            List<String> sortedTgaFiles = new List<string>(tgaFilesArray);
            // Make sure they are sorted.
            sortedTgaFiles.Sort();
            sequenceLoaded.imageList = new List<ImageBuffer>();
            int imageIndex = 0;
            foreach (String tgaFile in sortedTgaFiles)
            {
                sequenceLoaded.AddImage(new ImageBuffer(new BlenderPreMultBGRA()));
                System.IO.Stream imageStream = System.IO.File.Open(tgaFile, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite);
                ImageTgaIO.LoadImageData(sequenceLoaded.imageList[imageIndex], imageStream, 32);
                imageIndex++;
            }

            return sequenceLoaded;
        }

        public void AddImage(ImageBuffer imageBuffer)
        {
            imageList.Add(imageBuffer);
        }

        public int GetFrameIndexByRatio(double fractionOfTotalLength)
        {
            return (int)((fractionOfTotalLength * (NumFrames - 1)) + .5);
        }

        public ImageBuffer GetImageByTime(double NumSeconds)
        {
            double TotalSeconds = NumFrames / FramePerSecond;
            return GetImageByRatio(NumSeconds / TotalSeconds);
        }

        public ImageBuffer GetImageByRatio(double fractionOfTotalLength)
        {
            return GetImageByIndex(fractionOfTotalLength * (NumFrames - 1));
        }

        public ImageBuffer GetImageByIndex(double ImageIndex)
        {
            return GetImageByIndex((int)(ImageIndex + .5));
        }

        public ImageBuffer GetImageByIndex(int ImageIndex)
        {
            if (looping)
            {
                return imageList[ImageIndex % NumFrames];
            }

            if (ImageIndex < 0)
            {
                return imageList[0];
            }
            else if (ImageIndex > NumFrames - 1)
            {
                return imageList[NumFrames - 1];
            }

            return imageList[ImageIndex];
        }
    }
}

#endregion //ImageSequence.cs
#region ImageTgaIO.cs

namespace MatterHackers.Agg.Image
{
    public static class ImageTgaIO
    {
        // Header of a TGA file
        public struct STargaHeader
        {
            public byte PostHeaderSkip;
            public byte ColorMapType;		// 0 = RGB, 1 = Palette
            public byte ImageType;			// 1 = Palette, 2 = RGB, 3 = mono, 9 = RLE Palette, 10 = RLE RGB, 11 RLE mono
            public ushort ColorMapStart;
            public ushort ColorMapLength;
            public byte ColorMapBits;
            public ushort XStart;				// offsets the image would like to have (ignored)
            public ushort YStart;				// offsets the image would like to have (ignored)
            public ushort Width;
            public ushort Height;
            public byte BPP;				// bit depth of the image
            public byte Descriptor;

            public void BinaryWrite(System.IO.BinaryWriter writerToWriteTo)
            {
                writerToWriteTo.Write(PostHeaderSkip);
                writerToWriteTo.Write(ColorMapType);
                writerToWriteTo.Write(ImageType);
                writerToWriteTo.Write(ColorMapStart);
                writerToWriteTo.Write(ColorMapLength);
                writerToWriteTo.Write(ColorMapBits);
                writerToWriteTo.Write(XStart);
                writerToWriteTo.Write(YStart);
                writerToWriteTo.Write(Width);
                writerToWriteTo.Write(Height);
                writerToWriteTo.Write(BPP);
                writerToWriteTo.Write(Descriptor);
            }
        };

        private const int TargaHeaderSize = 18;
        const int RGB_BLUE = 2;
        const int RGB_GREEN = 1;
        const int RGB_RED = 0;
        const int RGBA_ALPHA = 3;

        // these are used during loading (only valid during load)
        static int TGABytesPerLine;

        static void Do24To8Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
        {
            throw new System.NotImplementedException();
#if false

	        int i;
	        if (Width) 
	        {
		        i = 0;
		        Dest = &Dest[Height*Width];
		        do 
		        {
			        if(p[RGB_RED] == 0 && p[RGB_GREEN] == 0 && p[RGB_BLUE] == 0)
			        {
				        Dest[i] = 0;
			        }
			        else
			        {
				        // no other color can map to color 0
				        Dest[i] =(byte) pStaticRemap->GetColorIndex(p[RGB_RED], p[RGB_GREEN], p[RGB_BLUE], 1);
			        }
			        p += 3;
		        } while (++i<Width);
	        }
#endif
        }

        static void Do32To8Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
        {
            throw new System.NotImplementedException();

#if false
	        int i;
	        if (Width) 
	        {
		        i = 0;
		        Dest = &Dest[Height*Width];
		        do 
		        {
			        if(p[RGB_RED] == 0 && p[RGB_GREEN] == 0 && p[RGB_BLUE] == 0)
			        {
				        Dest[i] = 0;
			        }
			        else
			        {
				        // no other color can map to color 0
				        Dest[i] = (byte)pStaticRemap->GetColorIndex(p[RGB_RED], p[RGB_GREEN], p[RGB_BLUE], 1);
			        }
			        p += 4;
		        } while (++i < Width);
	        }
#endif
        }

        static void Do24To24Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
        {
            if (Width > 0)
            {
                int DestOffset = Height * Width * 3;
                for (int i = 0; i < Width * 3; i++)
                {
                    Dest[DestOffset + i] = Source[SourceOffset + i];
                }
            }
        }

        static void Do32To24Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
        {
            if (Width > 0)
            {
                int i = 0;
                int DestOffest = Height * Width * 3;
                do
                {
                    Dest[DestOffest + i * 3 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];
                    Dest[DestOffest + i * 3 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];
                    Dest[DestOffest + i * 3 + RGB_RED] = Source[SourceOffset + RGB_RED];
                    SourceOffset += 4;
                } while (++i < Width);
            }
        }

        static void Do24To32Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
        {
            if (Width > 0)
            {
                int i = 0;
                int DestOffest = Height * Width * 4;
                do
                {
                    Dest[DestOffest + i * 4 + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];
                    Dest[DestOffest + i * 4 + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];
                    Dest[DestOffest + i * 4 + RGB_RED] = Source[SourceOffset + RGB_RED];
                    Dest[DestOffest + i * 4 + 3] = 255;
                    SourceOffset += 3;
                } while (++i < Width);
            }
        }

        static void Do32To32Bit(byte[] Dest, byte[] Source, int SourceOffset, int Width, int Height)
        {
            if (Width > 0)
            {
                int i = 0;
                int DestOffest = Height * Width * 4;
                do
                {
                    Dest[DestOffest + RGB_BLUE] = Source[SourceOffset + RGB_BLUE];
                    Dest[DestOffest + RGB_GREEN] = Source[SourceOffset + RGB_GREEN];
                    Dest[DestOffest + RGB_RED] = Source[SourceOffset + RGB_RED];
                    Dest[DestOffest + RGBA_ALPHA] = Source[SourceOffset + RGBA_ALPHA];
                    SourceOffset += 4;
                    DestOffest += 4;
                } while (++i < Width);
            }
        }

        static bool ReadTGAInfo(byte[] WorkPtr, out STargaHeader TargaHeader)
        {
            TargaHeader.PostHeaderSkip = WorkPtr[0];
            TargaHeader.ColorMapType = WorkPtr[1];
            TargaHeader.ImageType = WorkPtr[2];
            TargaHeader.ColorMapStart = BitConverter.ToUInt16(WorkPtr, 3);
            TargaHeader.ColorMapLength = BitConverter.ToUInt16(WorkPtr, 5);
            TargaHeader.ColorMapBits = WorkPtr[7];
            TargaHeader.XStart = BitConverter.ToUInt16(WorkPtr, 8);
            TargaHeader.YStart = BitConverter.ToUInt16(WorkPtr, 10);
            TargaHeader.Width = BitConverter.ToUInt16(WorkPtr, 12);
            TargaHeader.Height = BitConverter.ToUInt16(WorkPtr, 14);
            TargaHeader.BPP = WorkPtr[16];
            TargaHeader.Descriptor = WorkPtr[17];



            // check the header
            if (TargaHeader.ColorMapType != 0 ||	// 0 = RGB, 1 = Palette
                // 1 = Palette, 2 = RGB, 3 = mono, 9 = RLE Palette, 10 = RLE RGB, 11 RLE mono
                (TargaHeader.ImageType != 2 && TargaHeader.ImageType != 10 && TargaHeader.ImageType != 9) ||
                (TargaHeader.BPP != 24 && TargaHeader.BPP != 32))
            {
#if ASSERTS_ENABLED
		        if ( ((byte*)pTargaHeader)[0] == 'B' && ((byte*)pTargaHeader)[1] == 'M' )
		        {
			        assert(!"This TGA's header looks like a BMP!"); //  look at the first two bytes and see if they are 'BM'
			        // if so it's a BMP not a TGA
		        }
		        else
		        {
			        byte * pColorMapType = NULL;
			        switch (TargaHeader.ColorMapType)
			        {
				        case 0:
					        pColorMapType = "RGB Color Map";
					        break;
				        case 1:
					        pColorMapType = "Palette Color Map";
					        break;
				        default:
					        pColorMapType = "<Illegal Color Map>";
					        break;
			        }
			        byte * pImageType = NULL;
			        switch (TargaHeader.ImageType)
			        {
				        case 1:
					        pImageType = "Palette Image Type";
					        break;
				        case 2:
					        pImageType = "RGB Image Type";
					        break;
				        case 3:
					        pImageType = "mono Image Type";
					        break;
				        case 9:
					        pImageType = "RLE Palette Image Type";
					        break;
				        case 10:
					        pImageType = "RLE RGB Image Type";
					        break;
				        case 11:
					        pImageType = "RLE mono Image Type";
					        break;
				        default:
					        pImageType = "<Illegal Image Type>";
					        break;
			        }
			        int ColorDepth = TargaHeader.BPP;
			        CJString ErrorString;
			        ErrorString.Format( "Image type %s %s (%u bpp) not supported!", pColorMapType, pImageType, ColorDepth);
			        ShowSystemMessage("TGA File IO Error", ErrorString.GetBytePtr(), "TGA Error");
		        }
#endif // ASSERTS_ENABLED
                return false;
            }

            return true;
        }

        const int IS_PIXLE_RUN = 0x80;
        const int RUN_LENGTH_MASK = 0x7f;

        static int Decompress(byte[] pDecompressBits, byte[] pBitsToPars, int ParsOffset, int Width, int Depth, int LineBeingRead)
        {
            int DecompressOffset = 0;
            int Total = 0;
            do
            {
                int i;
                int NumPixels = (pBitsToPars[ParsOffset] & RUN_LENGTH_MASK) + 1;
                Total += NumPixels;
                if ((pBitsToPars[ParsOffset++] & IS_PIXLE_RUN) != 0)
                {
                    // decompress the run for NumPixels
                    byte r, g, b, a;
                    b = pBitsToPars[ParsOffset++];
                    g = pBitsToPars[ParsOffset++];
                    r = pBitsToPars[ParsOffset++];
                    switch (Depth)
                    {
                        case 24:
                            for (i = 0; i < NumPixels; i++)
                            {
                                pDecompressBits[DecompressOffset++] = b;
                                pDecompressBits[DecompressOffset++] = g;
                                pDecompressBits[DecompressOffset++] = r;
                            }
                            break;

                        case 32:
                            a = pBitsToPars[ParsOffset++];
                            for (i = 0; i < NumPixels; i++)
                            {
                                pDecompressBits[DecompressOffset++] = b;
                                pDecompressBits[DecompressOffset++] = g;
                                pDecompressBits[DecompressOffset++] = r;
                                pDecompressBits[DecompressOffset++] = a;
                            }
                            break;

                        default:
                            throw new System.Exception("Bad bit depth.");
                    }
                }
                else // store NumPixels normally
                {
                    switch (Depth)
                    {
                        case 24:
                            for (i = 0; i < NumPixels * 3; i++)
                            {
                                pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];
                            }
                            break;

                        case 32:
                            for (i = 0; i < NumPixels * 4; i++)
                            {
                                pDecompressBits[DecompressOffset++] = pBitsToPars[ParsOffset++];
                            }
                            break;

                        default:
                            throw new System.Exception("Bad bit depth.");
                    }
                }
            } while (Total < Width);

            if (Total > Width)
            {
                throw new System.Exception("The TGA you loaded is corrupt (line " + LineBeingRead.ToString() + ").");
            }

            return ParsOffset;
        }


        static int LowLevelReadTGABitsFromBuffer(ImageBuffer imageToReadTo, byte[] wholeFileBuffer, int DestBitDepth)
        {
            STargaHeader TargaHeader = new STargaHeader();
            int FileReadOffset;

            if (!ReadTGAInfo(wholeFileBuffer, out TargaHeader))
            {
                return 0;
            }

            // if the frame we are loading is different then the one we have allocated
            // or we don't have any bits allocated

            if ((imageToReadTo.Width * imageToReadTo.Height) != (TargaHeader.Width * TargaHeader.Height))
            {
                imageToReadTo.Allocate(TargaHeader.Width, TargaHeader.Height, TargaHeader.Width * DestBitDepth / 8, DestBitDepth);
            }

            // work out the line width
            switch (imageToReadTo.BitDepth)
            {
                case 24:
                    TGABytesPerLine = imageToReadTo.Width * 3;
                    if (imageToReadTo.GetRecieveBlender() == null)
                    {
                        imageToReadTo.SetRecieveBlender(new BlenderBGR());
                    }
                    break;

                case 32:
                    TGABytesPerLine = imageToReadTo.Width * 4;
                    if (imageToReadTo.GetRecieveBlender() == null)
                    {
                        imageToReadTo.SetRecieveBlender(new BlenderBGRA());
                    }
                    break;

                default:
                    throw new System.Exception("Bad bit depth.");
            }

            if (TGABytesPerLine > 0)
            {
                byte[] BufferToDecompressTo = null;
                FileReadOffset = TargaHeaderSize + TargaHeader.PostHeaderSkip;

                if (TargaHeader.ImageType == 10) // 10 is RLE compressed
                {
                    BufferToDecompressTo = new byte[TGABytesPerLine * 2];
                }

                // read all the lines *
                for (int i = 0; i < imageToReadTo.Height; i++)
                {
                    byte[] BufferToCopyFrom;
                    int CopyOffset = 0;

                    int CurReadLine;

                    // bit 5 tells us if the image is stored top to bottom or bottom to top
                    if ((TargaHeader.Descriptor & 0x20) != 0)
                    {
                        // bottom to top
                        CurReadLine = imageToReadTo.Height - i - 1;
                    }
                    else
                    {
                        // top to bottom
                        CurReadLine = i;
                    }

                    if (TargaHeader.ImageType == 10) // 10 is RLE compressed
                    {
                        FileReadOffset = Decompress(BufferToDecompressTo, wholeFileBuffer, FileReadOffset, imageToReadTo.Width, TargaHeader.BPP, CurReadLine);
                        BufferToCopyFrom = BufferToDecompressTo;
                    }
                    else
                    {
                        BufferToCopyFrom = wholeFileBuffer;
                        CopyOffset = FileReadOffset;
                    }

                    int bufferOffset;
                    byte[] imageBuffer = imageToReadTo.GetBuffer(out bufferOffset);

                    switch (imageToReadTo.BitDepth)
                    {
                        case 8:
                            switch (TargaHeader.BPP)
                            {
                                case 24:
                                    Do24To8Bit(imageBuffer, BufferToCopyFrom, CopyOffset, imageToReadTo.Width, CurReadLine);
                                    break;

                                case 32:
                                    Do32To8Bit(imageBuffer, BufferToCopyFrom, CopyOffset, imageToReadTo.Width, CurReadLine);
                                    break;
                            }
                            break;

                        case 24:
                            switch (TargaHeader.BPP)
                            {
                                case 24:
                                    Do24To24Bit(imageBuffer, BufferToCopyFrom, CopyOffset, imageToReadTo.Width, CurReadLine);
                                    break;

                                case 32:
                                    Do32To24Bit(imageBuffer, BufferToCopyFrom, CopyOffset, imageToReadTo.Width, CurReadLine);
                                    break;
                            }
                            break;

                        case 32:
                            switch (TargaHeader.BPP)
                            {
                                case 24:
                                    Do24To32Bit(imageBuffer, BufferToCopyFrom, CopyOffset, imageToReadTo.Width, CurReadLine);
                                    break;

                                case 32:
                                    Do32To32Bit(imageBuffer, BufferToCopyFrom, CopyOffset, imageToReadTo.Width, CurReadLine);
                                    break;
                            }
                            break;

                        default:
                            throw new System.Exception("Bad bit depth");
                    }

                    if (TargaHeader.ImageType != 10) // 10 is RLE compressed
                    {
                        FileReadOffset += TGABytesPerLine;
                    }
                }
            }

            return TargaHeader.Width;
        }

        const int MAX_RUN_LENGTH = 127;
        static int memcmp(byte[] pCheck, int CheckOffset, byte[] pSource, int SourceOffset, int Width)
        {
            for (int i = 0; i < Width; i++)
            {
                if (pCheck[CheckOffset + i] < pSource[SourceOffset + i])
                {
                    return -1;
                }
                if (pCheck[CheckOffset + i] > pSource[SourceOffset + i])
                {
                    return 1;
                }
            }

            return 0;
        }

        static int GetSameLength(byte[] checkBufer, int checkOffset, byte[] sourceBuffer, int sourceOffsetToNextPixel, int numBytesInPixel, int maxSameLengthWidth)
        {
            int Count = 0;
            while (memcmp(checkBufer, checkOffset, sourceBuffer, sourceOffsetToNextPixel, numBytesInPixel) == 0 && Count < maxSameLengthWidth)
            {
                Count++;
                sourceOffsetToNextPixel += numBytesInPixel;
            }

            return Count;
        }

        static int GetDifLength(byte[] pCheck, byte[] pSource, int SourceOffset, int numBytesInPixel, int Max)
        {
            int Count = 0;
            while (memcmp(pCheck, 0, pSource, SourceOffset, numBytesInPixel) != 0 && Count < Max)
            {
                Count++;
                for (int i = 0; i < numBytesInPixel; i++)
                {
                    pCheck[i] = pSource[SourceOffset + i];
                }
                SourceOffset += numBytesInPixel;
            }

            return Count;
        }

        const int MIN_RUN_LENGTH = 2;

        static int CompressLine8(byte[] destBuffer, byte[] sourceBuffer, int sourceOffset, int Width)
        {
            int WritePos = 0;
            int pixelsProcessed = 0;

            while (pixelsProcessed < Width)
            {
                // always get as many as you can that are the same first
                int Max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - pixelsProcessed);
                int SameLength = GetSameLength(sourceBuffer, sourceOffset, sourceBuffer, sourceOffset + 1, 1, Max);
                if (SameLength >= MIN_RUN_LENGTH)
                //if(SameLength)
                {
                    // write in the count
                    if (SameLength > MAX_RUN_LENGTH)
                    {
                        throw new System.Exception("Bad Length");
                    }
                    destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);

                    // write in the same length pixel value
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset];

                    pixelsProcessed += SameLength + 1;
                }
                else
                {
                    byte CheckPixel = sourceBuffer[sourceOffset];
                    int DifLength = Max;

                    if (DifLength == 0)
                    {
                        DifLength = 1;
                    }
                    // write in the count (if there is only one the count is 0)
                    if (DifLength > MAX_RUN_LENGTH)
                    {
                        throw new System.Exception("Bad Length");
                    }

                    destBuffer[WritePos++] = (byte)(DifLength - 1);

                    while (DifLength-- != 0)
                    {
                        // write in the same length pixel value
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset++];
                        pixelsProcessed++;
                    }
                }
            }

            return WritePos;
        }

        static byte[] differenceHold = new byte[4];

        static int CompressLine24(byte[] destBuffer, byte[] sourceBuffer, int sourceOffset, int Width)
        {
            int WritePos = 0;
            int pixelsProcessed = 0;

            while (pixelsProcessed < Width)
            {
                // always get as many as you can that are the same first
                int Max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - pixelsProcessed);
                int SameLength = GetSameLength(sourceBuffer, sourceOffset, sourceBuffer, sourceOffset + 3, 3, Max);
                if (SameLength > 0)
                {
                    // write in the count
                    if (SameLength > MAX_RUN_LENGTH)
                    {
                        throw new Exception();
                    }

                    destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);

                    // write in the same length pixel value
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];

                    sourceOffset += (SameLength) * 3;
                    pixelsProcessed += SameLength + 1;
                }
                else
                {
                    differenceHold[0] = sourceBuffer[sourceOffset + 0];
                    differenceHold[1] = sourceBuffer[sourceOffset + 1];
                    differenceHold[2] = sourceBuffer[sourceOffset + 2];
                    int DifLength = GetDifLength(differenceHold, sourceBuffer, sourceOffset + 3, 3, Max);
                    if (DifLength == 0)
                    {
                        DifLength = 1;
                    }

                    // write in the count (if there is only one the count is 0)
                    if (SameLength > MAX_RUN_LENGTH)
                    {
                        throw new Exception();
                    }
                    destBuffer[WritePos++] = (byte)(DifLength - 1);

                    while (DifLength-- > 0)
                    {
                        // write in the same length pixel value
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];

                        sourceOffset += 3;
                        pixelsProcessed++;
                    }
                }
            }

            return WritePos;
        }

        static int CompressLine32(byte[] destBuffer, byte[] sourceBuffer, int sourceOffset, int Width)
        {
            int WritePos = 0;
            int pixelsProcessed = 0;

            while (pixelsProcessed < Width)
            {
                // always get as many as you can that are the same first
                int Max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - pixelsProcessed);
                int SameLength = GetSameLength(sourceBuffer, sourceOffset, sourceBuffer, sourceOffset + 4, 4, Max);
                if (SameLength > 0)
                {
                    // write in the count
                    if (SameLength > MAX_RUN_LENGTH)
                    {
                        throw new Exception();
                    }

                    destBuffer[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);

                    // write in the same length pixel value
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];
                    destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];

                    sourceOffset += (SameLength) * 4;
                    pixelsProcessed += SameLength + 1;
                }
                else
                {
                    differenceHold[0] = sourceBuffer[sourceOffset + 0];
                    differenceHold[1] = sourceBuffer[sourceOffset + 1];
                    differenceHold[2] = sourceBuffer[sourceOffset + 2];
                    differenceHold[3] = sourceBuffer[sourceOffset + 3];
                    int DifLength = GetDifLength(differenceHold, sourceBuffer, sourceOffset + 4, 4, Max);
                    if (DifLength == 0)
                    {
                        DifLength = 1;
                    }

                    // write in the count (if there is only one the count is 0)
                    if (SameLength > MAX_RUN_LENGTH)
                    {
                        throw new Exception();
                    }
                    destBuffer[WritePos++] = (byte)(DifLength - 1);

                    while (DifLength-- > 0)
                    {
                        // write in the dif length pixel value
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset + 0];
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset + 1];
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset + 2];
                        destBuffer[WritePos++] = sourceBuffer[sourceOffset + 3];

                        sourceOffset += 4;
                        pixelsProcessed++;
                    }
                }
            }

            return WritePos;
            /*
            while(SourcePos < Width)
            {
                // always get as many as you can that are the same first
                int Max = System.Math.Min(MAX_RUN_LENGTH, (Width - 1) - SourcePos);
                int SameLength = GetSameLength((byte*)&pSource[SourcePos], (byte*)&pSource[SourcePos + 1], 4, Max);
                if(SameLength)
                {
                    // write in the count
                    assert(SameLength<= MAX_RUN_LENGTH);
                    pDest[WritePos++] = (byte)((SameLength) | IS_PIXLE_RUN);

                    // write in the same length pixel value
                    pDest[WritePos++] = pSource[SourcePos].Blue;
                    pDest[WritePos++] = pSource[SourcePos].Green;
                    pDest[WritePos++] = pSource[SourcePos].Red;
                    pDest[WritePos++] = pSource[SourcePos].Alpha;

                    SourcePos += SameLength + 1;
                }
                else
                {
                    Pixel32 CheckPixel = pSource[SourcePos];
                    int DifLength = GetDifLength((byte*)&CheckPixel, (byte*)&pSource[SourcePos+1], 4, Max);
                    if(!DifLength)
                    {
                        DifLength = 1;
                    }

                    // write in the count (if there is only one the count is 0)
                    assert(DifLength <= MAX_RUN_LENGTH);
                    pDest[WritePos++] = (byte)(DifLength-1);

                    while(DifLength--)
                    {
                        // write in the same length pixel value
                        pDest[WritePos++] = pSource[SourcePos].Blue;
                        pDest[WritePos++] = pSource[SourcePos].Green;
                        pDest[WritePos++] = pSource[SourcePos].Red;
                        pDest[WritePos++] = pSource[SourcePos].Alpha;
                        SourcePos++;
                    }
                }
            }

            return WritePos;
             */
        }

        static public bool SaveImageData(String fileNameToSaveTo, ImageBuffer image)
        {
            return Save(image, fileNameToSaveTo);
        }

        static public bool Save(ImageBuffer image, String fileNameToSaveTo)
        {
            System.IO.Stream file = System.IO.File.Open(fileNameToSaveTo, System.IO.FileMode.Create);
            return Save(image, file);
        }

        static public bool Save(ImageBuffer image, System.IO.Stream streamToSaveImageDataTo)
        {
            STargaHeader TargaHeader;

            System.IO.BinaryWriter writerToSaveTo = new System.IO.BinaryWriter(streamToSaveImageDataTo);

            int SourceDepth = image.BitDepth;

            // make sure there is something to save before opening the file
            if (image.Width <= 0 || image.Height <= 0)
            {
                return false;
            }

            // set up the header
            TargaHeader.PostHeaderSkip = 0;	// no skip after the header
            if (SourceDepth == 8)
            {
                TargaHeader.ColorMapType = 1;		// Color type is Palette
                TargaHeader.ImageType = 9;		// 1 = Palette, 9 = RLE Palette
                TargaHeader.ColorMapStart = 0;
                TargaHeader.ColorMapLength = 256;
                TargaHeader.ColorMapBits = 24;
            }
            else
            {
                TargaHeader.ColorMapType = 0;		// Color type is RGB
#if WRITE_RLE_COMPRESSED
		        TargaHeader.ImageType = 10;		// RLE RGB
#else
                TargaHeader.ImageType = 2;		// RGB
#endif
                TargaHeader.ColorMapStart = 0;
                TargaHeader.ColorMapLength = 0;
                TargaHeader.ColorMapBits = 0;
            }
            TargaHeader.XStart = 0;
            TargaHeader.YStart = 0;
            TargaHeader.Width = (ushort)image.Width;
            TargaHeader.Height = (ushort)image.Height;
            TargaHeader.BPP = (byte)SourceDepth;
            TargaHeader.Descriptor = 0;	// all 8 bits are used for alpha

            TargaHeader.BinaryWrite(writerToSaveTo);

            byte[] pLineBuffer = new byte[image.StrideInBytesAbs() * 2];

            //int BytesToSave;
            switch (SourceDepth)
            {
                case 8:
                    /*
                if (image.HasPalette())
                {
                    for(int i=0; i<256; i++)
                    {
                        TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_BLUE]);
                        TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_GREEN]);
                        TGAFile.Write(image.GetPaletteIfAllocated()->pPalette[i * RGB_SIZE + RGB_RED]);
                    }
                } 
                else 
                     */
                    {	// there is no palette for this DIB but we should write something
                        for (int i = 0; i < 256; i++)
                        {
                            writerToSaveTo.Write((byte)i);
                            writerToSaveTo.Write((byte)i);
                            writerToSaveTo.Write((byte)i);
                        }
                    }
                    for (int i = 0; i < image.Height; i++)
                    {
                        int bufferOffset;
                        byte[] buffer = image.GetPixelPointerY(i, out bufferOffset);
#if WRITE_RLE_COMPRESSED
                    BytesToSave = CompressLine8(pLineBuffer, buffer, bufferOffset, image.Width());
			        writerToSaveTo.Write(pLineBuffer, 0, BytesToSave);
#else
                        writerToSaveTo.Write(buffer, bufferOffset, image.Width);
#endif
                    }
                    break;

                case 24:
                    for (int i = 0; i < image.Height; i++)
                    {
                        int bufferOffset;
                        byte[] buffer = image.GetPixelPointerY(i, out bufferOffset);
#if WRITE_RLE_COMPRESSED
                    BytesToSave = CompressLine24(pLineBuffer, buffer, bufferOffset, image.Width());
                    writerToSaveTo.Write(pLineBuffer, 0, BytesToSave);
#else
                        writerToSaveTo.Write(buffer, bufferOffset, image.Width * 3);
#endif
                    }
                    break;

                case 32:
                    for (int i = 0; i < image.Height; i++)
                    {
                        int bufferOffset;
                        byte[] buffer = image.GetPixelPointerY(i, out bufferOffset);
#if WRITE_RLE_COMPRESSED
                    BytesToSave = CompressLine32(pLineBuffer, buffer, bufferOffset, image.Width);
                    writerToSaveTo.Write(pLineBuffer, 0, BytesToSave);
#else
                        writerToSaveTo.Write(buffer, bufferOffset, image.Width * 4);
#endif
                    }
                    break;

                default:
                    throw new NotSupportedException();
            }

            writerToSaveTo.Close();
            return true;
        }

        /*
        bool SourceNeedsToBeResaved(String pFileName)
        {
            CFile TGAFile;
            if(TGAFile.Open(pFileName, CFile::modeRead))
            {
                STargaHeader TargaHeader;
                byte[] pWorkPtr = new byte[sizeof(STargaHeader)];

                TGAFile.Read(pWorkPtr, sizeof(STargaHeader));
                TGAFile.Close();

                if(ReadTGAInfo(pWorkPtr, &TargaHeader))
                {
                    ArrayDeleteAndSetNull(pWorkPtr);
                    return TargaHeader.ImageType != 10;
                }

                ArrayDeleteAndSetNull(pWorkPtr);
            }

            return true;
        }
         */

        static public int ReadBitsFromBuffer(ImageBuffer image, byte[] WorkPtr, int destBitDepth)
        {
            return LowLevelReadTGABitsFromBuffer(image, WorkPtr, destBitDepth);
        }

        public static bool LoadImageData(string fileName, ImageBuffer image)
        {
            return LoadImageData(image, fileName);
        }

        static public bool LoadImageData(ImageBuffer image, string fileName)
        {
            if (System.IO.File.Exists(fileName))
            {
                System.IO.StreamReader streamReader = new System.IO.StreamReader(fileName);
                return LoadImageData(image, streamReader.BaseStream, 32);
            }

            return false;
        }

        static public bool LoadImageData(ImageBuffer image, System.IO.Stream streamToLoadImageDataFrom, int destBitDepth)
        {
            byte[] ImageData = new byte[streamToLoadImageDataFrom.Length];
            streamToLoadImageDataFrom.Read(ImageData, 0, (int)streamToLoadImageDataFrom.Length);
            return ReadBitsFromBuffer(image, ImageData, destBitDepth) > 0;
        }

        static public int GetBitDepth(System.IO.Stream streamToReadFrom)
        {
            STargaHeader TargaHeader;
            byte[] ImageData = new byte[streamToReadFrom.Length];
            streamToReadFrom.Read(ImageData, 0, (int)streamToReadFrom.Length);
            if (ReadTGAInfo(ImageData, out TargaHeader))
            {
                return TargaHeader.BPP;
            }

            return 0;
        }
    }
}

#endregion //ImageTgaIO.cs
#region IMarkers.cs


//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
    public interface IMarkers
    {
        void remove_all();
        void add_vertex(double x, double y, ShapePath.FlagsAndCommand unknown);
    };
}

#endregion //IMarkers.cs
#region IScanline.cs

namespace MatterHackers.Agg
{
    public struct ScanlineSpan
    {
        public int x;
        public int len;
        public int cover_index;
    };

    public interface IScanlineCache
    {
        void finalize(int y);
        void reset(int min_x, int max_x);
        void ResetSpans();
        int num_spans();
        ScanlineSpan begin();
        ScanlineSpan GetNextScanlineSpan();
        int y();
        byte[] GetCovers();
        void add_cell(int x, int cover);
        void add_span(int x, int len, int cover);
    };
}

#endregion //IScanline.cs
#region ITransform.cs


//----------------------------------------------------------------------------
namespace MatterHackers.Agg.Transform
{
    public interface ITransform
    {
        void transform(ref double x, ref double y);
    };
}

#endregion //ITransform.cs
#region IVertexDest.cs

//----------------------------------------------------------------------------

namespace MatterHackers.Agg
{
    public interface IVertexDest
    {
        void remove_all();

        int size();
        void add(Vector2 vertex);

        Vector2 this[int i]
        {
            get;
        }
    };
}

#endregion //IVertexDest.cs
#region IVertexSource.cs

namespace MatterHackers.Agg.VertexSource
{
    public struct VertexData
    {
        public VertexData(ShapePath.FlagsAndCommand command, Vector2 position)
        {
            this.command = command;
            this.position = position;
        }

        public ShapePath.FlagsAndCommand command;
        public Vector2 position;

        public bool IsMoveTo
        {
            get { return ShapePath.is_move_to(command); }
        }

        public bool IsLineTo
        {
            get { return ShapePath.is_line_to(command); }
        }
    }

    public interface IVertexSource
    {
        IEnumerable<VertexData> Vertices();

        void rewind(int pathId = 0); // for a PathStorage this is the vertex index.
        ShapePath.FlagsAndCommand vertex(out double x, out double y);
    }

    public interface IVertexSourceProxy : IVertexSource
    {
        IVertexSource VertexSource { get; set; }
    }
}

#endregion //IVertexSource.cs
#region KDTree.cs

namespace MatterHackers.Agg
{
    public interface IKDLeafItem
    {
        int Dimensions
        {
            get;
        }

        double GetPositionForDimension(int dimension);
        void SetPositionForDimension(int dimension, double position);
    }

    public class KDTreeNode<StoredType> where StoredType : IKDLeafItem
    {
        public double SplitPosition { get; set; }
        public int DimensionSplitIsOn { get; set; }

        public KDTreeNode<StoredType> NodeLessThanSplit { get; set; }
        public KDTreeNode<StoredType> NodeGreaterThanOrEqualToSplit { get; set; }
        public StoredType LeafItem { get; set; }

        public IEnumerable GetDistanceEnumerator(double[] distanceOnEachDimension)
        {
            if (LeafItem != null && distanceOnEachDimension.Length != LeafItem.Dimensions)
            {
                throw new ArgumentException("You must pass in an array that is the same number of dimensions as the StoredType.");
            }

            throw new NotImplementedException();
        }

        public IEnumerable<StoredType> UnorderedEnumerator()
        {
            if (NodeLessThanSplit != null)
            {
                foreach (StoredType item in NodeLessThanSplit.UnorderedEnumerator())
                {
                    yield return item;
                }
            }

            if (NodeGreaterThanOrEqualToSplit != null)
            {
                foreach (StoredType item in NodeGreaterThanOrEqualToSplit.UnorderedEnumerator())
                {
                    yield return item;
                }
            }

            if (LeafItem != null)
            {
                yield return LeafItem;
            }
        }

        public static double FindMedianOnDimension(IEnumerable<StoredType> listToCreateFrom, int dimension, out int count)
        {
            count = 0;
            double accumulatedPosition = 0;
            foreach (StoredType item in listToCreateFrom)
            {
                count++;
                accumulatedPosition += item.GetPositionForDimension(dimension);
            }

            if (count > 0)
            {
                return accumulatedPosition / count;
            }

            return 0;
        }

        public static KDTreeNode<StoredType> CreateTree(IEnumerable<StoredType> collectionToCreateFrom, int splitingDimension = 0)
        {
            //KDTreeUnitTests.Run();

            int count;
            double medianOnDimension = FindMedianOnDimension(collectionToCreateFrom, splitingDimension, out count);

            if (count == 0)
            {
                return null;
            }

            StoredType firstItemFromCollection = default(StoredType); // if StoredType is a class this will set it to null - if struct, a zeroed struct.
            foreach (StoredType item in collectionToCreateFrom)
            {
                firstItemFromCollection = item;
                break;
            }

            KDTreeNode<StoredType> newNode = new KDTreeNode<StoredType>();
            newNode.DimensionSplitIsOn = splitingDimension;

            if (count > 1)
            {
                newNode.SplitPosition = medianOnDimension;
                List<StoredType> lessThanList = new List<StoredType>();
                List<StoredType> greaterThanOrEqualList = new List<StoredType>();
                foreach (StoredType item in collectionToCreateFrom)
                {
                    double positionOfItemOnDimension = item.GetPositionForDimension(splitingDimension);
                    if (positionOfItemOnDimension < newNode.SplitPosition)
                    {
                        lessThanList.Add(item);
                    }
                    else
                    {
                        if (positionOfItemOnDimension == newNode.SplitPosition && newNode.LeafItem == null)
                        {
                            // if all the points were in exactly the same position we would just get a big linked list.
                            newNode.LeafItem = item;
                        }
                        else
                        {
                            greaterThanOrEqualList.Add(item);
                        }
                    }
                }

                int nextSplitDimension = (splitingDimension + 1) % firstItemFromCollection.Dimensions;
                newNode.NodeLessThanSplit = CreateTree(lessThanList, nextSplitDimension);
                newNode.NodeGreaterThanOrEqualToSplit = CreateTree(greaterThanOrEqualList, nextSplitDimension);

                return newNode;
            }

            newNode.LeafItem = firstItemFromCollection;

            return newNode;
        }
    }

    public class Vector2DLeafItem : IKDLeafItem
    {
        Vector2 position;

        public Vector2DLeafItem() { }

        public Vector2DLeafItem(double x, double y)
        {
            position.x = x;
            position.y = y;
        }

        public int Dimensions { get { return 2; } }
        public double GetPositionForDimension(int dimension) { return position[dimension]; }
        public void SetPositionForDimension(int dimension, double position) { this.position[dimension] = position; }
    }

    public class Vector3DLeafItem : IKDLeafItem
    {
        Vector3 position;

        public Vector3DLeafItem() { }

        public Vector3DLeafItem(double x, double y, double z)
        {
            position.x = x;
            position.y = y;
            position.z = z;
        }

        public int Dimensions { get { return 3; } }
        public double GetPositionForDimension(int dimension) { return position[dimension]; }
        public void SetPositionForDimension(int dimension, double position) { this.position[dimension] = position; }
    }

    //[TestFixture]
    //public class KDTreeTests
    //{
    //    [Test]
    //    public void SamePointTest2D()
    //    {
    //        Vector2DLeafItem item1 = new Vector2DLeafItem(5, 5);
    //        Vector2DLeafItem item2 = new Vector2DLeafItem(5, 5);
    //        Vector2DLeafItem item3 = new Vector2DLeafItem(5, 5);
    //        IEnumerable<Vector2DLeafItem> enumerable = new Vector2DLeafItem[] { item1, item2, item3 }.AsEnumerable<Vector2DLeafItem>();
    //        KDTreeNode<Vector2DLeafItem> rootNode = KDTreeNode<Vector2DLeafItem>.CreateTree(enumerable);

    //        KDTreeNode<Vector2DLeafItem> testNode = rootNode;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 0);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit != null);
    //        Assert.IsTrue(testNode.LeafItem == item1);

    //        testNode = testNode.NodeGreaterThanOrEqualToSplit;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 1);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit != null);
    //        Assert.IsTrue(testNode.LeafItem == item2);

    //        testNode = testNode.NodeGreaterThanOrEqualToSplit;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 0);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit == null);
    //        Assert.IsTrue(testNode.LeafItem == item3);
    //    }

    //    private static void RunTestOnNode3D(Vector3DLeafItem item1, Vector3DLeafItem item2, Vector3DLeafItem item3, KDTreeNode<Vector3DLeafItem> rootNode)
    //    {
    //        KDTreeNode<Vector3DLeafItem> testNode = rootNode;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 0);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit != null);
    //        Assert.IsTrue(testNode.LeafItem == item1);

    //        testNode = testNode.NodeGreaterThanOrEqualToSplit;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 1);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit != null);
    //        Assert.IsTrue(testNode.LeafItem == item2);

    //        testNode = testNode.NodeGreaterThanOrEqualToSplit;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 2);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit == null);
    //        Assert.IsTrue(testNode.LeafItem == item3);
    //    }

    //    [Test]
    //    public void SamePointTest3D()
    //    {
    //        Vector3DLeafItem item1 = new Vector3DLeafItem(5, 5, 5);
    //        Vector3DLeafItem item2 = new Vector3DLeafItem(5, 5, 5);
    //        Vector3DLeafItem item3 = new Vector3DLeafItem(5, 5, 5);
    //        IEnumerable<Vector3DLeafItem> enumerable = new Vector3DLeafItem[] { item1, item2, item3 }.AsEnumerable<Vector3DLeafItem>();
    //        KDTreeNode<Vector3DLeafItem> rootNode = KDTreeNode<Vector3DLeafItem>.CreateTree(enumerable);

    //        RunTestOnNode3D(item1, item2, item3, rootNode);
    //    }

    //    [Test]
    //    public void CreateFromKDTree()
    //    {
    //        Vector3DLeafItem item1 = new Vector3DLeafItem(5, 5, 5);
    //        Vector3DLeafItem item2 = new Vector3DLeafItem(5, 5, 5);
    //        Vector3DLeafItem item3 = new Vector3DLeafItem(5, 5, 5);
    //        IEnumerable<Vector3DLeafItem> enumerable = new Vector3DLeafItem[] { item1, item2, item3 }.AsEnumerable<Vector3DLeafItem>();
    //        KDTreeNode<Vector3DLeafItem> rootNode = KDTreeNode<Vector3DLeafItem>.CreateTree(enumerable);
    //        RunTestOnNode3D(item1, item2, item3, rootNode);

    //        KDTreeNode<Vector3DLeafItem> fromRootNode = KDTreeNode<Vector3DLeafItem>.CreateTree(rootNode.UnorderedEnumerator());

    //        KDTreeNode<Vector3DLeafItem> testNode = fromRootNode;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 0);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit != null);

    //        testNode = testNode.NodeGreaterThanOrEqualToSplit;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 1);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit != null);

    //        testNode = testNode.NodeGreaterThanOrEqualToSplit;
    //        Assert.IsTrue(testNode.DimensionSplitIsOn == 2);
    //        Assert.IsTrue(testNode.NodeLessThanSplit == null);
    //        Assert.IsTrue(testNode.NodeGreaterThanOrEqualToSplit == null);
    //    }

    //    [Test]
    //    public void EnumerateFromPoint()
    //    {
    //        Vector3DLeafItem item1 = new Vector3DLeafItem(1, 0, 0);
    //        Vector3DLeafItem item2 = new Vector3DLeafItem(2, 0, 0);
    //        Vector3DLeafItem item3 = new Vector3DLeafItem(3, 0, 0);
    //        IEnumerable<Vector3DLeafItem> enumerable = new Vector3DLeafItem[] { item1, item2, item3 }.AsEnumerable<Vector3DLeafItem>();
    //        KDTreeNode<Vector3DLeafItem> rootNode = KDTreeNode<Vector3DLeafItem>.CreateTree(enumerable);

    //        int index = 0;
    //        foreach (Vector3DLeafItem item in rootNode.GetDistanceEnumerator(new double[] { 2.1, 0, 0 }))
    //        {
    //            switch (index++)
    //            {
    //                case 0:
    //                    Assert.IsTrue(item == item2);
    //                    break;

    //                case 1:
    //                    Assert.IsTrue(item == item3);
    //                    break;

    //                case 2:
    //                    Assert.IsTrue(item == item1);
    //                    break;
    //            }
    //        }
    //    }
    //}

    //public static class KDTreeUnitTests
    //{
    //    static bool ranTests = false;

    //    public static bool RanTests { get { return ranTests; } }
    //    public static void Run()
    //    {
    //        if (!ranTests)
    //        {
    //            ranTests = true;
    //            KDTreeTests test = new KDTreeTests();
    //            test.SamePointTest2D();
    //            test.SamePointTest3D();
    //            test.CreateFromKDTree();
    //            test.EnumerateFromPoint();
    //        }
    //    }
    //}
}

#endregion //KDTree.cs
#region LiberationSansFont.cs

namespace MatterHackers.Agg.Font
{
    public class LiberationSansFont
    {
        static TypeFace instance;

        public static TypeFace Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new TypeFace();
                    instance.ReadSVG(FontData());
                }

                return instance;
            }
        }

        private static String FontData()
        {
            return @"<?xml version=""1.0"" standalone=""no""?>
<!DOCTYPE svg PUBLIC ""-//W3C//DTD SVG 1.1//EN"" ""http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"" >
<svg>
<metadata>
Created by FontForge 20110222 at Mon Jun 27 20:33:45 2011
 By Application Server
Copyright (c) 2007 Red Hat, Inc. All rights reserved. LIBERATION is a trademark of Red Hat, Inc.
</metadata>
<defs>
<font id=""LiberationSans"" horiz-adv-x=""1139"" >
  <font-face 
    font-family=""Liberation Sans""
    font-weight=""400""
    font-stretch=""normal""
    units-per-em=""2048""
    panose-1=""2 11 6 4 2 2 2 2 2 4""
    ascent=""1638""
    descent=""-410""
    x-height=""1082""
    cap-height=""1409""
    bbox=""-416 -621 2151 1864""
    underline-thickness=""150""
    underline-position=""-142""
    unicode-range=""U+0020-F005""
  />
<missing-glyph horiz-adv-x=""748"" 
d=""M68 0v1365h544v-1365h-544zM136 68h408v1229h-408v-1229z"" />
    <glyph glyph-name="".notdef"" horiz-adv-x=""748"" 
d=""M68 0v1365h544v-1365h-544zM136 68h408v1229h-408v-1229z"" />
    <glyph glyph-name="".null"" horiz-adv-x=""0"" 
 />
    <glyph glyph-name=""nonmarkingreturn"" horiz-adv-x=""682"" 
 />
    <glyph glyph-name=""uni00A0"" unicode="" "" horiz-adv-x=""569"" 
 />
    <glyph glyph-name=""uni00A0"" unicode=""&#xa0;"" horiz-adv-x=""569"" 
 />
    <glyph glyph-name=""exclam"" unicode=""!"" horiz-adv-x=""569"" 
d=""M359 397h-148l-24 1012h196zM185 0v201h194v-201h-194z"" />
    <glyph glyph-name=""quotedbl"" unicode=""&#x22;"" horiz-adv-x=""727"" 
d=""M618 966h-142l-20 443h184zM249 966h-141l-21 443h184z"" />
    <glyph glyph-name=""numbersign"" unicode=""#"" 
d=""M896 885l-78 -369h260v-108h-283l-88 -408h-110l86 408h-363l-84 -408h-110l84 408h-201v108h225l78 369h-252v108h274l89 408h110l-88 -408h363l88 408h110l-88 -408h211v-108h-233zM425 885l-80 -369h362l78 369h-360z"" />
    <glyph glyph-name=""dollar"" unicode=""$"" 
d=""M518 20q-217 9 -339.5 101.5t-156.5 257.5l170 37q11 -53 34 -96.5t62 -75.5t95.5 -51.5t134.5 -24.5v496l-20 5q-77 18 -151 43t-132 66.5t-93.5 105.5t-35.5 162q0 84 32 146t89.5 103.5t136.5 63.5t174 26v131h124v-131q100 -5 172.5 -27.5t123.5 -62.5t84 -97.5
t53 -132.5l-174 -33q-20 94 -81 146.5t-178 63.5v-445q59 -14 116 -29t108.5 -35.5t95.5 -48.5t76 -67.5t50 -94t18 -126.5q0 -77 -28 -142.5t-85 -115.5t-144.5 -81t-206.5 -37v-162h-124v162zM934 394q0 63 -23.5 103t-64 65.5t-93.5 41.5t-111 31v-468q65 4 119 19.5
t92.5 43.5t59.5 68.5t21 95.5zM258 1048q0 -54 20 -91t55 -62t82.5 -41.5t102.5 -30.5v421q-72 -4 -122 -20.5t-80.5 -42.5t-44 -60t-13.5 -73z"" />
    <glyph glyph-name=""percent"" unicode=""%"" horiz-adv-x=""1821"" 
d=""M1748 434q0 -125 -25.5 -210.5t-69 -138t-101.5 -75t-124 -22.5t-123.5 22.5t-100 74.5t-67 137.5t-24.5 211.5q0 133 24 220t67 138.5t101.5 72t126.5 20.5q66 0 123.5 -20.5t100 -72t67.5 -138.5t25 -220zM527 0h-155l922 1409h157zM394 1421q64 0 121 -20.5t100 -71.5
t67.5 -137t24.5 -217q0 -126 -25 -212t-67.5 -139.5t-100.5 -76.5t-124 -23q-67 0 -125 23t-100.5 76t-67 139t-24.5 213q0 131 24.5 217t67.5 137t102 71.5t127 20.5zM1600 434q0 99 -11 164.5t-32.5 104.5t-53 55t-71.5 16q-42 0 -74 -16.5t-54 -55.5t-33 -104.5
t-11 -163.5q0 -95 11.5 -159t33 -103.5t53 -56.5t72.5 -17q39 0 70.5 17t53.5 56.5t34 103.5t12 159zM560 975q0 98 -11 163t-32 104t-52 55t-71 16q-43 0 -75.5 -16.5t-54.5 -55.5t-33 -104t-11 -162q0 -95 11.5 -160t33 -104.5t53.5 -56.5t74 -17q38 0 69 17t53 56.5
t34 104.5t12 160z"" />
    <glyph glyph-name=""ampersand"" unicode=""&#x26;"" horiz-adv-x=""1366"" 
d=""M1193 -12q-96 0 -168 33t-130 94q-30 -26 -68 -50t-84.5 -43t-101 -30.5t-118.5 -11.5q-117 0 -202.5 30t-140.5 82.5t-81.5 124t-26.5 154.5q0 79 25.5 143.5t71 117t108.5 94t138 74.5q-18 34 -32.5 72.5t-25.5 77.5t-17 78t-6 74q0 66 20 123.5t62.5 100t109 67
t159.5 24.5q73 0 134.5 -19t106.5 -55t70 -89t25 -121q0 -75 -33 -133.5t-89 -104.5t-130 -83.5t-157 -70.5q62 -114 135 -214.5t158 -197.5q61 90 101.5 189.5t69.5 220.5l145 -43q-35 -139 -88.5 -252.5t-123.5 -216.5q53 -54 106 -76t102 -22q32 0 61.5 3.5t55.5 12.5
v-135q-28 -11 -65.5 -16.5t-75.5 -5.5zM869 1133q0 37 -13.5 67t-37.5 51.5t-58.5 33t-76.5 11.5q-96 0 -146 -51.5t-50 -142.5q0 -59 18.5 -123.5t46.5 -120.5q65 26 123 53.5t101 60t68 72t25 89.5zM795 217q-89 105 -171 220t-148 237q-113 -48 -174.5 -122t-61.5 -179
q0 -55 17.5 -102.5t53.5 -83t90.5 -56t127.5 -20.5q44 0 83.5 9.5t73.5 24.5t61.5 34t47.5 38z"" />
    <glyph glyph-name=""quotesingle"" unicode=""'"" horiz-adv-x=""391"" 
d=""M266 966h-141l-21 443h184z"" />
    <glyph glyph-name=""parenleft"" unicode=""("" horiz-adv-x=""682"" 
d=""M127 532q0 139 21 266t66 244t115 227t167 215h174q-94 -105 -162.5 -215.5t-112.5 -228t-65.5 -244.5t-21.5 -266t21.5 -266t65.5 -245t112.5 -228t162.5 -215h-174q-97 105 -167 215t-115 227t-66 243.5t-21 266.5v4z"" />
    <glyph glyph-name=""parenright"" unicode="")"" horiz-adv-x=""682"" 
d=""M555 528q0 -140 -21 -266.5t-66 -243.5t-115 -227t-167 -215h-174q94 105 162.5 215t112.5 228t65.5 245t21.5 266t-21.5 266t-65.5 244.5t-112.5 228t-162.5 215.5h174q97 -105 167 -215t115 -227t66 -244t21 -266v-4z"" />
    <glyph glyph-name=""asterisk"" unicode=""*"" horiz-adv-x=""797"" 
d=""M456 1114l264 103l45 -132l-282 -73l185 -250l-119 -72l-150 258l-156 -256l-119 72l189 248l-280 73l45 134l267 -107l-12 297h136z"" />
    <glyph glyph-name=""plus"" unicode=""+"" horiz-adv-x=""1196"" 
d=""M671 608v-428h-147v428h-424v146h424v428h147v-428h424v-146h-424z"" />
    <glyph glyph-name=""comma"" unicode="","" horiz-adv-x=""569"" 
d=""M385 219v-168q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v219h195z"" />
    <glyph glyph-name=""uni00AD"" unicode=""-"" horiz-adv-x=""682"" 
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""uni00AD"" unicode=""&#xad;"" horiz-adv-x=""682"" 
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""period"" unicode=""."" horiz-adv-x=""569"" 
d=""M187 0v219h195v-219h-195z"" />
    <glyph glyph-name=""slash"" unicode=""/"" horiz-adv-x=""569"" 
d=""M0 -20l411 1504h158l-407 -1504h-162z"" />
    <glyph glyph-name=""zero"" unicode=""0"" 
d=""M1059 705q0 -203 -38.5 -341.5t-105 -224t-156.5 -122.5t-192 -37q-103 0 -192 37t-154.5 122t-103 223.5t-37.5 342.5q0 213 37.5 352.5t103.5 222.5t156 116.5t196 33.5q101 0 189.5 -33.5t154.5 -116.5t104 -222.5t38 -352.5zM876 705q0 168 -20 279.5t-59 178
t-95.5 94t-128.5 27.5q-76 0 -134 -28t-97.5 -94.5t-59.5 -178t-20 -278.5q0 -162 20.5 -273t60 -178.5t96.5 -97t130 -29.5q71 0 128 29.5t96.5 97t61 178.5t21.5 273z"" />
    <glyph glyph-name=""one"" unicode=""1"" 
d=""M156 0v153h359v1084l-318 -227v170l333 229h166v-1256h343v-153h-883z"" />
    <glyph glyph-name=""two"" unicode=""2"" 
d=""M103 0v127q51 117 124.5 206.5t154.5 162t160.5 134.5t143.5 124t103.5 130t39.5 154q0 60 -18 105.5t-52 76.5t-81.5 46.5t-105.5 15.5q-54 0 -101.5 -15t-84.5 -45t-60.5 -74.5t-30.5 -103.5l-184 17q9 76 42 143t91 117.5t139.5 79.5t188.5 29q105 0 187 -25
t138.5 -74t86.5 -121t30 -166q0 -71 -25.5 -135t-68 -122t-98.5 -112t-117 -105.5t-123 -102t-116.5 -101.5t-97.5 -103.5t-67 -109.5h735v-153h-933z"" />
    <glyph glyph-name=""three"" unicode=""3"" 
d=""M1049 389q0 -97 -31.5 -173t-92 -128.5t-150 -80t-204.5 -27.5q-131 0 -220.5 32.5t-147.5 86t-87 122t-38 141.5l186 17q8 -56 29.5 -102t58.5 -79t91 -51t128 -18q136 0 213.5 67t77.5 199q0 78 -34.5 125.5t-86 74t-112 35.5t-111.5 9h-102v156h98q51 0 106 10.5
t100.5 38t75 74.5t29.5 120q0 113 -66.5 178.5t-197.5 65.5q-119 0 -192.5 -61t-85.5 -172l-181 14q11 93 51 162t101.5 114.5t140.5 68t168 22.5q118 0 203 -29.5t139 -80t79.5 -118.5t25.5 -145q0 -62 -17 -116t-53 -97t-91.5 -74t-133.5 -47v-4q85 -9 148 -38.5
t104 -73.5t61.5 -100t20.5 -118z"" />
    <glyph glyph-name=""four"" unicode=""4"" 
d=""M881 319v-319h-170v319h-664v140l645 950h189v-948h198v-142h-198zM711 1206q-2 -5 -10 -19.5t-18 -32.5t-20.5 -36.5t-18.5 -30.5l-361 -532q-5 -8 -14.5 -21t-19.5 -26.5t-20 -26.5t-16 -20h498v745z"" />
    <glyph glyph-name=""five"" unicode=""5"" 
d=""M1053 459q0 -106 -32 -194t-95 -151.5t-156.5 -98.5t-216.5 -35q-111 0 -193.5 26t-139.5 71.5t-90.5 106.5t-47.5 131l182 21q11 -40 31 -77.5t54.5 -67t85 -47t122.5 -17.5q70 0 127 21.5t97.5 63.5t62.5 103t22 140q0 65 -21 119.5t-60 94t-95.5 61.5t-128.5 22
q-45 0 -83 -8t-70.5 -22t-59 -32.5t-49.5 -38.5h-176l47 758h801v-153h-637l-27 -447q48 37 120 63.5t171 26.5q105 0 189 -32t143 -90.5t91 -139.5t32 -178z"" />
    <glyph glyph-name=""six"" unicode=""6"" 
d=""M1049 461q0 -106 -29.5 -194.5t-87 -152t-142.5 -99t-196 -35.5q-123 0 -215 47t-153 135.5t-91.5 217t-30.5 292.5q0 188 34.5 330t99.5 237t158.5 143t211.5 48q72 0 135 -15t114.5 -48.5t90.5 -88.5t62 -135l-172 -31q-28 91 -89.5 131.5t-142.5 40.5q-74 0 -134 -35
t-102 -104.5t-64.5 -174.5t-22.5 -245q49 91 138 138.5t204 47.5q96 0 174 -31t133.5 -89.5t86 -142t30.5 -187.5zM866 453q0 73 -18 132t-54 100.5t-89 64t-123 22.5q-49 0 -99 -14.5t-90.5 -47t-66 -85.5t-25.5 -129q0 -78 20 -145.5t57.5 -117.5t90.5 -79t119 -29
q65 0 116.5 22.5t87.5 65t55 103.5t19 137z"" />
    <glyph glyph-name=""seven"" unicode=""7"" 
d=""M1036 1263q-106 -162 -195 -311.5t-153 -301t-99.5 -311t-35.5 -339.5h-188q0 169 40 331.5t108 319t158 307.5t191 298h-757v153h931v-146z"" />
    <glyph glyph-name=""eight"" unicode=""8"" 
d=""M1050 393q0 -90 -28.5 -165.5t-87 -130.5t-149.5 -86t-215 -31t-214.5 31t-150 85.5t-88 130t-28.5 164.5q0 77 23.5 137t63 103.5t90 70t104.5 35.5v4q-59 14 -105.5 45t-78 74.5t-48 96.5t-16.5 112q0 74 28.5 139.5t84.5 115t139 78t192 28.5q115 0 199.5 -29
t140 -78.5t82.5 -115.5t27 -140q0 -58 -16.5 -111t-48 -96.5t-78 -74t-107.5 -42.5v-4q61 -10 113 -36.5t90 -70t60 -103.5t22 -136zM828 1057q0 53 -13.5 97t-44.5 75.5t-81 49t-123 17.5q-71 0 -120 -17.5t-80.5 -49t-45.5 -75.5t-14 -97q0 -42 11 -86t40 -80t80 -59
t131 -23q85 0 136.5 23t79 59t36 80t8.5 86zM863 410q0 51 -14 98.5t-48 84t-91.5 59t-143.5 22.5q-79 0 -134.5 -22.5t-90 -59.5t-50.5 -85.5t-16 -100.5q0 -65 16 -118.5t51 -92t92 -59.5t138 -21q82 0 138 21t90 59.5t48.5 93t14.5 121.5z"" />
    <glyph glyph-name=""nine"" unicode=""9"" 
d=""M1042 733q0 -188 -35.5 -329.5t-101.5 -235.5t-160.5 -141t-212.5 -47q-81 0 -146 16.5t-116 51.5t-87 91t-58 135l172 27q28 -91 87.5 -133.5t150.5 -42.5q73 0 133.5 34.5t103 103.5t66.5 173t26 244q-21 -47 -57.5 -84t-83 -62.5t-100.5 -39t-109 -13.5
q-96 0 -173.5 34.5t-131.5 96.5t-83.5 149.5t-29.5 194.5q0 109 31.5 197t91.5 149.5t147.5 94.5t198.5 33q235 0 356 -174t121 -523zM846 907q0 78 -18.5 147t-55 120t-90 80.5t-123.5 29.5q-65 0 -117 -23t-88 -65.5t-55.5 -103.5t-19.5 -136q0 -71 17.5 -132t52.5 -105.5
t87 -70t121 -25.5q50 0 101.5 17t93 52t68 88.5t26.5 126.5z"" />
    <glyph glyph-name=""colon"" unicode="":"" horiz-adv-x=""569"" 
d=""M187 875v207h195v-207h-195zM187 0v207h195v-207h-195z"" />
    <glyph glyph-name=""uni037E"" unicode="";"" horiz-adv-x=""569"" 
d=""M385 207v-156q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v207h195zM190 875v207h195v-207h-195z"" />
    <glyph glyph-name=""uni037E"" unicode=""&#x37e;"" horiz-adv-x=""569"" 
d=""M385 207v-156q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v207h195zM190 875v207h195v-207h-195z"" />
    <glyph glyph-name=""less"" unicode=""&#x3c;"" horiz-adv-x=""1196"" 
d=""M101 571v205l995 418v-154l-858 -366l858 -367v-153z"" />
    <glyph glyph-name=""equal"" unicode=""="" horiz-adv-x=""1196"" 
d=""M100 856v148h995v-148h-995zM100 344v148h995v-148h-995z"" />
    <glyph glyph-name=""greater"" unicode=""&#x3e;"" horiz-adv-x=""1196"" 
d=""M101 154v153l858 367l-858 366v154l995 -418v-205z"" />
    <glyph glyph-name=""question"" unicode=""?"" 
d=""M1063 1032q0 -71 -18.5 -125t-49.5 -96.5t-70.5 -76t-80.5 -63.5t-80.5 -59t-71 -63t-51 -75.5t-20.5 -96.5h-175q2 69 21.5 121t50.5 92t70 71.5t79 60t78.5 57t68.5 63.5t48.5 79t18.5 103t-21 105t-59.5 77.5t-93 47.5t-121.5 16q-140 0 -222 -70t-96 -192l-184 12
q11 84 44.5 158.5t94 130.5t150 88.5t211.5 32.5q114 0 203 -28t150.5 -79.5t93.5 -125.5t32 -165zM438 0v201h195v-201h-195z"" />
    <glyph glyph-name=""at"" unicode=""@"" horiz-adv-x=""2079"" 
d=""M1902 755q0 -144 -33.5 -263.5t-92.5 -205.5t-141.5 -134t-179.5 -48q-56 0 -95.5 13.5t-64.5 37t-36 55.5t-11 70q0 15 1 36.5t2 33.5h-6q-24 -45 -58.5 -89.5t-81 -79t-105 -56t-129.5 -21.5q-84 0 -146.5 29t-103 80.5t-60.5 122t-20 153.5q0 120 35.5 230.5
t101.5 195t158.5 135.5t206.5 51q60 0 108 -13.5t84.5 -37.5t63.5 -57.5t45 -73.5h6l39 160h156l-116 -506q-19 -84 -28 -144t-9 -109q0 -48 21.5 -71t59.5 -23q62 0 115.5 40.5t93 111.5t62 167t22.5 208q0 129 -41.5 240t-122 192t-199.5 127t-275 46q-134 0 -247.5 -32
t-205.5 -90t-161.5 -138.5t-116.5 -176.5t-71 -205.5t-24 -224.5q0 -141 43 -260t125.5 -204.5t204 -133.5t279.5 -48q105 0 196 16.5t167 40.5t136 52.5t104 52.5l55 -112q-50 -30 -117.5 -61.5t-150.5 -57.5t-181 -42.5t-209 -16.5q-190 0 -337.5 57.5t-249 160.5
t-154 245t-52.5 311q0 139 31.5 267t90.5 238t144 200t192.5 154t235 99t271.5 35q201 0 347 -59t241.5 -159t141.5 -232t46 -279zM1296 747q0 50 -17 92t-48.5 72t-76 46.5t-100.5 16.5q-86 0 -151 -42.5t-108.5 -111.5t-66 -155.5t-22.5 -173.5q0 -120 47.5 -188
t146.5 -68q69 0 129 31t108 82t83 117t53 137q9 36 16 76t7 69z"" />
    <glyph glyph-name=""A"" unicode=""A"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" />
    <glyph glyph-name=""B"" unicode=""B"" horiz-adv-x=""1366"" 
d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49
h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" />
    <glyph glyph-name=""C"" unicode=""C"" horiz-adv-x=""1479"" 
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" />
    <glyph glyph-name=""D"" unicode=""D"" horiz-adv-x=""1479"" 
d=""M1381 719q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v1409h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-1103h314q111 0 205.5 36t163.5 107t108 177t39 246z"" />
    <glyph glyph-name=""E"" unicode=""E"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110z"" />
    <glyph glyph-name=""F"" unicode=""F"" horiz-adv-x=""1251"" 
d=""M359 1253v-524h786v-158h-786v-571h-191v1409h1001v-156h-810z"" />
    <glyph glyph-name=""G"" unicode=""G"" horiz-adv-x=""1593"" 
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293z"" />
    <glyph glyph-name=""H"" unicode=""H"" horiz-adv-x=""1479"" 
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191z"" />
    <glyph glyph-name=""I"" unicode=""I"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""J"" unicode=""J"" horiz-adv-x=""1024"" 
d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" />
    <glyph glyph-name=""K"" unicode=""K"" horiz-adv-x=""1366"" 
d=""M1106 0l-563 680l-184 -140v-540h-191v1409h191v-706l679 706h225l-600 -612l680 -797h-237z"" />
    <glyph glyph-name=""L"" unicode=""L"" 
d=""M168 0v1409h191v-1253h712v-156h-903z"" />
    <glyph glyph-name=""M"" unicode=""M"" horiz-adv-x=""1706"" 
d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5
t19 -64.5t16.5 -62.5t10.5 -45.5q3 16 11 46t18.5 63t20.5 64t18 51l368 977h245v-1409h-172z"" />
    <glyph glyph-name=""N"" unicode=""N"" horiz-adv-x=""1479"" 
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" />
    <glyph glyph-name=""O"" unicode=""O"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""P"" unicode=""P"" horiz-adv-x=""1366"" 
d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" />
    <glyph glyph-name=""Q"" unicode=""Q"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -149 -38.5 -272.5t-111 -216.5t-178 -151.5t-239.5 -76.5q21 -64 47.5 -109t60.5 -73.5t75.5 -42t92.5 -13.5q28 0 60 4t55 9v-134q-38 -9 -83.5 -15.5t-94.5 -6.5q-86 0 -150 25.5t-112.5 73t-83.5 116.5t-62 156q-158 8 -277.5 65.5t-199 154t-119.5 226
t-40 281.5q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5
q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""R"" unicode=""R"" horiz-adv-x=""1479"" 
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
"" />
    <glyph glyph-name=""S"" unicode=""S"" horiz-adv-x=""1366"" 
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" />
    <glyph glyph-name=""T"" unicode=""T"" horiz-adv-x=""1251"" 
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""U"" unicode=""U"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33z"" />
    <glyph glyph-name=""V"" unicode=""V"" horiz-adv-x=""1366"" 
d=""M782 0h-198l-575 1409h201l390 -992q15 -45 30 -89.5t27 -79.5q14 -41 27 -80q12 37 26 78q12 35 26.5 79t31.5 92l388 992h201z"" />
    <glyph glyph-name=""W"" unicode=""W"" horiz-adv-x=""1933"" 
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199z"" />
    <glyph glyph-name=""X"" unicode=""X"" horiz-adv-x=""1366"" 
d=""M1112 0l-423 616l-432 -616h-211l536 732l-495 677h211l392 -553l381 553h211l-482 -670l523 -739h-211z"" />
    <glyph glyph-name=""Y"" unicode=""Y"" horiz-adv-x=""1366"" 
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210z"" />
    <glyph glyph-name=""Z"" unicode=""Z"" horiz-adv-x=""1251"" 
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156z"" />
    <glyph glyph-name=""bracketleft"" unicode=""["" horiz-adv-x=""569"" 
d=""M146 -425v1909h407v-129h-233v-1651h233v-129h-407z"" />
    <glyph glyph-name=""backslash"" unicode=""\"" horiz-adv-x=""569"" 
d=""M407 -20l-407 1504h158l411 -1504h-162z"" />
    <glyph glyph-name=""bracketright"" unicode=""]"" horiz-adv-x=""569"" 
d=""M16 -425v129h233v1651h-233v129h407v-1909h-407z"" />
    <glyph glyph-name=""asciicircum"" unicode=""^"" horiz-adv-x=""961"" 
d=""M787 673l-309 633l-306 -633h-162l368 736h203l370 -736h-164z"" />
    <glyph glyph-name=""underscore"" unicode=""_"" 
d=""M-31 -407v130h1193v-130h-1193z"" />
    <glyph glyph-name=""grave"" unicode=""`"" horiz-adv-x=""682"" 
d=""M436 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""a"" unicode=""a"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48z"" />
    <glyph glyph-name=""b"" unicode=""b"" 
d=""M1053 546q0 -566 -398 -566q-123 0 -204.5 44.5t-132.5 143.5h-2q0 -26 -1.5 -54t-3 -52t-3 -41t-2.5 -21h-174q1 9 2 30.5t2 51.5t1.5 66t0.5 75v1261h180v-423q0 -30 -0.5 -57.5t-1.5 -48.5q-1 -25 -2 -47h4q50 104 132.5 149t204.5 45q205 0 301.5 -138t96.5 -418z
M864 540q0 112 -14 192t-45 131.5t-79 75.5t-117 24q-71 0 -125.5 -23t-91 -74t-55.5 -134t-19 -203q0 -116 19 -195t55.5 -128.5t90.5 -71t124 -21.5q66 0 114 23t80 74t47.5 132.5t15.5 197.5z"" />
    <glyph glyph-name=""c"" unicode=""c"" horiz-adv-x=""1024"" 
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183z"" />
    <glyph glyph-name=""d"" unicode=""d"" 
d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v419h180v-1261q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5t-3 42.5t-2.5 50.5t-1 52.5h-4z
M275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" />
    <glyph glyph-name=""e"" unicode=""e"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""f"" unicode=""f"" horiz-adv-x=""569"" 
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211z"" />
    <glyph glyph-name=""g"" unicode=""g"" 
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191z"" />
    <glyph glyph-name=""h"" unicode=""h"" 
d=""M317 897q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-721h-181v686q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-638h-180v1484h180v-386q0 -33 -1 -66t-2.5 -61t-2.5 -47.5
t-2 -26.5h3z"" />
    <glyph glyph-name=""i"" unicode=""i"" horiz-adv-x=""455"" 
d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180z"" />
    <glyph glyph-name=""j"" unicode=""j"" horiz-adv-x=""455"" 
d=""M137 1312v172h180v-172h-180zM317 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" />
    <glyph glyph-name=""k"" unicode=""k"" horiz-adv-x=""1024"" 
d=""M816 0l-366 494l-132 -109v-385h-180v1484h180v-927l475 525h211l-439 -465l462 -617h-211z"" />
    <glyph glyph-name=""l"" unicode=""l"" horiz-adv-x=""455"" 
d=""M138 0v1484h180v-1484h-180z"" />
    <glyph glyph-name=""m"" unicode=""m"" horiz-adv-x=""1706"" 
d=""M768 0v686q0 79 -10 132t-33.5 85.5t-61.5 46t-93 13.5q-57 0 -103 -22.5t-78.5 -65t-50 -105t-17.5 -143.5v-627h-179v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q24 47 52 85t65.5 64.5t86 41t112.5 14.5q123 0 194.5 -49
t99.5 -156h3q24 47 54 85t70 64.5t90 41t114 14.5q82 0 141.5 -22t97.5 -68t56 -118.5t18 -172.5v-721h-178v686q0 79 -10 132t-33.5 85.5t-61.5 46t-93 13.5q-57 0 -103 -21.5t-78.5 -63.5t-50 -105t-17.5 -146v-627h-178z"" />
    <glyph glyph-name=""n"" unicode=""n"" 
d=""M825 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181z"" />
    <glyph glyph-name=""o"" unicode=""o"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209z"" />
    <glyph glyph-name=""p"" unicode=""p"" 
d=""M1053 546q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40t1 -53.5t0.5 -58.5v-423h-180v1286q0 39 -0.5 75t-1.5 65.5t-2 50.5t-2 30h174q1 -3 2.5 -21t3 -43.5t3 -54.5t1.5 -55h4q25 52 57 88.5t73 60t91.5 34
t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" />
    <glyph glyph-name=""q"" unicode=""q"" 
d=""M484 -20q-206 0 -302 139t-96 417q0 282 98.5 424t299.5 142q67 0 118.5 -12t92 -35.5t71 -58.5t55.5 -82h2q0 25 1.5 55.5t3 57.5t3.5 46.5t4 22.5h173q-2 -17 -4.5 -89t-2.5 -206v-1226h-180v439q0 26 0.5 54t1.5 53q1 28 2 57h-2q-26 -51 -57.5 -88.5t-72.5 -62
t-92.5 -36t-116.5 -11.5zM821 554q0 118 -20.5 198t-58 128t-91 68.5t-119.5 20.5q-69 0 -118 -25.5t-79.5 -78t-45 -133t-14.5 -190.5q0 -108 13.5 -188t44 -132t79 -77.5t118.5 -25.5q60 0 113 18.5t92.5 67t62.5 133t23 216.5z"" />
    <glyph glyph-name=""r"" unicode=""r"" horiz-adv-x=""682"" 
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180z"" />
    <glyph glyph-name=""s"" unicode=""s"" horiz-adv-x=""1024"" 
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102z"" />
    <glyph glyph-name=""t"" unicode=""t"" horiz-adv-x=""569"" 
d=""M554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" />
    <glyph glyph-name=""u"" unicode=""u"" 
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181z"" />
    <glyph glyph-name=""v"" unicode=""v"" horiz-adv-x=""1024"" 
d=""M613 0h-213l-393 1082h192l238 -704q7 -22 16.5 -53.5t19.5 -65.5t18.5 -65.5t14.5 -52.5q6 21 15.5 52.5t19.5 64.5t20.5 64.5t18.5 53.5l246 706h191z"" />
    <glyph glyph-name=""w"" unicode=""w"" horiz-adv-x=""1479"" 
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176z"" />
    <glyph glyph-name=""x"" unicode=""x"" horiz-adv-x=""1024"" 
d=""M801 0l-291 444l-293 -444h-194l385 556l-367 526h199l270 -421l268 421h201l-367 -524l390 -558h-201z"" />
    <glyph glyph-name=""y"" unicode=""y"" horiz-adv-x=""1024"" 
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190z"" />
    <glyph glyph-name=""z"" unicode=""z"" horiz-adv-x=""1024"" 
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901z"" />
    <glyph glyph-name=""braceleft"" unicode=""{"" horiz-adv-x=""684"" 
d=""M513 -425q-65 0 -114.5 20.5t-82.5 58.5t-50 92t-17 122v361q0 63 -14.5 107t-42 72t-67.5 42t-91 16v127q51 2 91 16t67.5 42t42 72t14.5 106v362q0 141 66.5 217t197.5 76h135v-129h-63q-91 0 -129.5 -53.5t-38.5 -161.5v-356q0 -50 -15 -92t-41 -74t-61.5 -54
t-76.5 -32v-2q43 -10 78.5 -32t61 -54.5t40 -74.5t14.5 -93v-357q0 -106 38.5 -160.5t129.5 -54.5h63v-129h-135z"" />
    <glyph glyph-name=""bar"" unicode=""|"" horiz-adv-x=""532"" 
d=""M183 -434v1918h166v-1918h-166z"" />
    <glyph glyph-name=""braceright"" unicode=""}"" horiz-adv-x=""684"" 
d=""M94 -296q91 0 130.5 54.5t39.5 160.5v357q0 51 14 93t39.5 74.5t61 54.5t78.5 32v2q-42 10 -77 32t-61 54t-40.5 74t-14.5 92v356q0 108 -39.5 161.5t-130.5 53.5h-60v129h132q131 0 197.5 -76t66.5 -217v-362q0 -62 14.5 -106t42 -72t68 -42t92.5 -16v-127
q-52 -2 -92.5 -16t-68 -42t-42 -72t-14.5 -107v-361q0 -68 -17 -122t-50 -92t-82.5 -58.5t-114.5 -20.5h-132v129h60z"" />
    <glyph glyph-name=""asciitilde"" unicode=""~"" horiz-adv-x=""1196"" 
d=""M844 553q-69 0 -141.5 22t-145.5 48q-129 45 -217 45q-38 0 -70.5 -6t-62.5 -17.5t-58 -27.5t-57 -37v143q50 38 116 61t147 23q40 0 80 -6.5t78.5 -16.5t76 -23t74.5 -26q21 -8 46 -15.5t50.5 -14.5t51 -11t48.5 -4q69 0 130.5 25t113.5 67v-149q-32 -23 -61.5 -38
t-60 -24.5t-64.5 -13.5t-74 -4z"" />
    <glyph glyph-name=""exclamdown"" unicode=""&#xa1;"" horiz-adv-x=""682"" 
d=""M266 685h148l24 -1012h-196zM440 1082v-201h-194v201h194z"" />
    <glyph glyph-name=""cent"" unicode=""&#xa2;"" 
d=""M538 282v830q-166 -24 -202 -228q-13 -78 -13 -177t13 -177q38 -218 202 -248zM662 284q150 34 174 205l182 -12q-27 -211 -210 -301q-63 -31 -146 -39v-168h-124v168q-211 19 -312 177q-91 142 -91 383q0 278 121 421q102 120 282 136v155h124v-155q222 -23 311 -202
q27 -55 39 -118l-185 -14q-14 90 -61 133.5t-104 55.5v-825z"" />
    <glyph glyph-name=""sterling"" unicode=""&#xa3;"" 
d=""M1104 311q-9 -80 -37.5 -138.5t-73 -97t-102 -57t-124.5 -18.5h-698v154q89 46 132 126t43 201v144h-186v129h186v280q0 92 24 165.5t73.5 124.5t125.5 78.5t179 27.5q70 0 131.5 -14.5t111 -43.5t85 -72t53.5 -100l-174 -57q-10 31 -29.5 57t-46 44t-59 28t-68.5 10
q-114 0 -170 -57.5t-56 -182.5v-288h408v-129h-408v-126q0 -56 -11 -109t-33 -99t-53.5 -81.5t-71.5 -56.5h483q38 0 71.5 9.5t60 30.5t45 54.5t26.5 81.5z"" />
    <glyph glyph-name=""currency"" unicode=""&#xa4;"" 
d=""M137 684q0 71 20.5 134.5t57.5 117.5l-100 100l104 103l99 -101q54 39 117.5 60.5t136.5 21.5q71 0 134 -21t117 -59l97 97l104 -105l-96 -96q37 -54 58.5 -117.5t21.5 -134.5t-22 -135t-60 -117l100 -100l-102 -105l-101 101q-54 -37 -117 -57.5t-134 -20.5
q-72 0 -136 21t-116 59l-105 -105l-102 105l102 102q-37 54 -57.5 117.5t-20.5 134.5zM291 686q0 -58 22 -109t60.5 -89t89.5 -60t109 -22q57 0 108 22t89.5 60t60.5 89t22 109t-22 109t-60.5 89t-89.5 60.5t-108 22.5q-58 0 -109 -22.5t-89.5 -60.5t-60.5 -89t-22 -109z
"" />
    <glyph glyph-name=""yen"" unicode=""&#xa5;"" 
d=""M720 709h321v-125h-383v-154h383v-127h-383v-303h-178v303h-381v127h381l2 154h-383v125h320l-421 700h199l371 -647l375 647h199z"" />
    <glyph glyph-name=""brokenbar"" unicode=""&#xa6;"" horiz-adv-x=""532"" 
d=""M183 706v778h166v-778h-166zM183 -434v779h166v-779h-166z"" />
    <glyph glyph-name=""section"" unicode=""&#xa7;"" 
d=""M588 1484q79 0 148 -15t123 -46.5t90.5 -80.5t51.5 -118l-161 -20q-8 45 -31 74t-57 46t-76 23.5t-88 6.5q-125 0 -189.5 -39.5t-64.5 -110.5q0 -45 25 -77t66.5 -55t96 -39t113.5 -30q68 -16 137.5 -39t125.5 -59.5t91 -89.5t35 -129q0 -45 -14 -88.5t-41.5 -80
t-68.5 -64t-95 -40.5q49 -21 88.5 -46.5t67 -57.5t42.5 -72.5t15 -91.5q0 -73 -29 -131.5t-85 -100t-138 -63.5t-189 -22q-93 0 -170 13.5t-135.5 45.5t-98 84t-58.5 129l161 31q12 -55 39 -88.5t66 -52t89 -25t107 -6.5q58 0 109 9t89 29t60.5 52.5t22.5 79.5
q0 54 -28.5 90t-76 61.5t-109 43.5t-126.5 34q-65 15 -130.5 38t-117.5 59.5t-84.5 89t-32.5 126.5q0 45 16 86.5t45.5 77t71.5 62t95 41.5q-42 14 -79.5 37t-66 55t-45 72t-16.5 88q0 139 105.5 216.5t308.5 77.5zM866 663q0 48 -26.5 82.5t-70.5 60t-100.5 43t-117.5 31.5
q-58 -3 -102.5 -19.5t-74.5 -42.5t-45.5 -60.5t-15.5 -73.5q0 -46 24.5 -79t65.5 -57t95 -41t114 -32q54 1 100.5 13t80.5 35.5t53.5 58.5t19.5 81z"" />
    <glyph glyph-name=""dieresis"" unicode=""&#xa8;"" horiz-adv-x=""682"" 
d=""M439 1219v184h163v-184h-163zM45 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""copyright"" unicode=""&#xa9;"" horiz-adv-x=""1509"" 
d=""M1477 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z
M1385 707q0 86 -22.5 166.5t-63.5 150t-99 127t-128 98.5t-150.5 63.5t-167.5 22.5q-130 0 -244 -49.5t-199.5 -135t-135 -199.5t-49.5 -244q0 -131 49.5 -245.5t135 -200t199.5 -134.5t244 -49q87 0 167.5 22.5t150.5 63t128 98t99 127.5t63.5 150.5t22.5 167.5zM498 709
q0 -72 16.5 -132t50 -103t83.5 -67t117 -24q49 0 86.5 13.5t65.5 36t47.5 50t33.5 56.5l115 -35q-22 -43 -51 -83.5t-70 -72t-96.5 -50.5t-130.5 -19q-101 0 -175.5 32t-123.5 89t-73 136t-24 173q0 97 24 175.5t72.5 134t121.5 85t171 29.5q75 0 131 -18t96 -47.5t67.5 -67
t45.5 -76.5l-114 -33q-12 26 -31 51t-46.5 44t-63.5 30.5t-83 11.5q-69 0 -118.5 -23t-81.5 -64.5t-47 -100.5t-15 -131z"" />
    <glyph glyph-name=""ordfeminine"" unicode=""&#xaa;"" horiz-adv-x=""758"" 
d=""M260 651q-53 0 -96 14.5t-74 42.5t-47.5 69t-16.5 93q0 69 25.5 115t68.5 74t99.5 40t118.5 13l178 4v60q0 46 -10.5 76t-30 47.5t-47.5 24.5t-63 7q-67 0 -107.5 -29.5t-49.5 -105.5l-149 10q7 47 28.5 88t59 72t91.5 48.5t125 17.5q68 0 122.5 -14.5t93 -44.5
t59.5 -77.5t21 -113.5v-308q0 -58 14 -83t49 -25q12 0 23 2.5t20 5.5v-104q-19 -5 -40 -9t-43 -4q-41 0 -69.5 11t-47.5 30.5t-29 45t-12 54.5h-4q-38 -77 -104 -112t-156 -35zM299 762q48 0 88 17t68.5 44.5t44.5 63t16 72.5v65l-138 -4q-41 -2 -78 -7.5t-64.5 -20
t-43.5 -40.5t-16 -69q0 -56 29 -88.5t94 -32.5z"" />
    <glyph glyph-name=""guillemotleft"" unicode=""&#xab;"" 
d=""M886 141l-338 365v63l338 371h168v-31l-338 -372l340 -367v-29h-170zM419 141l-336 365v63l336 371h167v-31l-335 -372l337 -367v-29h-169z"" />
    <glyph glyph-name=""logicalnot"" unicode=""&#xac;"" horiz-adv-x=""1196"" 
d=""M950 180v428h-850v146h995v-574h-145z"" />
    <glyph glyph-name=""registered"" unicode=""&#xae;"" horiz-adv-x=""1509"" 
d=""M1477 707q0 -100 -26 -192.5t-73 -173t-112.5 -146t-146 -112.5t-173 -73t-192.5 -26q-99 0 -191.5 26t-172.5 73t-146.5 112.5t-113.5 146t-73 173t-26 192.5t26 192t73 172.5t113 146.5t146.5 113t172.5 73t192 26q150 0 281.5 -57t230 -155t155 -229.5t56.5 -281.5z
M1385 707q0 86 -22.5 166.5t-63.5 150t-99 127t-128 98.5t-150.5 63.5t-167.5 22.5q-130 0 -244 -49.5t-199.5 -135t-135 -199.5t-49.5 -244q0 -131 49.5 -245.5t135 -200t199.5 -134.5t244 -49q87 0 167.5 22.5t150.5 63t128 98t99 127.5t63.5 150.5t22.5 167.5zM955 289
l-199 336h-161v-336h-127v831h307q142 0 217.5 -63t75.5 -174q0 -102 -52 -163.5t-137 -80.5l221 -350h-145zM941 881q0 69 -47.5 105t-128.5 36h-170v-301h182q80 0 122 42.5t42 117.5z"" />
    <glyph glyph-name=""macron"" unicode=""&#xaf;"" horiz-adv-x=""1131"" 
d=""M1148 1452h-1165v94h1165v-94z"" />
    <glyph glyph-name=""degree"" unicode=""&#xb0;"" horiz-adv-x=""819"" 
d=""M696 1145q0 -59 -22.5 -111t-61.5 -90.5t-91.5 -61t-111.5 -22.5t-111 22.5t-91 61t-62 90.5t-23 111q0 60 23 112t62 90.5t91 60.5t111 22t111.5 -22t91.5 -60.5t61.5 -90.5t22.5 -112zM587 1145q0 37 -13.5 70t-37.5 57.5t-56.5 38.5t-70.5 14q-37 0 -69.5 -14
t-56.5 -38.5t-38 -57.5t-14 -70t14 -69.5t38 -57t56.5 -39t69.5 -14.5q38 0 70.5 14.5t56.5 39t37.5 57t13.5 69.5z"" />
    <glyph glyph-name=""plusminus"" unicode=""&#xb1;"" horiz-adv-x=""1124"" 
d=""M636 680v-395h-147v395h-424v145h424v394h147v-394h424v-145h-424zM65 0v145h995v-145h-995z"" />
    <glyph glyph-name=""uni00B2"" unicode=""&#xb2;"" horiz-adv-x=""682"" 
d=""M43 563l-2 103q27 61 71 109t94 88.5t101.5 76.5t92.5 72.5t67 76.5t26 89q0 62 -35.5 99.5t-109.5 37.5q-68 0 -112 -36.5t-52 -104.5l-133 8q6 51 29 94.5t61 75.5t91.5 50.5t121.5 18.5q65 0 116.5 -16.5t87 -46.5t54 -73t18.5 -97q0 -62 -27 -112t-68.5 -93
t-92.5 -80.5t-98.5 -74t-86.5 -73.5t-57 -79h443v-113h-600z"" />
    <glyph glyph-name=""uni00B3"" unicode=""&#xb3;"" horiz-adv-x=""682"" 
d=""M642 795q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5
t-108 34.5q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" />
    <glyph glyph-name=""acute"" unicode=""&#xb4;"" horiz-adv-x=""682"" 
d=""M72 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""uni00B5"" unicode=""&#xb5;"" horiz-adv-x=""1180"" 
d=""M140 -425v1507h181v-686q0 -78 16 -131t45 -85.5t71 -46.5t94 -14q128 0 201 87t73 249v627h180v-816q0 -44 5.5 -72t15.5 -44t24.5 -22.5t32.5 -6.5q11 0 27 2.5t27 5.5v-129q-26 -8 -51.5 -14t-61.5 -6q-54 0 -89.5 15t-57.5 41t-32 61.5t-12 76.5h-3
q-52 -95 -125.5 -144.5t-173.5 -49.5q-67 0 -121.5 20.5t-85.5 58.5v-484h-180z"" />
    <glyph glyph-name=""paragraph"" unicode=""&#xb6;"" horiz-adv-x=""1100"" 
d=""M884 1307v-1571h-112v1571h-217v-1571h-113v958q-80 0 -146.5 22.5t-114.5 66.5t-74.5 110.5t-26.5 155.5q0 84 25 150.5t72.5 113t116.5 71.5t156 25h563v-102h-129z"" />
    <glyph glyph-name=""uni2219"" unicode=""&#xb7;"" horiz-adv-x=""569"" 
d=""M187 446v220h195v-220h-195z"" />
    <glyph glyph-name=""uni2219"" unicode=""&#x2219;"" horiz-adv-x=""569"" 
d=""M187 446v220h195v-220h-195z"" />
    <glyph glyph-name=""cedilla"" unicode=""&#xb8;"" horiz-adv-x=""682"" 
d=""M483 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""uni00B9"" unicode=""&#xb9;"" horiz-adv-x=""682"" 
d=""M80 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557z"" />
    <glyph glyph-name=""ordmasculine"" unicode=""&#xba;"" horiz-adv-x=""748"" 
d=""M723 1042q0 -188 -88 -289.5t-263 -101.5q-168 0 -256.5 100.5t-88.5 290.5q0 91 21.5 163.5t65 123t109 77t153.5 26.5q93 0 158.5 -26.5t107.5 -76.5t61.5 -122.5t19.5 -164.5zM574 1042q0 83 -12.5 138t-37.5 87.5t-61 46t-84 13.5t-85.5 -13.5t-63 -46.5t-38.5 -88
t-13 -137q0 -84 14 -139t39.5 -88t60.5 -46t78 -13q49 0 86.5 13t63.5 46t39.5 88t13.5 139z"" />
    <glyph glyph-name=""guillemotright"" unicode=""&#xbb;"" 
d=""M718 141h-168v29l338 367l-336 372v31h166l338 -371v-63zM253 141h-170v29l338 367l-336 372v31h168l335 -371v-63z"" />
    <glyph glyph-name=""onequarter"" unicode=""&#xbc;"" horiz-adv-x=""1708"" 
d=""M56 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1503 180v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM1374 715q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26z"" />
    <glyph glyph-name=""onehalf"" unicode=""&#xbd;"" horiz-adv-x=""1708"" 
d=""M56 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1053 2l-2 103q27 61 71 109t94 88.5t101.5 76.5t92.5 72.5t67 76.5t26 89q0 62 -35.5 99.5t-109.5 37.5q-68 0 -112 -36.5t-52 -104.5l-133 8q6 51 29 94.5t61 75.5
t91.5 50.5t121.5 18.5q65 0 116.5 -16.5t87 -46.5t54 -73t18.5 -97q0 -62 -27 -112t-68.5 -93t-92.5 -80.5t-98.5 -74t-86.5 -73.5t-57 -79h443v-113h-600z"" />
    <glyph glyph-name=""threequarters"" unicode=""&#xbe;"" horiz-adv-x=""1708"" 
d=""M513 0h-148l881 1409h145zM1503 180v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM1374 715q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26zM688 795q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5
t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5t-108 34.5q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5
t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" />
    <glyph glyph-name=""questiondown"" unicode=""&#xbf;"" horiz-adv-x=""1251"" 
d=""M131 50q0 71 18.5 125t49.5 96.5t70.5 76t80.5 63.5t80.5 59t71 63t51 75.5t20.5 96.5h175q-2 -69 -21.5 -121t-50.5 -92t-70 -71.5t-79 -60t-78.5 -57t-68.5 -63.5t-48.5 -79t-18.5 -103t21 -105t59.5 -77.5t93 -47.5t121.5 -16q140 0 222 70t96 192l184 -12
q-11 -84 -44.5 -158.5t-94 -130.5t-150 -88.5t-211.5 -32.5q-114 0 -203 28t-150.5 79.5t-93.5 125t-32 165.5zM756 1082v-201h-195v201h195z"" />
    <glyph glyph-name=""Agrave"" unicode=""&#xc0;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM750 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Aacute"" unicode=""&#xc1;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM547 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Acircumflex"" unicode=""&#xc2;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM1014 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Atilde"" unicode=""&#xc3;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM842 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88
h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Adieresis"" unicode=""&#xc4;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM803 1530v184h163v-184h-163zM409 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Aring"" unicode=""&#xc5;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM928 1546q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94
t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM820 1546q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5
t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""AE"" unicode=""&#xc6;"" horiz-adv-x=""2048"" 
d=""M969 0v412h-548l-198 -412h-199l686 1409h1209v-156h-759v-452h699v-154h-699v-491h800v-156h-991zM969 1262h-151q-1 -3 -9 -20.5t-19 -42.5t-24.5 -54t-25.5 -54.5t-21 -44.5t-11 -24l-217 -461h478v701z"" />
    <glyph glyph-name=""Ccedilla"" unicode=""&#xc7;"" horiz-adv-x=""1479"" 
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM993 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5
t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""Egrave"" unicode=""&#xc8;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM735 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Eacute"" unicode=""&#xc9;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM551 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Ecircumflex"" unicode=""&#xca;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM1037 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Edieresis"" unicode=""&#xcb;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM816 1530v184h163v-184h-163zM422 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Igrave"" unicode=""&#xcc;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM319 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Iacute"" unicode=""&#xcd;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM142 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Icircumflex"" unicode=""&#xce;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM616 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Idieresis"" unicode=""&#xcf;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM401 1530v184h163v-184h-163zM7 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Eth"" unicode=""&#xd0;"" horiz-adv-x=""1479"" 
d=""M14 801h154v608h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v647h-154v154zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-455h406v-154h-406v-494h314q111 0 205.5 36
t163.5 107t108 177t39 246z"" />
    <glyph glyph-name=""Ntilde"" unicode=""&#xd1;"" horiz-adv-x=""1479"" 
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM909 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25
q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Ograve"" unicode=""&#xd2;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM854 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Oacute"" unicode=""&#xd3;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM621 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Ocircumflex"" unicode=""&#xd4;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM1131 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Otilde"" unicode=""&#xd5;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM941 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25
q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Odieresis"" unicode=""&#xd6;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM910 1530v184h163v-184h-163zM516 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""multiply"" unicode=""&#xd7;"" horiz-adv-x=""1196"" 
d=""M142 330l354 354l-352 352l104 103l350 -353l350 351l105 -105l-350 -348l352 -352l-102 -105l-353 353l-356 -355z"" />
    <glyph glyph-name=""Oslash"" unicode=""&#xd8;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-127 0 -230 29t-184 83l-120 -145h-190l200 241q-88 97 -131 230t-43 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q125 0 228.5 -28t185.5 -82l121 146h192l-201 -242q85 -94 128.5 -223.5
t43.5 -289.5zM1300 711q0 112 -24.5 204t-73.5 164l-709 -853q59 -44 134 -67.5t168 -23.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM291 711q0 -113 25 -208t76 -170l707 853q-59 42 -134.5 65t-167.5 23q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231z"" />
    <glyph glyph-name=""Ugrave"" unicode=""&#xd9;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM813 1530
l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""Uacute"" unicode=""&#xda;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM565 1530v20
l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Ucircumflex"" unicode=""&#xdb;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM1070 1550v-20
h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Udieresis"" unicode=""&#xdc;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM853 1530v184
h163v-184h-163zM459 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Yacute"" unicode=""&#xdd;"" horiz-adv-x=""1366"" 
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM536 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Thorn"" unicode=""&#xde;"" horiz-adv-x=""1366"" 
d=""M1258 735q0 -88 -29.5 -167.5t-90 -139.5t-151.5 -95.5t-214 -35.5h-414v-297h-191v1409h191v-252h402q125 0 218 -30t155 -85.5t93 -133.5t31 -173zM1066 731q0 134 -82 208.5t-246 74.5h-379v-576h387q82 0 142.5 22t100 61.5t58.5 93t19 116.5z"" />
    <glyph glyph-name=""germandbls"" unicode=""&#xdf;"" horiz-adv-x=""1251"" 
d=""M1167 295q0 -66 -20.5 -123.5t-64 -100t-111.5 -67t-162 -24.5q-80 0 -154 12.5t-129 36.5l-2 164q25 -14 58.5 -26.5t70.5 -22t76 -15t76 -5.5q92 0 141 43t49 122q0 56 -27 94.5t-67.5 69.5t-88 59.5t-88 65t-67.5 85.5t-27 122q0 51 16.5 87.5t41 65.5t53.5 53
t53.5 50t41 57.5t16.5 74.5q0 37 -16.5 68t-48 53.5t-76.5 35.5t-102 13q-68 0 -121.5 -17.5t-90 -56t-56 -99.5t-19.5 -149v-1021h-180v1027q0 118 31.5 204.5t91.5 142.5t147 83t197 27q102 0 179.5 -23t130 -63t79 -94.5t26.5 -116.5q0 -61 -16.5 -106t-42 -79.5
t-54.5 -61t-54.5 -50t-42 -47.5t-16.5 -52q0 -38 27.5 -67.5t68.5 -58t88.5 -60.5t88.5 -74.5t68.5 -99.5t27.5 -136z"" />
    <glyph glyph-name=""agrave"" unicode=""&#xe0;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM624 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""aacute"" unicode=""&#xe1;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM412 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""acircumflex"" unicode=""&#xe2;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM880 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""atilde"" unicode=""&#xe3;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM737 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5
t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""adieresis"" unicode=""&#xe4;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM674 1219v184h163v-184h-163zM280 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""aring"" unicode=""&#xe5;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM799 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM691 1410q0 28 -10.5 52.5t-28.5 42.5
t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""ae"" unicode=""&#xe6;"" horiz-adv-x=""1821"" 
d=""M968 503v-17q1 -82 18 -150t52 -117t89.5 -76.5t132.5 -27.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-321 0 -423 257q-29 -51 -66 -97.5t-88 -82t-119.5 -56.5t-161.5 -21q-167 0 -251.5 86t-84.5 236q0 71 19 125
t52.5 93t79 64.5t99 41.5t112 22.5t118.5 7.5l240 4v59q0 67 -13 114t-41.5 76t-72.5 42.5t-105 13.5q-54 0 -98 -7.5t-76 -27t-51.5 -53t-26.5 -84.5l-188 17q10 64 39 117.5t81.5 92.5t132 60.5t191.5 21.5q128 0 214 -35t135 -104q63 74 151.5 106.5t194.5 32.5
q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-762zM786 534l-195 -4q-40 -1 -80.5 -4t-78.5 -12t-71 -24.5t-57.5 -41t-38.5 -62t-14 -87.5q0 -87 50 -135.5t143 -48.5q90 0 154.5 31.5t106 80.5t61.5 107t20 111v89zM1544 641q-15 171 -87 249.5t-207 78.5
q-45 0 -93 -14.5t-88.5 -51.5t-67.5 -100.5t-31 -161.5h574z"" />
    <glyph glyph-name=""ccedilla"" unicode=""&#xe7;"" horiz-adv-x=""1024"" 
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM751 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5
t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""egrave"" unicode=""&#xe8;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM657 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""eacute"" unicode=""&#xe9;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM440 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""ecircumflex"" unicode=""&#xea;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM907 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""edieresis"" unicode=""&#xeb;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM687 1219v184h163v-184h-163zM293 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""igrave"" unicode=""&#xec;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM340 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""iacute"" unicode=""&#xed;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM135 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""icircumflex"" unicode=""&#xee;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM617 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""idieresis"" unicode=""&#xef;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM402 1219v184h163v-184h-163zM8 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""eth"" unicode=""&#xf0;"" 
d=""M566 -20q-125 0 -215.5 36.5t-149.5 102.5t-87 158.5t-28 203.5q0 107 26 198t84 158t151 104.5t226 37.5q71 0 129.5 -16t101.5 -43q-43 86 -100.5 174t-133.5 157l-301 -133v114l218 94q-56 45 -116 84t-126 74h209q45 -20 86.5 -45.5t83.5 -56.5l306 132l-1 -112
l-211 -92q81 -74 145.5 -162t108.5 -188t67.5 -211.5t23.5 -232.5v-6q0 -122 -28.5 -220t-88.5 -167t-154 -106t-226 -37zM874 481q0 94 -16.5 162.5t-52 113.5t-92 67t-136.5 22q-81 0 -138.5 -22.5t-94 -68.5t-53 -114.5t-16.5 -159.5q0 -190 72 -279t217 -89q81 0 140 22
t96.5 67t55.5 114.5t18 164.5z"" />
    <glyph glyph-name=""ntilde"" unicode=""&#xf1;"" 
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM737 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5
t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""ograve"" unicode=""&#xf2;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM659 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""oacute"" unicode=""&#xf3;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM431 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""ocircumflex"" unicode=""&#xf4;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM902 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""otilde"" unicode=""&#xf5;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM739 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5
t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""odieresis"" unicode=""&#xf6;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM689 1219v184h163v-184h-163zM295 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""divide"" unicode=""&#xf7;"" horiz-adv-x=""1124"" 
d=""M478 958v183h168v-183h-168zM65 608v146h995v-146h-995zM478 223v183h168v-183h-168z"" />
    <glyph glyph-name=""oslash"" unicode=""&#xf8;"" horiz-adv-x=""1251"" 
d=""M1112 542q0 -284 -125 -423t-363 -139q-97 0 -175 24t-138 74l-100 -116h-167l184 214q-41 68 -62 159t-21 207q0 560 485 560q103 0 181 -23t135 -68l91 105h167l-173 -201q42 -69 61.5 -161.5t19.5 -211.5zM923 542q0 68 -6 122.5t-17 98.5l-483 -562
q38 -49 90.5 -68.5t114.5 -19.5q69 0 125 19.5t95 68.5t60 132t21 209zM334 542q0 -130 24 -215l482 561q-37 45 -89 63t-118 18q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205z"" />
    <glyph glyph-name=""ugrave"" unicode=""&#xf9;"" 
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM672 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""uacute"" unicode=""&#xfa;"" 
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM415 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""ucircumflex"" unicode=""&#xfb;"" 
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM901 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""udieresis"" unicode=""&#xfc;"" 
d=""M320 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM676 1219v184h163v-184h-163zM282 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""yacute"" unicode=""&#xfd;"" horiz-adv-x=""1024"" 
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM355 1201
v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""thorn"" unicode=""&#xfe;"" 
d=""M138 1484h180v-423q0 -30 -0.5 -57.5t-1.5 -48.5q-1 -25 -2 -47h6q25 52 57 88.5t73 60t91.5 34t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40
t1 -53.5t0.5 -58.5v-423h-180v1909zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" />
    <glyph glyph-name=""ydieresis"" unicode=""&#xff;"" horiz-adv-x=""1024"" 
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM626 1219
v184h163v-184h-163zM232 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""Amacron"" unicode=""&#x100;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM960 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""amacron"" unicode=""&#x101;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM833 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Abreve"" unicode=""&#x102;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM685 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83
t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""abreve"" unicode=""&#x103;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM560 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68
t-134 -25.5z"" />
    <glyph glyph-name=""Aogonek"" unicode=""&#x104;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM1379 -389q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136
q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""aogonek"" unicode=""&#x105;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM1139 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66
t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""Cacute"" unicode=""&#x106;"" horiz-adv-x=""1479"" 
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM667 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""cacute"" unicode=""&#x107;"" horiz-adv-x=""1024"" 
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM431 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Ccircumflex"" unicode=""&#x108;"" horiz-adv-x=""1479"" 
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM1122 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""ccircumflex"" unicode=""&#x109;"" horiz-adv-x=""1024"" 
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM870 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Cdotaccent"" unicode=""&#x10a;"" horiz-adv-x=""1479"" 
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM702 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""cdotaccent"" unicode=""&#x10b;"" horiz-adv-x=""1024"" 
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM456 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Ccaron"" unicode=""&#x10c;"" horiz-adv-x=""1479"" 
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21zM898 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""ccaron"" unicode=""&#x10d;"" horiz-adv-x=""1024"" 
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183zM652 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Dcaron"" unicode=""&#x10e;"" horiz-adv-x=""1479"" 
d=""M1381 719q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v1409h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-1103h314q111 0 205.5 36t163.5 107t108 177t39 246zM796 1530
h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""dcaron"" unicode=""&#x10f;"" horiz-adv-x=""1259"" 
d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v419h180v-1261q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5t-3 42.5t-2.5 50.5t-1 52.5h-4z
M275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5zM1279 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94
h-88v167h195v-106z"" />
    <glyph glyph-name=""Dcroat"" unicode=""&#x110;"" horiz-adv-x=""1479"" 
d=""M14 801h154v608h466q163 0 300.5 -40.5t236.5 -125t154.5 -214.5t55.5 -310q0 -176 -53 -310.5t-145 -225t-217.5 -137t-270.5 -46.5h-527v647h-154v154zM1189 719q0 143 -41 244.5t-115 166.5t-177 95.5t-226 30.5h-271v-455h406v-154h-406v-494h314q111 0 205.5 36
t163.5 107t108 177t39 246z"" />
    <glyph glyph-name=""dcroat"" unicode=""&#x111;"" 
d=""M821 174q-50 -104 -132.5 -149t-204.5 -45q-205 0 -301.5 138t-96.5 418q0 566 398 566q123 0 205 -45t132 -143h2q0 10 -0.5 31.5t-1 45t-0.5 44.5v30v141h-300v131h300v147h180v-147h132v-131h-132v-983q0 -39 0.5 -75t1.5 -66t2 -51.5t2 -30.5h-172q-2 10 -3.5 28.5
t-3 42.5t-2.5 50.5t-1 52.5h-4zM275 542q0 -112 14 -192t45 -131.5t79 -75.5t117 -24q71 0 125.5 23t91 74.5t55.5 134.5t19 203q0 115 -19 194.5t-56 128.5t-90.5 70.5t-123.5 21.5q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" />
    <glyph glyph-name=""Emacron"" unicode=""&#x112;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM978 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""emacron"" unicode=""&#x113;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM845 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Ebreve"" unicode=""&#x114;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM701 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""ebreve"" unicode=""&#x115;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM569 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117
q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Edotaccent"" unicode=""&#x116;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM613 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""edotaccent"" unicode=""&#x117;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM480 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Eogonek"" unicode=""&#x118;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM1278 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24
q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""eogonek"" unicode=""&#x119;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM811 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52
t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""Ecaron"" unicode=""&#x11a;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM805 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""ecaron"" unicode=""&#x11b;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM672 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Gcircumflex"" unicode=""&#x11c;"" horiz-adv-x=""1593"" 
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM1137 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""gcircumflex"" unicode=""&#x11d;"" 
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM878 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Gbreve"" unicode=""&#x11e;"" horiz-adv-x=""1593"" 
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM810 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5
t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""gbreve"" unicode=""&#x11f;"" 
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM546 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5
t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Gdotaccent"" unicode=""&#x120;"" horiz-adv-x=""1593"" 
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM721 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""gdotaccent"" unicode=""&#x121;"" 
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM457 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Gcommaaccent"" unicode=""&#x122;"" horiz-adv-x=""1593"" 
d=""M103 711q0 165 44.5 298t133 226.5t219.5 144t304 50.5q130 0 228 -23t170 -66t122 -104.5t85 -138.5l-182 -54q-26 52 -62.5 94.5t-88.5 72.5t-120.5 46.5t-156.5 16.5q-128 0 -222.5 -40t-156.5 -114t-92.5 -178t-30.5 -231t33 -232.5t98 -182t161.5 -119t223.5 -42.5
q83 0 153 14t126.5 36.5t99.5 50t72 55.5v254h-421v160h597v-486q-47 -48 -110.5 -91.5t-142.5 -76.5t-173 -52t-201 -19q-178 0 -311 54.5t-221.5 152t-133 231.5t-44.5 293zM918 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""gcommaaccent"" unicode=""&#x123;"" 
d=""M548 -425q-93 0 -165 19t-123 54.5t-83 84.5t-46 109l181 26q18 -75 79.5 -115.5t161.5 -40.5q61 0 111 17t85 54.5t54 97.5t19 146v174h-2q-20 -41 -49.5 -78.5t-72 -66.5t-98.5 -46.5t-128 -17.5q-103 0 -176.5 34.5t-120 103.5t-68 171.5t-21.5 237.5q0 130 21.5 234
t70 176.5t126 111t188.5 38.5q115 0 199.5 -52.5t130.5 -149.5h2q0 25 1.5 56t3 58.5t3.5 47.5t4 23h171q-1 -9 -2 -30.5t-2 -51.5t-1.5 -66.5t-0.5 -75.5v-827q0 -227 -111.5 -341.5t-341.5 -114.5zM822 541q0 113 -24.5 193.5t-64.5 131.5t-91.5 75t-105.5 24
q-69 0 -118.5 -24t-82 -75.5t-48 -132t-15.5 -192.5q0 -117 15.5 -196.5t47.5 -128.5t81 -70t117 -21q54 0 105.5 23t92.5 73t66 129t25 191zM442 1317q0 87 22 145.5t62 105.5h117q-45 -48 -69.5 -96t-24.5 -94h88v-167h-195v106z"" />
    <glyph glyph-name=""Hcircumflex"" unicode=""&#x124;"" horiz-adv-x=""1479"" 
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191zM1071 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""hcircumflex"" unicode=""&#x125;"" 
d=""M317 897q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-721h-181v686q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-638h-180v1484h180v-386q0 -33 -1 -66t-2.5 -61t-2.5 -47.5
t-2 -26.5h3zM904 1614v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""Hbar"" unicode=""&#x126;"" horiz-adv-x=""1479"" 
d=""M1126 0v653h-767v-653h-191v1025h-154v154h154v230h191v-230h767v230h186v-230h153v-154h-153v-1025h-186zM1126 813v212h-767v-212h767z"" />
    <glyph glyph-name=""hbar"" unicode=""&#x127;"" 
d=""M317 857q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-681h-181v646q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180v1206h-132v131h132v147h180v-147h300v-131h-300
v-148q0 -33 -1 -66t-2.5 -61t-2.5 -47.5t-2 -26.5h3z"" />
    <glyph glyph-name=""Itilde"" unicode=""&#x128;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM443 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5
t-97 -25.5z"" />
    <glyph glyph-name=""itilde"" unicode=""&#x129;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM443 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5
t-97 -25.5z"" />
    <glyph glyph-name=""Imacron"" unicode=""&#x12a;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM561 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""imacron"" unicode=""&#x12b;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM561 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Ibreve"" unicode=""&#x12c;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM286 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""ibreve"" unicode=""&#x12d;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM286 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Iogonek"" unicode=""&#x12e;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM442 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""iogonek"" unicode=""&#x12f;"" horiz-adv-x=""455"" 
d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180zM381 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5
v-107z"" />
    <glyph glyph-name=""Idotaccent"" unicode=""&#x130;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM195 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""dotlessi"" unicode=""&#x131;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180z"" />
    <glyph glyph-name=""IJ"" unicode=""&#x132;"" horiz-adv-x=""1505"" 
d=""M170 0v1409h191v-1409h-191zM938 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" />
    <glyph glyph-name=""ij"" unicode=""&#x133;"" horiz-adv-x=""909"" 
d=""M137 1312v172h180v-172h-180zM137 0v1082h180v-1082h-180zM591 1312v172h180v-172h-180zM771 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" />
    <glyph glyph-name=""Jcircumflex"" unicode=""&#x134;"" horiz-adv-x=""1024"" 
d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31zM973 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""jcircumflex"" unicode=""&#x135;"" horiz-adv-x=""455"" 
d=""M77 -425q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5zM559 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Kcommaaccent"" unicode=""&#x136;"" horiz-adv-x=""1366"" 
d=""M1106 0l-563 680l-184 -140v-540h-191v1409h191v-706l679 706h225l-600 -612l680 -797h-237zM805 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""kcommaaccent"" unicode=""&#x137;"" horiz-adv-x=""1024"" 
d=""M816 0l-366 494l-132 -109v-385h-180v1484h180v-927l475 525h211l-439 -465l462 -617h-211zM662 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""kgreenlandic"" unicode=""&#x138;"" horiz-adv-x=""1024"" 
d=""M816 0l-366 494l-132 -108v-386h-180v1082h180v-525l475 525h211l-439 -465l462 -617h-211z"" />
    <glyph glyph-name=""Lacute"" unicode=""&#x139;"" 
d=""M168 0v1409h191v-1253h712v-156h-903zM245 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""lacute"" unicode=""&#x13a;"" horiz-adv-x=""455"" 
d=""M138 0v1484h180v-1484h-180zM91 1608v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""Lcommaaccent"" unicode=""&#x13b;"" 
d=""M168 0v1409h191v-1253h712v-156h-903zM717 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""lcommaaccent"" unicode=""&#x13c;"" horiz-adv-x=""455"" 
d=""M138 0v1484h180v-1484h-180zM327 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""Lcaron"" unicode=""&#x13d;"" 
d=""M168 0v1409h191v-1253h712v-156h-903zM858 1303q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""lcaron"" unicode=""&#x13e;"" horiz-adv-x=""597"" 
d=""M138 0v1484h180v-1484h-180zM617 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""Ldot"" unicode=""&#x13f;"" 
d=""M168 0v1409h191v-1253h712v-156h-903zM625 687v172h180v-172h-180z"" />
    <glyph glyph-name=""ldot"" unicode=""&#x140;"" horiz-adv-x=""684"" 
d=""M138 0v1484h180v-1484h-180zM478 687v172h180v-172h-180z"" />
    <glyph glyph-name=""Lslash"" unicode=""&#x141;"" 
d=""M616 797l-257 -149v-492h712v-156h-903v538l-148 -85v158l148 85v713h191v-603l257 148v-157z"" />
    <glyph glyph-name=""lslash"" unicode=""&#x142;"" horiz-adv-x=""455"" 
d=""M138 0v542l-122 -68v158l122 68v784h180v-680l124 72v-159l-124 -71v-646h-180z"" />
    <glyph glyph-name=""Nacute"" unicode=""&#x143;"" horiz-adv-x=""1479"" 
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM601 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""nacute"" unicode=""&#x144;"" 
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM460 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Ncommaaccent"" unicode=""&#x145;"" horiz-adv-x=""1479"" 
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM836 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""ncommaaccent"" unicode=""&#x146;"" 
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM675 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""Ncaron"" unicode=""&#x147;"" horiz-adv-x=""1479"" 
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230zM841 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""ncaron"" unicode=""&#x148;"" 
d=""M829 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM680 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""napostrophe"" unicode=""&#x149;"" horiz-adv-x=""1237"" 
d=""M923 0v686q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22
t107 -68t61.5 -118.5t19.5 -172.5v-721h-181zM199 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 129h-88v197h195v-145z"" />
    <glyph glyph-name=""Eng"" unicode=""&#x14a;"" horiz-adv-x=""1481"" 
d=""M941 -20q-56 0 -104 12t-87.5 32t-71 47t-55.5 57l127 115q37 -45 87 -77.5t109 -32.5q64 0 103 29t59.5 82.5t27 130t6.5 171.5v322q0 108 -19.5 185t-60 126t-104 72t-150.5 23q-94 0 -175.5 -31t-142 -83.5t-95.5 -122t-35 -146.5v-891h-191v1092q0 37 -0.5 83t-1 91
t-1 83t-1.5 60h184q1 -22 2.5 -53.5t2.5 -66t1.5 -69t0.5 -62.5h4q34 61 85.5 111.5t116.5 85.5t141.5 54.5t162.5 19.5q124 0 212.5 -32t144.5 -98.5t82.5 -168.5t26.5 -241v-347q0 -130 -15 -234t-58 -177t-119 -112t-199 -39z"" />
    <glyph glyph-name=""eng"" unicode=""&#x14b;"" 
d=""M769 -425q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v793q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 34 -0.5 71.5t-1.5 71t-2 57.5t-2 31h170
q1 -5 2 -27t2.5 -50.5t2.5 -58t1 -49.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68t61.5 -118.5t19.5 -172.5v-855q0 -62 -11 -115t-38 -92t-73.5 -61.5t-118.5 -22.5z"" />
    <glyph glyph-name=""Omacron"" unicode=""&#x14c;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM1070 1570h-549v127h549v-127z"" />
    <glyph glyph-name=""omacron"" unicode=""&#x14d;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM844 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Obreve"" unicode=""&#x14e;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM795 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94
t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""obreve"" unicode=""&#x14f;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM569 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5
t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Ohungarumlaut"" unicode=""&#x150;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM514 1530v20l197 227h207v-29l-310 -218h-94zM861 1530v20l197 227h207v-29l-310 -218h-94z"" />
    <glyph glyph-name=""ohungarumlaut"" unicode=""&#x151;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM287 1201v20l217 287h207v-29l-330 -278h-94zM634 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""OE"" unicode=""&#x152;"" horiz-adv-x=""2048"" 
d=""M999 0q-20 -3 -45.5 -4.5t-54 -3t-57 -2t-53.5 -0.5q-169 0 -298.5 53t-217 148.5t-132 228t-44.5 291.5q0 165 47 296.5t136 223t218 140.5t293 49q26 0 55 -1t57.5 -2.5t54.5 -3.5t45 -4h914v-156h-803v-452h743v-154h-743v-491h844v-156h-959zM789 145q32 0 70 1t64 3
v1111q-11 1 -27 2t-34.5 1.5t-37 0.5h-33.5q-125 0 -218.5 -37t-156 -108t-94 -174t-31.5 -234q0 -129 32 -233.5t95 -178.5t156 -114t215 -40z"" />
    <glyph glyph-name=""oe"" unicode=""&#x153;"" horiz-adv-x=""1933"" 
d=""M1070 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-137 0 -236 45.5t-160 137.5q-63 -93 -163.5 -138t-237.5 -45q-113 0 -203.5 34t-154 104t-97.5 175.5t-34 248.5
q0 279 126.5 419.5t368.5 140.5q281 0 398 -177q67 94 167 135.5t219 41.5q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-772zM881 542q0 126 -21 208t-59.5 131t-93.5 68.5t-123 19.5q-69 0 -126 -20.5t-97.5 -70t-63 -131.5t-22.5 -205q0 -126 23.5 -208.5
t64 -131.5t94.5 -69t116 -20q69 0 126 19.5t97.5 68.5t62.5 132t22 209zM1656 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""Racute"" unicode=""&#x154;"" horiz-adv-x=""1479"" 
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
M553 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""racute"" unicode=""&#x155;"" horiz-adv-x=""682"" 
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM254 1201
v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Rcommaaccent"" unicode=""&#x156;"" horiz-adv-x=""1479"" 
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
M845 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""rcommaaccent"" unicode=""&#x157;"" horiz-adv-x=""682"" 
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM330 -193
q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""Rcaron"" unicode=""&#x158;"" horiz-adv-x=""1479"" 
d=""M1164 0l-366 585h-439v-585h-191v1409h663q120 0 212.5 -27.5t155.5 -79.5t96 -127t33 -169q0 -67 -19.5 -132t-61.5 -119t-107 -93t-156 -55l400 -607h-220zM1136 1004q0 64 -22 111t-64 78.5t-102 47t-136 15.5h-453v-520h461q82 0 142 20.5t98.5 56.5t57 85t18.5 106z
M796 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""rcaron"" unicode=""&#x159;"" horiz-adv-x=""682"" 
d=""M142 0v830q0 34 -0.5 69.5t-1.5 68.5t-2 62t-2 52h170q1 -23 2.5 -52.5t3 -60.5t2 -59.5t0.5 -48.5h4q19 62 40.5 107.5t50.5 75t69 44t97 14.5q22 0 42 -3.5t31 -6.5v-165q-18 5 -42 7.5t-54 2.5q-62 0 -105.5 -28t-71 -77.5t-40.5 -118t-13 -149.5v-564h-180zM494 1201
h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Sacute"" unicode=""&#x15a;"" horiz-adv-x=""1366"" 
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM562 1530v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""sacute"" unicode=""&#x15b;"" horiz-adv-x=""1024"" 
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM385 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Scircumflex"" unicode=""&#x15c;"" horiz-adv-x=""1366"" 
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM1032 1548v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""scircumflex"" unicode=""&#x15d;"" horiz-adv-x=""1024"" 
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM834 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Scedilla"" unicode=""&#x15e;"" horiz-adv-x=""1366"" 
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM905 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33
q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""scedilla"" unicode=""&#x15f;"" horiz-adv-x=""1024"" 
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM701 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5z"" />
    <glyph glyph-name=""Scaron"" unicode=""&#x160;"" horiz-adv-x=""1366"" 
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134zM809 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""scaron"" unicode=""&#x161;"" horiz-adv-x=""1024"" 
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102zM611 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""Tcommaaccent"" unicode=""&#x162;"" horiz-adv-x=""1251"" 
d=""M830 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5zM720 1253v-1253h-190v1253
h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""tcommaaccent"" unicode=""&#x163;"" horiz-adv-x=""569"" 
d=""M554 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l65 182h107l-39 -100q94 -3 141 -43.5t47 -109.5zM554 8q-41 -11 -83.5 -17.5
t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" />
    <glyph glyph-name=""Tcaron"" unicode=""&#x164;"" horiz-adv-x=""1251"" 
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484zM727 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""tcaron"" unicode=""&#x165;"" horiz-adv-x=""768"" 
d=""M554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133zM785 1378q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""Tbar"" unicode=""&#x166;"" horiz-adv-x=""1251"" 
d=""M720 1253v-452h281v-154h-281v-647h-190v647h-279v154h279v452h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""tbar"" unicode=""&#x167;"" horiz-adv-x=""569"" 
d=""M336 516v-248q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v287h-125v131h125v304h-125v131h132l53 242h120v-242h200v-131h-200v-304h200v-131h-200z"" />
    <glyph glyph-name=""Utilde"" unicode=""&#x168;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM896 1530
q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""utilde"" unicode=""&#x169;"" 
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM738 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5
t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""Umacron"" unicode=""&#x16a;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM1015 1565h-549
v127h549v-127z"" />
    <glyph glyph-name=""umacron"" unicode=""&#x16b;"" 
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM840 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""Ubreve"" unicode=""&#x16c;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM738 1530
q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <glyph glyph-name=""ubreve"" unicode=""&#x16d;"" 
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM564 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""Uring"" unicode=""&#x16e;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM982 1613
q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM874 1613q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5
q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""uring"" unicode=""&#x16f;"" 
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM811 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM703 1410q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5
q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""Uhungarumlaut"" unicode=""&#x170;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM445 1530v20
l197 227h207v-29l-310 -218h-94zM792 1530v20l197 227h207v-29l-310 -218h-94z"" />
    <glyph glyph-name=""uhungarumlaut"" unicode=""&#x171;"" 
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM283 1201v20l217 287h207v-29l-330 -278h-94zM630 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Uogonek"" unicode=""&#x172;"" horiz-adv-x=""1479"" 
d=""M731 -20q-116 0 -220 31t-182.5 96.5t-124.5 166t-46 238.5v897h191v-881q0 -107 28.5 -181.5t79.5 -121.5t120.5 -68.5t152.5 -21.5q82 0 155 22t128 70t86.5 125.5t31.5 188.5v868h190v-879q0 -141 -46.5 -244.5t-126.5 -171.5t-187.5 -101t-229.5 -33zM974 -400
q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""uogonek"" unicode=""&#x173;"" 
d=""M314 1082v-686q0 -79 11.5 -132t37.5 -85.5t68.5 -46t105.5 -13.5q64 0 115.5 22.5t88 65t56.5 105t20 143.5v627h180v-851q0 -34 0.5 -71.5t1.5 -71t2 -57.5t2 -31h-170q-1 5 -2 27t-2.5 50.5t-2.5 58t-1 49.5h-3q-26 -47 -57 -85t-72 -64.5t-94 -41t-123 -14.5
q-90 0 -155 22t-107 68t-61.5 118t-19.5 173v721h181zM1029 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z
"" />
    <glyph glyph-name=""Wcircumflex"" unicode=""&#x174;"" horiz-adv-x=""1933"" 
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM1295 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""wcircumflex"" unicode=""&#x175;"" horiz-adv-x=""1479"" 
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM1066 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Ycircumflex"" unicode=""&#x176;"" horiz-adv-x=""1366"" 
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM1009 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""ycircumflex"" unicode=""&#x177;"" horiz-adv-x=""1024"" 
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM844 1221
v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""Ydieresis"" unicode=""&#x178;"" horiz-adv-x=""1366"" 
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM799 1530v184h163v-184h-163zM405 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Zacute"" unicode=""&#x179;"" horiz-adv-x=""1251"" 
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156zM488 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""zacute"" unicode=""&#x17a;"" horiz-adv-x=""1024"" 
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901zM381 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Zdotaccent"" unicode=""&#x17b;"" horiz-adv-x=""1251"" 
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156zM536 1605v172h180v-172h-180z"" />
    <glyph glyph-name=""zdotaccent"" unicode=""&#x17c;"" horiz-adv-x=""1024"" 
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901zM409 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""Zcaron"" unicode=""&#x17d;"" horiz-adv-x=""1251"" 
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156zM750 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""zcaron"" unicode=""&#x17e;"" horiz-adv-x=""1024"" 
d=""M49 0v137l661 806h-621v139h824v-137l-662 -806h699v-139h-901zM594 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""longs"" unicode=""&#x17f;"" horiz-adv-x=""455"" 
d=""M318 0h-180v1204q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-1179z"" />
    <glyph glyph-name=""florin"" unicode=""&#x192;"" 
d=""M932 1312q-17 5 -48 10t-62 5t-54 -9.5t-39.5 -29.5t-28.5 -52t-21 -77l-26 -137h211l-25 -131h-213l-254 -1325h-180l254 1325h-152l27 131h151l29 152q12 59 32 110t55.5 89t90 59.5t135.5 21.5q32 0 73 -5t76 -15z"" />
    <glyph glyph-name=""Aringacute"" unicode=""&#x1fa;"" horiz-adv-x=""1366"" 
d=""M926 1392q0 -45 -19 -84.5t-52 -69.5q-16 -15 -34 -26l541 -1212h-195l-161 371h-642l-162 -371h-198l548 1209q-21 12 -39 29q-33 30 -52 69.5t-19 84.5t19 84.5t52 69t77 46.5t94 17t94 -17t77 -46.5t52 -69t19 -84.5zM768 923q-16 36 -30.5 73t-25.5 67t-18.5 50.5
t-8.5 24.5q-2 -4 -9 -24.5t-18.5 -51.5t-26 -67.5t-29.5 -72.5l-180 -417h527zM818 1392q0 25 -10.5 47t-28.5 38.5t-42.5 26t-52.5 9.5q-29 0 -53.5 -9.5t-42.5 -26t-28.5 -38.5t-10.5 -47q0 -26 10.5 -48t28.5 -39.5t42 -27.5q21 -8 45 -9h9q28 0 52.5 9.5t42.5 27
t28.5 39.5t10.5 48zM571 1657v16l217 181h207v-23l-310 -174h-114z"" />
    <glyph glyph-name=""aringacute"" unicode=""&#x1fb;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48zM811 1239q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM703 1239q0 28 -10.5 52.5t-28.5 42.5
t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5zM427 1547v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""AEacute"" unicode=""&#x1fc;"" horiz-adv-x=""2048"" 
d=""M969 0v412h-548l-198 -412h-199l686 1409h1209v-156h-759v-452h699v-154h-699v-491h800v-156h-991zM969 1262h-151q-1 -3 -9 -20.5t-19 -42.5t-24.5 -54t-25.5 -54.5t-21 -44.5t-11 -24l-217 -461h478v701zM1068 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""aeacute"" unicode=""&#x1fd;"" horiz-adv-x=""1821"" 
d=""M968 503v-17q1 -82 18 -150t52 -117t89.5 -76.5t132.5 -27.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-321 0 -423 257q-29 -51 -66 -97.5t-88 -82t-119.5 -56.5t-161.5 -21q-167 0 -251.5 86t-84.5 236q0 71 19 125
t52.5 93t79 64.5t99 41.5t112 22.5t118.5 7.5l240 4v59q0 67 -13 114t-41.5 76t-72.5 42.5t-105 13.5q-54 0 -98 -7.5t-76 -27t-51.5 -53t-26.5 -84.5l-188 17q10 64 39 117.5t81.5 92.5t132 60.5t191.5 21.5q128 0 214 -35t135 -104q63 74 151.5 106.5t194.5 32.5
q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-762zM786 534l-195 -4q-40 -1 -80.5 -4t-78.5 -12t-71 -24.5t-57.5 -41t-38.5 -62t-14 -87.5q0 -87 50 -135.5t143 -48.5q90 0 154.5 31.5t106 80.5t61.5 107t20 111v89zM1544 641q-15 171 -87 249.5t-207 78.5
q-45 0 -93 -14.5t-88.5 -51.5t-67.5 -100.5t-31 -161.5h574zM759 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Oslashacute"" unicode=""&#x1fe;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-127 0 -230 29t-184 83l-120 -145h-190l200 241q-88 97 -131 230t-43 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q125 0 228.5 -28t185.5 -82l121 146h192l-201 -242q85 -94 128.5 -223.5
t43.5 -289.5zM1300 711q0 112 -24.5 204t-73.5 164l-709 -853q59 -44 134 -67.5t168 -23.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM291 711q0 -113 25 -208t76 -170l707 853q-59 42 -134.5 65t-167.5 23q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231zM659 1530
v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""oslashacute"" unicode=""&#x1ff;"" horiz-adv-x=""1251"" 
d=""M1112 542q0 -284 -125 -423t-363 -139q-97 0 -175 24t-138 74l-100 -116h-167l184 214q-41 68 -62 159t-21 207q0 560 485 560q103 0 181 -23t135 -68l91 105h167l-173 -201q42 -69 61.5 -161.5t19.5 -211.5zM923 542q0 68 -6 122.5t-17 98.5l-483 -562
q38 -49 90.5 -68.5t114.5 -19.5q69 0 125 19.5t95 68.5t60 132t21 209zM334 542q0 -130 24 -215l482 561q-37 45 -89 63t-118 18q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205zM506 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Scommaaccent"" unicode=""&#x218;"" horiz-adv-x=""1366"" 
d=""M801 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5
t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67
t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" />
    <glyph glyph-name=""scommaaccent"" unicode=""&#x219;"" horiz-adv-x=""1024"" 
d=""M625 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8
t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112
q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5t44.5 -77t16.5 -102z"" />
    <glyph glyph-name=""uni021A"" unicode=""&#x21a;"" horiz-adv-x=""1251"" 
d=""M723 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""uni021B"" unicode=""&#x21b;"" horiz-adv-x=""569"" 
d=""M443 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95zM554 8q-41 -11 -83.5 -17.5t-98.5 -6.5q-216 0 -216 245v722h-125v131h132l53 242h120v-242h200v-131h-200v-683q0 -78 25.5 -109.5t88.5 -31.5q26 0 50.5 4t53.5 10v-133z"" />
    <glyph glyph-name=""circumflex"" unicode=""&#x2c6;"" horiz-adv-x=""682"" 
d=""M662 1221v-20h-105l-219 169h-2l-232 -169h-104v20l234 270h204z"" />
    <glyph glyph-name=""caron"" unicode=""&#x2c7;"" horiz-adv-x=""682"" 
d=""M438 1201h-204l-234 270v20h104l232 -169h2l219 169h105v-20z"" />
    <glyph glyph-name=""uni02C9"" unicode=""&#x2c9;"" horiz-adv-x=""682"" 
d=""M600 1236h-549v127h549v-127z"" />
    <glyph glyph-name=""breve"" unicode=""&#x2d8;"" horiz-adv-x=""682"" 
d=""M297 1201q-74 0 -132 25.5t-100 68t-67 98.5t-33 117h117q8 -43 27.5 -72.5t47.5 -47.5t64 -25.5t78 -7.5t77.5 8t63.5 26t47 47.5t27 71.5h117q-9 -61 -34 -117t-66.5 -98.5t-99.5 -68t-134 -25.5z"" />
    <glyph glyph-name=""dotaccent"" unicode=""&#x2d9;"" horiz-adv-x=""682"" 
d=""M156 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""ring"" unicode=""&#x2da;"" horiz-adv-x=""682"" 
d=""M535 1410q0 -50 -19 -94t-52 -77t-77 -52t-94 -19t-94 19t-77 52t-52 77t-19 94t19 94t52 76.5t77 51.5t94 19t94 -19t77 -51.5t52 -76.5t19 -94zM427 1410q0 28 -10.5 52.5t-28.5 42.5t-42.5 28.5t-52.5 10.5q-29 0 -53.5 -10.5t-42.5 -28.5t-28.5 -42.5t-10.5 -52.5
q0 -29 10.5 -53.5t28.5 -43.5t42.5 -29.5t53.5 -10.5q28 0 52.5 10.5t42.5 29.5t28.5 43.5t10.5 53.5z"" />
    <glyph glyph-name=""ogonek"" unicode=""&#x2db;"" horiz-adv-x=""682"" 
d=""M430 -400q-28 -12 -63.5 -19.5t-75.5 -7.5q-105 0 -158 51t-53 136q0 47 17 86.5t41 70t50.5 51.5t46.5 32h133q-25 -14 -51 -36.5t-47.5 -52t-35 -64.5t-13.5 -74q0 -42 24.5 -66t69.5 -24q29 0 58 6.5t57 17.5v-107z"" />
    <glyph glyph-name=""tilde"" unicode=""&#x2dc;"" horiz-adv-x=""682"" 
d=""M492 1201q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""hungarumlaut"" unicode=""&#x2dd;"" horiz-adv-x=""682"" 
d=""M22 1201v20l217 287h207v-29l-330 -278h-94zM369 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""tonos"" unicode=""&#x384;"" horiz-adv-x=""682"" 
d=""M205 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""dieresistonos"" unicode=""&#x385;"" horiz-adv-x=""682"" 
d=""M250 1200v33l69 368h187v-37l-181 -364h-75zM29 1231v172h150v-172h-150zM501 1231v172h150v-172h-150z"" />
    <glyph glyph-name=""Alphatonos"" unicode=""&#x386;"" horiz-adv-x=""1367"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527zM57 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""anoteleia"" unicode=""&#x387;"" horiz-adv-x=""569"" 
d=""M187 446v220h195v-220h-195z"" />
    <glyph glyph-name=""Epsilontonos"" unicode=""&#x388;"" horiz-adv-x=""1606"" 
d=""M408 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM-11 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Etatonos"" unicode=""&#x389;"" horiz-adv-x=""1716"" 
d=""M1358 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191zM-14 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Iotatonos"" unicode=""&#x38a;"" horiz-adv-x=""786"" 
d=""M406 0v1409h191v-1409h-191zM-24 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Omicrontonos"" unicode=""&#x38c;"" horiz-adv-x=""1586"" 
d=""M1491 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1296 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM-69 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Upsilontonos"" unicode=""&#x38e;"" horiz-adv-x=""1752"" 
d=""M1163 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM65 1086v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""Omegatonos"" unicode=""&#x38f;"" horiz-adv-x=""1541"" 
d=""M775 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5
q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43zM-69 1086
v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""iotadieresistonos"" unicode=""&#x390;"" horiz-adv-x=""455"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM141 1200v33l69 368h187v-37l-181 -364h-75zM-80 1231v172h150v-172h-150zM392 1231v172h150v-172h-150z"" />
    <glyph glyph-name=""Alpha"" unicode=""&#x391;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" />
    <glyph glyph-name=""Beta"" unicode=""&#x392;"" horiz-adv-x=""1366"" 
d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49
h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" />
    <glyph glyph-name=""Gamma"" unicode=""&#x393;"" horiz-adv-x=""1128"" 
d=""M1071 1410v-156h-712v-1253h-191v1409h903z"" />
    <glyph glyph-name=""Delta"" unicode=""&#x394;"" horiz-adv-x=""1368"" 
d=""M62 141l517 1268h217l510 -1268v-141h-1245zM1106 156l-338 862q-16 40 -30.5 81t-25.5 75.5t-18.5 58.5t-8.5 32q-2 -8 -9 -32.5t-18.5 -59.5t-25.5 -76t-30 -81l-339 -860h843z"" />
    <glyph glyph-name=""Epsilon"" unicode=""&#x395;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110z"" />
    <glyph glyph-name=""Zeta"" unicode=""&#x396;"" horiz-adv-x=""1251"" 
d=""M1187 0h-1122v143l858 1110h-785v156h1002v-139l-858 -1114h905v-156z"" />
    <glyph glyph-name=""Eta"" unicode=""&#x397;"" horiz-adv-x=""1479"" 
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191z"" />
    <glyph glyph-name=""Theta"" unicode=""&#x398;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231zM502 794h587v-160h-587v160z"" />
    <glyph glyph-name=""Iota"" unicode=""&#x399;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""Kappa"" unicode=""&#x39a;"" horiz-adv-x=""1366"" 
d=""M1106 0l-563 680l-184 -140v-540h-191v1409h191v-706l679 706h225l-600 -612l680 -797h-237z"" />
    <glyph glyph-name=""Lambda"" unicode=""&#x39b;"" horiz-adv-x=""1368"" 
d=""M1358 1h-201l-388 992q-17 47 -31.5 91.5t-26.5 79.5q-14 41 -26 78q-13 -39 -27 -80q-12 -35 -27 -79.5t-30 -89.5l-390 -992h-201l575 1409h198z"" />
    <glyph glyph-name=""Mu"" unicode=""&#x39c;"" horiz-adv-x=""1706"" 
d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5
t19 -64.5t16.5 -62.5t10.5 -45.5q3 16 11 46t18.5 63t20.5 64t18 51l368 977h245v-1409h-172z"" />
    <glyph glyph-name=""Nu"" unicode=""&#x39d;"" horiz-adv-x=""1479"" 
d=""M1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" />
    <glyph glyph-name=""Xi"" unicode=""&#x39e;"" horiz-adv-x=""1331"" 
d=""M125 1409h1081v-156h-1081v156zM1241 156v-156h-1151v156h1151zM1086 801v-154h-841v154h841z"" />
    <glyph glyph-name=""Omicron"" unicode=""&#x39f;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""Pi"" unicode=""&#x3a0;"" horiz-adv-x=""1479"" 
d=""M1121 0v1248h-762v-1248h-191v1409h1144v-1409h-191z"" />
    <glyph glyph-name=""Rho"" unicode=""&#x3a1;"" horiz-adv-x=""1366"" 
d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" />
    <glyph glyph-name=""Sigma"" unicode=""&#x3a3;"" horiz-adv-x=""1266"" 
d=""M108 0v162l538 579l-521 507v161h999v-156h-784l458 -445v-124l-490 -528h877v-156h-1077z"" />
    <glyph glyph-name=""Tau"" unicode=""&#x3a4;"" horiz-adv-x=""1251"" 
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""Upsilon"" unicode=""&#x3a5;"" horiz-adv-x=""1366"" 
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210z"" />
    <glyph glyph-name=""Phi"" unicode=""&#x3a6;"" horiz-adv-x=""1634"" 
d=""M1518 736q0 -105 -32 -199t-97.5 -165.5t-164 -113.5t-231.5 -42h-83v-227h-185v227h-83q-133 0 -231.5 42t-164 113.5t-97.5 165.5t-32 199q0 113 33.5 205.5t100 158t167 101.5t235.5 36h72v182h185v-182h71q135 0 236 -36t167.5 -101.5t100 -158t33.5 -205.5z
M1326 732q0 187 -92.5 277t-275.5 90h-48v-746h56q92 0 160 26.5t112.5 75.5t66 119t21.5 158zM309 732q0 -88 21.5 -158t66 -119t112.5 -75.5t160 -26.5h56v746h-52q-182 0 -273 -90t-91 -277z"" />
    <glyph glyph-name=""Chi"" unicode=""&#x3a7;"" horiz-adv-x=""1366"" 
d=""M1112 0l-423 616l-432 -616h-211l536 732l-495 677h211l392 -553l381 553h211l-482 -670l523 -739h-211z"" />
    <glyph glyph-name=""Psi"" unicode=""&#x3a8;"" horiz-adv-x=""1711"" 
d=""M763 0v427h-83q-133 0 -233.5 42t-167.5 113t-100.5 165.5t-33.5 198.5v463h191v-467q0 -80 23.5 -148.5t70 -118.5t116 -78.5t161.5 -28.5h56v841h185v-841h56q95 0 165 28.5t115.5 78.5t68 118.5t22.5 148.5v467h191v-463q0 -104 -34 -198.5t-101 -165.5t-167.5 -113
t-232.5 -42h-83v-427h-185z"" />
    <glyph glyph-name=""Omega"" unicode=""&#x3a9;"" horiz-adv-x=""1531"" 
d=""M765 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5
q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43z"" />
    <glyph glyph-name=""Iotadieresis"" unicode=""&#x3aa;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM401 1530v184h163v-184h-163zM7 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""Upsilondieresis"" unicode=""&#x3ab;"" horiz-adv-x=""1366"" 
d=""M777 584v-584h-190l2 584l-544 825h205l434 -671l432 671h205zM802 1530v184h163v-184h-163zM408 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""alphatonos"" unicode=""&#x3ac;"" horiz-adv-x=""1184"" 
d=""M843 237q-26 -56 -58.5 -103t-76 -81.5t-99 -53.5t-125.5 -19q-205 0 -301.5 138t-96.5 418q0 284 108.5 425t317.5 141q69 0 125 -19.5t99 -54t74.5 -81t51.5 -100.5h2q4 21 11 49t16.5 59.5t21 64t24.5 62.5h188q-22 -47 -45 -111t-42.5 -133.5t-34.5 -139t-20 -127.5
q3 -103 14.5 -190.5t27 -159.5t33.5 -127t36 -94h-183q-11 28 -21.5 61t-18.5 65.5t-14.5 61.5t-9.5 49h-4zM275 542q0 -112 14 -192t43.5 -131.5t76 -75.5t112.5 -24q54 0 104 26t91 79.5t71.5 133.5t44.5 188q-12 86 -34.5 163t-58 134.5t-86.5 91.5t-121 34
q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5zM494 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""epsilontonos"" unicode=""&#x3ad;"" horiz-adv-x=""913"" 
d=""M456 114q54 0 102 15.5t87.5 39.5t71 52t52.5 54l105 -100q-32 -39 -74 -74.5t-95 -62t-118 -42.5t-143 -16q-96 0 -166.5 23t-116.5 65t-68.5 100t-22.5 127q0 58 21 105.5t57 82t84 55.5t102 26v2q-51 6 -93.5 26t-73 52t-47.5 75t-17 94q0 62 25 115t72.5 91.5
t115.5 60.5t155 22q118 0 213.5 -43t162.5 -142l-128 -88q-47 71 -109.5 105t-137.5 34q-91 0 -139 -42.5t-48 -116.5q0 -57 27.5 -92t76 -53.5t114 -24.5t140.5 -6v-135q-72 0 -141.5 -5.5t-124 -25.5t-87.5 -60t-33 -109q0 -45 14.5 -79.5t40.5 -57.5t63 -35t81 -12z
M407 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""etatonos"" unicode=""&#x3ae;"" 
d=""M825 -424v1110q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 68 -11 128.5t-25 102.5h170q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68
t61.5 -118.5t19.5 -172.5v-1145h-181zM518 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""iotatonos"" unicode=""&#x3af;"" horiz-adv-x=""455"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM158 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""upsilondieresistonos"" unicode=""&#x3b0;"" horiz-adv-x=""1120"" 
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5zM472 1200v33l69 368h187v-37l-181 -364h-75zM251 1231v172h150v-172h-150zM723 1231v172h150v-172h-150z"" />
    <glyph glyph-name=""alpha"" unicode=""&#x3b1;"" horiz-adv-x=""1184"" 
d=""M843 237q-26 -56 -58.5 -103t-76 -81.5t-99 -53.5t-125.5 -19q-205 0 -301.5 138t-96.5 418q0 284 108.5 425t317.5 141q69 0 125 -19.5t99 -54t74.5 -81t51.5 -100.5h2q4 21 11 49t16.5 59.5t21 64t24.5 62.5h188q-22 -47 -45 -111t-42.5 -133.5t-34.5 -139t-20 -127.5
q3 -103 14.5 -190.5t27 -159.5t33.5 -127t36 -94h-183q-11 28 -21.5 61t-18.5 65.5t-14.5 61.5t-9.5 49h-4zM275 542q0 -112 14 -192t43.5 -131.5t76 -75.5t112.5 -24q54 0 104 26t91 79.5t71.5 133.5t44.5 188q-12 86 -34.5 163t-58 134.5t-86.5 91.5t-121 34
q-66 0 -114 -23t-80 -74t-47.5 -132.5t-15.5 -197.5z"" />
    <glyph glyph-name=""beta"" unicode=""&#x3b2;"" horiz-adv-x=""1178"" 
d=""M1097 405q0 -89 -26.5 -166t-82 -135t-142 -91t-206.5 -33q-102 0 -182 27.5t-136 66.5h-6q3 -57 4.5 -103t1.5 -99v-297h-180v1452q0 237 114 347t340 110q99 0 175 -23.5t127 -68.5t77.5 -110t26.5 -147q0 -73 -17.5 -128.5t-48 -96.5t-71 -69t-86.5 -46
q57 -11 114 -38.5t102.5 -74t73.5 -115t28 -162.5zM322 205q28 -19 63.5 -36t76 -29.5t84 -19.5t86.5 -7q72 0 127 20.5t91.5 58.5t55.5 91t19 119q0 65 -19 120t-59.5 95.5t-104.5 63t-153 22.5v142q127 27 183.5 96.5t56.5 191.5q0 44 -13.5 82.5t-42 67t-72 44.5
t-103.5 16q-70 0 -122 -17.5t-86 -56t-51 -99.5t-17 -149v-816z"" />
    <glyph glyph-name=""gamma"" unicode=""&#x3b3;"" horiz-adv-x=""1024"" 
d=""M7 1082h192l245 -675q7 -22 17.5 -53.5t20.5 -65t18.5 -65t12.5 -53.5q5 21 14 52t19.5 64.5t21.5 65t19 53.5l239 677h191l-390 -1029q-17 -45 -32.5 -100.5t-29 -117.5t-25 -128t-18.5 -131h-191q17 131 41 237.5t48 197.5z"" />
    <glyph glyph-name=""delta"" unicode=""&#x3b4;"" horiz-adv-x=""1140"" 
d=""M864 471q0 85 -24.5 157.5t-59 130t-72.5 100.5t-64 70q-73 -26 -140 -66.5t-118 -97.5t-81 -130t-30 -164q0 -76 17.5 -141.5t54 -113.5t92 -75.5t132.5 -27.5q81 0 137 27t90.5 74.5t50 113t15.5 143.5zM607 1352q-13 0 -34 1t-43.5 2.5t-43 2.5t-33.5 2l316 -324
q54 -55 105 -113t90.5 -125t64 -146.5t24.5 -176.5q0 -110 -32 -201t-93.5 -156.5t-151.5 -101.5t-205 -36q-114 0 -204 34t-152.5 97.5t-95.5 155t-33 206.5q0 112 36.5 200t100 155.5t148 116t180.5 81.5l-319 339v119h733v-132h-358z"" />
    <glyph glyph-name=""epsilon"" unicode=""&#x3b5;"" horiz-adv-x=""913"" 
d=""M456 114q54 0 102 15.5t87.5 39.5t71 52t52.5 54l105 -100q-32 -39 -74 -74.5t-95 -62t-118 -42.5t-143 -16q-96 0 -166.5 23t-116.5 65t-68.5 100t-22.5 127q0 58 21 105.5t57 82t84 55.5t102 26v2q-51 6 -93.5 26t-73 52t-47.5 75t-17 94q0 62 25 115t72.5 91.5
t115.5 60.5t155 22q118 0 213.5 -43t162.5 -142l-128 -88q-47 71 -109.5 105t-137.5 34q-91 0 -139 -42.5t-48 -116.5q0 -57 27.5 -92t76 -53.5t114 -24.5t140.5 -6v-135q-72 0 -141.5 -5.5t-124 -25.5t-87.5 -60t-33 -109q0 -45 14.5 -79.5t40.5 -57.5t63 -35t81 -12z"" />
    <glyph glyph-name=""zeta"" unicode=""&#x3b6;"" horiz-adv-x=""903"" 
d=""M277 379q0 -64 21.5 -103.5t58.5 -64t87 -40t107 -30.5q54 -15 109.5 -32t100.5 -45.5t74 -72.5t29 -112q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56q9 12 18.5 28.5t17.5 35.5t13.5 38.5t5.5 38.5q0 34 -18 56.5t-51 39t-80 29t-104 25.5q-42 10 -86.5 21.5
t-85.5 29.5t-77.5 43t-63.5 62t-42.5 87t-15.5 117q0 83 24.5 171t67 176t99 175.5t120 170.5t131 160.5t131.5 145.5v4q-12 -1 -29 -1.5t-35 -1t-35 -1t-28 -0.5h-345v131h642v-127q-62 -70 -127.5 -148.5t-127 -161.5t-115.5 -169t-94.5 -171.5t-64 -168.5t-23.5 -159z
"" />
    <glyph glyph-name=""eta"" unicode=""&#x3b7;"" 
d=""M825 -424v1110q0 79 -11.5 132t-37.5 85.5t-68.5 46t-105.5 13.5q-64 0 -115.5 -22.5t-88 -65t-56.5 -105t-20 -143.5v-627h-180v851q0 68 -11 128.5t-25 102.5h170q9 -21 16 -45t12 -48.5t7.5 -48t2.5 -43.5h3q26 47 57 85t72 64.5t94 41t123 14.5q90 0 155 -22t107 -68
t61.5 -118.5t19.5 -172.5v-1145h-181z"" />
    <glyph glyph-name=""theta"" unicode=""&#x3b8;"" 
d=""M1033 733q0 -381 -120 -567t-348 -186q-108 0 -193.5 46t-144.5 139t-90 234.5t-31 333.5q0 373 116.5 561.5t348.5 188.5q121 0 208.5 -46.5t143.5 -140.5t83 -234.5t27 -328.5zM563 113q62 0 112 26t86.5 90t57.5 172t24 272h-547q3 -164 25 -271.5t57.5 -172
t82.5 -90.5t102 -26zM574 1354q-62 0 -111.5 -25.5t-85.5 -88.5t-57 -169t-24 -267h547q-3 161 -23 267t-54.5 169t-83 88.5t-108.5 25.5z"" />
    <glyph glyph-name=""iota"" unicode=""&#x3b9;"" horiz-adv-x=""455"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198z"" />
    <glyph glyph-name=""kappa"" unicode=""&#x3ba;"" horiz-adv-x=""1024"" 
d=""M816 0l-366 494l-132 -109v-385h-180v1082h180v-525l475 525h211l-439 -465l462 -617h-211z"" />
    <glyph glyph-name=""lambda"" unicode=""&#x3bb;"" horiz-adv-x=""1024"" 
d=""M463 965l-36 99q-27 73 -48 125.5t-43.5 86t-51 49t-68.5 15.5q-11 0 -27 -3.5t-22 -6.5l-35 130q25 9 61 16.5t68 7.5q55 0 98.5 -18t80 -58.5t70 -106t69.5 -160.5l427 -1141h-190l-207 577q-8 22 -17 50t-18 57.5t-17 57.5t-13 49q-7 -21 -18 -51t-23.5 -61
t-24.5 -58.5t-20 -45.5l-257 -575h-187z"" />
    <glyph glyph-name=""mu"" unicode=""&#x3bc;"" horiz-adv-x=""1180"" 
d=""M862 0q-1 6 -2.5 29t-3 52.5l-3 59t-1.5 49.5h-4q-26 -51 -54 -90.5t-62.5 -66t-77.5 -40t-100 -13.5q-82 0 -142 32t-92 90h-4q3 -32 3.5 -63.5t0.5 -58.5v-373h-182v1475h182v-644q0 -69 12.5 -127t42 -100.5t78.5 -66t123 -23.5q67 0 117 26t83.5 71.5t50 108.5
t16.5 138v617h181v-849q0 -34 0.5 -72t1.5 -71.5t2 -58t2 -31.5h-168z"" />
    <glyph glyph-name=""nu"" unicode=""&#x3bd;"" horiz-adv-x=""1024"" 
d=""M946 846q0 -99 -31.5 -208t-84.5 -219.5t-123 -217.5t-147 -201h-170l-390 1082h189l311 -928q142 185 204 356t62 327q0 81 -14.5 140.5t-34.5 104.5h177q24 -45 38 -101.5t14 -134.5z"" />
    <glyph glyph-name=""xi"" unicode=""&#x3be;"" horiz-adv-x=""917"" 
d=""M86 354q0 76 25.5 149.5t80.5 135.5t142.5 107t212.5 64v2q-68 5 -127 24.5t-102.5 53.5t-69 82t-25.5 110q0 64 25 110.5t64.5 78.5t88 52t95.5 30v8q-12 -1 -46 -2t-74 -2.5t-78 -2.5t-56 -1h-74v131h634v-125q-77 -9 -149 -26t-128 -46.5t-90 -74.5t-34 -112
q0 -63 30 -103.5t79.5 -65t114.5 -36.5t134 -18v-131q-100 -13 -187.5 -40t-153 -71.5t-103.5 -108t-38 -147.5q0 -64 21.5 -103.5t58.5 -64t87 -40t107 -30.5q54 -15 111 -32t104 -45.5t77.5 -72.5t30.5 -112q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56
q9 12 18.5 28.5t17.5 35.5t13.5 38.5t5.5 38.5q0 34 -19.5 56.5t-54.5 39t-83.5 29t-105.5 25.5q-42 10 -86.5 21.5t-85.5 29.5t-77.5 43t-63.5 62t-42.5 87t-15.5 117z"" />
    <glyph glyph-name=""omicron"" unicode=""&#x3bf;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209z"" />
    <glyph glyph-name=""pi"" unicode=""&#x3c0;"" horiz-adv-x=""1413"" 
d=""M1126 -20q-59 0 -100 14t-67 43.5t-38 76.5t-12 113v724h-402v-72q0 -131 -8 -256.5t-21.5 -239.5t-31.5 -211.5t-37 -171.5h-188q19 76 38.5 174.5t35.5 211.5t26 236.5t10 248.5v80q-39 0 -78.5 -3.5t-74 -8.5t-61 -11.5t-38.5 -13.5v139q12 6 33.5 11.5t47 9.5t52.5 6
t50 2h1061v-131h-234v-685q0 -44 6.5 -72t18.5 -44t29.5 -22.5t39.5 -6.5q7 0 18.5 1t24 2t24 2.5t19.5 2.5v-129q-31 -8 -65.5 -14t-77.5 -6z"" />
    <glyph glyph-name=""rho"" unicode=""&#x3c1;"" horiz-adv-x=""1165"" 
d=""M1083 516q0 -118 -31.5 -216.5t-89 -169.5t-138 -110.5t-178.5 -39.5q-62 0 -111 10t-89 28.5t-73 45t-61 59.5h-4q2 -30 3 -60.5t1 -62.5v-425h-180v1006q0 119 30 215.5t88 164.5t142.5 105t194.5 37q103 0 193.5 -39.5t157.5 -114.5t106 -184.5t39 -248.5zM890 524
q0 104 -22 187t-63.5 140.5t-99.5 88t-130 30.5q-69 0 -119 -26.5t-82 -77t-47 -123.5t-15 -166v-317q28 -35 64 -62.5t76 -46t83.5 -28.5t87.5 -10q67 0 117 29t83.5 82.5t50 129.5t16.5 170z"" />
    <glyph glyph-name=""sigma1"" unicode=""&#x3c2;"" horiz-adv-x=""987"" 
d=""M582 961q-54 0 -98 -24.5t-77.5 -64.5t-58 -92t-40.5 -106t-23.5 -107t-7.5 -95q0 -68 16 -116t54 -84t100 -64.5t154 -58.5q53 -17 110 -35.5t104.5 -48t78 -74t30.5 -112.5q0 -34 -9 -68t-22 -65t-27.5 -56.5t-24.5 -42.5l-126 56q9 12 18.5 28.5t17.5 35.5t13.5 38.5
t5.5 38.5q0 30 -17.5 52t-51.5 40t-82.5 33.5t-111.5 32.5q-66 18 -122.5 38t-103.5 45.5t-83 59.5t-61 80.5t-38 107.5t-13 142q0 47 10 112t33 135t60.5 138t92.5 122t129 87t171 33q68 0 117.5 -10.5t86 -27.5t63.5 -39t49 -45l-116 -119q-18 19 -39 37t-45.5 32
t-53 22.5t-62.5 8.5z"" />
    <glyph glyph-name=""sigma"" unicode=""&#x3c3;"" horiz-adv-x=""1264"" 
d=""M1072 491q0 -112 -30.5 -206t-92 -161.5t-153 -105.5t-214.5 -38t-216 37t-155 106.5t-93.5 170.5t-31.5 230q0 144 43 249t119.5 174t183 102t232.5 33h569v-131h-165q-9 0 -26.5 0.5t-39 1.5t-43.5 2t-39 2v-4q28 -42 55.5 -91.5t49 -107t34.5 -123t13 -140.5zM883 488
q0 74 -10 140t-27 124t-39.5 107.5t-47.5 91.5h-89q-83 0 -154.5 -25t-125 -77.5t-84 -132.5t-30.5 -190q0 -207 75.5 -310t222.5 -103q78 0 136.5 26t96.5 74.5t57 118t19 156.5z"" />
    <glyph glyph-name=""tau"" unicode=""&#x3c4;"" horiz-adv-x=""809"" 
d=""M281 951q-39 0 -78.5 -3.5t-74 -8.5t-61 -11.5t-38.5 -13.5v139q12 6 33.5 11.5t47 9.5t52.5 6t50 2h580v-131h-304v-685q0 -44 6.5 -72t18.5 -44t29.5 -22.5t39.5 -6.5q7 0 18.5 1t24 2t24 2.5t19.5 2.5v-129q-31 -8 -65.5 -14t-77.5 -6q-59 0 -100 14t-67 43.5
t-38 76.5t-12 113v724h-27z"" />
    <glyph glyph-name=""upsilon"" unicode=""&#x3c5;"" horiz-adv-x=""1120"" 
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5z"" />
    <glyph glyph-name=""phi"" unicode=""&#x3c6;"" horiz-adv-x=""1328"" 
d=""M1242 565q0 -151 -37 -258.5t-103 -177.5t-158 -105.5t-202 -41.5v-407h-170v407q-114 5 -204.5 41t-153 105t-96 172.5t-33.5 244.5q0 102 24.5 196t76 169t131 126.5t188.5 69.5l21 -136q-69 -15 -117 -53.5t-78 -95.5t-43.5 -128.5t-13.5 -151.5q0 -213 73.5 -313.5
t224.5 -108.5v580q0 193 77 299t235 106q84 0 150.5 -38t112.5 -108.5t70.5 -170t24.5 -222.5zM1053 567q0 193 -43.5 298.5t-123.5 105.5q-68 0 -106 -64.5t-38 -204.5v-583q162 7 236.5 116t74.5 332z"" />
    <glyph glyph-name=""chi"" unicode=""&#x3c7;"" horiz-adv-x=""1075"" 
d=""M542 239l-333 -663h-188l440 825l-170 343q-27 54 -49 95t-42 68.5t-41 41.5t-46 14q-11 0 -27 -3.5t-23 -6.5l-34 131q24 9 55 14.5t63 5.5q48 0 83 -13.5t65 -44.5t59.5 -82t65.5 -126l142 -295l264 539h187l-368 -697l406 -809h-190z"" />
    <glyph glyph-name=""psi"" unicode=""&#x3c8;"" horiz-adv-x=""1460"" 
d=""M814 119q87 1 149 16.5t102 52t58.5 97t18.5 151.5v646h182v-644q0 -122 -29.5 -208t-91.5 -141t-158.5 -81.5t-230.5 -27.5v-405h-170v405q-134 1 -230 27.5t-158 81.5t-91.5 141t-29.5 208v644h181v-646q0 -90 19 -150.5t58.5 -97t101.5 -52.5t149 -17v1221h170v-1221z
"" />
    <glyph glyph-name=""omega"" unicode=""&#x3c9;"" horiz-adv-x=""1599"" 
d=""M883 449q0 -157 57 -243.5t159 -86.5q65 0 108.5 28t70 79t37.5 123.5t11 162.5q0 82 -14.5 157t-45 135.5t-79 102.5t-115.5 57l23 139q109 -18 188.5 -74t131 -136.5t76 -177.5t24.5 -198q0 -128 -26.5 -228t-77 -168.5t-124.5 -104.5t-169 -36q-68 0 -120 18t-90.5 52
t-64.5 83.5t-42 113.5h-4q-16 -64 -42 -113.5t-64.5 -83.5t-91 -52t-119.5 -18q-95 0 -169 36t-124.5 104.5t-77 168.5t-26.5 228q0 101 24.5 198t76 177.5t131 136.5t188.5 74l23 -139q-68 -15 -116 -57t-79 -102.5t-45 -135.5t-14 -157q0 -90 11 -162.5t37 -123.5t69 -79
t108 -28q51 0 92 22.5t69.5 64.5t43.5 103.5t15 139.5v252h166v-252z"" />
    <glyph glyph-name=""iotadieresis"" unicode=""&#x3ca;"" horiz-adv-x=""455"" 
d=""M199 0q-15 16 -27 42.5t-19.5 58.5t-11.5 67t-4 68v846h180v-855q0 -32 5.5 -64t16 -62t25.5 -56t33 -45h-198zM343 1219v184h163v-184h-163zM-51 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""upsilondieresis"" unicode=""&#x3cb;"" horiz-adv-x=""1120"" 
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5zM681 1219v184h163v-184h-163zM287 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""omicrontonos"" unicode=""&#x3cc;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209zM502 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""upsilontonos"" unicode=""&#x3cd;"" horiz-adv-x=""1120"" 
d=""M1022 571q0 -137 -26.5 -246t-83 -186t-144.5 -118t-211 -41q-109 0 -189 25t-132 78.5t-77.5 136.5t-25.5 199v663h181v-669q0 -146 58.5 -220t192.5 -74q73 0 125 25t84.5 79t47.5 139t15 205q0 68 -10 141.5t-26.5 143t-36.5 129.5t-41 101h188q18 -40 38 -96.5
t36 -123.5t26.5 -141.5t10.5 -149.5zM457 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""omegatonos"" unicode=""&#x3ce;"" horiz-adv-x=""1599"" 
d=""M883 449q0 -157 57 -243.5t159 -86.5q65 0 108.5 28t70 79t37.5 123.5t11 162.5q0 82 -14.5 157t-45 135.5t-79 102.5t-115.5 57l23 139q109 -18 188.5 -74t131 -136.5t76 -177.5t24.5 -198q0 -128 -26.5 -228t-77 -168.5t-124.5 -104.5t-169 -36q-68 0 -120 18t-90.5 52
t-64.5 83.5t-42 113.5h-4q-16 -64 -42 -113.5t-64.5 -83.5t-91 -52t-119.5 -18q-95 0 -169 36t-124.5 104.5t-77 168.5t-26.5 228q0 101 24.5 198t76 177.5t131 136.5t188.5 74l23 -139q-68 -15 -116 -57t-79 -102.5t-45 -135.5t-14 -157q0 -90 11 -162.5t37 -123.5t69 -79
t108 -28q51 0 92 22.5t69.5 64.5t43.5 103.5t15 139.5v252h166v-252zM716 1218v33l69 292h207v-37l-201 -288h-75z"" />
    <glyph glyph-name=""uni0400"" unicode=""&#x400;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM735 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""afii10023"" unicode=""&#x401;"" horiz-adv-x=""1367"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110zM816 1530v184h163v-184h-163zM422 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10051"" unicode=""&#x402;"" horiz-adv-x=""1771"" 
d=""M720 1253v-352q33 7 87.5 17t118 19.5t128.5 16t118 6.5q226 0 334.5 -93.5t108.5 -281.5v-214q0 -93 -20.5 -165.5t-63.5 -122.5t-109.5 -76.5t-158.5 -26.5q-53 0 -97 8.5t-81.5 24.5t-69.5 39t-61 51l111 123q18 -16 38.5 -32.5t44.5 -29.5t52 -21.5t61 -8.5
q84 0 124 50.5t40 161.5v219q0 119 -64.5 180t-208.5 61q-51 0 -112.5 -5t-121.5 -12.5t-112.5 -16t-85.5 -16.5v-756h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""afii10052"" unicode=""&#x403;"" horiz-adv-x=""1109"" 
d=""M1071 1410v-156h-712v-1253h-191v1409h903zM441 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""afii10053"" unicode=""&#x404;"" horiz-adv-x=""1472"" 
d=""M792 1274q-111 0 -197.5 -34t-148.5 -97t-98.5 -152t-46.5 -199h654v-154h-654q9 -112 47.5 -204.5t102.5 -158.5t152 -102t197 -36q90 0 160.5 25t124.5 66t93.5 93.5t66.5 107.5l156 -77q-40 -79 -94 -147t-128 -118t-169.5 -78.5t-218.5 -28.5q-171 0 -299.5 54.5
t-215 152t-129.5 231.5t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" />
    <glyph glyph-name=""afii10054"" unicode=""&#x405;"" horiz-adv-x=""1366"" 
d=""M1272 389q0 -89 -34.5 -164t-106.5 -129.5t-181.5 -85t-259.5 -30.5q-263 0 -410 92t-187 266l185 37q14 -55 43 -100t78.5 -77.5t122.5 -50.5t175 -18q85 0 156 14.5t122 44.5t79.5 77.5t28.5 113.5q0 69 -31.5 112t-88.5 71t-136 47t-175 41q-59 13 -118.5 28.5
t-114 37t-102.5 50.5t-83 69.5t-55 94t-20 123.5q0 100 40.5 171.5t112.5 117.5t170 67t212 21q131 0 224 -20.5t157 -61.5t102.5 -101.5t61.5 -140.5l-188 -33q-14 51 -40.5 91t-69.5 67t-104.5 41t-144.5 14q-98 0 -164.5 -17.5t-107 -47.5t-58 -70.5t-17.5 -87.5
q0 -63 31.5 -103.5t85.5 -67.5t125 -45t151 -36q65 -15 129.5 -30.5t123.5 -37t110.5 -50.5t89.5 -71t59.5 -99t21.5 -134z"" />
    <glyph glyph-name=""afii10055"" unicode=""&#x406;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""afii10056"" unicode=""&#x407;"" horiz-adv-x=""569"" 
d=""M189 0v1409h191v-1409h-191zM401 1530v184h163v-184h-163zM7 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10057"" unicode=""&#x408;"" horiz-adv-x=""1024"" 
d=""M457 -20q-171 0 -280.5 89t-144.5 281l187 31q10 -65 33 -111.5t55 -76.5t71 -44t80 -14q104 0 164 71.5t60 209.5v837h-271v156h461v-989q0 -101 -28 -182t-81.5 -138.5t-130.5 -88.5t-175 -31z"" />
    <glyph glyph-name=""afii10058"" unicode=""&#x409;"" horiz-adv-x=""2165"" 
d=""M2059 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1249h-416l-49 -368q-22 -172 -43.5 -305.5t-46 -233t-54.5 -168t-69 -111t-90 -61t-117 -18.5q-25 0 -48.5 2.5t-37.5 7.5v152q11 -4 28.5 -5.5t27.5 -1.5q30 0 56 11.5t48.5 42.5t43.5 84.5t40.5 138
t39.5 203.5t41 280l67 510h770v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1867 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10059"" unicode=""&#x40a;"" horiz-adv-x=""2069"" 
d=""M1963 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-545v653h-574v-653h-191v1409h191v-596h574v596h191v-596h342q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1771 411q0 121 -82 185.5t-246 64.5h-319v-510h327q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10060"" unicode=""&#x40b;"" horiz-adv-x=""1749"" 
d=""M1393 0v575q0 122 -64 176.5t-197 54.5q-53 0 -111 -5t-113 -12.5t-104 -16.5t-84 -16v-756h-190v1253h-484v156h1203v-156h-529v-352q36 8 85 18t105 19t115 15.5t115 6.5q229 0 336 -93.5t107 -271.5v-595h-190z"" />
    <glyph glyph-name=""afii10061"" unicode=""&#x40c;"" horiz-adv-x=""1193"" 
d=""M168 1409h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v1409zM500 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""uni040D"" unicode=""&#x40d;"" horiz-adv-x=""1479"" 
d=""M841 1470l-330 278v29h207l217 -287v-20h-94zM1082 0l-754 1200q2 -49 5 -97q2 -41 3.5 -86.5t1.5 -80.5v-936h-170v1409h222l762 -1208l-6 98q-2 42 -4 91.5t-2 94.5v924h172v-1409h-230z"" />
    <glyph glyph-name=""afii10062"" unicode=""&#x40e;"" horiz-adv-x=""1301"" 
d=""M734 318q-47 -88 -87.5 -152t-85.5 -105t-99.5 -61t-129.5 -20q-32 0 -65 5t-65 14t-61 22t-52 29l81 144q35 -22 76.5 -40.5t89.5 -18.5q37 0 66 10.5t55.5 36.5t55 71t66.5 113l49 89l-573 954h218l449 -784l384 784h205zM690 1530q-111 0 -181.5 28.5t-111 74
t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10145"" unicode=""&#x40f;"" horiz-adv-x=""1472"" 
d=""M646 -408v408h-478v1409h191v-1249h759v1249h186v-1409h-478v-408h-180z"" />
    <glyph glyph-name=""afii10017"" unicode=""&#x410;"" horiz-adv-x=""1366"" 
d=""M1167 0l-161 412h-642l-162 -412h-198l575 1409h217l566 -1409h-195zM768 1026q-16 40 -30.5 81t-25.5 74.5t-18.5 56t-8.5 27.5q-2 -5 -9 -28t-18.5 -57t-26 -75t-29.5 -81l-180 -463h527z"" />
    <glyph glyph-name=""afii10018"" unicode=""&#x411;"" horiz-adv-x=""1344"" 
d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h926v-156h-735v-440h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10019"" unicode=""&#x412;"" horiz-adv-x=""1366"" 
d=""M1258 397q0 -107 -42 -182.5t-113 -123t-165 -69.5t-198 -22h-572v1409h512q117 0 209 -19.5t156 -61.5t97.5 -106.5t33.5 -154.5q0 -59 -16.5 -111t-50 -94.5t-84 -73t-117.5 -45.5q85 -10 150.5 -39t109.5 -74t67 -104.5t23 -128.5zM984 1044q0 114 -78 163t-226 49
h-321v-446h321q84 0 142 16.5t94 47t52 73.5t16 97zM1065 412q0 67 -24.5 114t-70.5 77t-110.5 44t-144.5 14h-356v-508h371q73 0 134.5 12t106 42t69.5 80t25 125z"" />
    <glyph glyph-name=""afii10020"" unicode=""&#x413;"" horiz-adv-x=""1109"" 
d=""M1071 1410v-156h-712v-1253h-191v1409h903z"" />
    <glyph glyph-name=""afii10021"" unicode=""&#x414;"" horiz-adv-x=""1387"" 
d=""M1174 160h175v-568h-180v408h-974v-408h-180v568h144q41 51 74 120t60.5 159.5t49.5 204.5t40 255l67 510h724v-1249zM988 160v1089h-375l-49 -368q-18 -134 -38 -244.5t-43 -199.5t-50 -157.5t-59 -119.5h614z"" />
    <glyph glyph-name=""afii10022"" unicode=""&#x415;"" horiz-adv-x=""1366"" 
d=""M168 0v1409h1069v-156h-878v-452h818v-154h-818v-491h919v-156h-1110z"" />
    <glyph glyph-name=""afii10024"" unicode=""&#x416;"" horiz-adv-x=""1891"" 
d=""M850 645q-17 0 -39.5 3t-46.5 8.5t-47 12t-40 14.5l-427 -683h-222l509 775q-48 35 -179 224l-283 410h200l205 -305q66 -99 111 -160.5t83 -95.5t78.5 -46t97.5 -12v619h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224
l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v645z"" />
    <glyph glyph-name=""afii10025"" unicode=""&#x417;"" horiz-adv-x=""1237"" 
d=""M621 -20q-118 0 -206 25t-153 70.5t-112 109.5t-83 143l165 77q24 -55 57 -104t78.5 -86.5t106 -59.5t140.5 -22q77 0 138 18.5t103.5 53t65 84.5t22.5 114q0 133 -96 192t-298 59h-71v148h71q181 0 267.5 59.5t86.5 182.5q0 55 -19.5 98t-55.5 72.5t-88 44.5t-117 15
q-77 0 -134 -20t-98.5 -54t-69.5 -79t-47 -94l-178 61q33 82 81 145.5t114 107t150 66t189 22.5q108 0 194 -26.5t146 -74.5t92 -116t32 -151q0 -68 -20 -121.5t-56.5 -93.5t-88.5 -67.5t-115 -42.5q67 -10 125.5 -35t102 -66t69 -98.5t25.5 -130.5q0 -95 -34.5 -173
t-100.5 -134.5t-162 -87.5t-218 -31z"" />
    <glyph glyph-name=""afii10026"" unicode=""&#x418;"" horiz-adv-x=""1472"" 
d=""M168 0v1409h172v-924q0 -51 -1 -100t-3 -88q-2 -46 -4 -86l750 1198h222v-1409h-170v936q0 39 0.5 83.5t2.5 82.5q1 44 3 88l-742 -1190h-230z"" />
    <glyph glyph-name=""afii10027"" unicode=""&#x419;"" horiz-adv-x=""1472"" 
d=""M168 0v1409h172v-924q0 -51 -1 -100t-3 -88q-2 -46 -4 -86l750 1198h222v-1409h-170v936q0 39 0.5 83.5t2.5 82.5q1 44 3 88l-742 -1190h-230zM742 1530q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164
q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10028"" unicode=""&#x41a;"" horiz-adv-x=""1193"" 
d=""M168 1409h191v-619q57 0 97.5 12t78.5 46t83 95.5t111 160.5l205 305h200l-283 -410q-131 -189 -179 -224l509 -775h-222l-427 683q-17 -8 -40 -14.5t-47 -12t-46.5 -8.5t-39.5 -3v-645h-191v1409z"" />
    <glyph glyph-name=""afii10029"" unicode=""&#x41b;"" horiz-adv-x=""1344"" 
d=""M991 1249h-418l-49 -368q-22 -172 -43.5 -305.5t-46 -233t-54.5 -168t-69 -111t-90 -61t-117 -18.5q-25 0 -48.5 2.5t-37.5 7.5v152q11 -4 28.5 -5.5t27.5 -1.5q30 0 56 11.5t48.5 42.5t43.5 84.5t40.5 138t39.5 203.5t41 280l67 510h767v-1409h-186v1249z"" />
    <glyph glyph-name=""afii10030"" unicode=""&#x41c;"" horiz-adv-x=""1706"" 
d=""M1366 0v940q0 51 1 104t3 97q2 51 5 99q-14 -51 -29 -101q-13 -43 -28.5 -91.5t-30.5 -87.5l-364 -960h-134l-369 960q-6 15 -12.5 35t-14 42.5t-15 46t-14.5 46.5q-17 53 -33 110q1 -56 3 -111q2 -47 3 -98.5t1 -90.5v-940h-170v1409h251l375 -977q7 -20 17 -51.5
t19 -64.5t16.5 -62.5t10.5 -45.5q3 16 11 46t18.5 63t20.5 64t18 51l368 977h245v-1409h-172z"" />
    <glyph glyph-name=""afii10031"" unicode=""&#x41d;"" horiz-adv-x=""1479"" 
d=""M1121 0v653h-762v-653h-191v1409h191v-596h762v596h191v-1409h-191z"" />
    <glyph glyph-name=""afii10032"" unicode=""&#x41e;"" horiz-adv-x=""1593"" 
d=""M1495 711q0 -165 -47.5 -300t-137.5 -231t-220 -148t-295 -52q-174 0 -305 54.5t-218 152t-131 231.5t-44 293q0 165 46 298t135 226.5t219.5 144t299.5 50.5q168 0 298.5 -51t219 -145t134.5 -227t46 -296zM1300 711q0 127 -32.5 231t-96 178t-157.5 114t-217 40
q-126 0 -221 -40t-158.5 -114t-95 -178t-31.5 -231t32.5 -232.5t96 -182t158 -119t217.5 -42.5q132 0 227.5 43t157 119.5t91 182.5t29.5 231z"" />
    <glyph glyph-name=""afii10033"" unicode=""&#x41f;"" horiz-adv-x=""1472"" 
d=""M1119 0v1248h-762v-1248h-191v1409h1144v-1409h-191z"" />
    <glyph glyph-name=""afii10034"" unicode=""&#x420;"" horiz-adv-x=""1366"" 
d=""M1258 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-414v-549h-191v1409h593q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM1066 983q0 134 -82 203.5t-246 69.5h-379v-556h387q165 0 242.5 73t77.5 210z"" />
    <glyph glyph-name=""afii10035"" unicode=""&#x421;"" horiz-adv-x=""1479"" 
d=""M792 1274q-120 0 -212.5 -40t-155 -114t-94.5 -178t-32 -231t34.5 -232.5t99 -181.5t158 -118t210.5 -42q82 0 149.5 21.5t122 60.5t97.5 92.5t76 118.5l156 -78q-38 -79 -94 -147t-131.5 -118t-171 -78.5t-213.5 -28.5q-171 0 -299.5 54.5t-215 152t-129.5 231.5
t-43 293q0 165 45.5 298t133 226.5t215.5 144t292 50.5q225 0 376 -88t222 -261l-181 -60q-20 50 -54 95.5t-85 80.5t-119.5 56t-156.5 21z"" />
    <glyph glyph-name=""afii10036"" unicode=""&#x422;"" horiz-adv-x=""1251"" 
d=""M720 1253v-1253h-190v1253h-484v156h1158v-156h-484z"" />
    <glyph glyph-name=""afii10037"" unicode=""&#x423;"" horiz-adv-x=""1301"" 
d=""M734 318q-47 -88 -87.5 -152t-85.5 -105t-99.5 -61t-129.5 -20q-32 0 -65 5t-65 14t-61 22t-52 29l81 144q35 -22 76.5 -40.5t89.5 -18.5q37 0 66 10.5t55.5 36.5t55 71t66.5 113l49 89l-573 954h218l449 -784l384 784h205z"" />
    <glyph glyph-name=""afii10038"" unicode=""&#x424;"" horiz-adv-x=""1557"" 
d=""M1439 736q0 -105 -32 -199t-97.5 -165.5t-164 -113.5t-231.5 -42h-40v-227h-191v227h-40q-133 0 -231.5 42t-164 113.5t-97.5 165.5t-32 199q0 113 33.5 205.5t100 158t167 101.5t235.5 36h29v182h191v-182h28q135 0 236 -36t167.5 -101.5t100 -158t33.5 -205.5z
M1247 732q0 187 -92.5 277t-275.5 90h-5v-746h13q92 0 160 26.5t112.5 75.5t66 119t21.5 158zM310 732q0 -88 21.5 -158t66 -119t112.5 -75.5t160 -26.5h13v746h-9q-182 0 -273 -90t-91 -277z"" />
    <glyph glyph-name=""afii10039"" unicode=""&#x425;"" horiz-adv-x=""1366"" 
d=""M1112 0l-423 616l-432 -616h-211l536 732l-495 677h211l392 -553l381 553h211l-482 -670l523 -739h-211z"" />
    <glyph glyph-name=""afii10040"" unicode=""&#x426;"" horiz-adv-x=""1515"" 
d=""M1477 160v-568h-180v408h-1129v1409h191v-1249h757v1249h186v-1249h175z"" />
    <glyph glyph-name=""afii10041"" unicode=""&#x427;"" horiz-adv-x=""1365"" 
d=""M1008 508q-36 -8 -83 -18t-100.5 -19t-111 -15t-113.5 -6q-114 0 -197 23.5t-137 69.5t-80 114.5t-26 157.5v594h190v-574q0 -123 65 -177t199 -54q53 0 108 5t107 12.5t98 16t81 15.5v756h190v-1409h-190v508z"" />
    <glyph glyph-name=""afii10042"" unicode=""&#x428;"" horiz-adv-x=""1877"" 
d=""M168 0v1409h191v-1249h489v1249h186v-1249h489v1249h186v-1409h-1541z"" />
    <glyph glyph-name=""afii10043"" unicode=""&#x429;"" horiz-adv-x=""1920"" 
d=""M1839 160v-568h-180v408h-1491v1409h191v-1249h467v1249h186v-1249h466v1249h186v-1249h175z"" />
    <glyph glyph-name=""afii10044"" unicode=""&#x42a;"" horiz-adv-x=""1621"" 
d=""M696 813h322q125 0 218 -29t155 -81.5t93 -126t31 -163.5q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-525v1253h-459v156h650v-596zM1323 411q0 121 -82 185.5t-246 64.5h-299v-510h307q164 0 242 68t78 192z"" />
    <glyph glyph-name=""afii10045"" unicode=""&#x42b;"" horiz-adv-x=""1813"" 
d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h191v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 411q0 121 -82 185.5t-246 64.5h-359v-510h367q164 0 242 68t78 192zM1454 0v1409h191v-1409h-191z"" />
    <glyph glyph-name=""afii10046"" unicode=""&#x42c;"" horiz-adv-x=""1344"" 
d=""M1238 413q0 -87 -30.5 -162t-91 -131t-151.5 -88t-212 -32h-585v1409h191v-596h382q125 0 218 -29t155 -81.5t93 -126t31 -163.5zM1046 407q0 121 -82 186.5t-246 65.5h-359v-508h367q165 0 242.5 65.5t77.5 190.5z"" />
    <glyph glyph-name=""afii10047"" unicode=""&#x42d;"" horiz-adv-x=""1472"" 
d=""M713 1274q-88 0 -156.5 -21t-119.5 -56t-85.5 -80.5t-53.5 -95.5l-181 60q71 173 222 261t376 88q164 0 292 -50.5t215.5 -144t133 -226.5t45.5 -298q0 -159 -43 -293t-129 -231.5t-214.5 -152t-299.5 -54.5q-118 0 -212.5 27t-169 76.5t-131 117.5t-97.5 151l156 78
q27 -55 67.5 -107.5t95 -94t124.5 -66.5t157 -25q109 0 197 36t152 102t102.5 158.5t47.5 204.5h-654v154h654q-10 110 -46.5 199t-98.5 152t-148.5 97t-197.5 34z"" />
    <glyph glyph-name=""afii10048"" unicode=""&#x42e;"" horiz-adv-x=""2069"" 
d=""M1971 711q0 -165 -45 -300t-130 -231t-207.5 -148t-277.5 -52q-156 0 -275.5 49.5t-202 139t-127.5 213t-52 271.5h-295v-653h-191v1409h191v-596h298q13 142 62.5 256.5t132.5 194.5t199 123t262 43q159 0 281.5 -51t206 -145t127 -227t43.5 -296zM1776 711
q0 127 -30 231t-88.5 178t-145 114t-199.5 40q-116 0 -203.5 -40t-146 -114t-87.5 -178t-29 -231t30 -232.5t88.5 -182t145 -119t200.5 -42.5q121 0 209 43t145 119.5t84 182.5t27 231z"" />
    <glyph glyph-name=""afii10049"" unicode=""&#x42f;"" horiz-adv-x=""1479"" 
d=""M96 0l400 607q-91 16 -156 55t-107 93t-61.5 119t-19.5 132q0 94 33 169t96 127t155.5 79.5t212.5 27.5h663v-1409h-191v585h-439l-366 -585h-220zM344 1004q0 -57 18.5 -106t57 -85t98 -56.5t142.5 -20.5h461v520h-453q-76 0 -136 -15.5t-102 -47t-64 -78.5t-22 -111z
"" />
    <glyph glyph-name=""afii10065"" unicode=""&#x430;"" 
d=""M414 -20q-163 0 -245 86t-82 236q0 107 40.5 175.5t106 107.5t149.5 54t171 17l243 4v59q0 67 -14 114t-43 76t-72.5 42.5t-102.5 13.5q-52 0 -94 -7.5t-73 -27t-50 -53t-25 -84.5l-188 17q10 64 38 117.5t79.5 92.5t129 60.5t187.5 21.5q204 0 307 -93.5t103 -270.5
v-466q0 -80 21 -120.5t80 -40.5q15 0 30 2t29 5v-112q-34 -8 -67.5 -12t-71.5 -4q-51 0 -87.5 13.5t-59.5 41t-35 68t-15 94.5h-6q-29 -52 -63.5 -94t-80.5 -71.5t-104.5 -45.5t-134.5 -16zM455 115q86 0 150.5 31.5t107 80.5t63.5 107t21 111v89l-197 -4
q-66 -1 -125.5 -9.5t-104.5 -33.5t-71.5 -70t-26.5 -118q0 -88 47.5 -136t135.5 -48z"" />
    <glyph glyph-name=""afii10066"" unicode=""&#x431;"" horiz-adv-x=""1173"" 
d=""M898 502q0 114 -19.5 189.5t-56 121t-88.5 64t-117 18.5q-69 0 -126 -19.5t-97.5 -65.5t-62.5 -121t-22 -187q0 -114 22 -189t60.5 -119.5t91 -62.5t114.5 -18q69 0 125 18t95 62t60 119.5t21 189.5zM655 1027q222 0 327 -130.5t105 -392.5q0 -265 -125 -394.5
t-363 -129.5q-113 0 -202 35t-150.5 113t-94 203t-32.5 305q0 192 29 331t93 235.5t167 154t250 85.5q57 11 107 19.5t95.5 15.5t88.5 13l86 12v-161q-86 -11 -166.5 -22.5t-171.5 -28.5q-78 -14 -140 -30.5t-109 -41.5t-80.5 -61.5t-55.5 -90.5t-33.5 -128.5t-13.5 -175.5
q19 55 52.5 103.5t82 84.5t111.5 56.5t143 20.5z"" />
    <glyph glyph-name=""afii10067"" unicode=""&#x432;"" horiz-adv-x=""1088"" 
d=""M564 1082q76 0 148 -12t128 -43t90 -83t34 -133q0 -53 -17.5 -93.5t-47.5 -69.5t-71 -47.5t-87 -27.5v-7q54 -7 101.5 -24.5t82 -48t54.5 -75.5t20 -106q0 -78 -30.5 -136.5t-85 -97.5t-130 -58.5t-166.5 -19.5h-445v1082h422zM322 133h236q69 0 116.5 10t77 32t43 55.5
t13.5 80.5q0 50 -14 85t-45.5 57t-81.5 32t-121 10h-224v-362zM322 945v-320h216q68 0 113.5 9.5t73 29t39 50t11.5 73.5q0 82 -51 120t-172 38h-230z"" />
    <glyph glyph-name=""afii10068"" unicode=""&#x433;"" horiz-adv-x=""747"" 
d=""M687 1082v-131h-365v-951h-180v1082h545z"" />
    <glyph glyph-name=""afii10069"" unicode=""&#x434;"" horiz-adv-x=""1195"" 
d=""M834 951h-306q-24 -177 -48.5 -308.5t-48.5 -228.5t-48 -165t-46 -118h497v820zM1160 -408h-163v408h-814v-408h-163v539h119q30 50 59 121.5t58 181.5t57.5 267.5t56.5 380.5h644v-951h146v-539z"" />
    <glyph glyph-name=""afii10070"" unicode=""&#x435;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""afii10072"" unicode=""&#x436;"" horiz-adv-x=""1370"" 
d=""M595 477q-26 0 -58.5 6t-51.5 14l-278 -497h-200l353 592q-17 14 -50 56.5t-78 108.5l-216 325h188l148 -239q48 -77 80.5 -123t58.5 -71t50 -33t54 -8v474h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592
h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v477z"" />
    <glyph glyph-name=""afii10073"" unicode=""&#x437;"" horiz-adv-x=""939"" 
d=""M458 -20q-167 0 -265.5 62.5t-143.5 191.5l159 44q25 -78 88 -121t166 -43q96 0 152.5 47t56.5 138q0 59 -27.5 98t-73.5 61.5t-106 31.5t-124 9v137q64 0 121 7.5t100 26.5t67.5 52.5t24.5 85.5q0 74 -49.5 117t-142.5 43q-35 0 -70 -7t-65 -23.5t-51 -44t-28 -69.5
l-162 20q12 68 43 117t79.5 80.5t112.5 46t142 14.5q85 0 154 -21t118 -59t75.5 -90t26.5 -115q0 -57 -22 -101t-57.5 -74.5t-79.5 -48.5t-89 -22v-2q56 -6 106 -26.5t87.5 -54t59 -80t21.5 -104.5q0 -69 -24.5 -128.5t-75 -103t-126.5 -68t-178 -24.5z"" />
    <glyph glyph-name=""afii10074"" unicode=""&#x438;"" horiz-adv-x=""1144"" 
d=""M316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174z"" />
    <glyph glyph-name=""afii10075"" unicode=""&#x439;"" horiz-adv-x=""1144"" 
d=""M316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174zM574 1200q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164
q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10076"" unicode=""&#x43a;"" horiz-adv-x=""896"" 
d=""M138 1082h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v1082z"" />
    <glyph glyph-name=""afii10077"" unicode=""&#x43b;"" horiz-adv-x=""1195"" 
d=""M872 0v951h-375q-25 -184 -46 -327.5t-43 -251.5t-47.5 -182.5t-61 -121t-82.5 -67.5t-112 -21q-29 0 -53 4t-41 9v129q11 -4 30 -6.5t38 -2.5q35 0 60.5 21t45.5 68t36.5 121.5t33.5 182.5t36 250.5t44 325.5h718v-1082h-181z"" />
    <glyph glyph-name=""afii10078"" unicode=""&#x43c;"" horiz-adv-x=""1408"" 
d=""M787 0h-153l-324 951q1 -26 2.5 -56t2 -60.5t1 -59t0.5 -51.5v-724h-174v1082h280l220 -661q23 -63 41.5 -138.5t26.5 -147.5q10 72 27.5 147.5t40.5 138.5l220 661h269v-1082h-173v724q0 22 0.5 52t2 62t2.5 62t3 53z"" />
    <glyph glyph-name=""afii10079"" unicode=""&#x43d;"" horiz-adv-x=""1131"" 
d=""M322 1082v-458h487v458h180v-1082h-180v493h-487v-493h-180v1082h180z"" />
    <glyph glyph-name=""afii10080"" unicode=""&#x43e;"" 
d=""M1053 542q0 -284 -125 -423t-363 -139q-113 0 -202 34t-150.5 104t-94 175.5t-32.5 248.5q0 560 485 560q126 0 217.5 -35t150 -105t86.5 -175t28 -245zM864 542q0 126 -19.5 208t-57 131t-91.5 68.5t-122 19.5q-69 0 -124.5 -20.5t-94.5 -70t-59.5 -131.5t-20.5 -205
q0 -126 22 -208.5t60.5 -131.5t91 -69t114.5 -20q69 0 125 19.5t95 68.5t60 132t21 209z"" />
    <glyph glyph-name=""afii10081"" unicode=""&#x43f;"" horiz-adv-x=""1109"" 
d=""M967 1082v-1082h-180v951h-465v-951h-180v1082h825z"" />
    <glyph glyph-name=""afii10082"" unicode=""&#x440;"" 
d=""M1053 546q0 -123 -20 -227t-66.5 -179t-123 -117.5t-188.5 -42.5q-116 0 -203 44t-133 144h-5q1 -2 1.5 -18t1 -40t1 -53.5t0.5 -58.5v-423h-180v1286q0 39 -0.5 75t-1.5 65.5t-2 50.5t-2 30h174q1 -3 2.5 -21t3 -43.5t3 -54.5t1.5 -55h4q25 52 57 88.5t73 60t91.5 34
t113.5 10.5q112 0 188.5 -40t123 -112.5t66.5 -175t20 -227.5zM864 542q0 100 -12 178t-41.5 132t-78.5 82t-123 28q-60 0 -113 -17t-92.5 -65t-62.5 -132.5t-23 -219.5q0 -115 19 -194.5t55.5 -128.5t90.5 -70.5t124 -21.5q75 0 124.5 29t79 84t41.5 134.5t12 181.5z"" />
    <glyph glyph-name=""afii10083"" unicode=""&#x441;"" horiz-adv-x=""1024"" 
d=""M275 546q0 -93 13.5 -171t45.5 -134.5t84.5 -87.5t129.5 -31q96 0 160.5 52t79.5 160l182 -12q-9 -67 -39 -129t-81.5 -109t-125.5 -75.5t-171 -28.5q-127 0 -216 43t-144.5 118.5t-80.5 178t-25 222.5q0 109 18 192.5t50.5 146t76.5 105t95.5 68t108.5 37t115 11.5
q91 0 162 -25t122.5 -68.5t83.5 -102.5t45 -127l-185 -14q-14 90 -71 143t-162 53q-77 0 -128.5 -25.5t-83.5 -77t-45.5 -129.5t-13.5 -183z"" />
    <glyph glyph-name=""afii10084"" unicode=""&#x442;"" horiz-adv-x=""938"" 
d=""M35 1082h868v-131h-344v-951h-180v951h-344v131z"" />
    <glyph glyph-name=""afii10085"" unicode=""&#x443;"" horiz-adv-x=""1024"" 
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190z"" />
    <glyph glyph-name=""afii10086"" unicode=""&#x444;"" horiz-adv-x=""1685"" 
d=""M1598 546q0 -123 -19 -227t-62 -179t-113 -117.5t-171 -42.5q-105 0 -184 44t-121 144h-6q2 -35 3.5 -73.5t1.5 -96.5v-423h-170v423q0 54 1 95t4 81h-5q-46 -104 -120.5 -149t-185.5 -45q-186 0 -275.5 137.5t-89.5 418.5q0 284 92.5 425t272.5 141q112 0 186.5 -45
t119.5 -143h5q0 10 -1 30.5t-2 43.5t-1.5 44t-0.5 33v419h170v-420q0 -11 -0.5 -32.5t-1 -45t-1 -45t-0.5 -33.5h5q46 104 118 148.5t186 44.5q101 0 171 -40t113 -112.5t62 -175t19 -227.5zM275 542q0 -112 13 -192t41 -131.5t70.5 -75.5t102.5 -24t107 21.5t79.5 70.5
t49.5 127.5t19 191.5v24q0 115 -17 194.5t-49 128.5t-79 70.5t-108 21.5q-57 0 -100 -23t-71.5 -74t-43 -132.5t-14.5 -197.5zM1409 542q0 100 -11.5 178t-37.5 132t-70 82t-108 28q-53 0 -99 -17t-81 -65t-55 -132.5t-20 -219.5v-23q1 -108 18.5 -183t50 -121.5t78.5 -67
t106 -20.5q65 0 109 29t70.5 84t38 134.5t11.5 181.5z"" />
    <glyph glyph-name=""afii10087"" unicode=""&#x445;"" horiz-adv-x=""1024"" 
d=""M801 0l-291 444l-293 -444h-194l385 556l-367 526h199l270 -421l268 421h201l-367 -524l390 -558h-201z"" />
    <glyph glyph-name=""afii10088"" unicode=""&#x446;"" horiz-adv-x=""1173"" 
d=""M322 1082v-951h477v951h180v-951h147v-539h-163v408h-821v1082h180z"" />
    <glyph glyph-name=""afii10089"" unicode=""&#x447;"" horiz-adv-x=""1067"" 
d=""M302 1082v-402q0 -34 8 -63.5t27.5 -51.5t51.5 -34.5t79 -12.5q70 0 136 13t140 34v517h180v-1082h-180v461q-38 -15 -78.5 -30.5t-84 -27.5t-90 -20t-97.5 -8q-66 0 -116.5 20.5t-85 58.5t-52.5 93t-18 124v411h180z"" />
    <glyph glyph-name=""afii10090"" unicode=""&#x448;"" horiz-adv-x=""1643"" 
d=""M142 0v1082h180v-951h410v951h180v-951h409v951h180v-1082h-1359z"" />
    <glyph glyph-name=""afii10091"" unicode=""&#x449;"" horiz-adv-x=""1685"" 
d=""M142 0v1082h180v-951h405v951h180v-951h404v951h180v-951h147v-539h-163v408h-1333z"" />
    <glyph glyph-name=""afii10092"" unicode=""&#x44a;"" horiz-adv-x=""1280"" 
d=""M781 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-409v951h-328v131h508v-458h228zM553 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372z"" />
    <glyph glyph-name=""afii10093"" unicode=""&#x44b;"" horiz-adv-x=""1472"" 
d=""M550 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-409v1082h180v-458h228zM322 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372zM1150 0v1082h180v-1082h-180z"" />
    <glyph glyph-name=""afii10094"" unicode=""&#x44c;"" horiz-adv-x=""1067"" 
d=""M568 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-427v1082h180v-458h246zM322 127h220q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-221v-372z"" />
    <glyph glyph-name=""afii10095"" unicode=""&#x44d;"" horiz-adv-x=""1045"" 
d=""M55 315l182 12q16 -108 82.5 -160t166.5 -52q73 0 124.5 26.5t85.5 75t51 116t22 149.5h-413v131h413q-4 90 -21 156.5t-50.5 110.5t-85 66t-124.5 22q-109 0 -168 -52.5t-74 -143.5l-185 14q13 68 46 126t85.5 100t125 66t165.5 24q90 0 175 -26.5t152 -90.5t107.5 -172
t40.5 -271q0 -120 -25.5 -222.5t-82.5 -178t-148 -118.5t-221 -43q-99 0 -174.5 27t-128.5 73t-83.5 107t-39.5 128z"" />
    <glyph glyph-name=""afii10096"" unicode=""&#x44e;"" horiz-adv-x=""1536"" 
d=""M1450 542q0 -284 -117.5 -423t-340.5 -139q-102 0 -182.5 31t-138 95t-90 160t-37.5 227h-222v-493h-180v1082h180v-458h223q33 478 453 478q237 0 344.5 -140t107.5 -420zM1261 542q0 126 -17.5 208t-51 131t-82 68.5t-109.5 19.5q-63 0 -112.5 -20.5t-84.5 -70
t-53.5 -131.5t-18.5 -205q0 -126 19.5 -208.5t54.5 -131.5t82 -69t103 -20q62 0 112 19.5t85 68.5t54 132t19 209z"" />
    <glyph glyph-name=""afii10097"" unicode=""&#x44f;"" horiz-adv-x=""1109"" 
d=""M535 458l-315 -458h-203l344 471q-131 27 -190 108.5t-59 203.5q0 149 108 224t315 75h432v-1082h-180v458h-252zM787 955h-234q-130 0 -190 -46t-60 -139q0 -94 53.5 -140.5t177.5 -46.5h253v372z"" />
    <glyph glyph-name=""uni0450"" unicode=""&#x450;"" 
d=""M592 1218l-330 278v29h207l217 -287v-20h-94zM276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5
t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584z"" />
    <glyph glyph-name=""afii10071"" unicode=""&#x451;"" 
d=""M276 503q0 -85 17.5 -156.5t54 -123t93.5 -80t137 -28.5q117 0 187.5 47t95.5 119l158 -45q-17 -45 -47.5 -90.5t-81.5 -82t-127.5 -60t-184.5 -23.5q-240 0 -365.5 143t-125.5 425q0 152 38 257.5t104 171.5t154 95.5t188 29.5q136 0 227.5 -44t147 -121.5t79 -182.5
t23.5 -227v-24h-772zM862 641q-15 171 -87 249.5t-207 78.5q-45 0 -94.5 -14.5t-91.5 -51.5t-71 -100.5t-33 -161.5h584zM687 1219v184h163v-184h-163zM293 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10099"" unicode=""&#x452;"" 
d=""M142 0v1206h-132v131h132v147h180v-147h300v-131h-300v-148q0 -33 -1 -66t-2.5 -61t-2.5 -47.5t-2 -26.5h3q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-815q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5
q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38 31.5t18.5 55t5 79.5v753q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180z"" />
    <glyph glyph-name=""afii10100"" unicode=""&#x453;"" horiz-adv-x=""747"" 
d=""M687 1082v-131h-365v-951h-180v1082h545zM288 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""afii10101"" unicode=""&#x454;"" horiz-adv-x=""1045"" 
d=""M564 -20q-130 0 -221 43t-148 118.5t-82.5 178t-25.5 222.5q0 163 40.5 271t107.5 172t152 90.5t175 26.5q93 0 165.5 -24t125 -66t85.5 -100t46 -126l-185 -14q-15 91 -74 143.5t-168 52.5q-73 0 -124.5 -22t-85 -66t-50.5 -110.5t-21 -156.5h412v-131h-413
q4 -82 21.5 -149.5t51.5 -116t85.5 -75t125.5 -26.5q100 0 166.5 51.5t82.5 160.5l182 -12q-9 -67 -39.5 -128t-83.5 -107t-128.5 -73t-174.5 -27z"" />
    <glyph glyph-name=""afii10102"" unicode=""&#x455;"" horiz-adv-x=""1024"" 
d=""M950 299q0 -76 -29.5 -135.5t-85.5 -100t-137.5 -62t-186.5 -21.5q-94 0 -169.5 14.5t-132.5 46.5t-95.5 84.5t-56.5 128.5l159 31q23 -87 95 -127.5t200 -40.5q58 0 106.5 8t83.5 27.5t54.5 52t19.5 80.5q0 49 -23 80.5t-64 52.5t-99.5 36.5t-128.5 34.5q-65 17 -129 38
t-115.5 55.5t-83.5 85.5t-32 128q0 148 105.5 225.5t307.5 77.5q179 0 284.5 -63t133.5 -202l-162 -20q-9 42 -33 70.5t-58 46t-76.5 25t-88.5 7.5q-122 0 -180 -37t-58 -112q0 -44 21.5 -72.5t60 -48t92.5 -34t119 -30.5q43 -11 88 -23.5t87.5 -30t80 -41t65.5 -56.5
t44.5 -77t16.5 -102z"" />
    <glyph glyph-name=""afii10103"" unicode=""&#x456;"" horiz-adv-x=""455"" 
d=""M137 0v1082h180v-1082h-180zM137 1312v172h180v-172h-180z"" />
    <glyph glyph-name=""afii10104"" unicode=""&#x457;"" horiz-adv-x=""569"" 
d=""M194 0v1082h180v-1082h-180zM386 1219v184h163v-184h-163zM-8 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""afii10105"" unicode=""&#x458;"" horiz-adv-x=""455"" 
d=""M137 1312v172h180v-172h-180zM317 -134q0 -62 -10.5 -115t-37.5 -92t-73.5 -61.5t-118.5 -22.5q-34 0 -66.5 2t-60.5 7v139q13 -2 31 -4t31 -2q38 0 62.5 10t38.5 31.5t19 55t5 79.5v1189h180v-1216z"" />
    <glyph glyph-name=""afii10106"" unicode=""&#x459;"" horiz-adv-x=""1856"" 
d=""M1357 624q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-450v951h-411q-25 -184 -46 -327.5t-43 -251.5t-47.5 -182.5t-61 -121t-82.5 -67.5t-112 -21q-29 0 -53 4t-41 9v129q11 -4 30 -6.5t38 -2.5q35 0 60.5 21t45.5 68t36.5 121.5
t33.5 182.5t36 250.5t44 325.5h754v-458h268zM1089 127h242q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-243v-372z"" />
    <glyph glyph-name=""afii10107"" unicode=""&#x45a;"" horiz-adv-x=""1664"" 
d=""M937 1082v-458h228q205 0 310 -73.5t105 -232.5q0 -74 -26 -133t-78 -100t-129.5 -63t-180.5 -22h-410v493h-434v-493h-180v1082h180v-458h434v458h181zM937 127h202q69 0 117 12.5t77.5 37t42.5 60t13 81.5q0 94 -58 137.5t-191 43.5h-203v-372z"" />
    <glyph glyph-name=""afii10108"" unicode=""&#x45b;"" 
d=""M317 857q30 55 65 93.5t77 63.5t92 36.5t112 11.5q104 0 170.5 -28t105 -78.5t53 -120.5t14.5 -154v-681h-181v646q0 69 -8.5 121t-32.5 86.5t-68 52t-114 17.5q-64 0 -115.5 -23t-88 -65t-56.5 -102t-20 -135v-598h-180v1206h-132v131h132v147h180v-147h300v-131h-300
v-148q0 -33 -1 -66t-2.5 -61t-2.5 -47.5t-2 -26.5h3z"" />
    <glyph glyph-name=""afii10109"" unicode=""&#x45c;"" horiz-adv-x=""896"" 
d=""M138 1082h180v-474q30 0 54 8t50 33t58.5 71t80.5 123l148 239h188l-216 -325q-45 -66 -78 -108.5t-50 -56.5l353 -592h-200l-278 497q-19 -8 -51.5 -14t-58.5 -6v-477h-180v1082zM391 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""uni045D"" unicode=""&#x45d;"" horiz-adv-x=""1144"" 
d=""M588 1201l-330 278v29h207l217 -287v-20h-94zM316 1082v-592q0 -23 -1.5 -61.5t-3 -79.5t-3 -78t-2.5 -58l499 869h197v-1082h-172v660q0 19 1 47.5t2.5 58.5t3 58.5t3.5 48.5l-506 -873h-192v1082h174z"" />
    <glyph glyph-name=""afii10110"" unicode=""&#x45e;"" horiz-adv-x=""1024"" 
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM523 1200
q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""afii10193"" unicode=""&#x45f;"" horiz-adv-x=""1131"" 
d=""M142 0v1082h180v-951h487v951h180v-1082h-342v-408h-163v408h-342z"" />
    <glyph glyph-name=""afii10050"" unicode=""&#x490;"" horiz-adv-x=""1001"" 
d=""M774 1409v411h180v-567h-595v-1252h-191v1408h606z"" />
    <glyph glyph-name=""afii10098"" unicode=""&#x491;"" horiz-adv-x=""842"" 
d=""M322 0h-180v1082h473v402h163v-533h-456v-951z"" />
    <glyph glyph-name=""Wgrave"" unicode=""&#x1e80;"" horiz-adv-x=""1933"" 
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM993 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""wgrave"" unicode=""&#x1e81;"" horiz-adv-x=""1479"" 
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM764 1201l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""Wacute"" unicode=""&#x1e82;"" horiz-adv-x=""1933"" 
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM831 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""wacute"" unicode=""&#x1e83;"" horiz-adv-x=""1479"" 
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM622 1201v20l217 287h207v-29l-330 -278h-94z"" />
    <glyph glyph-name=""Wdieresis"" unicode=""&#x1e84;"" horiz-adv-x=""1933"" 
d=""M1511 0h-228l-244 895q-11 38 -23.5 90t-22.5 99q-12 55 -24 112q-13 -58 -25 -113q-11 -48 -23 -99t-23 -89l-246 -895h-228l-415 1409h199l253 -895q17 -63 32.5 -125t26.5 -111q13 -58 24 -110q15 69 31 136q7 28 14 59t14.5 61t15 57.5t13.5 50.5l245 877h183
l245 -877q6 -23 13.5 -50.5t15 -57t14.5 -60.5t14 -59q16 -67 31 -137q1 0 9 34.5t20 86.5t26.5 112.5t29.5 112.5l249 895h199zM1085 1530v184h163v-184h-163zM691 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""wdieresis"" unicode=""&#x1e85;"" horiz-adv-x=""1479"" 
d=""M1174 0h-209l-173 698q-8 27 -16.5 67t-16.5 78q-10 44 -19 91q-9 -45 -19 -89q-8 -38 -17.5 -79t-17.5 -72l-178 -694h-208l-303 1082h178l183 -735q7 -23 14 -56.5t14 -65.5q7 -37 15 -76q8 38 17 74q8 31 16 63t14 53l196 743h193l189 -743q7 -26 15 -59t15 -62
q8 -34 16 -69q8 38 16 74q7 31 14.5 64.5t14.5 59.5l191 735h176zM856 1219v184h163v-184h-163zM462 1219v184h165v-184h-165z"" />
    <glyph glyph-name=""Ygrave"" unicode=""&#x1ef2;"" horiz-adv-x=""1366"" 
d=""M777 584v-584h-190v584l-542 825h210l429 -671l427 671h210zM706 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""ygrave"" unicode=""&#x1ef3;"" horiz-adv-x=""1024"" 
d=""M604 0q-38 -98 -77.5 -176.5t-88.5 -134t-109 -85t-138 -29.5q-34 0 -63 2t-61 9v135q19 -3 43 -4.5t41 -1.5q79 0 147 59t119 188l17 43l-429 1077h192l228 -598q10 -27 25.5 -72l31 -90t27.5 -81t14 -45q3 11 14.5 43.5t26 72.5t29.5 81t25 71l212 618h190zM541 1201
l-330 278v29h207l217 -287v-20h-94z"" />
    <glyph glyph-name=""uni2010"" unicode=""&#x2010;"" horiz-adv-x=""682"" 
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""uni2011"" unicode=""&#x2011;"" horiz-adv-x=""682"" 
d=""M91 464v160h500v-160h-500z"" />
    <glyph glyph-name=""endash"" unicode=""&#x2013;"" 
d=""M0 451v137h1138v-137h-1138z"" />
    <glyph glyph-name=""emdash"" unicode=""&#x2014;"" horiz-adv-x=""2048"" 
d=""M0 451v137h2048v-137h-2048z"" />
    <glyph glyph-name=""afii00208"" unicode=""&#x2015;"" horiz-adv-x=""2048"" 
d=""M0 451v137h2048v-137h-2048z"" />
    <glyph glyph-name=""underscoredbl"" unicode=""&#x2017;"" horiz-adv-x=""1131"" 
d=""M-31 -434v130h1193v-130h-1193zM-31 -217v130h1193v-130h-1193z"" />
    <glyph glyph-name=""quoteleft"" unicode=""&#x2018;"" horiz-adv-x=""455"" 
d=""M127 952v146q0 52 5 95t15 80.5t25 70.5t35 65h121q-45 -65 -70 -131t-25 -131h89v-195h-195z"" />
    <glyph glyph-name=""quoteright"" unicode=""&#x2019;"" horiz-adv-x=""455"" 
d=""M328 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 129h-88v197h195v-145z"" />
    <glyph glyph-name=""quotesinglbase"" unicode=""&#x201a;"" horiz-adv-x=""455"" 
d=""M328 51q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-144z"" />
    <glyph glyph-name=""quotereversed"" unicode=""&#x201b;"" horiz-adv-x=""455"" 
d=""M321 1409v-197h-88q0 -63 24.5 -129t69.5 -131h-123q-20 32 -34.5 65t-24.5 70.5t-14.5 80.5t-4.5 96v145h195z"" />
    <glyph glyph-name=""quotedblleft"" unicode=""&#x201c;"" horiz-adv-x=""682"" 
d=""M407 952v146q0 52 5 95t14.5 80.5t24 70.5t34.5 65h122q-45 -65 -69.5 -131t-24.5 -131h88v-195h-194zM75 952v146q0 52 5 95t15 80.5t25 70.5t35 65h121q-45 -65 -70 -131t-25 -131h89v-195h-195z"" />
    <glyph glyph-name=""quotedblright"" unicode=""&#x201d;"" horiz-adv-x=""682"" 
d=""M607 1264q0 -53 -5 -96t-14.5 -80.5t-24.5 -70.5t-35 -65h-121q45 65 69.5 131t24.5 131h-88v195h194v-145zM276 1264q0 -53 -4.5 -96t-14.5 -80.5t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-145z"" />
    <glyph glyph-name=""quotedblbase"" unicode=""&#x201e;"" horiz-adv-x=""682"" 
d=""M607 51q0 -53 -5 -96.5t-14.5 -81t-24.5 -70.5t-35 -65h-121q45 65 69.5 131t24.5 131h-88v195h194v-144zM276 51q0 -53 -4.5 -96.5t-14.5 -81t-24.5 -70.5t-34.5 -65h-123q45 65 69.5 131t24.5 131h-88v195h195v-144z"" />
    <glyph glyph-name=""dagger"" unicode=""&#x2020;"" 
d=""M649 1000l-22 -1138h-115l-22 1138l-352 -27v164l352 -29l-28 376h215l-28 -376l353 29v-164z"" />
    <glyph glyph-name=""daggerdbl"" unicode=""&#x2021;"" 
d=""M497 1000l-360 -27v164l360 -29l-16 376h175l-16 -376l361 29v-164l-361 27l-26 -330l26 -327l360 27v-164l-360 29l16 -376h-175l16 376l-361 -29v164l361 -27l26 327z"" />
    <glyph glyph-name=""bullet"" unicode=""&#x2022;"" horiz-adv-x=""717"" 
d=""M636 682q0 -58 -22.5 -109t-60.5 -89.5t-89 -60.5t-109 -22q-57 0 -106.5 22t-87 60.5t-59 89.5t-21.5 109q0 57 21.5 107t59 87t87 58.5t106.5 21.5q58 0 109 -21.5t89 -58.5t60.5 -87t22.5 -107z"" />
    <glyph glyph-name=""ellipsis"" unicode=""&#x2026;"" horiz-adv-x=""2048"" 
d=""M1576 0v219h194v-219h-194zM929 0v219h192v-219h-192zM278 0v219h195v-219h-195z"" />
    <glyph glyph-name=""perthousand"" unicode=""&#x2030;"" horiz-adv-x=""2048"" 
d=""M304 0h-155l922 1409h157zM356 1421q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM502 1060q0 73 -9.5 122t-28 78t-46 41
t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5zM1044 716q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5
t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM1190 355q0 73 -9.5 122t-28 78t-46 41t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5zM1699 716
q60 0 113.5 -16.5t93.5 -58t63 -111t23 -175.5q0 -102 -23 -172t-63.5 -113t-94.5 -62t-116 -19q-63 0 -117 18.5t-94 61.5t-63 113t-23 173q0 106 23 175.5t63.5 111t95.5 58t119 16.5zM1845 355q0 73 -9.5 122t-28 78t-46 41t-62.5 12q-38 0 -67 -12t-48.5 -41.5t-29 -78
t-9.5 -121.5q0 -71 10 -119.5t29.5 -78t47.5 -42.5t65 -13q34 0 61 13t46.5 42.5t30 78t10.5 119.5z"" />
    <glyph glyph-name=""minute"" unicode=""&#x2032;"" horiz-adv-x=""384"" 
d=""M85 890l64 519h196l-158 -519h-102z"" />
    <glyph glyph-name=""second"" unicode=""&#x2033;"" horiz-adv-x=""725"" 
d=""M85 890l64 519h196l-158 -519h-102zM427 890l64 519h196l-158 -519h-102z"" />
    <glyph glyph-name=""guilsinglleft"" unicode=""&#x2039;"" horiz-adv-x=""682"" 
d=""M424 141l-336 365v63l336 371h167v-31l-335 -372l337 -367v-29h-169z"" />
    <glyph glyph-name=""guilsinglright"" unicode=""&#x203a;"" horiz-adv-x=""682"" 
d=""M257 141h-168v29l338 367l-336 372v31h166l337 -371v-63z"" />
    <glyph glyph-name=""exclamdbl"" unicode=""&#x203c;"" horiz-adv-x=""1024"" 
d=""M359 397h-148l-24 1012h196zM185 0v201h194v-201h-194zM815 397h-148l-24 1012h196zM641 0v201h194v-201h-194z"" />
    <glyph glyph-name=""uni203E"" unicode=""&#x203e;"" horiz-adv-x=""682"" 
d=""M747 1503h-811v117h811v-117z"" />
    <glyph glyph-name=""uni2215"" unicode=""&#x2044;"" horiz-adv-x=""342"" 
d=""M-268 0h-148l881 1409h145z"" />
    <glyph glyph-name=""uni2215"" unicode=""&#x2215;"" horiz-adv-x=""342"" 
d=""M-268 0h-148l881 1409h145z"" />
    <glyph glyph-name=""uni207F"" unicode=""&#x207f;"" horiz-adv-x=""747"" 
d=""M514 519v398q0 46 -6.5 76.5t-21 49t-38 26.5t-58.5 8q-72 0 -114.5 -50t-42.5 -144v-364h-128v511q0 20 -0.5 43t-1 43t-1.5 34.5t-1 18.5h119q0 -3 1 -16.5t2 -30.5t2 -34.5t1 -29.5h2q15 28 34 51t43.5 39t56.5 24.5t74 8.5q110 0 158.5 -54t48.5 -175v-433h-129z"" />
    <glyph glyph-name=""franc"" unicode=""&#x20a3;"" 
d=""M359 1254v-476h687v-157h-687v-213h402v-129h-402v-279h-180v279h-175v129h175v1001h891v-155h-711z"" />
    <glyph glyph-name=""lira"" unicode=""&#x20a4;"" 
d=""M1104 311q-9 -80 -37.5 -138.5t-73 -97t-102 -57t-124.5 -18.5h-698v154q89 46 132 126t43 201v25h-186v129h186v140h-186v129h186v130q0 92 24 165.5t73.5 124.5t125.5 78.5t179 27.5q70 0 131.5 -14.5t111 -43.5t85 -72t53.5 -100l-174 -57q-10 31 -29.5 57t-46 44
t-59 28t-68.5 10q-114 0 -170 -57.5t-56 -182.5v-138h408v-129h-408v-140h408v-129h-408v-7q0 -56 -11 -109t-33 -99t-53.5 -81.5t-71.5 -56.5h483q38 0 71.5 9.5t60 30.5t45 54.5t26.5 81.5z"" />
    <glyph glyph-name=""peseta"" unicode=""&#x20a7;"" horiz-adv-x=""2240"" 
d=""M954 985q0 -92 -30.5 -171.5t-91 -138t-151.5 -92.5t-212 -34h-130v-549h-181v1409h299q125 0 218 -30.5t155 -86t93 -134t31 -173.5zM772 983q0 134 -82 203.5t-246 69.5h-105v-556h113q165 0 242.5 73t77.5 210zM1407 8q-35 -11 -72 -17.5t-85 -6.5q-105 0 -151.5 61.5
t-46.5 183.5v453h-104v131h111l53 242h110v-242h157v-131h-157v-414q0 -78 20.5 -114.5t75.5 -36.5q23 0 43 4t46 10v-123zM2151 229q0 -120 -91.5 -184.5t-261.5 -64.5q-75 0 -135.5 12t-106.5 39t-76.5 71t-45.5 108l159 26q17 -61 66.5 -90t137.5 -29q40 0 74 5
t58.5 17.5t38 32.5t13.5 50t-17 50.5t-48 35t-74.5 26t-95.5 24.5q-49 12 -97 28t-86.5 42.5t-62 66t-23.5 98.5q0 112 84 171.5t245 59.5q141 0 223.5 -52.5t104.5 -168.5l-161 -17q-6 28 -21.5 47t-38 31t-49.5 17t-57 5q-155 0 -155 -85q0 -25 16 -43t44.5 -32t68.5 -25
t88 -22t98 -26.5t91 -42.5t67 -70.5t26 -110.5z"" />
    <glyph glyph-name=""Euro"" unicode=""&#x20ac;"" 
d=""M691 126q100 0 160 50t74 141l185 -14q-13 -68 -44.5 -127t-83 -102.5t-125 -68.5t-170.5 -25q-120 0 -208.5 38.5t-149 108t-95 165.5t-47.5 210h-171l40 129h120q-1 8 -2 31t-1 47q0 27 1 53.5t2 32.5h-160l40 127h129q15 122 51.5 216.5t98 159.5t148 98.5t201.5 33.5
q97 0 170.5 -25t125 -68.5t83 -102.5t44.5 -127l-185 -14q-14 91 -74.5 141t-166.5 50q-68 0 -121 -19.5t-92.5 -63t-64.5 -112t-36 -167.5h446l-40 -127h-413q-2 -16 -2.5 -39.5t-0.5 -46.5q0 -22 1 -40.5t3 -37.5h452l-40 -129h-404q9 -81 30 -150t59.5 -119t95.5 -78.5
t137 -28.5z"" />
    <glyph glyph-name=""afii61248"" unicode=""&#x2105;"" horiz-adv-x=""1813"" 
d=""M1744 434q0 -125 -25.5 -210.5t-69 -138t-101.5 -75t-124 -22.5t-123.5 22.5t-100 74.5t-67 137.5t-24.5 211.5q0 133 24 220t67 138.5t101.5 72t126.5 20.5q66 0 123.5 -20.5t100 -72t67.5 -138.5t25 -220zM523 0h-155l922 1409h157zM1596 434q0 99 -11 164.5
t-32.5 104.5t-53 55t-71.5 16q-42 0 -74 -16.5t-54 -55.5t-33 -104.5t-11 -163.5q0 -95 11.5 -159t33 -103.5t53 -56.5t72.5 -17q39 0 70.5 17t53.5 56.5t34 103.5t12 159zM215 975q0 -75 10 -137t33.5 -107t61 -70t91.5 -25q69 0 116 41t58 128l141 -9q-6 -54 -28.5 -103.5
t-61 -87.5t-94 -60.5t-127.5 -22.5q-94 0 -160 34.5t-107 95t-60 142.5t-19 178q0 130 29.5 216.5t78 138t110.5 72.5t127 21q68 0 121 -20t91 -55t62 -82t33 -102l-143 -11q-10 72 -51.5 114.5t-116.5 42.5q-108 0 -151.5 -82t-43.5 -250z"" />
    <glyph glyph-name=""afii61289"" unicode=""&#x2113;"" horiz-adv-x=""662"" 
d=""M433 78q51 0 85 52t51 161h69q-20 -154 -80 -232.5t-169 -78.5q-111 0 -174.5 79.5t-63.5 234.5v175q-32 -17 -65 -31t-67 -27v73q35 14 68 28.5t64 30.5v587q0 59 12.5 113t42 95.5t78.5 66t121 24.5q52 0 91.5 -21t66 -60t40 -94.5t13.5 -124.5q0 -99 -22 -189
t-61.5 -166t-94.5 -135t-121 -97v-244q0 -57 9.5 -98.5t25.5 -68.5t37 -40t44 -13zM525 1122q0 52 -7 94.5t-20.5 73t-33.5 47t-46 16.5q-32 0 -51.5 -18t-30.5 -48.5t-15 -71t-4 -86.5v-507q49 33 87.5 85t65.5 117.5t41 141t14 156.5z"" />
    <glyph glyph-name=""afii61352"" unicode=""&#x2116;"" horiz-adv-x=""2197"" 
d=""M1062 0l-720 1190q1 -44 3 -88q1 -38 2 -82.5t1 -83.5v-936h-160v1409h202l728 -1198q-2 40 -4 86q-2 39 -3 88t-1 100v924h162v-1409h-210zM2094 690q0 -188 -88 -289.5t-263 -101.5q-168 0 -256.5 100.5t-88.5 290.5q0 91 21.5 163.5t65 123t109 77t153.5 26.5
q93 0 158.5 -26.5t107.5 -76.5t61.5 -122.5t19.5 -164.5zM1935 690q0 81 -12 134.5t-35.5 85.5t-58 45t-79.5 13q-46 0 -81.5 -13.5t-59.5 -45.5t-36.5 -85.5t-12.5 -133.5q0 -82 13 -136t37 -85.5t57.5 -44.5t74.5 -13q46 0 82 13t61 44.5t37.5 85.5t12.5 136zM1439 0v146
h635v-146h-635z"" />
    <glyph glyph-name=""trademark"" unicode=""&#x2122;"" horiz-adv-x=""2048"" 
d=""M1691 634v425v194q-5 -11 -9 -22q-4 -9 -6.5 -18t-4.5 -14l-230 -565h-108l-163 413q-2 5 -14 37t-26 70q-17 44 -37 99q-1 -10 -1 -20q-1 -8 -1 -17v-15v-567h-128v775h190l223 -563q2 -4 4.5 -10.5t4.5 -13.5l6 -18q20 51 36 92q7 18 13.5 35t12 31t9 23t3.5 11
l168 413h184v-775h-126zM577 1298v-664h-134v664h-255v111h650v-111h-261z"" />
    <glyph glyph-name=""uni2126"" unicode=""&#x2126;"" horiz-adv-x=""1573"" 
d=""M786 1430q151 0 271.5 -43t204.5 -124t129 -198t45 -264q0 -106 -29.5 -201.5t-84 -179t-133 -152.5t-177.5 -123q42 2 81 5q33 2 68.5 4t58.5 2h244v-156h-589v224q96 51 165.5 114t114 134.5t65.5 151t21 164.5q0 116 -30.5 206.5t-88.5 152.5t-142.5 94.5t-192.5 32.5
q-109 0 -194 -32.5t-143 -94.5t-88.5 -152.5t-30.5 -206.5q0 -85 21 -164.5t65.5 -151t114 -134.5t165.5 -114v-224h-589v156h244q23 0 58.5 -2t68.5 -4q39 -3 81 -5q-99 54 -177.5 123t-133 152.5t-84 179t-29.5 201.5q0 147 45 264t129 198t204.5 124t271.5 43z"" />
    <glyph glyph-name=""estimated"" unicode=""&#x212e;"" horiz-adv-x=""1229"" 
d=""M619 -34q-130 0 -229 46.5t-166 125t-101.5 180.5t-34.5 213q0 147 47.5 253.5t123.5 176t170.5 102.5t189.5 33q112 0 209 -39.5t168 -112.5t111.5 -178t40.5 -235h-827v-356q22 -24 54 -46.5t71 -40t83 -27.5t90 -10q75 0 133 15.5t104.5 45.5t84.5 73.5t73 99.5
l72 -42q-36 -57 -78 -107t-96.5 -88t-126 -60t-166.5 -22zM917 616v277q-19 20 -48.5 41t-68 38t-84.5 28t-99 11q-51 0 -94.5 -9.5t-80.5 -25.5t-67 -37t-54 -45v-278h596z"" />
    <glyph glyph-name=""oneeighth"" unicode=""&#x215b;"" horiz-adv-x=""1708"" 
d=""M80 563v107h211v620l-202 -138v120l210 137h123v-739h215v-107h-557zM493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32
t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5
t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3
q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82z"" />
    <glyph glyph-name=""threeeighths"" unicode=""&#x215c;"" horiz-adv-x=""1708"" 
d=""M493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12
q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62
t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM676 795
q0 -116 -77.5 -180t-219.5 -64q-87 0 -145 19.5t-94.5 51.5t-54.5 72.5t-24 83.5l136 13q9 -67 53 -101.5t129 -34.5q77 0 118.5 36t41.5 112q0 45 -18.5 72t-46.5 41.5t-61.5 19t-62.5 4.5h-61v109h57q29 0 59.5 6.5t55.5 22t41 42t16 66.5q0 60 -37 94.5t-108 34.5
q-68 0 -110 -35t-48 -100l-135 12q7 58 32 101t64.5 71.5t90.5 42.5t110 14q69 0 121 -16.5t87 -46t52.5 -69t17.5 -85.5q0 -75 -43 -130t-133 -75v-2q52 -5 89.5 -23.5t61.5 -45.5t35 -61.5t11 -71.5z"" />
    <glyph glyph-name=""fiveeighths"" unicode=""&#x215d;"" horiz-adv-x=""1708"" 
d=""M493 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12
q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62
t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM676 835
q0 -65 -19 -117t-55.5 -89t-90.5 -57t-124 -20q-66 0 -116.5 16.5t-87.5 46t-59 70t-31 88.5l133 15q5 -27 17 -50.5t31.5 -41.5t46.5 -28.5t63 -10.5q71 0 114 42.5t43 135.5q0 81 -40.5 123.5t-115.5 42.5q-51 0 -89.5 -18.5t-61.5 -41.5h-129l33 468h506v-113h-398
l-19 -245q29 26 74.5 42.5t99.5 16.5q67 0 118.5 -19.5t86 -55t52.5 -86.5t18 -114z"" />
    <glyph glyph-name=""seveneighths"" unicode=""&#x215e;"" horiz-adv-x=""1708"" 
d=""M433 0h-148l881 1409h145zM1451 631q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM1472 252q0 28 -6.5 54t-24 46t-48 32t-79.5 12
q-45 0 -74.5 -12t-47.5 -32.5t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM1614 238q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62
t54 42t62.5 21v3q-36 8 -63.5 26.5t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82zM734 1308
q-64 -97 -117 -185t-91.5 -176t-60 -181.5t-21.5 -201.5h-133q0 102 23.5 196t63.5 183.5t93.5 177t113.5 175.5h-460v113h589v-101z"" />
    <glyph glyph-name=""arrowleft"" unicode=""&#x2190;"" horiz-adv-x=""2048"" 
d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h989v-86h-989z"" />
    <glyph glyph-name=""arrowup"" unicode=""&#x2191;"" horiz-adv-x=""1024"" 
d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-989h-86v989z"" />
    <glyph glyph-name=""arrowright"" unicode=""&#x2192;"" horiz-adv-x=""2048"" 
d=""M1407 637q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-989v86h989z"" />
    <glyph glyph-name=""arrowdown"" unicode=""&#x2193;"" horiz-adv-x=""1024"" 
d=""M555 162q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v989h86v-989z"" />
    <glyph glyph-name=""arrowboth"" unicode=""&#x2194;"" horiz-adv-x=""2048"" 
d=""M641 551q29 -34 58.5 -83t60.5 -114h-72q-58 68 -123 124t-147 98v36q82 42 147 98t123 124h72q-31 -65 -60.5 -114t-58.5 -83h766q-29 34 -58.5 83t-60.5 114h72q58 -68 123 -124t147 -98v-36q-82 -42 -147 -98t-123 -124h-72q31 65 60.5 114t58.5 83h-766z"" />
    <glyph glyph-name=""arrowupdn"" unicode=""&#x2195;"" horiz-adv-x=""1024"" 
d=""M469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5t83 -58.5v766z"" />
    <glyph glyph-name=""arrowupdnbse"" unicode=""&#x21a8;"" horiz-adv-x=""1024"" 
d=""M272 -104h480v-80h-480v80zM469 928q-34 -29 -83 -58.5t-114 -60.5v72q68 58 124 123t98 147h36q42 -82 98 -147t124 -123v-72q-65 31 -114 60.5t-83 58.5v-766q34 29 83 58.5t114 60.5v-72q-68 -58 -124 -123t-98 -147h-36q-42 82 -98 147t-124 123v72q65 -31 114 -60.5
t83 -58.5v766z"" />
    <glyph glyph-name=""partialdiff"" unicode=""&#x2202;"" horiz-adv-x=""1012"" 
d=""M954 938q0 -46 -3.5 -98t-10 -105t-15.5 -106t-20 -101q-31 -128 -79 -231t-113 -175t-146 -110.5t-178 -38.5q-93 0 -156.5 31.5t-102.5 85t-56.5 122.5t-17.5 144q0 60 11 131.5t34.5 143.5t60 139t87.5 119t117 83.5t149 31.5q42 0 80.5 -13t70.5 -37t57 -57.5
t41 -75.5h4q1 25 2.5 54t1.5 63q0 196 -65 300.5t-194 104.5q-28 0 -57.5 -5.5t-58.5 -15t-56.5 -23.5t-49.5 -31l36 147q42 23 100 42.5t125 19.5q113 0 190 -44t124 -118.5t67.5 -172t20.5 -204.5zM743 680q-8 42 -26 79t-43.5 64.5t-57.5 43.5t-68 16q-53 0 -96 -25.5
t-76.5 -67.5t-58 -97t-40.5 -113t-23.5 -116t-7.5 -106q0 -53 10.5 -98.5t31.5 -79t53.5 -52.5t76.5 -19q66 0 120 49.5t95.5 130t69.5 183t40 208.5z"" />
    <glyph glyph-name=""uni2206"" unicode=""&#x2206;"" horiz-adv-x=""1253"" 
d=""M5 141l517 1268h217l510 -1268v-141h-1245zM1049 156l-338 862q-16 40 -30.5 81t-25.5 75.5t-18.5 58.5t-8.5 32q-2 -8 -9 -32.5t-18.5 -59.5t-25.5 -76t-30 -81l-339 -860h843z"" />
    <glyph glyph-name=""product"" unicode=""&#x220f;"" horiz-adv-x=""1686"" 
d=""M1268 -434v1681h-842v-1681h-191v1843h1217v-1843h-184z"" />
    <glyph glyph-name=""summation"" unicode=""&#x2211;"" horiz-adv-x=""1460"" 
d=""M154 -434v109l635 816l-619 812v106h1090v-152h-846l584 -764l-600 -775h930v-152h-1174z"" />
    <glyph glyph-name=""minus"" unicode=""&#x2212;"" horiz-adv-x=""1196"" 
d=""M101 608v146h995v-146h-995z"" />
    <glyph glyph-name=""radical"" unicode=""&#x221a;"" horiz-adv-x=""1124"" 
d=""M622 -14h-106l-283 792h-182v117h270l242 -690l430 1415h129z"" />
    <glyph glyph-name=""infinity"" unicode=""&#x221e;"" horiz-adv-x=""1460"" 
d=""M1373 590q0 -78 -22 -148.5t-63 -123.5t-98.5 -84t-127.5 -31q-97 0 -181 66.5t-154 215.5q-32 -63 -69.5 -114t-79.5 -87t-87 -55.5t-91 -19.5q-69 0 -126.5 27.5t-99 77.5t-64.5 121.5t-23 160.5q0 81 22 152t63 123t99 82t129 30q94 0 178 -67.5t151 -215.5
q31 62 68.5 113t79.5 87.5t89 56.5t98 20q69 0 126 -27.5t97.5 -78t63 -122t22.5 -159.5zM1040 846q-70 0 -129.5 -63t-115.5 -193q51 -128 110.5 -192t136.5 -64q43 0 78.5 20t61 55t39 82t13.5 101t-14.5 100t-40 80.5t-61 54t-78.5 19.5zM664 596q-51 128 -110.5 192
t-137.5 64q-43 0 -78 -20t-59.5 -55t-38 -82t-13.5 -101q0 -51 12.5 -97.5t36.5 -81t59.5 -55t82.5 -20.5q70 0 130 63t116 193z"" />
    <glyph glyph-name=""orthogonal"" unicode=""&#x221f;"" horiz-adv-x=""2005"" 
d=""M408 1223h94v-1129h1130v-94h-1224v1223z"" />
    <glyph glyph-name=""intersection"" unicode=""&#x2229;"" horiz-adv-x=""1472"" 
d=""M278 -2v512q0 116 34 212t95 165t144.5 107t181.5 38q99 0 183.5 -38t146 -107t96.5 -165t35 -212v-512h-103v514q0 98 -26.5 175.5t-74 131.5t-112.5 82.5t-143 28.5t-143 -28t-112 -82t-73 -132t-26 -178v-512h-103z"" />
    <glyph glyph-name=""integral"" unicode=""&#x222b;"" horiz-adv-x=""561"" 
d=""M36 -434q-36 0 -73.5 5.5t-60.5 13.5v147q20 -8 51 -16t66 -8q51 0 84 18.5t52.5 50.5t27.5 74t8 90l-2 1212q0 94 25 161t70 110t107.5 63t137.5 20q34 0 71.5 -4.5t59.5 -13.5v-148q-18 10 -48.5 18.5t-66.5 8.5q-51 0 -84 -20t-52.5 -52.5t-27.5 -74.5t-8 -86v-1214
q0 -94 -25 -161t-69.5 -110t-106.5 -63.5t-136 -20.5z"" />
    <glyph glyph-name=""approxequal"" unicode=""&#x2248;"" horiz-adv-x=""1124"" 
d=""M808 758q-69 0 -141.5 21.5t-145.5 47.5q-65 22 -118.5 33.5t-98.5 11.5q-38 0 -70.5 -6t-62.5 -17t-58 -27.5t-57 -37.5v144q50 37 116 60.5t147 23.5q40 0 80 -6.5t78.5 -17t76 -24t74.5 -26.5q21 -8 46 -15.5t50.5 -14.5t51 -11t48.5 -4q69 0 130.5 25.5t113.5 68.5
v-149q-32 -23 -61.5 -38t-60 -24.5t-64.5 -13.5t-74 -4zM808 336q-69 0 -141.5 22t-145.5 48q-65 23 -118.5 35t-98.5 12q-38 0 -70.5 -6t-62.5 -17.5t-58 -27.5t-57 -37v141q50 38 116 61t147 23q40 0 80 -6.5t78.5 -16.5t76 -23t74.5 -26q21 -8 46 -15.5t50.5 -14.5
t51 -11t48.5 -4q69 0 130.5 25t113.5 67v-147q-32 -23 -61.5 -39t-60 -25.5t-64.5 -13.5t-74 -4z"" />
    <glyph glyph-name=""notequal"" unicode=""&#x2260;"" horiz-adv-x=""1124"" 
d=""M448 344l-152 -289h-145l151 289h-237v148h311l190 364h-501v148h573l154 292h143l-152 -292h277v-148h-350l-191 -364h541v-148h-612z"" />
    <glyph glyph-name=""equivalence"" unicode=""&#x2261;"" horiz-adv-x=""1195"" 
d=""M100 956v148h995v-148h-995zM100 244v148h995v-148h-995zM100 600v148h995v-148h-995z"" />
    <glyph glyph-name=""lessequal"" unicode=""&#x2264;"" horiz-adv-x=""1124"" 
d=""M65 631v205l995 395v-154l-858 -344l858 -344v-153zM63 0v145h995v-145h-995z"" />
    <glyph glyph-name=""greaterequal"" unicode=""&#x2265;"" horiz-adv-x=""1124"" 
d=""M65 236v153l858 344l-858 344v154l995 -395v-205zM65 0v145h995v-145h-995z"" />
    <glyph glyph-name=""house"" unicode=""&#x2302;"" horiz-adv-x=""1237"" 
d=""M157 0v635l461 518l461 -518v-635h-922zM237 82h762v518l-381 426l-381 -426v-518z"" />
    <glyph glyph-name=""revlogicalnot"" unicode=""&#x2310;"" horiz-adv-x=""1196"" 
d=""M100 180v574h995v-146h-850v-428h-145z"" />
    <glyph glyph-name=""integraltp"" unicode=""&#x2320;"" horiz-adv-x=""1237"" 
d=""M693 -614h-147v1878q0 196 84 319q82 123 210 123q63 0 100.5 -31.5t37.5 -79.5q0 -40 -25.5 -66t-62.5 -26q-30 0 -43 10q-8 4 -21 16t-33 34q-33 39 -49 39q-36 0 -45 -39q-6 -35 -6 -140v-2037z"" />
    <glyph glyph-name=""integralbt"" unicode=""&#x2321;"" horiz-adv-x=""1237"" 
d=""M546 1706h147v-1880q0 -205 -90 -330q-40 -56 -91.5 -83t-113.5 -27q-30 0 -55 8t-43.5 22.5t-28.5 34t-10 43.5q0 20 7 37t18.5 29t27 19t33.5 7q33 0 59 -16q5 -2 15.5 -13.5t25.5 -31.5q31 -37 47 -37q37 0 45 41q7 31 7 137v2040z"" />
    <glyph glyph-name=""SF100000"" unicode=""&#x2500;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF110000"" unicode=""&#x2502;"" horiz-adv-x=""1280"" 
d=""M472 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF010000"" unicode=""&#x250c;"" horiz-adv-x=""1451"" 
d=""M653 694h808v-145h-663v-1170h-145v1315z"" />
    <glyph glyph-name=""SF030000"" unicode=""&#x2510;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h808v-1315h-145v1170h-663z"" />
    <glyph glyph-name=""SF020000"" unicode=""&#x2514;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-1170h663v-145h-808v1315z"" />
    <glyph glyph-name=""SF040000"" unicode=""&#x2518;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-1315h-808z"" />
    <glyph glyph-name=""SF080000"" unicode=""&#x251c;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-1170h663v-145h-663v-1170h-145v2485z"" />
    <glyph glyph-name=""SF090000"" unicode=""&#x2524;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-2485h-145v1170h-663z"" />
    <glyph glyph-name=""SF060000"" unicode=""&#x252c;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h1471v-145h-663v-1170h-145v1170h-663z"" />
    <glyph glyph-name=""SF070000"" unicode=""&#x2534;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-1170h663v-145h-1471z"" />
    <glyph glyph-name=""SF050000"" unicode=""&#x253c;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h663v1170h145v-1170h663v-145h-663v-1170h-145v1170h-663z"" />
    <glyph glyph-name=""SF430000"" unicode=""&#x2550;"" horiz-adv-x=""1451"" 
d=""M-10 729v145h1471v-145h-1471zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF240000"" unicode=""&#x2551;"" horiz-adv-x=""1451"" 
d=""M473 1864h145v-2485h-145v2485zM833 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF510000"" unicode=""&#x2552;"" horiz-adv-x=""1451"" 
d=""M653 874h808v-145h-663v-215h663v-145h-663v-990h-145v1495z"" />
    <glyph glyph-name=""SF520000"" unicode=""&#x2553;"" horiz-adv-x=""1451"" 
d=""M1461 694v-145h-483v-1170h-145v1170h-215v-1170h-145v1315h988z"" />
    <glyph glyph-name=""SF390000"" unicode=""&#x2554;"" horiz-adv-x=""1451"" 
d=""M473 874h988v-145h-843v-1350h-145v1495zM833 514h628v-145h-483v-990h-145v1135z"" />
    <glyph glyph-name=""SF220000"" unicode=""&#x2555;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h808v-1495h-145v990h-663z"" />
    <glyph glyph-name=""SF210000"" unicode=""&#x2556;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h988v-1315h-145v1170h-215v-1170h-145v1170h-483z"" />
    <glyph glyph-name=""SF250000"" unicode=""&#x2557;"" horiz-adv-x=""1451"" 
d=""M978 874v-1495h-145v1350h-843v145h988zM618 -621h-145v990h-483v145h628v-1135z"" />
    <glyph glyph-name=""SF500000"" unicode=""&#x2558;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-990h663v-145h-663v-215h663v-145h-808v1495z"" />
    <glyph glyph-name=""SF490000"" unicode=""&#x2559;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-1170h483v-145h-988v1315h145v-1170h215v1170z"" />
    <glyph glyph-name=""SF380000"" unicode=""&#x255a;"" horiz-adv-x=""1451"" 
d=""M473 1864h145v-1350h843v-145h-988v1495zM833 1864h145v-990h483v-145h-628v1135z"" />
    <glyph glyph-name=""SF280000"" unicode=""&#x255b;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h663v990h145v-1495h-808z"" />
    <glyph glyph-name=""SF270000"" unicode=""&#x255c;"" horiz-adv-x=""1451"" 
d=""M978 549h-988v145h483v1170h145v-1170h215v1170h145v-1315z"" />
    <glyph glyph-name=""SF260000"" unicode=""&#x255d;"" horiz-adv-x=""1451"" 
d=""M978 369h-988v145h843v1350h145v-1495zM473 1864h145v-1135h-628v145h483v990z"" />
    <glyph glyph-name=""SF360000"" unicode=""&#x255e;"" horiz-adv-x=""1451"" 
d=""M653 1864h145v-990h663v-145h-663v-215h663v-145h-663v-990h-145v2485z"" />
    <glyph glyph-name=""SF370000"" unicode=""&#x255f;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-1170h483v-145h-483v-1170h-145v2485zM473 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF420000"" unicode=""&#x2560;"" horiz-adv-x=""1451"" 
d=""M618 -621h-145v2485h145v-2485zM833 514h628v-145h-483v-990h-145v1135zM833 1864h145v-990h483v-145h-628v1135z"" />
    <glyph glyph-name=""SF190000"" unicode=""&#x2561;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h663v990h145v-2485h-145v990h-663z"" />
    <glyph glyph-name=""SF200000"" unicode=""&#x2562;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h483v1170h145v-2485h-145v1170h-483zM833 1864h145v-2485h-145v2485z"" />
    <glyph glyph-name=""SF230000"" unicode=""&#x2563;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-2485h-145v2485zM473 1864h145v-1135h-628v145h483v990zM618 -621h-145v990h-483v145h628v-1135z"" />
    <glyph glyph-name=""SF470000"" unicode=""&#x2564;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h1471v-145h-663v-990h-145v990h-663zM-10 729v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF480000"" unicode=""&#x2565;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h1471v-145h-483v-1170h-145v1170h-215v-1170h-145v1170h-483z"" />
    <glyph glyph-name=""SF410000"" unicode=""&#x2566;"" horiz-adv-x=""1451"" 
d=""M618 -621h-145v990h-483v145h628v-1135zM833 514h628v-145h-483v-990h-145v1135zM1461 874v-145h-1471v145h1471z"" />
    <glyph glyph-name=""SF450000"" unicode=""&#x2567;"" horiz-adv-x=""1451"" 
d=""M-10 729v145h663v990h145v-990h663v-145h-1471zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF460000"" unicode=""&#x2568;"" horiz-adv-x=""1451"" 
d=""M-10 549v145h483v1170h145v-1170h215v1170h145v-1170h483v-145h-1471z"" />
    <glyph glyph-name=""SF400000"" unicode=""&#x2569;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-990h483v-145h-628v1135zM473 1864h145v-1135h-628v145h483v990zM-10 369v145h1471v-145h-1471z"" />
    <glyph glyph-name=""SF540000"" unicode=""&#x256a;"" horiz-adv-x=""1451"" 
d=""M-10 369v145h663v215h-663v145h663v990h145v-990h663v-145h-663v-215h663v-145h-663v-990h-145v990h-663z"" />
    <glyph glyph-name=""SF530000"" unicode=""&#x256b;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-1170h483v-145h-483v-1170h-145v1170h-215v-1170h-145v1170h-483v145h483v1170h145v-1170h215v1170z"" />
    <glyph glyph-name=""SF440000"" unicode=""&#x256c;"" horiz-adv-x=""1451"" 
d=""M833 1864h145v-990h483v-145h-628v1135zM618 -621h-145v990h-483v145h628v-1135zM833 514h628v-145h-483v-990h-145v1135zM473 1864h145v-1135h-628v145h483v990z"" />
    <glyph glyph-name=""upblock"" unicode=""&#x2580;"" horiz-adv-x=""1451"" 
d=""M1451 621h-1451v1243h1451v-1243z"" />
    <glyph glyph-name=""dnblock"" unicode=""&#x2584;"" horiz-adv-x=""1451"" 
d=""M1451 -621h-1451v1242h1451v-1242z"" />
    <glyph glyph-name=""block"" unicode=""&#x2588;"" horiz-adv-x=""1451"" 
d=""M1451 -621h-1451v2485h1451v-2485z"" />
    <glyph glyph-name=""lfblock"" unicode=""&#x258c;"" horiz-adv-x=""1451"" 
d=""M726 -621h-726v2485h726v-2485z"" />
    <glyph glyph-name=""rtblock"" unicode=""&#x2590;"" horiz-adv-x=""1451"" 
d=""M1451 -621h-726v2485h726v-2485z"" />
    <glyph glyph-name=""ltshade"" unicode=""&#x2591;"" horiz-adv-x=""1451"" 
d=""M103 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM933 1314h103v-98h-103v98zM310 1119h104v-96h-104v96zM725 1119h104v-96h-104v96zM1140 1119h104v-96h-104v96zM933 927h103v-96h-103v96zM517 927h104v-96h-104v96zM103 927h104v-96h-104v96zM1140 732h104v-96
h-104v96zM725 732h104v-96h-104v96zM310 732h104v-96h-104v96zM103 540h104v-96h-104v96zM517 540h104v-96h-104v96zM933 540h103v-96h-103v96zM1140 345h104v-96h-104v96zM725 345h104v-96h-104v96zM310 345h104v-96h-104v96zM103 153h104v-97h-104v97zM517 153h104v-97
h-104v97zM933 153h103v-97h-103v97zM310 -42h104v-94h-104v94zM725 -42h104v-94h-104v94zM1140 -42h104v-94h-104v94zM933 -234h103v-97h-103v97zM517 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM310 -427h104v-96h-104v96zM725 -427h104v-96h-104v96zM1140 -427h104
v-96h-104v96zM310 1506h104v-98h-104v98zM725 1506h104v-98h-104v98zM1140 1506h104v-98h-104v98zM103 1699h104v-96h-104v96zM517 1699h104v-96h-104v96zM933 1699h103v-96h-103v96zM1347 1314h104v-98h-104v98zM1347 927h104v-96h-104v96zM1347 540h104v-96h-104v96z
M1347 153h104v-97h-104v97zM1347 -234h104v-97h-104v97zM1347 1699h104v-96h-104v96z"" />
    <glyph glyph-name=""shade"" unicode=""&#x2592;"" horiz-adv-x=""1451"" 
d=""M103 1314h104v-98h-104v98zM310 1314h104v-98h-104v98zM517 1314h104v-98h-104v98zM725 1314h104v-98h-104v98zM933 1314h104v-98h-104v98zM1140 1314h104v-98h-104v98zM0 1119h103v-96h-103v96zM207 1119h103v-96h-103v96zM414 1119h103v-96h-103v96zM621 1119h104v-96
h-104v96zM829 1119h104v-96h-104v96zM1037 1119h103v-96h-103v96zM103 927h104v-96h-104v96zM310 927h104v-96h-104v96zM517 927h104v-96h-104v96zM725 927h104v-96h-104v96zM933 927h104v-96h-104v96zM1140 927h104v-96h-104v96zM0 732h103v-96h-103v96zM207 732h103v-96
h-103v96zM414 732h103v-96h-103v96zM621 732h104v-96h-104v96zM829 732h104v-96h-104v96zM1037 732h103v-96h-103v96zM103 540h104v-96h-104v96zM310 540h104v-96h-104v96zM517 540h104v-96h-104v96zM725 540h104v-96h-104v96zM933 540h104v-96h-104v96zM1140 540h104v-96
h-104v96zM0 345h103v-96h-103v96zM414 345h103v-96h-103v96zM621 345h104v-96h-104v96zM829 345h104v-96h-104v96zM1037 345h103v-96h-103v96zM207 345h103v-96h-103v96zM1140 153h104v-97h-104v97zM933 153h104v-97h-104v97zM725 153h104v-97h-104v97zM517 153h104v-97
h-104v97zM310 153h104v-97h-104v97zM103 153h104v-97h-104v97zM0 -42h103v-94h-103v94zM207 -42h103v-94h-103v94zM414 -42h103v-94h-103v94zM621 -42h104v-94h-104v94zM829 -42h104v-94h-104v94zM1037 -42h103v-94h-103v94zM1140 -234h104v-97h-104v97zM933 -234h104v-97
h-104v97zM725 -234h104v-97h-104v97zM517 -234h104v-97h-104v97zM310 -234h104v-97h-104v97zM103 -234h104v-97h-104v97zM0 -427h103v-96h-103v96zM207 -427h103v-96h-103v96zM414 -427h103v-96h-103v96zM621 -427h104v-96h-104v96zM829 -427h104v-96h-104v96zM1037 -427
h103v-96h-103v96zM0 1506h103v-98h-103v98zM207 1506h103v-98h-103v98zM414 1506h103v-98h-103v98zM621 1506h104v-98h-104v98zM829 1506h104v-98h-104v98zM1037 1506h103v-98h-103v98zM103 1699h104v-96h-104v96zM310 1699h104v-96h-104v96zM517 1699h104v-96h-104v96z
M725 1699h104v-96h-104v96zM933 1699h104v-96h-104v96zM1140 1699h104v-96h-104v96zM1347 1314h104v-98h-104v98zM1244 1119h103v-96h-103v96zM1347 927h104v-96h-104v96zM1244 732h103v-96h-103v96zM1347 540h104v-96h-104v96zM1244 345h103v-96h-103v96zM1347 153h104v-97
h-104v97zM1244 -42h103v-94h-103v94zM1347 -234h104v-97h-104v97zM1244 -427h103v-96h-103v96zM1244 1506h103v-98h-103v98zM1347 1699h104v-96h-104v96z"" />
    <glyph glyph-name=""dkshade"" unicode=""&#x2593;"" horiz-adv-x=""1493"" 
d=""M1493 -621h-1493v290h106v97h-106v290h106v97h-106v291h106v96h-106v289h106v98h-106v289h106v98h-106v289h106v96h107v-96h106v96h107v-96h106v96h107v-96h107v96h107v-96h107v96h107v-96h106v96h107v-96h106v96h107v-193h-107v-98h107v-289h-107v-96h107v-291h-107v-96
h107v-291h-107v-96h107v-291h-107v-94h107v-291h-107v-96h107v-98zM106 1119v-96h107v96h-107zM319 1119v-96h107v96h-107zM532 1119v-96h107v96h-107zM746 1119v-96h107v96h-107zM960 927h-107v-98h107v98zM746 927h-107v-98h107v98zM532 927h-106v-98h106v98zM319 927
h-106v-98h106v98zM106 732v-96h107v96h-107zM319 732v-96h107v96h-107zM532 732v-96h107v96h-107zM746 732v-96h107v96h-107zM319 540h-106v-96h106v96zM426 540v-96h106v96h-106zM639 540v-96h107v96h-107zM853 540v-96h107v96h-107zM106 345v-96h107v96h-107zM532 345v-96
h107v96h-107zM426 249v96h-107v-96h107zM746 345v-96h107v96h-107zM960 56v97h-107v-97h107zM746 56v97h-107v-97h107zM532 56v97h-106v-97h106zM319 56v97h-106v-97h106zM106 -42v-94h107v94h-107zM319 -42v-94h107v94h-107zM532 -42v-94h107v94h-107zM746 -42v-94h107v94
h-107zM960 -331v97h-107v-97h107zM746 -331v97h-107v-97h107zM532 -331v97h-106v-97h106zM319 -331v97h-106v-97h106zM106 -427v-96h107v96h-107zM319 -427v-96h107v96h-107zM532 -427v-96h107v96h-107zM746 -427v-96h107v96h-107zM960 1314h-107v-98h107v98zM746 1314h-107
v-98h107v98zM532 1314h-106v-98h106v98zM319 1314h-106v-98h106v98zM853 1506h-107v-98h107v98zM639 1506h-107v-98h107v98zM426 1506h-107v-98h107v98zM213 1506h-107v-98h107v98zM960 1119v-96h107v96h-107zM1173 1119v-96h107v96h-107zM1386 927h-106v-98h106v98z
M1173 927h-106v-98h106v98zM960 732v-96h107v96h-107zM1173 732v-96h107v96h-107zM1173 540h-106v-96h106v96zM1280 540v-96h106v96h-106zM960 345v-96h107v96h-107zM1280 249v96h-107v-96h107zM1386 56v97h-106v-97h106zM1173 56v97h-106v-97h106zM960 -42v-94h107v94h-107
zM1173 -42v-94h107v94h-107zM1386 -331v97h-106v-97h106zM1173 -331v97h-106v-97h106zM960 -427v-96h107v96h-107zM1173 -427v-96h107v96h-107zM1386 1314h-106v-98h106v98zM1173 1314h-106v-98h106v98zM1280 1506h-107v-98h107v98zM1067 1506h-107v-98h107v98z"" />
    <glyph glyph-name=""filledbox"" unicode=""&#x25a0;"" horiz-adv-x=""1237"" 
d=""M123 1108h991v-991h-991v991z"" />
    <glyph glyph-name=""H22073"" unicode=""&#x25a1;"" horiz-adv-x=""1237"" 
d=""M6 1225h1225v-1225h-1225v1225zM82 1149v-1073h1073v1073h-1073z"" />
    <glyph glyph-name=""H18543"" unicode=""&#x25aa;"" horiz-adv-x=""726"" 
d=""M617 383h-508v508h508v-508z"" />
    <glyph glyph-name=""H18551"" unicode=""&#x25ab;"" horiz-adv-x=""726"" 
d=""M617 383h-508v508h508v-508zM541 459v354h-356v-354h356z"" />
    <glyph glyph-name=""filledrect"" unicode=""&#x25ac;"" horiz-adv-x=""2048"" 
d=""M0 616h2048v-616h-2048v616z"" />
    <glyph glyph-name=""triagup"" unicode=""&#x25b2;"" horiz-adv-x=""2027"" 
d=""M414 0l600 1198l598 -1198h-1198z"" />
    <glyph glyph-name=""triagrt"" unicode=""&#x25ba;"" horiz-adv-x=""2027"" 
d=""M401 1196l1225 -610l-1225 -613v1223z"" />
    <glyph glyph-name=""triagdn"" unicode=""&#x25bc;"" horiz-adv-x=""2027"" 
d=""M1612 1171l-598 -1198l-600 1198h1198z"" />
    <glyph glyph-name=""triaglf"" unicode=""&#x25c4;"" horiz-adv-x=""2027"" 
d=""M1626 1196v-1223l-1225 613z"" />
    <glyph glyph-name=""lozenge"" unicode=""&#x25ca;"" horiz-adv-x=""1012"" 
d=""M547 0h-82l-457 719l457 721h82l459 -719zM508 1286l-354 -565l354 -574l352 574z"" />
    <glyph glyph-name=""circle"" unicode=""&#x25cb;"" horiz-adv-x=""1237"" 
d=""M167 612q0 94 35 176.5t96 144t143 97t176 35.5t176.5 -35.5t144 -97t97 -144t35.5 -176.5t-35.5 -176t-97 -143t-144 -96t-176.5 -35t-176 35t-143 96t-96 143t-35 176zM253 612q0 -76 28.5 -142t77.5 -115.5t115.5 -78t142.5 -28.5t143 28.5t116.5 78t78.5 115.5
t29 142t-29 143t-78.5 116.5t-116.5 78.5t-143 29t-142.5 -29t-115.5 -78.5t-77.5 -116.5t-28.5 -143z"" />
    <glyph glyph-name=""H18533"" unicode=""&#x25cf;"" horiz-adv-x=""1237"" 
d=""M618 1018q110 0 217 -57q53 -28 94 -69t70 -93q29 -54 44.5 -109t15.5 -112q0 -183 -129 -312t-312 -129q-182 0 -311 129t-129 312q0 58 15 112.5t44 108.5q29 52 70.5 93t93.5 69q108 57 217 57z"" />
    <glyph glyph-name=""invbullet"" unicode=""&#x25d8;"" horiz-adv-x=""1237"" 
d=""M41 0v1155h1155v-1155h-1155zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" />
    <glyph glyph-name=""invcircle"" unicode=""&#x25d9;"" horiz-adv-x=""1237"" 
d=""M41 0v1155h1155v-1155h-1155zM253 577q0 75 29 141.5t78.5 116t116 78.5t141.5 29t141.5 -29t116 -78.5t78.5 -116t29 -141.5t-29 -141.5t-78.5 -116t-116 -78.5t-141.5 -29t-141.5 29t-116 78.5t-78.5 116t-29 141.5zM176 577q0 -91 34.5 -171t94.5 -140t140 -94.5
t171 -34.5t171.5 34.5t140.5 94.5t94.5 140t34.5 171t-34.5 171.5t-94.5 140.5t-140.5 94.5t-171.5 34.5t-171 -34.5t-140 -94.5t-94.5 -140.5t-34.5 -171.5z"" />
    <glyph glyph-name=""openbullet"" unicode=""&#x25e6;"" horiz-adv-x=""726"" 
d=""M611 637q0 -53 -18.5 -96t-55.5 -80q-37 -35 -80 -53.5t-94 -18.5q-101 0 -176 72q-35 37 -53.5 80t-18.5 96q0 102 72 174q74 74 176 74q103 0 174 -74q74 -71 74 -174zM535 637q0 70 -51 121t-121 51t-121 -51t-51 -121q0 -69 51 -123q49 -49 121 -49t121 49
q51 54 51 123z"" />
    <glyph glyph-name=""smileface"" unicode=""&#x263a;"" horiz-adv-x=""2091"" 
d=""M1657 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM1567 584q0 217 -153 370q-151 154 -369 154t-369 -154q-153 -153 -153 -370q0 -216 153 -369
q152 -154 369 -154t369 154q153 153 153 369zM889 711q0 -32 -23 -55t-55 -23t-54.5 23t-22.5 55t22.5 54.5t54.5 22.5t55 -22.5t23 -54.5zM1356 711q0 -32 -22 -55t-54 -23t-55.5 23t-23.5 55t23.5 54.5t55.5 22.5t54 -22.5t22 -54.5zM822 422q76 -137 223 -137
q145 0 221 137l62 -35q-98 -186 -283 -186q-94 0 -164.5 47.5t-118.5 138.5z"" />
    <glyph glyph-name=""invsmileface"" unicode=""&#x263b;"" horiz-adv-x=""2155"" 
d=""M1689 584q0 -254 -180 -432q-179 -179 -432 -179t-432 179q-180 178 -180 432q0 128 45 235.5t135 198.5q178 178 432 178t432 -178q90 -91 135 -198.5t45 -235.5zM921 711q0 32 -23 54.5t-55 22.5t-54.5 -22.5t-22.5 -54.5t22.5 -55t54.5 -23t55 23t23 55zM1388 711
q0 32 -22 54.5t-54 22.5t-55.5 -22.5t-23.5 -54.5t23.5 -55t55.5 -23t54 23t22 55zM794 387q48 -91 118.5 -138.5t164.5 -47.5q185 0 283 186l-62 35q-76 -137 -221 -137q-147 0 -223 137z"" />
    <glyph glyph-name=""sun"" unicode=""&#x263c;"" horiz-adv-x=""1877"" 
d=""M905 1083h66v-217q32 -3 60.5 -9t55.5 -16.5t53.5 -26.5t55.5 -38l186 182l45 -45l-184 -184q45 -59 67 -115.5t25 -113.5h215v-62h-215q-8 -60 -30 -115t-62 -106l184 -188l-49 -43l-182 182q-31 -23 -58.5 -39t-50.5 -27q-24 -9 -53 -15t-63 -11v-217h-66v217
q-63 9 -118 32t-103 58l-188 -180l-43 45l182 184q-40 51 -63 106.5t-31 118.5h-215v62h215q12 128 92 223l-180 184l40 49l189 -182q57 40 113 62t110 28v217zM936 805q-69 0 -127.5 -25t-106.5 -73q-98 -100 -98 -236q0 -137 98 -235q48 -50 106.5 -73.5t127.5 -23.5
q139 0 235 97q99 97 99 235q0 137 -99 236q-49 48 -107.5 73t-127.5 25z"" />
    <glyph glyph-name=""female"" unicode=""&#x2640;"" horiz-adv-x=""1536"" 
d=""M732 578q-55 8 -100 31t-80 65q-71 80 -71 188q0 122 83 205q44 43 94.5 64.5t110.5 21.5q118 0 201 -86q86 -83 86 -205q0 -109 -72 -190q-72 -82 -178 -94v-166h256v-70h-256v-262h-74v262h-258v70h258v166zM767 1069q-83 0 -145 -59q-29 -31 -44.5 -66.5t-15.5 -79.5
q0 -43 15.5 -78.5t44.5 -66.5q62 -62 145 -62q87 0 146 62q61 61 61 145q0 44 -15 79.5t-44 66.5q-62 59 -148 59z"" />
    <glyph glyph-name=""male"" unicode=""&#x2642;"" horiz-adv-x=""1536"" 
d=""M1023 1024q-17 5 -44 14t-64 23q-28 11 -48 23t-34 26q-5 3 -6.5 8t-1.5 10q0 8 6 17q3 2 6 3t8 1t12.5 -1t20.5 -3q32 -8 63.5 -12.5t63.5 -4.5q46 0 78 3.5t51 9.5q36 12 49 12q16 0 16 -14q0 -9 -6 -27q-9 -34 -12.5 -73.5t-3.5 -84.5q0 -31 2 -63t10 -66q2 -11 3 -19
t1 -13t-1 -8.5t-3 -6.5q-9 -6 -14 -6q-21 0 -41 39q-22 42 -37.5 83t-26.5 83l-237 -238q84 -81 84 -190q0 -125 -86 -211q-87 -88 -205 -88t-205 84q-84 84 -84 201t84 204q85 86 207 86q71 0 154 -43zM628 750q-90 0 -152 -62q-61 -61 -61 -149q0 -91 61 -152
q64 -61 152 -61q89 0 149 61q62 62 62 152q0 87 -62 149q-60 62 -149 62z"" />
    <glyph glyph-name=""spade"" unicode=""&#x2660;"" horiz-adv-x=""1088"" 
d=""M544 1231q14 -54 34 -101.5t46 -91.5q28 -43 75.5 -95.5t116.5 -115.5q141 -126 176 -192q37 -67 37 -137q0 -95 -63 -158q-66 -66 -154 -66q-157 0 -256 191q3 -147 39 -234q38 -86 119.5 -135.5t218.5 -58.5l8 -37h-792l6 37q125 0 211 49q43 25 76 59.5t55 80t32 105
t9 134.5q-45 -96 -111 -143.5t-149 -47.5q-90 0 -156 66q-63 63 -63 154q0 74 30 133q23 42 62 84.5t96 89.5q69 59 124 115.5t93 113.5q56 83 80 201z"" />
    <glyph glyph-name=""club"" unicode=""&#x2663;"" horiz-adv-x=""1344"" 
d=""M1094 0h-842l8 35q84 17 138 33.5t81 33.5q41 25 73 62.5t58 87.5q52 100 52 209q0 8 -1 19t-1 28q-58 -121 -148 -180q-43 -28 -87 -43t-89 -15q-59 0 -107.5 21t-89.5 59q-79 83 -79 199q0 115 73 194q73 80 166 80q31 0 71 -12.5t91 -38.5q-20 34 -33.5 60t-21.5 45
q-5 17 -8 36t-3 39q0 115 78 193q40 38 88.5 58t108.5 20q116 0 196 -80q80 -78 80 -187q0 -86 -69 -184q84 40 100 43q14 5 29 6.5t32 1.5q51 0 94 -18.5t79 -59.5q73 -76 73 -192q0 -118 -80 -201q-80 -80 -192 -80q-62 0 -128 30t-116 81q-17 19 -38.5 49.5t-47.5 75.5
q3 -81 14.5 -143.5t34.5 -108.5q22 -45 55.5 -83t79.5 -69q61 -39 220 -69z"" />
    <glyph glyph-name=""heart"" unicode=""&#x2665;"" horiz-adv-x=""1216"" 
d=""M610 -23q-14 56 -35 106.5t-47 98.5q-28 50 -79.5 123.5t-127.5 175.5q-56 76 -90.5 122.5t-48.5 68.5q-43 65 -61.5 118t-18.5 109q0 103 68 174q70 70 172 70q98 0 176 -72q28 -28 51.5 -68t40.5 -94q34 119 105 177.5t159 58.5q50 0 92.5 -18t77.5 -52q70 -70 70 -164
q0 -86 -41 -174q-20 -45 -59 -104.5t-99 -134.5q-75 -96 -129 -172t-86 -131q-31 -54 -53 -109t-37 -109z"" />
    <glyph glyph-name=""diamond"" unicode=""&#x2666;"" horiz-adv-x=""1045"" 
d=""M519 1223q45 -78 101.5 -160.5t125.5 -175.5t127 -163.5t105 -123.5q-39 -40 -99 -115t-143 -186q-69 -93 -122 -172.5t-93 -151.5q-13 25 -30.5 54t-39.5 61q-38 57 -87 124.5t-109 147.5q-14 20 -61 79.5t-128 158.5q50 59 114 139t144 187q59 77 107 151t88 146z"" />
    <glyph glyph-name=""musicalnote"" unicode=""&#x266a;"" horiz-adv-x=""1024"" 
d=""M489 1153h76v-100l153 -193q51 -69 80 -150.5t29 -166.5q0 -78 -24 -145t-70 -126h-47q29 65 43 127t14 121q0 60 -14 109.5t-43 89.5q-57 81 -121 90v-506q0 -63 -18.5 -112t-55.5 -87q-72 -75 -180 -75q-57 0 -86 27t-29 73q0 73 60 133q63 60 143 60q44 0 90 -19v850z
"" />
    <glyph glyph-name=""musicalnotedbl"" unicode=""&#x266b;"" horiz-adv-x=""1536"" 
d=""M1263 324q0 -63 -18 -113.5t-56 -85.5q-37 -37 -81 -56.5t-95 -19.5q-57 0 -85.5 27t-28.5 74q0 76 57 133q62 59 143 59q48 0 90 -18v448l-550 -149v-394q0 -62 -18.5 -111t-53.5 -87q-74 -74 -180 -74q-57 0 -86 26.5t-29 71.5q0 76 59 133q60 60 144 60q45 0 90 -19
v752l698 178v-835zM639 750l550 149v117l-550 -152v-114z"" />
    <glyph glyph-name=""uniFB01"" unicode=""&#xf001;"" horiz-adv-x=""1024"" 
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM706 1312v172h180v-172h-180zM706 0v1082h180v-1082h-180z
"" />
    <glyph glyph-name=""uniFB01"" unicode=""&#xfb01;"" horiz-adv-x=""1024"" 
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM706 1312v172h180v-172h-180zM706 0v1082h180v-1082h-180z
"" />
    <glyph glyph-name=""uniFB02"" unicode=""&#xf002;"" horiz-adv-x=""1024"" 
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM707 0v1484h180v-1484h-180z"" />
    <glyph glyph-name=""uniFB02"" unicode=""&#xfb02;"" horiz-adv-x=""1024"" 
d=""M361 951v-951h-180v951h-152v131h152v122q0 59 11 109.5t40.5 88t80.5 59t132 21.5q32 0 66.5 -3t60.5 -9v-137q-17 3 -39.5 5.5t-40.5 2.5q-40 0 -65.5 -11t-40 -31.5t-20 -50.5t-5.5 -69v-97h211v-131h-211zM707 0v1484h180v-1484h-180z"" />
    <glyph glyph-name=""uniF005"" unicode=""&#xf005;"" horiz-adv-x=""682"" 
d=""M483 -253q0 -41 -15 -74.5t-47.5 -57.5t-84.5 -36.5t-127 -12.5q-20 0 -42.5 0.5t-47.5 3.5v98q49 -6 86 -6q41 0 69 6t45.5 16.5t25 25.5t7.5 33q0 37 -30.5 57t-102.5 20h-28.5t-28.5 -2l31 96h62q52 0 94 -9t72 -29.5t46 -52t16 -76.5z"" />
    <glyph glyph-name=""middot"" horiz-adv-x=""682"" 
d=""M243 446v220h195v-220h-195z"" />
    <glyph glyph-name=""uniF004"" horiz-adv-x=""682"" 
d=""M328 -193q0 -87 -22 -140.5t-62 -100.5h-117q45 48 69.5 91t24.5 89h-88v156h195v-95z"" />
    <glyph glyph-name=""uni2074"" horiz-adv-x=""682"" 
d=""M551 741v-178h-131v178h-406v111l386 557h151v-555h111v-113h-111zM422 1276q-7 -13 -18 -31.5t-23 -38t-23 -37t-18 -28.5l-199 -287h279v289v33v38t0.5 36t1.5 26z"" />
    <glyph glyph-name=""uni2075"" horiz-adv-x=""682"" 
d=""M636 835q0 -65 -19 -117t-55.5 -89t-90.5 -57t-124 -20q-66 0 -116.5 16.5t-87.5 46t-59 70t-31 88.5l133 15q5 -27 17 -50.5t31.5 -41.5t46.5 -28.5t63 -10.5q71 0 114 42.5t43 135.5q0 81 -40.5 123.5t-115.5 42.5q-51 0 -89.5 -18.5t-61.5 -41.5h-129l33 468h506v-113
h-398l-19 -245q29 26 74.5 42.5t99.5 16.5q67 0 118.5 -19.5t86 -55t52.5 -86.5t18 -114z"" />
    <glyph glyph-name=""uni2077"" horiz-adv-x=""682"" 
d=""M632 1308q-64 -97 -117 -185t-91.5 -176t-60 -181.5t-21.5 -201.5h-133q0 102 23.5 196t63.5 183.5t93.5 177t113.5 175.5h-460v113h589v-101z"" />
    <glyph glyph-name=""uni2078"" horiz-adv-x=""682"" 
d=""M479 1193q0 28 -6 52t-21.5 41t-42 26.5t-67.5 9.5q-39 0 -65.5 -9.5t-42 -26.5t-22 -41t-6.5 -52q0 -23 4.5 -46.5t19 -43t41.5 -32t72 -12.5q48 0 75 12.5t40.5 32t17 43.5t3.5 46zM500 814q0 28 -6.5 54t-24 46t-48 32t-79.5 12q-45 0 -74.5 -12t-47.5 -32.5
t-25.5 -47t-7.5 -54.5q0 -35 7.5 -64.5t25.5 -50.5t48.5 -32.5t76.5 -11.5t76.5 11.5t47.5 32.5t24 51t7 66zM642 800q0 -54 -17.5 -99.5t-54 -78.5t-93 -51.5t-133.5 -18.5t-133.5 18.5t-93.5 51.5t-54.5 78t-17.5 99q0 46 14.5 82t38 62t54 42t62.5 21v3q-36 8 -63.5 26.5
t-46.5 44.5t-29 58t-10 67q0 45 17.5 84.5t52.5 69t87 46.5t120 17q72 0 124.5 -17.5t87 -47.5t51 -69.5t16.5 -83.5q0 -35 -10 -66.5t-29 -57.5t-47 -44.5t-64 -25.5v-3q36 -6 67.5 -21.5t54.5 -41.5t36 -62t13 -82z"" />
    <glyph glyph-name=""glyph571"" horiz-adv-x=""682"" 
d=""M340 1200q-111 0 -181.5 28.5t-111 74t-56.5 103t-18 114.5h164q6 -103 58 -151t145 -48t145 48t58 151h164q-2 -57 -18 -114.5t-56.5 -103t-111 -74t-181.5 -28.5z"" />
    <glyph glyph-name=""glyph572"" horiz-adv-x=""455"" 
d=""M325 1303q0 -87 -22 -145.5t-62 -105.5h-117q45 48 69.5 96t24.5 94h-88v167h195v-106z"" />
    <glyph glyph-name=""glyph573"" horiz-adv-x=""455"" 
d=""M130 1317q0 87 22 145.5t62 105.5h117q-45 -48 -69.5 -96t-24.5 -94h88v-167h-195v106z"" />
    <glyph glyph-name=""glyph574"" horiz-adv-x=""602"" 
d=""M416 1530l-310 217v29h207l217 -226v-20h-114z"" />
    <glyph glyph-name=""glyph575"" horiz-adv-x=""602"" 
d=""M72 1530v20l217 226h207v-29l-310 -217h-114z"" />
    <glyph glyph-name=""glyph576"" horiz-adv-x=""664"" 
d=""M662 1550v-20h-105l-219 139h-2l-232 -139h-104v20l234 240h204z"" />
    <glyph glyph-name=""glyph577"" horiz-adv-x=""664"" 
d=""M438 1530h-204l-234 239v21h104l232 -139h2l219 139h105v-21z"" />
    <glyph glyph-name=""glyph578"" horiz-adv-x=""647"" 
d=""M439 1530v184h163v-184h-163zM45 1530v184h165v-184h-165z"" />
    <glyph glyph-name=""glyph579"" horiz-adv-x=""672"" 
d=""M492 1530q-42 0 -84 18.5t-81 41t-74.5 41t-66.5 18.5q-55 0 -82 -31t-36 -88h-91q5 45 15 92.5t32.5 86.5t59.5 64t96 25q44 0 86 -18.5t81 -41t73.5 -41t64.5 -18.5q54 0 81.5 31.5t35.5 87.5h92q-5 -44 -15 -91.5t-31.5 -86.5t-58.5 -64.5t-97 -25.5z"" />
    <glyph glyph-name=""glyph580"" horiz-adv-x=""815"" 
d=""M32 1530v20l197 227h207v-29l-310 -218h-94zM379 1530v20l197 227h207v-29l-310 -218h-94z"" />
    <glyph glyph-name=""glyph581"" horiz-adv-x=""584"" 
d=""M308 1530q-74 0 -132 20.5t-100 55t-67 79.5t-33 94h117q17 -53 71.5 -83t145.5 -30t144.5 30.5t70.5 82.5h117q-9 -49 -34 -94t-66.5 -79.5t-99.5 -55t-134 -20.5z"" />
    <hkern u1=""&#x20;"" u2=""&#x3ab;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x3a5;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x3a4;"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""&#x39b;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""&#x394;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""&#x391;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""&#x386;"" k=""113"" />
    <hkern u1=""&#x20;"" u2=""Y"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""T"" k=""37"" />
    <hkern u1=""&#x20;"" u2=""A"" k=""113"" />
    <hkern u1=""&#x31;"" u2=""&#x31;"" k=""152"" />
    <hkern u1=""A"" u2=""&#x2019;"" k=""152"" />
    <hkern u1=""A"" u2=""y"" k=""37"" />
    <hkern u1=""A"" u2=""w"" k=""37"" />
    <hkern u1=""A"" u2=""v"" k=""37"" />
    <hkern u1=""A"" u2=""Y"" k=""152"" />
    <hkern u1=""A"" u2=""W"" k=""76"" />
    <hkern u1=""A"" u2=""V"" k=""152"" />
    <hkern u1=""A"" u2=""T"" k=""152"" />
    <hkern u1=""A"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""F"" u2=""A"" k=""113"" />
    <hkern u1=""F"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""F"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""L"" u2=""&#x2019;"" k=""113"" />
    <hkern u1=""L"" u2=""y"" k=""76"" />
    <hkern u1=""L"" u2=""Y"" k=""152"" />
    <hkern u1=""L"" u2=""W"" k=""152"" />
    <hkern u1=""L"" u2=""V"" k=""152"" />
    <hkern u1=""L"" u2=""T"" k=""152"" />
    <hkern u1=""L"" u2=""&#x20;"" k=""76"" />
    <hkern u1=""P"" u2=""A"" k=""152"" />
    <hkern u1=""P"" u2=""&#x2e;"" k=""264"" />
    <hkern u1=""P"" u2=""&#x2c;"" k=""264"" />
    <hkern u1=""P"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""R"" u2=""Y"" k=""37"" />
    <hkern u1=""R"" u2=""W"" k=""37"" />
    <hkern u1=""R"" u2=""V"" k=""37"" />
    <hkern u1=""R"" u2=""T"" k=""37"" />
    <hkern u1=""T"" u2=""y"" k=""113"" />
    <hkern u1=""T"" u2=""w"" k=""113"" />
    <hkern u1=""T"" u2=""u"" k=""76"" />
    <hkern u1=""T"" u2=""s"" k=""227"" />
    <hkern u1=""T"" u2=""r"" k=""76"" />
    <hkern u1=""T"" u2=""o"" k=""227"" />
    <hkern u1=""T"" u2=""i"" k=""76"" />
    <hkern u1=""T"" u2=""e"" k=""227"" />
    <hkern u1=""T"" u2=""c"" k=""227"" />
    <hkern u1=""T"" u2=""a"" k=""227"" />
    <hkern u1=""T"" u2=""O"" k=""37"" />
    <hkern u1=""T"" u2=""A"" k=""152"" />
    <hkern u1=""T"" u2=""&#x3b;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x3a;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""T"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""T"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""V"" u2=""y"" k=""76"" />
    <hkern u1=""V"" u2=""u"" k=""76"" />
    <hkern u1=""V"" u2=""r"" k=""76"" />
    <hkern u1=""V"" u2=""o"" k=""113"" />
    <hkern u1=""V"" u2=""i"" k=""37"" />
    <hkern u1=""V"" u2=""e"" k=""113"" />
    <hkern u1=""V"" u2=""a"" k=""152"" />
    <hkern u1=""V"" u2=""A"" k=""152"" />
    <hkern u1=""V"" u2=""&#x3b;"" k=""76"" />
    <hkern u1=""V"" u2=""&#x3a;"" k=""76"" />
    <hkern u1=""V"" u2=""&#x2e;"" k=""188"" />
    <hkern u1=""V"" u2=""&#x2d;"" k=""113"" />
    <hkern u1=""V"" u2=""&#x2c;"" k=""188"" />
    <hkern u1=""W"" u2=""y"" k=""18"" />
    <hkern u1=""W"" u2=""u"" k=""37"" />
    <hkern u1=""W"" u2=""r"" k=""37"" />
    <hkern u1=""W"" u2=""o"" k=""37"" />
    <hkern u1=""W"" u2=""e"" k=""37"" />
    <hkern u1=""W"" u2=""a"" k=""76"" />
    <hkern u1=""W"" u2=""A"" k=""76"" />
    <hkern u1=""W"" u2=""&#x3b;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x3a;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""W"" u2=""&#x2d;"" k=""37"" />
    <hkern u1=""W"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""Y"" u2=""v"" k=""113"" />
    <hkern u1=""Y"" u2=""u"" k=""113"" />
    <hkern u1=""Y"" u2=""q"" k=""188"" />
    <hkern u1=""Y"" u2=""p"" k=""152"" />
    <hkern u1=""Y"" u2=""o"" k=""188"" />
    <hkern u1=""Y"" u2=""i"" k=""76"" />
    <hkern u1=""Y"" u2=""e"" k=""188"" />
    <hkern u1=""Y"" u2=""a"" k=""152"" />
    <hkern u1=""Y"" u2=""A"" k=""152"" />
    <hkern u1=""Y"" u2=""&#x3b;"" k=""133"" />
    <hkern u1=""Y"" u2=""&#x3a;"" k=""113"" />
    <hkern u1=""Y"" u2=""&#x2e;"" k=""264"" />
    <hkern u1=""Y"" u2=""&#x2d;"" k=""188"" />
    <hkern u1=""Y"" u2=""&#x2c;"" k=""264"" />
    <hkern u1=""Y"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""f"" u2=""&#x2019;"" k=""-37"" />
    <hkern u1=""f"" u2=""f"" k=""37"" />
    <hkern u1=""r"" u2=""&#x2019;"" k=""-76"" />
    <hkern u1=""r"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""r"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""v"" u2=""&#x2e;"" k=""152"" />
    <hkern u1=""v"" u2=""&#x2c;"" k=""152"" />
    <hkern u1=""w"" u2=""&#x2e;"" k=""113"" />
    <hkern u1=""w"" u2=""&#x2c;"" k=""113"" />
    <hkern u1=""y"" u2=""&#x2e;"" k=""152"" />
    <hkern u1=""y"" u2=""&#x2c;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x3c7;"" k=""37"" />
    <hkern u1=""&#x386;"" u2=""&#x3bd;"" k=""37"" />
    <hkern u1=""&#x386;"" u2=""&#x3b3;"" k=""37"" />
    <hkern u1=""&#x386;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x3a6;"" k=""59"" />
    <hkern u1=""&#x386;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x3a4;"" k=""152"" />
    <hkern u1=""&#x386;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x386;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x38c;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x38e;"" u2=""&#x3cc;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ca;"" k=""-98"" />
    <hkern u1=""&#x38e;"" u2=""&#x3c6;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3c3;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3bf;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3bc;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ba;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b7;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3b1;"" k=""186"" />
    <hkern u1=""&#x38e;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x38e;"" u2=""&#x3ae;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x3a9;"" k=""98"" />
    <hkern u1=""&#x38e;"" u2=""&#x3a6;"" k=""115"" />
    <hkern u1=""&#x38e;"" u2=""&#x39f;"" k=""115"" />
    <hkern u1=""&#x38e;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x398;"" k=""115"" />
    <hkern u1=""&#x38e;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x38e;"" u2=""&#x390;"" k=""-170"" />
    <hkern u1=""&#x38f;"" u2=""&#x3ab;"" k=""47"" />
    <hkern u1=""&#x38f;"" u2=""&#x3a5;"" k=""47"" />
    <hkern u1=""&#x391;"" u2=""&#x2019;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x3c7;"" k=""37"" />
    <hkern u1=""&#x391;"" u2=""&#x3bd;"" k=""37"" />
    <hkern u1=""&#x391;"" u2=""&#x3b3;"" k=""37"" />
    <hkern u1=""&#x391;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x3a6;"" k=""59"" />
    <hkern u1=""&#x391;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x3a4;"" k=""152"" />
    <hkern u1=""&#x391;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x391;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x391;"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""&#x393;"" u2=""&#x3ca;"" k=""-88"" />
    <hkern u1=""&#x393;"" u2=""&#x3b9;"" k=""88"" />
    <hkern u1=""&#x393;"" u2=""&#x39b;"" k=""188"" />
    <hkern u1=""&#x393;"" u2=""&#x394;"" k=""188"" />
    <hkern u1=""&#x393;"" u2=""&#x391;"" k=""188"" />
    <hkern u1=""&#x393;"" u2=""&#x390;"" k=""-164"" />
    <hkern u1=""&#x393;"" u2=""&#x2e;"" k=""225"" />
    <hkern u1=""&#x393;"" u2=""&#x2c;"" k=""225"" />
    <hkern u1=""&#x394;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x394;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x394;"" u2=""&#x3a4;"" k=""119"" />
    <hkern u1=""&#x394;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x394;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x394;"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""&#x398;"" u2=""&#x3ab;"" k=""66"" />
    <hkern u1=""&#x398;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x398;"" u2=""&#x39b;"" k=""37"" />
    <hkern u1=""&#x398;"" u2=""&#x394;"" k=""37"" />
    <hkern u1=""&#x398;"" u2=""&#x391;"" k=""37"" />
    <hkern u1=""&#x39a;"" u2=""&#x3ce;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3cc;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c9;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c6;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3c3;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3bf;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3be;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b8;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b6;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b4;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3b1;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3ac;"" k=""25"" />
    <hkern u1=""&#x39a;"" u2=""&#x3a6;"" k=""113"" />
    <hkern u1=""&#x39a;"" u2=""&#x39f;"" k=""63"" />
    <hkern u1=""&#x39a;"" u2=""&#x398;"" k=""63"" />
    <hkern u1=""&#x39b;"" u2=""&#x3ab;"" k=""152"" />
    <hkern u1=""&#x39b;"" u2=""&#x3a5;"" k=""152"" />
    <hkern u1=""&#x39b;"" u2=""&#x3a4;"" k=""152"" />
    <hkern u1=""&#x39b;"" u2=""&#x39f;"" k=""43"" />
    <hkern u1=""&#x39b;"" u2=""&#x398;"" k=""43"" />
    <hkern u1=""&#x39b;"" u2=""&#x20;"" k=""113"" />
    <hkern u1=""&#x39f;"" u2=""&#x3ab;"" k=""66"" />
    <hkern u1=""&#x39f;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x39f;"" u2=""&#x39b;"" k=""37"" />
    <hkern u1=""&#x39f;"" u2=""&#x394;"" k=""43"" />
    <hkern u1=""&#x39f;"" u2=""&#x391;"" k=""37"" />
    <hkern u1=""&#x3a1;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a1;"" u2=""&#x2e;"" k=""262"" />
    <hkern u1=""&#x3a1;"" u2=""&#x2c;"" k=""262"" />
    <hkern u1=""&#x3a1;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3a3;"" u2=""&#x3c4;"" k=""98"" />
    <hkern u1=""&#x3a3;"" u2=""&#x3c0;"" k=""98"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cd;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cc;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3cb;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ca;"" k=""-188"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c8;"" k=""150"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c7;"" k=""113"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c6;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c5;"" k=""176"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3c3;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bf;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bd;"" k=""113"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3bc;"" k=""150"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b7;"" k=""150"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b5;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b3;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b1;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b0;"" k=""178"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ad;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3ac;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a9;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a6;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x39f;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x398;"" k=""37"" />
    <hkern u1=""&#x3a4;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a4;"" u2=""&#x390;"" k=""-188"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3b;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x3a;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x2e;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x2c;"" k=""225"" />
    <hkern u1=""&#x3a4;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3cc;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ca;"" k=""-121"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3c6;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3c3;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3bf;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3bc;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ba;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b7;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b3;"" k=""98"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b1;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3ae;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a9;"" k=""98"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a6;"" k=""115"" />
    <hkern u1=""&#x3a5;"" u2=""&#x39f;"" k=""115"" />
    <hkern u1=""&#x3a5;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x398;"" k=""115"" />
    <hkern u1=""&#x3a5;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3a5;"" u2=""&#x390;"" k=""-188"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3b;"" k=""113"" />
    <hkern u1=""&#x3a5;"" u2=""&#x3a;"" k=""113"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2e;"" k=""262"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2d;"" k=""186"" />
    <hkern u1=""&#x3a5;"" u2=""&#x2c;"" k=""262"" />
    <hkern u1=""&#x3a5;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3a6;"" u2=""&#x3ab;"" k=""66"" />
    <hkern u1=""&#x3a6;"" u2=""&#x3a5;"" k=""66"" />
    <hkern u1=""&#x3a6;"" u2=""&#x391;"" k=""59"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3ce;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3cc;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c9;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c6;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3c3;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3bf;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b8;"" k=""39"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b4;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3b1;"" k=""78"" />
    <hkern u1=""&#x3a8;"" u2=""&#x3ac;"" k=""78"" />
    <hkern u1=""&#x3a9;"" u2=""&#x3ab;"" k=""47"" />
    <hkern u1=""&#x3a9;"" u2=""&#x3a5;"" k=""47"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3cc;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ca;"" k=""-98"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3c6;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3c3;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3bf;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3bc;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ba;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b9;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b7;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3b1;"" k=""186"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3af;"" k=""76"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3ae;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3a9;"" k=""98"" />
    <hkern u1=""&#x3ab;"" u2=""&#x3a6;"" k=""115"" />
    <hkern u1=""&#x3ab;"" u2=""&#x39f;"" k=""115"" />
    <hkern u1=""&#x3ab;"" u2=""&#x39b;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x398;"" k=""115"" />
    <hkern u1=""&#x3ab;"" u2=""&#x394;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x391;"" k=""152"" />
    <hkern u1=""&#x3ab;"" u2=""&#x390;"" k=""-170"" />
    <hkern u1=""&#x3ab;"" u2=""&#x20;"" k=""37"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3b4;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ce;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3cc;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c9;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c6;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c4;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c3;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3c0;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3bf;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3bd;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ba;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b9;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b8;"" k=""98"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b7;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b4;"" k=""76"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b3;"" k=""86"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3b1;"" k=""137"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ae;"" k=""37"" />
    <hkern u1=""&#x3b6;"" u2=""&#x3ac;"" k=""137"" />
    <hkern u1=""&#x3b8;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3ce;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3cc;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c9;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c6;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c3;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3c2;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3bf;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3be;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b8;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b6;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b4;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3b1;"" k=""25"" />
    <hkern u1=""&#x3ba;"" u2=""&#x3ac;"" k=""25"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3ce;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3cd;"" k=""49"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3cc;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c9;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c6;"" k=""37"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c5;"" k=""49"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c3;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3c2;"" k=""47"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3bf;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3be;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b4;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3b1;"" k=""31"" />
    <hkern u1=""&#x3bb;"" u2=""&#x3ac;"" k=""31"" />
    <hkern u1=""&#x3be;"" u2=""&#x3cc;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c6;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c3;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3c2;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3bf;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3be;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b6;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b4;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3b1;"" k=""55"" />
    <hkern u1=""&#x3be;"" u2=""&#x3ac;"" k=""55"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3bf;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3ce;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c9;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c6;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c3;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3c2;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3bf;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3b6;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3b1;"" k=""29"" />
    <hkern u1=""&#x3c0;"" u2=""&#x3ac;"" k=""29"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3c1;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3ce;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c9;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c6;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c3;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3c2;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3bf;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b6;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b4;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3b1;"" k=""29"" />
    <hkern u1=""&#x3c4;"" u2=""&#x3ac;"" k=""29"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3c6;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3ce;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3cc;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c9;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c6;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c3;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3c2;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3bf;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b6;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b4;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3b1;"" k=""55"" />
    <hkern u1=""&#x3c7;"" u2=""&#x3ac;"" k=""55"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3c9;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3cc;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c7;"" k=""55"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c4;"" k=""29"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3c0;"" k=""29"" />
    <hkern u1=""&#x3ce;"" u2=""&#x3bb;"" k=""39"" />
    <hkern u1=""&#x403;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x403;"" u2=""&#xbb;"" k=""137"" />
    <hkern u1=""&#x403;"" u2=""&#xab;"" k=""137"" />
    <hkern u1=""&#x403;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x403;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x409;"" u2=""&#x2019;"" k=""160"" />
    <hkern u1=""&#x40a;"" u2=""&#x2019;"" k=""137"" />
    <hkern u1=""&#x410;"" u2=""&#x2019;"" k=""115"" />
    <hkern u1=""&#x410;"" u2=""&#x44d;"" k=""-45"" />
    <hkern u1=""&#x410;"" u2=""&#x444;"" k=""-23"" />
    <hkern u1=""&#x410;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x410;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x410;"" u2=""&#x42d;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x427;"" k=""160"" />
    <hkern u1=""&#x410;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x410;"" u2=""&#x423;"" k=""90"" />
    <hkern u1=""&#x410;"" u2=""&#x422;"" k=""160"" />
    <hkern u1=""&#x410;"" u2=""&#x421;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x41f;"" k=""23"" />
    <hkern u1=""&#x410;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x410;"" u2=""&#x41b;"" k=""-45"" />
    <hkern u1=""&#x410;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x410;"" u2=""&#x414;"" k=""-68"" />
    <hkern u1=""&#x411;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x411;"" u2=""&#x43b;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x42f;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x42d;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x42a;"" k=""68"" />
    <hkern u1=""&#x411;"" u2=""&#x427;"" k=""92"" />
    <hkern u1=""&#x411;"" u2=""&#x425;"" k=""45"" />
    <hkern u1=""&#x411;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x423;"" k=""47"" />
    <hkern u1=""&#x411;"" u2=""&#x422;"" k=""92"" />
    <hkern u1=""&#x411;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x411;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x412;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x442;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x434;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x42f;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x42a;"" k=""115"" />
    <hkern u1=""&#x412;"" u2=""&#x427;"" k=""92"" />
    <hkern u1=""&#x412;"" u2=""&#x425;"" k=""90"" />
    <hkern u1=""&#x412;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x423;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x422;"" k=""137"" />
    <hkern u1=""&#x412;"" u2=""&#x421;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x41e;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x41b;"" k=""23"" />
    <hkern u1=""&#x412;"" u2=""&#x417;"" k=""68"" />
    <hkern u1=""&#x412;"" u2=""&#x416;"" k=""45"" />
    <hkern u1=""&#x412;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x412;"" u2=""&#x410;"" k=""68"" />
    <hkern u1=""&#x413;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x413;"" u2=""&#x44f;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x44e;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x44c;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x44b;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x443;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x440;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x43e;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x43d;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x43c;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x43b;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x438;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x435;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x434;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x432;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x430;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x42f;"" k=""68"" />
    <hkern u1=""&#x413;"" u2=""&#x421;"" k=""92"" />
    <hkern u1=""&#x413;"" u2=""&#x41e;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x41c;"" k=""47"" />
    <hkern u1=""&#x413;"" u2=""&#x41b;"" k=""115"" />
    <hkern u1=""&#x413;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x413;"" u2=""&#x414;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x410;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#xbb;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#xab;"" k=""137"" />
    <hkern u1=""&#x413;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x413;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x414;"" u2=""&#x443;"" k=""-45"" />
    <hkern u1=""&#x414;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x414;"" u2=""&#x437;"" k=""-68"" />
    <hkern u1=""&#x414;"" u2=""&#x427;"" k=""70"" />
    <hkern u1=""&#x414;"" u2=""&#x424;"" k=""45"" />
    <hkern u1=""&#x414;"" u2=""&#x423;"" k=""-23"" />
    <hkern u1=""&#x415;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x415;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x416;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x416;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x416;"" u2=""&#x435;"" k=""25"" />
    <hkern u1=""&#x416;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x416;"" u2=""&#x42a;"" k=""-45"" />
    <hkern u1=""&#x416;"" u2=""&#x423;"" k=""-45"" />
    <hkern u1=""&#x416;"" u2=""&#x422;"" k=""-23"" />
    <hkern u1=""&#x416;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x416;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x416;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x42f;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x427;"" k=""45"" />
    <hkern u1=""&#x417;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x423;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x422;"" k=""45"" />
    <hkern u1=""&#x417;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x417;"" u2=""&#x41b;"" k=""23"" />
    <hkern u1=""&#x41a;"" u2=""&#x424;"" k=""70"" />
    <hkern u1=""&#x41a;"" u2=""&#x423;"" k=""-23"" />
    <hkern u1=""&#x41a;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x41a;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x41a;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x41b;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x41b;"" u2=""&#x431;"" k=""-23"" />
    <hkern u1=""&#x41b;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x41c;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x41c;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x441;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x435;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x41c;"" u2=""&#x427;"" k=""23"" />
    <hkern u1=""&#x41c;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x43b;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x427;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x41e;"" u2=""&#x423;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x41b;"" k=""23"" />
    <hkern u1=""&#x41e;"" u2=""&#x416;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x41e;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x44f;"" k=""68"" />
    <hkern u1=""&#x420;"" u2=""&#x44d;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x43e;"" k=""90"" />
    <hkern u1=""&#x420;"" u2=""&#x435;"" k=""90"" />
    <hkern u1=""&#x420;"" u2=""&#x434;"" k=""160"" />
    <hkern u1=""&#x420;"" u2=""&#x430;"" k=""68"" />
    <hkern u1=""&#x420;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x420;"" u2=""&#x424;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x423;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x422;"" k=""92"" />
    <hkern u1=""&#x420;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x41c;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x41b;"" k=""115"" />
    <hkern u1=""&#x420;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x416;"" k=""23"" />
    <hkern u1=""&#x420;"" u2=""&#x414;"" k=""137"" />
    <hkern u1=""&#x420;"" u2=""&#x410;"" k=""137"" />
    <hkern u1=""&#x420;"" u2=""&#xbb;"" k=""115"" />
    <hkern u1=""&#x420;"" u2=""&#x3b;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x3a;"" k=""45"" />
    <hkern u1=""&#x420;"" u2=""&#x2e;"" k=""387"" />
    <hkern u1=""&#x420;"" u2=""&#x2c;"" k=""387"" />
    <hkern u1=""&#x421;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x436;"" k=""-45"" />
    <hkern u1=""&#x421;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x421;"" u2=""&#x42d;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x42a;"" k=""70"" />
    <hkern u1=""&#x421;"" u2=""&#x427;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x425;"" k=""115"" />
    <hkern u1=""&#x421;"" u2=""&#x423;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x422;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x421;"" u2=""&#x41c;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x421;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x421;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x421;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x44f;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x44e;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x44c;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x44b;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x449;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x445;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x443;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x441;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x440;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x43f;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x43e;"" k=""160"" />
    <hkern u1=""&#x422;"" u2=""&#x43c;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x43b;"" k=""92"" />
    <hkern u1=""&#x422;"" u2=""&#x43a;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x438;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x435;"" k=""115"" />
    <hkern u1=""&#x422;"" u2=""&#x432;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x430;"" k=""92"" />
    <hkern u1=""&#x422;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x422;"" u2=""&#x41e;"" k=""92"" />
    <hkern u1=""&#x422;"" u2=""&#x41b;"" k=""45"" />
    <hkern u1=""&#x422;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x422;"" u2=""&#x416;"" k=""-23"" />
    <hkern u1=""&#x422;"" u2=""&#x414;"" k=""68"" />
    <hkern u1=""&#x422;"" u2=""&#x410;"" k=""68"" />
    <hkern u1=""&#x422;"" u2=""&#xbb;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#xab;"" k=""90"" />
    <hkern u1=""&#x422;"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""&#x422;"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""&#x423;"" u2=""&#x2014;"" k=""23"" />
    <hkern u1=""&#x423;"" u2=""&#x44f;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x44e;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x449;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x448;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x446;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x445;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x441;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x440;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43f;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43e;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x43d;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43c;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x43b;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x43a;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x439;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x438;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x437;"" k=""115"" />
    <hkern u1=""&#x423;"" u2=""&#x436;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x435;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#x434;"" k=""160"" />
    <hkern u1=""&#x423;"" u2=""&#x433;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x432;"" k=""115"" />
    <hkern u1=""&#x423;"" u2=""&#x431;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x42d;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x41e;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x423;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x414;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#x410;"" k=""137"" />
    <hkern u1=""&#x423;"" u2=""&#xbb;"" k=""92"" />
    <hkern u1=""&#x423;"" u2=""&#xab;"" k=""90"" />
    <hkern u1=""&#x423;"" u2=""&#x3b;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x3a;"" k=""45"" />
    <hkern u1=""&#x423;"" u2=""&#x2e;"" k=""272"" />
    <hkern u1=""&#x423;"" u2=""&#x2c;"" k=""272"" />
    <hkern u1=""&#x424;"" u2=""&#x43b;"" k=""68"" />
    <hkern u1=""&#x424;"" u2=""&#x42f;"" k=""70"" />
    <hkern u1=""&#x424;"" u2=""&#x427;"" k=""45"" />
    <hkern u1=""&#x424;"" u2=""&#x423;"" k=""92"" />
    <hkern u1=""&#x424;"" u2=""&#x422;"" k=""115"" />
    <hkern u1=""&#x424;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x424;"" u2=""&#x414;"" k=""68"" />
    <hkern u1=""&#x424;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x425;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x425;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x425;"" u2=""&#x42d;"" k=""70"" />
    <hkern u1=""&#x425;"" u2=""&#x424;"" k=""68"" />
    <hkern u1=""&#x425;"" u2=""&#x421;"" k=""68"" />
    <hkern u1=""&#x425;"" u2=""&#x41e;"" k=""68"" />
    <hkern u1=""&#x425;"" u2=""&#x417;"" k=""45"" />
    <hkern u1=""&#x426;"" u2=""&#x430;"" k=""-45"" />
    <hkern u1=""&#x426;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x429;"" u2=""&#x443;"" k=""-45"" />
    <hkern u1=""&#x429;"" u2=""&#x430;"" k=""-23"" />
    <hkern u1=""&#x42a;"" u2=""&#x2019;"" k=""137"" />
    <hkern u1=""&#x42a;"" u2=""&#x42f;"" k=""68"" />
    <hkern u1=""&#x42c;"" u2=""&#x2019;"" k=""160"" />
    <hkern u1=""&#x42c;"" u2=""&#x42f;"" k=""92"" />
    <hkern u1=""&#x42c;"" u2=""&#x42d;"" k=""23"" />
    <hkern u1=""&#x42c;"" u2=""&#x427;"" k=""160"" />
    <hkern u1=""&#x42c;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x42c;"" u2=""&#x422;"" k=""205"" />
    <hkern u1=""&#x42c;"" u2=""&#x421;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x41e;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x41c;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x41b;"" k=""70"" />
    <hkern u1=""&#x42c;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x42c;"" u2=""&#x416;"" k=""68"" />
    <hkern u1=""&#x42c;"" u2=""&#x414;"" k=""45"" />
    <hkern u1=""&#x42c;"" u2=""&#x410;"" k=""45"" />
    <hkern u1=""&#x42d;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x42d;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x42d;"" u2=""&#x43b;"" k=""68"" />
    <hkern u1=""&#x42d;"" u2=""&#x436;"" k=""-23"" />
    <hkern u1=""&#x42d;"" u2=""&#x434;"" k=""68"" />
    <hkern u1=""&#x42d;"" u2=""&#x42f;"" k=""45"" />
    <hkern u1=""&#x42d;"" u2=""&#x425;"" k=""70"" />
    <hkern u1=""&#x42d;"" u2=""&#x41b;"" k=""68"" />
    <hkern u1=""&#x42d;"" u2=""&#x417;"" k=""23"" />
    <hkern u1=""&#x42d;"" u2=""&#x416;"" k=""25"" />
    <hkern u1=""&#x42d;"" u2=""&#x414;"" k=""68"" />
    <hkern u1=""&#x42e;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x42e;"" u2=""&#x43b;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x434;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x427;"" k=""68"" />
    <hkern u1=""&#x42e;"" u2=""&#x425;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x422;"" k=""115"" />
    <hkern u1=""&#x42e;"" u2=""&#x421;"" k=""23"" />
    <hkern u1=""&#x42e;"" u2=""&#x41e;"" k=""23"" />
    <hkern u1=""&#x42e;"" u2=""&#x41b;"" k=""92"" />
    <hkern u1=""&#x42e;"" u2=""&#x416;"" k=""45"" />
    <hkern u1=""&#x42e;"" u2=""&#x414;"" k=""90"" />
    <hkern u1=""&#x42e;"" u2=""&#x410;"" k=""68"" />
    <hkern u1=""&#x430;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x430;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x430;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x430;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x44f;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x44d;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x44a;"" k=""68"" />
    <hkern u1=""&#x431;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x431;"" u2=""&#x445;"" k=""68"" />
    <hkern u1=""&#x431;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x43c;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x43b;"" k=""92"" />
    <hkern u1=""&#x431;"" u2=""&#x437;"" k=""45"" />
    <hkern u1=""&#x431;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x431;"" u2=""&#x434;"" k=""92"" />
    <hkern u1=""&#x431;"" u2=""&#x430;"" k=""47"" />
    <hkern u1=""&#x432;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x44a;"" k=""68"" />
    <hkern u1=""&#x432;"" u2=""&#x447;"" k=""92"" />
    <hkern u1=""&#x432;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x443;"" k=""45"" />
    <hkern u1=""&#x432;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x432;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x43b;"" k=""47"" />
    <hkern u1=""&#x432;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x434;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x432;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x433;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x433;"" u2=""&#x441;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x43e;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x433;"" u2=""&#x435;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x434;"" k=""92"" />
    <hkern u1=""&#x433;"" u2=""&#x430;"" k=""45"" />
    <hkern u1=""&#x433;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x433;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x434;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x434;"" u2=""&#x44a;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x435;"" u2=""&#x445;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x435;"" u2=""&#x442;"" k=""68"" />
    <hkern u1=""&#x435;"" u2=""&#x43b;"" k=""68"" />
    <hkern u1=""&#x435;"" u2=""&#x437;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x435;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x435;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x436;"" u2=""&#x44a;"" k=""-45"" />
    <hkern u1=""&#x436;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x436;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x436;"" u2=""&#x431;"" k=""-23"" />
    <hkern u1=""&#x437;"" u2=""&#x44a;"" k=""45"" />
    <hkern u1=""&#x437;"" u2=""&#x447;"" k=""68"" />
    <hkern u1=""&#x437;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x43b;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x437;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x437;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x43a;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x442;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x441;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x43b;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x437;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x435;"" k=""-23"" />
    <hkern u1=""&#x43a;"" u2=""&#x431;"" k=""-45"" />
    <hkern u1=""&#x43a;"" u2=""&#x430;"" k=""-45"" />
    <hkern u1=""&#x43b;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x43b;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x43c;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x43c;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x43c;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x43e;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x43e;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x43e;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x43e;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x440;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x440;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x440;"" u2=""&#x43b;"" k=""70"" />
    <hkern u1=""&#x440;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x440;"" u2=""&#x434;"" k=""47"" />
    <hkern u1=""&#x441;"" u2=""&#x44d;"" k=""-23"" />
    <hkern u1=""&#x441;"" u2=""&#x447;"" k=""23"" />
    <hkern u1=""&#x441;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x441;"" u2=""&#x436;"" k=""-23"" />
    <hkern u1=""&#x442;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x442;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x442;"" u2=""&#x436;"" k=""-68"" />
    <hkern u1=""&#x442;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x434;"" k=""68"" />
    <hkern u1=""&#x442;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x442;"" u2=""&#x2e;"" k=""227"" />
    <hkern u1=""&#x442;"" u2=""&#x2c;"" k=""227"" />
    <hkern u1=""&#x443;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x44d;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x440;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x43e;"" k=""25"" />
    <hkern u1=""&#x443;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x443;"" u2=""&#x436;"" k=""-23"" />
    <hkern u1=""&#x443;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#x434;"" k=""68"" />
    <hkern u1=""&#x443;"" u2=""&#x431;"" k=""-23"" />
    <hkern u1=""&#x443;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x443;"" u2=""&#xbb;"" k=""-23"" />
    <hkern u1=""&#x443;"" u2=""&#x2e;"" k=""205"" />
    <hkern u1=""&#x443;"" u2=""&#x2c;"" k=""205"" />
    <hkern u1=""&#x444;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x444;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x443;"" k=""23"" />
    <hkern u1=""&#x444;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x444;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x445;"" u2=""&#x444;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x442;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x431;"" k=""23"" />
    <hkern u1=""&#x445;"" u2=""&#x430;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x441;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x446;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x449;"" u2=""&#x443;"" k=""-23"" />
    <hkern u1=""&#x449;"" u2=""&#x43e;"" k=""23"" />
    <hkern u1=""&#x449;"" u2=""&#x435;"" k=""23"" />
    <hkern u1=""&#x44c;"" u2=""&#x447;"" k=""137"" />
    <hkern u1=""&#x44c;"" u2=""&#x442;"" k=""160"" />
    <hkern u1=""&#x44d;"" u2=""&#x44f;"" k=""23"" />
    <hkern u1=""&#x44d;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x44d;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x44d;"" u2=""&#x43e;"" k=""-23"" />
    <hkern u1=""&#x44d;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x44d;"" u2=""&#x437;"" k=""23"" />
    <hkern u1=""&#x44d;"" u2=""&#x435;"" k=""-23"" />
    <hkern u1=""&#x44d;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x447;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x445;"" k=""23"" />
    <hkern u1=""&#x44e;"" u2=""&#x442;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x43c;"" k=""23"" />
    <hkern u1=""&#x44e;"" u2=""&#x43b;"" k=""45"" />
    <hkern u1=""&#x44e;"" u2=""&#x436;"" k=""23"" />
    <hkern u1=""&#x44e;"" u2=""&#x434;"" k=""45"" />
    <hkern u1=""&#x45e;"" u2=""&#x2e;"" k=""205"" />
    <hkern u1=""&#x45e;"" u2=""&#x2c;"" k=""205"" />
    <hkern u1=""&#x490;"" u2=""&#x2014;"" k=""45"" />
    <hkern u1=""&#x490;"" u2=""&#xbb;"" k=""160"" />
    <hkern u1=""&#x490;"" u2=""&#xab;"" k=""160"" />
    <hkern u1=""&#x490;"" u2=""&#x3b;"" k=""45"" />
    <hkern u1=""&#x490;"" u2=""&#x3a;"" k=""45"" />
    <hkern u1=""&#x490;"" u2=""&#x2e;"" k=""250"" />
    <hkern u1=""&#x490;"" u2=""&#x2c;"" k=""250"" />
    <hkern u1=""&#x2018;"" u2=""&#x2018;"" k=""37"" />
    <hkern u1=""&#x2019;"" u2=""&#x2019;"" k=""37"" />
    <hkern u1=""&#x2019;"" u2=""s"" k=""37"" />
    <hkern u1=""&#x2019;"" u2=""&#x20;"" k=""76"" />
    <hkern u1=""&#x201e;"" u2=""&#x42a;"" k=""68"" />
    <hkern u1=""&#x201e;"" u2=""&#x427;"" k=""68"" />
    <hkern u1=""&#x201e;"" u2=""&#x422;"" k=""160"" />
    <hkern u1=""&#x201e;"" u2=""&#x40b;"" k=""160"" />
    <hkern u1=""&#x201e;"" u2=""&#x402;"" k=""160"" />
  </font>
</defs></svg>";
        }
    }
}

#endregion //LiberationSansFont.cs
#region MathHelper.cs

namespace MatterHackers.VectorMath
{
    /// <summary>
    /// Contains common mathematical functions and constants.
    /// </summary>
    public static class MathHelper
    {
        #region Fields

        /// <summary>
        /// Defines the value of Pi as a <see cref="System.Single"/>.
        /// </summary>
        public const double Pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930382f;

        public const double Tau = Pi * 2;

        /// <summary>
        /// Defines the value of Pi divided by two as a <see cref="System.Single"/>.
        /// </summary>
        public const double PiOver2 = Pi / 2;

        /// <summary>
        /// Defines the value of Pi divided by three as a <see cref="System.Single"/>.
        /// </summary>
        public const double PiOver3 = Pi / 3;

        /// <summary>
        /// Definesthe value of  Pi divided by four as a <see cref="System.Single"/>.
        /// </summary>
        public const double PiOver4 = Pi / 4;

        /// <summary>
        /// Defines the value of Pi divided by six as a <see cref="System.Single"/>.
        /// </summary>
        public const double PiOver6 = Pi / 6;

        /// <summary>
        /// Defines the value of Pi multiplied by two as a <see cref="System.Single"/>.
        /// </summary>
        public const double TwoPi = 2 * Pi;

        /// <summary>
        /// Defines the value of Pi multiplied by 3 and divided by two as a <see cref="System.Single"/>.
        /// </summary>
        public const double ThreePiOver2 = 3 * Pi / 2;

        /// <summary>
        /// Defines the value of E as a <see cref="System.Single"/>.
        /// </summary>
        public const double E = 2.71828182845904523536f;

        /// <summary>
        /// Defines the base-10 logarithm of E.
        /// </summary>
        public const double Log10E = 0.434294482f;

        /// <summary>
        /// Defines the base-2 logarithm of E.
        /// </summary>
        public const double Log2E = 1.442695041f;

        #endregion

        #region Public Members

        #region NextPowerOfTwo

        /// <summary>
        /// Returns the next power of two that is larger than the specified number.
        /// </summary>
        /// <param name="n">The specified number.</param>
        /// <returns>The next power of two.</returns>
        public static long NextPowerOfTwo(long n)
        {
            if (n < 0) throw new ArgumentOutOfRangeException("n", "Must be positive.");
            return (long)System.Math.Pow(2, System.Math.Ceiling(System.Math.Log((double)n, 2)));
        }

        /// <summary>
        /// Returns the next power of two that is larger than the specified number.
        /// </summary>
        /// <param name="n">The specified number.</param>
        /// <returns>The next power of two.</returns>
        public static int NextPowerOfTwo(int n)
        {
            if (n < 0) throw new ArgumentOutOfRangeException("n", "Must be positive.");
            return (int)System.Math.Pow(2, System.Math.Ceiling(System.Math.Log((double)n, 2)));
        }

        /// <summary>
        /// Returns the next power of two that is larger than the specified number.
        /// </summary>
        /// <param name="n">The specified number.</param>
        /// <returns>The next power of two.</returns>
        public static float NextPowerOfTwo(float n)
        {
            if (n < 0) throw new ArgumentOutOfRangeException("n", "Must be positive.");
            return (float)System.Math.Pow(2, System.Math.Ceiling(System.Math.Log((double)n, 2)));
        }

        /// <summary>
        /// Returns the next power of two that is larger than the specified number.
        /// </summary>
        /// <param name="n">The specified number.</param>
        /// <returns>The next power of two.</returns>
        public static double NextPowerOfTwo(double n)
        {
            if (n < 0) throw new ArgumentOutOfRangeException("n", "Must be positive.");
            return System.Math.Pow(2, System.Math.Ceiling(System.Math.Log((double)n, 2)));
        }

        #endregion

        #region Factorial

        /// <summary>Calculates the factorial of a given natural number.
        /// </summary>
        /// <param name="n">The number.</param>
        /// <returns>n!</returns>
        public static long Factorial(int n)
        {
            long result = 1;

            for (; n > 1; n--)
                result *= n;

            return result;
        }

        #endregion

        #region BinomialCoefficient

        /// <summary>
        /// Calculates the binomial coefficient <paramref name="n"/> above <paramref name="k"/>.
        /// </summary>
        /// <param name="n">The n.</param>
        /// <param name="k">The k.</param>
        /// <returns>n! / (k! * (n - k)!)</returns>
        public static long BinomialCoefficient(int n, int k)
        {
            return Factorial(n) / (Factorial(k) * Factorial(n - k));
        }

        #endregion

        static public double Range0ToTau(double Value)
        {
            if (Value < 0)
            {
                Value += Tau;
            }

            if (Value >= Tau)
            {
                Value -= Tau;
            }

            if (Value < 0 || Value > Tau) throw new Exception("Value >= 0 && Value <= Tau");

            return Value;
        }


        static public double GetDeltaAngle(double StartAngle, double EndAngle)
        {
            if (StartAngle != Range0ToTau(StartAngle)) throw new Exception("StartAngle != Range0ToTau(StartAngle)");
            if (EndAngle != Range0ToTau(EndAngle)) throw new Exception("EndAngle != Range0ToTau(EndAngle)");

            double DeltaAngle = EndAngle - StartAngle;
            if (DeltaAngle > Tau / 2)
            {
                DeltaAngle -= Tau;
            }

            if (DeltaAngle < -Tau / 2)
            {
                DeltaAngle += Tau;
            }

            return DeltaAngle;
        }

        #region DegreesToRadians

        /// <summary>
        /// Convert degrees to radians
        /// </summary>
        /// <param name="degrees">An angle in degrees</param>
        /// <returns>The angle expressed in radians</returns>
        public static double DegreesToRadians(double degrees)
        {
            const double degToRad = System.Math.PI / 180.0f;
            return degrees * degToRad;
        }

        /// <summary>
        /// Convert radians to degrees
        /// </summary>
        /// <param name="radians">An angle in radians</param>
        /// <returns>The angle expressed in degrees</returns>
        public static double RadiansToDegrees(double radians)
        {
            const double radToDeg = 180.0f / System.Math.PI;
            return radians * radToDeg;
        }

        #endregion

        #region Swap

        /// <summary>
        /// Swaps two double values.
        /// </summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        public static void Swap(ref double a, ref double b)
        {
            double temp = a;
            a = b;
            b = temp;
        }

        /// <summary>
        /// Swaps two float values.
        /// </summary>
        /// <param name="a">The first value.</param>
        /// <param name="b">The second value.</param>
        public static void Swap(ref float a, ref float b)
        {
            float temp = a;
            a = b;
            b = temp;
        }

        #endregion

        #endregion

        public static bool AlmostEqual(double a, double b, double differenceAllowed)
        {
            if (a > b - differenceAllowed && a < b + differenceAllowed)
            {
                return true;
            }

            return false;
        }
    }
}

#endregion //MathHelper.cs
#region Matrix4x4@agg.cs

//namespace AGG
//{
//    public class Matrix4X4
//    {
//        double[] matrix = new double[16];

//        public Matrix4X4()
//        {
//            SetElement(0, 0, 1.0f);
//            SetElement(1, 1, 1.0f);
//            SetElement(2, 2, 1.0f);
//            SetElement(3, 3, 1.0f);
//        }

//        public Matrix4X4(Matrix4X4 CopyFrom)
//        {
//            for (int i = 0; i < 16; i++)
//            {
//                matrix[i] = CopyFrom.matrix[i];
//            }
//        }

//        public Matrix4X4(double[] CopyFrom)
//        {
//            SetElements(CopyFrom);
//        }

//        public double this[int index]
//        {
//            get
//            {
//                return matrix[index];
//            }

//            set
//            {
//                matrix[index] = value;
//            }
//        }

//        public double this[int row, int column]
//        {
//            get
//            {
//                return GetElement(row, column);
//            }

//            set
//            {
//                SetElement(row, column, value);
//            }
//        }

//        public double GetElement(int Row, int Column)
//        {
//            return matrix[Row * 4 + Column];
//        }

//        public void SetElement(int Row, int Column, double Value)
//        {
//            matrix[Row * 4 + Column] = Value;
//        }

//        public void AddElement(int Row, int Column, double Value)
//        {
//            matrix[Row * 4 + Column] += Value;
//        }

//        public void Identity()
//        {
//            Zero();
//            SetElement(0, 0, 1.0f);
//            SetElement(1, 1, 1.0f);
//            SetElement(2, 2, 1.0f);
//            SetElement(3, 3, 1.0f);
//        }

//        public void Zero()
//        {
//            for (int i = 0; i < 16; i++)
//            {
//                matrix[i] = 0;
//            }
//        }

//        // A bit of code from Intel LBB [10/29/2003]
//        /************************************************************
//        *
//        * input:
//        * mat - pointer to array of 16 doubles (source matrix)
//        * output:
//        * dst - pointer to array of 16 doubles (invert matrix)
//        *
//        Version														Cycles
//        C code with Cramer's rule									846
//        C code with Cramer's rule & Streaming SIMD Extensions		210
//        *************************************************************/
//        static void IntelInvertC(double[] matrixToInvert, double[] destMatrix)
//        {
//            double[] tmp = new double[12]; /* temp array for pairs */
//            double[] src = new double[16]; /* array of transpose source matrix */
//            double det; /* determinant */
//            /* transpose matrix */
//            for (int i = 0; i < 4; i++)
//            {
//                src[i] = matrixToInvert[i * 4];
//                src[i + 4] = matrixToInvert[i * 4 + 1];
//                src[i + 8] = matrixToInvert[i * 4 + 2];
//                src[i + 12] = matrixToInvert[i * 4 + 3];
//            }
//            /* calculate pairs for first 8 elements (cofactors) */
//            tmp[0] = src[10] * src[15];
//            tmp[1] = src[11] * src[14];
//            tmp[2] = src[9] * src[15];
//            tmp[3] = src[11] * src[13];
//            tmp[4] = src[9] * src[14];
//            tmp[5] = src[10] * src[13];
//            tmp[6] = src[8] * src[15];
//            tmp[7] = src[11] * src[12];
//            tmp[8] = src[8] * src[14];
//            tmp[9] = src[10] * src[12];
//            tmp[10] = src[8] * src[13];
//            tmp[11] = src[9] * src[12];
//            /* calculate first 8 elements (cofactors) */
//            destMatrix[0] = tmp[0] * src[5] + tmp[3] * src[6] + tmp[4] * src[7];
//            destMatrix[0] -= tmp[1] * src[5] + tmp[2] * src[6] + tmp[5] * src[7];
//            destMatrix[1] = tmp[1] * src[4] + tmp[6] * src[6] + tmp[9] * src[7];
//            destMatrix[1] -= tmp[0] * src[4] + tmp[7] * src[6] + tmp[8] * src[7];
//            destMatrix[2] = tmp[2] * src[4] + tmp[7] * src[5] + tmp[10] * src[7];
//            destMatrix[2] -= tmp[3] * src[4] + tmp[6] * src[5] + tmp[11] * src[7];
//            destMatrix[3] = tmp[5] * src[4] + tmp[8] * src[5] + tmp[11] * src[6];
//            destMatrix[3] -= tmp[4] * src[4] + tmp[9] * src[5] + tmp[10] * src[6];
//            destMatrix[4] = tmp[1] * src[1] + tmp[2] * src[2] + tmp[5] * src[3];
//            destMatrix[4] -= tmp[0] * src[1] + tmp[3] * src[2] + tmp[4] * src[3];
//            destMatrix[5] = tmp[0] * src[0] + tmp[7] * src[2] + tmp[8] * src[3];
//            destMatrix[5] -= tmp[1] * src[0] + tmp[6] * src[2] + tmp[9] * src[3];
//            destMatrix[6] = tmp[3] * src[0] + tmp[6] * src[1] + tmp[11] * src[3];
//            destMatrix[6] -= tmp[2] * src[0] + tmp[7] * src[1] + tmp[10] * src[3];
//            destMatrix[7] = tmp[4] * src[0] + tmp[9] * src[1] + tmp[10] * src[2];
//            destMatrix[7] -= tmp[5] * src[0] + tmp[8] * src[1] + tmp[11] * src[2];
//            /* calculate pairs for second 8 elements (cofactors) */
//            tmp[0] = src[2] * src[7];
//            tmp[1] = src[3] * src[6];
//            tmp[2] = src[1] * src[7];
//            tmp[3] = src[3] * src[5];
//            tmp[4] = src[1] * src[6];
//            tmp[5] = src[2] * src[5];
//            tmp[6] = src[0] * src[7];
//            tmp[7] = src[3] * src[4];
//            tmp[8] = src[0] * src[6];
//            tmp[9] = src[2] * src[4];
//            tmp[10] = src[0] * src[5];
//            tmp[11] = src[1] * src[4];
//            /* calculate second 8 elements (cofactors) */
//            destMatrix[8] = tmp[0] * src[13] + tmp[3] * src[14] + tmp[4] * src[15];
//            destMatrix[8] -= tmp[1] * src[13] + tmp[2] * src[14] + tmp[5] * src[15];
//            destMatrix[9] = tmp[1] * src[12] + tmp[6] * src[14] + tmp[9] * src[15];
//            destMatrix[9] -= tmp[0] * src[12] + tmp[7] * src[14] + tmp[8] * src[15];
//            destMatrix[10] = tmp[2] * src[12] + tmp[7] * src[13] + tmp[10] * src[15];
//            destMatrix[10] -= tmp[3] * src[12] + tmp[6] * src[13] + tmp[11] * src[15];
//            destMatrix[11] = tmp[5] * src[12] + tmp[8] * src[13] + tmp[11] * src[14];
//            destMatrix[11] -= tmp[4] * src[12] + tmp[9] * src[13] + tmp[10] * src[14];
//            destMatrix[12] = tmp[2] * src[10] + tmp[5] * src[11] + tmp[1] * src[9];
//            destMatrix[12] -= tmp[4] * src[11] + tmp[0] * src[9] + tmp[3] * src[10];
//            destMatrix[13] = tmp[8] * src[11] + tmp[0] * src[8] + tmp[7] * src[10];
//            destMatrix[13] -= tmp[6] * src[10] + tmp[9] * src[11] + tmp[1] * src[8];
//            destMatrix[14] = tmp[6] * src[9] + tmp[11] * src[11] + tmp[3] * src[8];
//            destMatrix[14] -= tmp[10] * src[11] + tmp[2] * src[8] + tmp[7] * src[9];
//            destMatrix[15] = tmp[10] * src[10] + tmp[4] * src[8] + tmp[9] * src[9];
//            destMatrix[15] -= tmp[8] * src[9] + tmp[11] * src[10] + tmp[5] * src[8];
//            /* calculate determinant */
//            det = src[0] * destMatrix[0] + src[1] * destMatrix[1] + src[2] * destMatrix[2] + src[3] * destMatrix[3];
//            /* calculate matrix inverse */
//            det = 1 / det;
//            for (int j = 0; j < 16; j++)
//            {
//                destMatrix[j] *= det;
//            }
//        }

//        public bool SetToInverse(Matrix4X4 OriginalMatrix)
//        {
//            IntelInvertC(OriginalMatrix.matrix, matrix);
//            return true;
//        }

//        public bool Invert()
//        {
//            Matrix4X4 Temp = new Matrix4X4(this);
//            return SetToInverse(Temp);
//        }

//        private void matrix_swap_mirror(int a, int b)
//        {
//            double Temp = GetElement(a, b);
//            SetElement(a, b, GetElement(b, a));
//            SetElement(b, a, Temp);
//        }

//        public void Transpose3X3()
//        {
//            matrix_swap_mirror(0, 1);
//            matrix_swap_mirror(0, 2);
//            matrix_swap_mirror(0, 3);
//            matrix_swap_mirror(1, 2);
//            matrix_swap_mirror(1, 3);
//            matrix_swap_mirror(2, 3);
//        }

//        public Vector3 Position
//        {
//            get
//            {
//                return new Vector3(GetElement(3, 0), GetElement(3, 1), GetElement(3, 2));
//            }

//            set
//            {
//                SetElement(3, 0, value.x);
//                SetElement(3, 1, value.y);
//                SetElement(3, 2, value.z);
//            }
//        }

//        public void Translate(double tx, double ty, double tz)
//        {
//            int i;

//            Zero();
//            for (i = 0; i < 4; i++)
//            {
//                SetElement(i, i, 1.0f);
//            }

//            // <Simon 2002/05/02> fixed matrix ordering problem
//            SetElement(3, 0, tx);
//            SetElement(3, 1, ty);
//            SetElement(3, 2, tz);
//        }

//        public void Translate(Vector3 Vect)
//        {
//            Translate(Vect.x, Vect.y, Vect.z);
//        }

//        public void AddTranslate(double x, double y, double z)
//        {
//            AddTranslate(new Vector3(x, y, z));
//        }

//        public void AddTranslate(Vector3 Vect)
//        {
//            Matrix4X4 Temp = new Matrix4X4();
//            Temp.Translate(Vect.x, Vect.y, Vect.z);

//            Multiply(Temp);
//        }

//        public void Scale(float sx, float sy, float sz)
//        {
//            Scale((double)sx, (double)sy, (double)sz);
//        }

//        public void Scale(double sx, double sy, double sz)
//        {
//            Zero();
//            SetElement(0, 0, sx);
//            SetElement(1, 1, sy);
//            SetElement(2, 2, sz);
//            SetElement(3, 3, 1.0f);
//        }

//        public void AddRotate(uint Axis, double Theta)
//        {
//            Matrix4X4 Temp = new Matrix4X4();
//            Temp.Rotate(Axis, Theta);

//            Multiply(Temp);
//        }

//        public void Rotate(uint Axis, double Theta)
//        {
//            double c, s;

//            if (Theta != 0)
//            {
//                c = (double)System.Math.Cos(Theta);
//                s = (double)System.Math.Sin(Theta);
//            }
//            else
//            {
//                c = 1.0f;
//                s = 0.0f;
//            }

//            switch (Axis)
//            {
//                case 0:
//                    SetElement(0, 0, 1.0f);
//                    SetElement(0, 1, 0.0f);
//                    SetElement(0, 2, 0.0f);
//                    SetElement(0, 3, 0.0f);

//                    SetElement(1, 0, 0.0f);
//                    SetElement(1, 1, c);
//                    SetElement(1, 2, s);
//                    SetElement(1, 3, 0.0f);

//                    SetElement(2, 0, 0.0f);
//                    SetElement(2, 1, -s);
//                    SetElement(2, 2, c);
//                    SetElement(2, 3, 0.0f);
//                    break;

//                case 1:
//                    SetElement(0, 0, c);
//                    SetElement(0, 1, 0.0f);
//                    SetElement(0, 2, -s);
//                    SetElement(0, 3, 0.0f);

//                    SetElement(1, 0, 0.0f);
//                    SetElement(1, 1, 1.0f);
//                    SetElement(1, 2, 0.0f);
//                    SetElement(1, 3, 0.0f);

//                    SetElement(2, 0, s);
//                    SetElement(2, 1, 0.0f);
//                    SetElement(2, 2, c);
//                    SetElement(2, 3, 0.0f);
//                    break;

//                case 2:
//                    SetElement(0, 0, c);
//                    SetElement(0, 1, s);
//                    SetElement(0, 2, 0.0f);
//                    SetElement(0, 3, 0.0f);

//                    SetElement(1, 0, -s);
//                    SetElement(1, 1, c);
//                    SetElement(1, 2, 0.0f);
//                    SetElement(1, 3, 0.0f);

//                    SetElement(2, 0, 0.0f);
//                    SetElement(2, 1, 0.0f);
//                    SetElement(2, 2, 1.0f);
//                    SetElement(2, 3, 0.0f);
//                    break;
//            }

//            // set the ones that don't change
//            SetElement(3, 0, 0.0f);
//            SetElement(3, 1, 0.0f);
//            SetElement(3, 2, 0.0f);
//            SetElement(3, 3, 1.0f);
//        }

//        public void Rotate(Vector3 Axis, double AngleRadians)
//        {
//            Axis.Normalize();

//            double Cos = (double)System.Math.Cos(AngleRadians);
//            double Sin = (double)System.Math.Sin(AngleRadians);

//            double OneMinusCos = 1.0f - Cos;

//            matrix[0 + 4 * 0] = OneMinusCos * Axis.x * Axis.x + Cos;
//            matrix[0 + 4 * 1] = OneMinusCos * Axis.x * Axis.y - Sin * Axis.z;
//            matrix[0 + 4 * 2] = OneMinusCos * Axis.x * Axis.z + Sin * Axis.y;
//            matrix[0 + 4 * 3] = 0.0f;

//            matrix[1 + 4 * 0] = OneMinusCos * Axis.x * Axis.y + Sin * Axis.z;
//            matrix[1 + 4 * 1] = OneMinusCos * Axis.y * Axis.y + Cos;
//            matrix[1 + 4 * 2] = OneMinusCos * Axis.y * Axis.z - Sin * Axis.x;
//            matrix[1 + 4 * 3] = 0.0f;

//            matrix[2 + 4 * 0] = OneMinusCos * Axis.x * Axis.z - Sin * Axis.y;
//            matrix[2 + 4 * 1] = OneMinusCos * Axis.y * Axis.z + Sin * Axis.x;
//            matrix[2 + 4 * 2] = OneMinusCos * Axis.z * Axis.z + Cos;
//            matrix[2 + 4 * 3] = 0.0f;

//            matrix[3 + 4 * 0] = 0.0f;
//            matrix[3 + 4 * 1] = 0.0f;
//            matrix[3 + 4 * 2] = 0.0f;
//            matrix[3 + 4 * 3] = 1.0f;
//        }

//        public bool Equals(Matrix4X4 OtherMatrix, double ErrorRange)
//        {
//            for (int i = 0; i < 4; i++)
//            {
//                for (int j = 0; j < 4; j++)
//                {
//                    if (GetElement(i, j) < OtherMatrix.GetElement(i, j) - ErrorRange
//                        || GetElement(i, j) > OtherMatrix.GetElement(i, j) + ErrorRange)
//                    {
//                        return false;
//                    }
//                }
//            }

//            return true;
//        }

//        public void PrepareMatrix(double Tx, double Ty, double Tz, double Rx, double Ry, double Rz, double Sx, double Sy, double Sz)
//        {
//            bool Initialized = false;

//            if (Sx != 1.0f || Sy != 1.0f || Sz != 1.0f)
//            {
//                if (Initialized)
//                {
//                    Matrix4X4 Temp = new Matrix4X4();
//                    Temp.Scale(Sx, Sy, Sz);
//                    Multiply(Temp);
//                }
//                else
//                {
//                    Scale(Sx, Sy, Sz);
//                    Initialized = true;
//                }
//            }
//            if (Rx != .0f)
//            {
//                if (Initialized)
//                {
//                    Matrix4X4 Temp = new Matrix4X4();
//                    Temp.Rotate(0, Rx);
//                    Multiply(Temp);
//                }
//                else
//                {
//                    Rotate(0, Rx);
//                    Initialized = true;
//                }
//            }
//            if (Ry != .0f)
//            {
//                if (Initialized)
//                {
//                    Matrix4X4 Temp = new Matrix4X4();
//                    Temp.Rotate(1, Ry);
//                    Multiply(Temp);
//                }
//                else
//                {
//                    Rotate(1, Ry);
//                    Initialized = true;
//                }
//            }
//            if (Rz != .0f)
//            {
//                if (Initialized)
//                {
//                    Matrix4X4 Temp = new Matrix4X4();
//                    Temp.Rotate(2, Rz);
//                    Multiply(Temp);
//                }
//                else
//                {
//                    Rotate(2, Rz);
//                    Initialized = true;
//                }
//            }
//            if (Tx != 0.0f || Ty != 0.0f || Tz != 0.0f)
//            {
//                if (Initialized)
//                {
//                    Matrix4X4 Temp = new Matrix4X4();
//                    Temp.Translate(Tx, Ty, Tz);
//                    Multiply(Temp);
//                }
//                else
//                {
//                    Translate(Tx, Ty, Tz);
//                    Initialized = true;
//                }

//                if (!Initialized)
//                {
//                    Identity();
//                }
//            }
//        }

//        public void PrepareMatrix(Vector3 pTranslateVector, Vector3 pRotateVector, Vector3 pScaleVector)
//        {
//            PrepareMatrix(pTranslateVector.x, pTranslateVector.y, pTranslateVector.z,
//                pRotateVector.x, pRotateVector.y, pRotateVector.z,
//                pScaleVector.x, pScaleVector.y, pScaleVector.z);
//        }

//        public void PrepareMatrixFromPositionAndDirection(Vector3 Position, Vector3 Direction)
//        {
//            // Setup translation part.
//            Translate(Position);

//            // Do orientation.
//            Vector3 YAxis = Direction;
//            YAxis.Normalize();

//            // Generate a candidate for the x axis.

//            // Try the world x axis first.
//            Vector3 XAxis = new Vector3(1.0f, 0.0f, 0.0f);

//            double Threshold = (double)System.Math.Cos(10.0f * MathHelper.Tau / 360);

//            if (Vector3.Dot(YAxis, XAxis) > Threshold)
//            {
//                // Too close so use the world y axis.
//                XAxis = new Vector3(0.0f, 1.0f, 0.0f);
//            }

//            // Get the z axis from the cross product.
//            Vector3 ZAxis = Vector3.Cross(XAxis, YAxis);
//            ZAxis.Normalize();

//            // Get the true x axis from y and z.
//            XAxis = Vector3.Cross(YAxis, ZAxis);

//            for (int i = 0; i < 3; i++)
//            {
//                SetElement(0, i, XAxis[i]);
//                SetElement(1, i, YAxis[i]);
//                SetElement(2, i, ZAxis[i]);
//            }

//            SetElement(0, 3, 0.0f);
//            SetElement(1, 3, 0.0f);
//            SetElement(2, 3, 0.0f);

//        }

//        public void PrepareInvMatrix(double Tx, double Ty, double Tz, double Rx, double Ry, double Rz, double Sx, double Sy, double Sz)
//        {
//            Matrix4X4 M0 = new Matrix4X4();
//            Matrix4X4 M1 = new Matrix4X4();
//            Matrix4X4 M2 = new Matrix4X4();
//            Matrix4X4 M3 = new Matrix4X4();
//            Matrix4X4 M4 = new Matrix4X4();
//            Matrix4X4 M5 = new Matrix4X4();
//            Matrix4X4 M6 = new Matrix4X4();
//            Matrix4X4 M7 = new Matrix4X4();

//            M0.Scale(Sx, Sy, Sz);
//            M1.Rotate(0, Rx);
//            M2.Rotate(1, Ry);
//            M3.Rotate(2, Rz);
//            M4.Translate(Tx, Ty, Tz);
//            // 4 * 3 * 2 * 1 * 0
//            M5.Multiply(M4, M3);
//            M6.Multiply(M5, M2);
//            M7.Multiply(M6, M1);
//            Multiply(M7, M0);
//        }

//        public void PrepareInvMatrix(Vector3 pTranslateVector, Vector3 pRotateVector, Vector3 pScaleVector)
//        {
//            PrepareInvMatrix(pTranslateVector.x, pTranslateVector.y, pTranslateVector.z,
//                             pRotateVector.x, pRotateVector.y, pRotateVector.z,
//                             pScaleVector.x, pScaleVector.y, pScaleVector.z);
//        }

//        public void TransformVector(double[] pChanged)
//        {
//            double[] Hold = (double[])pChanged.Clone();
//            pChanged[0] = GetElement(0, 0) * Hold[0] + GetElement(0, 1) * Hold[1] + GetElement(0, 2) * Hold[2] + GetElement(0, 3) * Hold[3];
//            pChanged[1] = GetElement(1, 0) * Hold[0] + GetElement(1, 1) * Hold[1] + GetElement(1, 2) * Hold[2] + GetElement(1, 3) * Hold[3];
//            pChanged[2] = GetElement(2, 0) * Hold[0] + GetElement(2, 1) * Hold[1] + GetElement(2, 2) * Hold[2] + GetElement(2, 3) * Hold[3];
//            pChanged[3] = GetElement(3, 0) * Hold[0] + GetElement(3, 1) * Hold[1] + GetElement(3, 2) * Hold[2] + GetElement(3, 3) * Hold[3];
//        }

//        public void TransformVector(ref Vector3 Changed)
//        {
//            Vector3 Original = Changed;
//            TransformVector(out Changed, Original);
//        }

//        public void TransformVector(out Vector3 Changed, Vector3 Original)
//        {
//            TransformVector3X3(out Changed, Original);
//            Changed.x += GetElement(3, 0);
//            Changed.y += GetElement(3, 1);
//            Changed.z += GetElement(3, 2);
//        }

//        public void TransformVector3X3(ref Vector3 Changed)
//        {
//            Vector3 Original = new Vector3(Changed);
//            TransformVector3X3(out Changed, Original);
//        }

//        public void TransformVector3X3(out Vector3 Changed, Vector3 Original)
//        {
//            Changed.x = GetElement(0, 0) * Original.x + GetElement(1, 0) * Original.y + GetElement(2, 0) * Original.z;
//            Changed.y = GetElement(0, 1) * Original.x + GetElement(1, 1) * Original.y + GetElement(2, 1) * Original.z;
//            Changed.z = GetElement(0, 2) * Original.x + GetElement(1, 2) * Original.y + GetElement(2, 2) * Original.z;
//        }

//        public void TransformVector3X3(Vector3[] vertsToTransform)
//        {
//            for (int i = 0; i < vertsToTransform.Length; i++)
//            {
//                TransformVector3X3(ref vertsToTransform[i]);
//            }
//        }

//        public uint ValidateMatrix()
//        {
//            if (GetElement(3, 0) == 0.0f && GetElement(3, 1) == 0.0f && GetElement(3, 2) == 0.0f && GetElement(3, 3) == 1.0f)
//            {
//                return 1;
//            }

//            return 0;
//        }

//        public static Matrix4X4 operator *(Matrix4X4 A, Matrix4X4 B)
//        {
//            Matrix4X4 Temp = new Matrix4X4(A);
//            Temp.Multiply(B);
//            return Temp;
//        }

//        public void Multiply(Matrix4X4 Two)
//        {
//            Matrix4X4 Hold = new Matrix4X4(this);
//            Multiply(Hold, Two);
//        }

//        public void Multiply(Matrix4X4 One, Matrix4X4 Two)
//        {
//            if (this == One || this == Two)
//            {
//                throw new System.FormatException("Neither of the input parameters can be the same Matrix as this.");
//            }

//            for (int i = 0; i < 4; i++)
//            {
//                for (int j = 0; j < 4; j++)
//                {
//                    SetElement(i, j, 0);
//                    for (int k = 0; k < 4; k++)
//                    {
//                        AddElement(i, j, One.GetElement(i, k) * Two.GetElement(k, j));
//                    }
//                }
//            }
//        }

//        // Returns the X-axis vector from this matrix
//        public void GetXAxisVector(Vector3 result)
//        {
//            // stored as row vectors
//            result.x = GetElement(0, 0);
//            result.y = GetElement(0, 1);
//            result.z = GetElement(0, 2);
//        }

//        // Returns the Y-axis vector from this matrix
//        public void GetYAxisVector(Vector3 result)
//        {
//            // stored as row vectors
//            result.x = GetElement(1, 0);
//            result.y = GetElement(1, 1);
//            result.z = GetElement(1, 2);
//        }

//        // Returns the Z-axis vector from this matrix
//        public void GetZAxisVector(Vector3 result)
//        {
//            // stored as row vectors
//            result.x = GetElement(2, 0);
//            result.y = GetElement(2, 1);
//            result.z = GetElement(2, 2);
//        }

//        // Returns the translation from this matrix
//        public void GetTranslation(Vector3 result)
//        {
//            // stored as row vectors
//            result.x = GetElement(3, 0);
//            result.y = GetElement(3, 1);
//            result.z = GetElement(3, 2);
//        }

//        public void SetElements(Matrix4X4 CopyFrom)
//        {
//            SetElements(CopyFrom.GetElements());
//        }

//        public void SetElements(double[] pElements)
//        {
//            for (int i = 0; i < 16; i++)
//            {
//                matrix[i] = pElements[i];
//            }
//        }

//        public void SetElements(double A00_00, double A00_01, double A00_02, double A00_03,
//                                     double A01_00, double A01_01, double A01_02, double A01_03,
//                                     double A02_00, double A02_01, double A02_02, double A02_03,
//                                     double A03_00, double A03_01, double A03_02, double A03_03)
//        {
//            int Offset = 0;
//            matrix[Offset++] = A00_00; matrix[Offset++] = A00_01; matrix[Offset++] = A00_02; matrix[Offset++] = A00_03;
//            matrix[Offset++] = A01_00; matrix[Offset++] = A01_01; matrix[Offset++] = A01_02; matrix[Offset++] = A01_03;
//            matrix[Offset++] = A02_00; matrix[Offset++] = A02_01; matrix[Offset++] = A02_02; matrix[Offset++] = A02_03;
//            matrix[Offset++] = A03_00; matrix[Offset++] = A03_01; matrix[Offset++] = A03_02; matrix[Offset++] = A03_03;
//        }

//        public void SetElements(float A00_00, float A00_01, float A00_02, float A00_03,
//                                     float A01_00, float A01_01, float A01_02, float A01_03,
//                                     float A02_00, float A02_01, float A02_02, float A02_03,
//                                     float A03_00, float A03_01, float A03_02, float A03_03)
//        {
//            SetElements((double)A00_00, (double)A00_01, (double)A00_02, (double)A00_03,
//                                     (double)A01_00, (double)A01_01, (double)A01_02, (double)A01_03,
//                                     (double)A02_00, (double)A02_01, (double)A02_02, (double)A02_03,
//                                     (double)A03_00, (double)A03_01, (double)A03_02, (double)A03_03);
//        }

//        public double[] GetElements()
//        {
//            return matrix;
//        }

//        public override string ToString()
//        {
//            string finalString = "Matrix4x4 (";
//            for (int i = 0; i < 16; i++)
//            {
//                finalString += this[i].ToString() + ", ";
//            }
//            finalString += ")";
//            return finalString;
//        }
//    }
//};

#endregion //Matrix4x4@agg.cs
#region Matrix4x4@VectorMath.cs

namespace MatterHackers.VectorMath
{
#if true
    /// <summary>
    /// Represents a 4x4 Matrix with double-precision components.
    /// </summary>
    //[Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public struct Matrix4X4 : IEquatable<Matrix4X4>
    {
        #region Fields

        /// <summary>
        /// Top row of the matrix
        /// </summary>
        public Vector4 Row0;
        /// <summary>
        /// 2nd row of the matrix
        /// </summary>
        public Vector4 Row1;
        /// <summary>
        /// 3rd row of the matrix
        /// </summary>
        public Vector4 Row2;
        /// <summary>
        /// Bottom row of the matrix
        /// </summary>
        public Vector4 Row3;

        /// <summary>
        /// The identity matrix
        /// </summary>
        public static Matrix4X4 Identity = new Matrix4X4(Vector4.UnitX, Vector4.UnitY, Vector4.UnitZ, Vector4.UnitW);

        #endregion

        #region Constructors

        /// <summary>
        /// Constructs a new instance.
        /// </summary>
        /// <param name="row0">Top row of the matrix</param>
        /// <param name="row1">Second row of the matrix</param>
        /// <param name="row2">Third row of the matrix</param>
        /// <param name="row3">Bottom row of the matrix</param>
        public Matrix4X4(Vector4 row0, Vector4 row1, Vector4 row2, Vector4 row3)
        {
            Row0 = row0;
            Row1 = row1;
            Row2 = row2;
            Row3 = row3;
        }

        /// <summary>
        /// Constructs a new instance.
        /// </summary>
        /// <param name="m00">First item of the first row.</param>
        /// <param name="m01">Second item of the first row.</param>
        /// <param name="m02">Third item of the first row.</param>
        /// <param name="m03">Fourth item of the first row.</param>
        /// <param name="m10">First item of the second row.</param>
        /// <param name="m11">Second item of the second row.</param>
        /// <param name="m12">Third item of the second row.</param>
        /// <param name="m13">Fourth item of the second row.</param>
        /// <param name="m20">First item of the third row.</param>
        /// <param name="m21">Second item of the third row.</param>
        /// <param name="m22">Third item of the third row.</param>
        /// <param name="m23">First item of the third row.</param>
        /// <param name="m30">Fourth item of the fourth row.</param>
        /// <param name="m31">Second item of the fourth row.</param>
        /// <param name="m32">Third item of the fourth row.</param>
        /// <param name="m33">Fourth item of the fourth row.</param>
        public Matrix4X4(
            double m00, double m01, double m02, double m03,
            double m10, double m11, double m12, double m13,
            double m20, double m21, double m22, double m23,
            double m30, double m31, double m32, double m33)
        {
            Row0 = new Vector4(m00, m01, m02, m03);
            Row1 = new Vector4(m10, m11, m12, m13);
            Row2 = new Vector4(m20, m21, m22, m23);
            Row3 = new Vector4(m30, m31, m32, m33);
        }

        public Matrix4X4(double[] double16)
        {
            Row0 = new Vector4(double16[0], double16[1], double16[2], double16[3]);
            Row1 = new Vector4(double16[4], double16[5], double16[6], double16[7]);
            Row2 = new Vector4(double16[8], double16[9], double16[10], double16[11]);
            Row3 = new Vector4(double16[12], double16[13], double16[14], double16[15]);
        }

        #endregion

        #region Public Members

        #region Properties

        /// <summary>
        /// The determinant of this matrix
        /// </summary>
        public double Determinant
        {
            get
            {
                return
                    Row0.x * Row1.y * Row2.z * Row3.w - Row0.x * Row1.y * Row2.w * Row3.z + Row0.x * Row1.z * Row2.w * Row3.y - Row0.x * Row1.z * Row2.y * Row3.w
                  + Row0.x * Row1.w * Row2.y * Row3.z - Row0.x * Row1.w * Row2.z * Row3.y - Row0.y * Row1.z * Row2.w * Row3.x + Row0.y * Row1.z * Row2.x * Row3.w
                  - Row0.y * Row1.w * Row2.x * Row3.z + Row0.y * Row1.w * Row2.z * Row3.x - Row0.y * Row1.x * Row2.z * Row3.w + Row0.y * Row1.x * Row2.w * Row3.z
                  + Row0.z * Row1.w * Row2.x * Row3.y - Row0.z * Row1.w * Row2.y * Row3.x + Row0.z * Row1.x * Row2.y * Row3.w - Row0.z * Row1.x * Row2.w * Row3.y
                  + Row0.z * Row1.y * Row2.w * Row3.x - Row0.z * Row1.y * Row2.x * Row3.w - Row0.w * Row1.x * Row2.y * Row3.z + Row0.w * Row1.x * Row2.z * Row3.y
                  - Row0.w * Row1.y * Row2.z * Row3.x + Row0.w * Row1.y * Row2.x * Row3.z - Row0.w * Row1.z * Row2.x * Row3.y + Row0.w * Row1.z * Row2.y * Row3.x;
            }
        }

        /// <summary>
        /// Get just the position out of the matrix.
        /// </summary>
        public Vector3 Position
        {
            get { return new Vector3(Row3); }
        }

        /// <summary>
        /// The first column of this matrix
        /// </summary>
        public Vector4 Column0
        {
            get { return new Vector4(Row0.x, Row1.x, Row2.x, Row3.x); }
        }

        /// <summary>
        /// The second column of this matrix
        /// </summary>
        public Vector4 Column1
        {
            get { return new Vector4(Row0.y, Row1.y, Row2.y, Row3.y); }
        }

        /// <summary>
        /// The third column of this matrix
        /// </summary>
        public Vector4 Column2
        {
            get { return new Vector4(Row0.z, Row1.z, Row2.z, Row3.z); }
        }

        /// <summary>
        /// The fourth column of this matrix
        /// </summary>
        public Vector4 Column3
        {
            get { return new Vector4(Row0.w, Row1.w, Row2.w, Row3.w); }
        }

        /// <summary>
        /// Gets or sets the value at row 1, column 1 of this instance.
        /// </summary>
        public double M11 { get { return Row0.x; } set { Row0.x = value; } }

        /// <summary>
        /// Gets or sets the value at row 1, column 2 of this instance.
        /// </summary>
        public double M12 { get { return Row0.y; } set { Row0.y = value; } }

        /// <summary>
        /// Gets or sets the value at row 1, column 3 of this instance.
        /// </summary>
        public double M13 { get { return Row0.z; } set { Row0.z = value; } }

        /// <summary>
        /// Gets or sets the value at row 1, column 4 of this instance.
        /// </summary>
        public double M14 { get { return Row0.w; } set { Row0.w = value; } }

        /// <summary>
        /// Gets or sets the value at row 2, column 1 of this instance.
        /// </summary>
        public double M21 { get { return Row1.x; } set { Row1.x = value; } }

        /// <summary>
        /// Gets or sets the value at row 2, column 2 of this instance.
        /// </summary>
        public double M22 { get { return Row1.y; } set { Row1.y = value; } }

        /// <summary>
        /// Gets or sets the value at row 2, column 3 of this instance.
        /// </summary>
        public double M23 { get { return Row1.z; } set { Row1.z = value; } }

        /// <summary>
        /// Gets or sets the value at row 2, column 4 of this instance.
        /// </summary>
        public double M24 { get { return Row1.w; } set { Row1.w = value; } }

        /// <summary>
        /// Gets or sets the value at row 3, column 1 of this instance.
        /// </summary>
        public double M31 { get { return Row2.x; } set { Row2.x = value; } }

        /// <summary>
        /// Gets or sets the value at row 3, column 2 of this instance.
        /// </summary>
        public double M32 { get { return Row2.y; } set { Row2.y = value; } }

        /// <summary>
        /// Gets or sets the value at row 3, column 3 of this instance.
        /// </summary>
        public double M33 { get { return Row2.z; } set { Row2.z = value; } }

        /// <summary>
        /// Gets or sets the value at row 3, column 4 of this instance.
        /// </summary>
        public double M34 { get { return Row2.w; } set { Row2.w = value; } }

        /// <summary>
        /// Gets or sets the value at row 4, column 1 of this instance.
        /// </summary>
        public double M41 { get { return Row3.x; } set { Row3.x = value; } }

        /// <summary>
        /// Gets or sets the value at row 4, column 2 of this instance.
        /// </summary>
        public double M42 { get { return Row3.y; } set { Row3.y = value; } }

        /// <summary>
        /// Gets or sets the value at row 4, column 3 of this instance.
        /// </summary>
        public double M43 { get { return Row3.z; } set { Row3.z = value; } }

        /// <summary>
        /// Gets or sets the value at row 4, column 4 of this instance.
        /// </summary>
        public double M44 { get { return Row3.w; } set { Row3.w = value; } }

        #endregion

        #region Instance

        public double this[int row, int column]
        {
            get
            {
                switch (row)
                {
                    case 0:
                        return Row0[column];
                    case 1:
                        return Row1[column];
                    case 2:
                        return Row2[column];
                    case 3:
                        return Row3[column];
                    default:
                        throw new IndexOutOfRangeException();
                }
            }

            set
            {
                switch (row)
                {
                    case 0:
                        Row0[column] = value;
                        break;
                    case 1:
                        Row1[column] = value;
                        break;
                    case 2:
                        Row2[column] = value;
                        break;
                    case 3:
                        Row3[column] = value;
                        break;
                    default:
                        throw new IndexOutOfRangeException();
                }
            }
        }

        public Quaternion GetRotation()
        {
            Quaternion rotation = Quaternion.Identity;
            double tr = M11 + M22 + M33;

            if (tr > 0)
            {
                double S = Math.Sqrt(tr + 1.0) * 2; // S=4*qw 
                rotation.W = 0.25 * S;
                rotation.X = (M32 - M23) / S;
                rotation.Y = (M13 - M31) / S;
                rotation.Z = (M21 - M12) / S;
            }
            else if ((M11 > M22) & (M11 > M33))
            {
                double S = Math.Sqrt(1.0 + M11 - M22 - M33) * 2; // S=4*qx 
                rotation.W = (M32 - M23) / S;
                rotation.X = 0.25 * S;
                rotation.Y = (M12 + M21) / S;
                rotation.Z = (M13 + M31) / S;
            }
            else if (M22 > M33)
            {
                double S = Math.Sqrt(1.0 + M22 - M11 - M33) * 2; // S=4*qy
                rotation.W = (M13 - M31) / S;
                rotation.X = (M12 + M21) / S;
                rotation.Y = 0.25 * S;
                rotation.Z = (M23 + M32) / S;
            }
            else
            {
                double S = Math.Sqrt(1.0 + M33 - M11 - M22) * 2; // S=4*qz
                rotation.W = (M21 - M12) / S;
                rotation.X = (M13 + M31) / S;
                rotation.Y = (M23 + M32) / S;
                rotation.Z = 0.25 * S;
            }

            return rotation;
        }

        #region public void Invert()

        /// <summary>
        /// Converts this instance into its inverse.
        /// </summary>
        public void Invert()
        {
            this = Matrix4X4.Invert(this);
        }

        #endregion

        #region public void Transpose()

        /// <summary>
        /// Converts this instance into its transpose.
        /// </summary>
        public void Transpose()
        {
            this = Matrix4X4.Transpose(this);
        }

        #endregion

        #endregion

        #region Static

        #region CreateFromAxisAngle

        /// <summary>
        /// Build a rotation matrix from the specified axis/angle rotation.
        /// </summary>
        /// <param name="axis">The axis to rotate about.</param>
        /// <param name="angle">Angle in radians to rotate counter-clockwise (looking in the direction of the given axis).</param>
        /// <param name="result">A matrix instance.</param>
        public static void CreateFromAxisAngle(Vector3 axis, double angle, out Matrix4X4 result)
        {
            double cos = System.Math.Cos(-angle);
            double sin = System.Math.Sin(-angle);
            double t = 1.0 - cos;

            axis.Normalize();

            result = new Matrix4X4(t * axis.x * axis.x + cos, t * axis.x * axis.y - sin * axis.z, t * axis.x * axis.z + sin * axis.y, 0.0,
                                 t * axis.x * axis.y + sin * axis.z, t * axis.y * axis.y + cos, t * axis.y * axis.z - sin * axis.x, 0.0,
                                 t * axis.x * axis.z - sin * axis.y, t * axis.y * axis.z + sin * axis.x, t * axis.z * axis.z + cos, 0.0,
                                 0, 0, 0, 1);
        }

        /// <summary>
        /// Build a rotation matrix from the specified axis/angle rotation.
        /// </summary>
        /// <param name="axis">The axis to rotate about.</param>
        /// <param name="angle">Angle in radians to rotate counter-clockwise (looking in the direction of the given axis).</param>
        /// <returns>A matrix instance.</returns>
        public static Matrix4X4 CreateFromAxisAngle(Vector3 axis, double angle)
        {
            Matrix4X4 result;
            CreateFromAxisAngle(axis, angle, out result);
            return result;
        }

        #endregion

        #region CreateRotation[XYZ]

        public static Matrix4X4 CreateRotation(Vector3 radians)
        {
            return Matrix4X4.CreateRotation(Quaternion.FromEulerAngles(radians));
        }

        /// <summary>
        /// Builds a rotation matrix for a rotation around the x-axis.
        /// </summary>
        /// <param name="angle">The counter-clockwise angle in radians.</param>
        /// <param name="result">The resulting Matrix4 instance.</param>
        public static void CreateRotationX(double angle, out Matrix4X4 result)
        {
            double cos = System.Math.Cos(angle);
            double sin = System.Math.Sin(angle);

            result.Row0 = Vector4.UnitX;
            result.Row1 = new Vector4(0, cos, sin, 0);
            result.Row2 = new Vector4(0, -sin, cos, 0);
            result.Row3 = Vector4.UnitW;
        }

        /// <summary>
        /// Builds a rotation matrix for a rotation around the x-axis.
        /// </summary>
        /// <param name="angle">The counter-clockwise angle in radians.</param>
        /// <returns>The resulting Matrix4 instance.</returns>
        public static Matrix4X4 CreateRotationX(double angle)
        {
            Matrix4X4 result;
            CreateRotationX(angle, out result);
            return result;
        }

        /// <summary>
        /// Builds a rotation matrix for a rotation around the y-axis.
        /// </summary>
        /// <param name="angle">The counter-clockwise angle in radians.</param>
        /// <param name="result">The resulting Matrix4 instance.</param>
        public static void CreateRotationY(double angle, out Matrix4X4 result)
        {
            double cos = System.Math.Cos(angle);
            double sin = System.Math.Sin(angle);

            result.Row0 = new Vector4(cos, 0, -sin, 0);
            result.Row1 = Vector4.UnitY;
            result.Row2 = new Vector4(sin, 0, cos, 0);
            result.Row3 = Vector4.UnitW;
        }

        /// <summary>
        /// Builds a rotation matrix for a rotation around the y-axis.
        /// </summary>
        /// <param name="angle">The counter-clockwise angle in radians.</param>
        /// <returns>The resulting Matrix4 instance.</returns>
        public static Matrix4X4 CreateRotationY(double angle)
        {
            Matrix4X4 result;
            CreateRotationY(angle, out result);
            return result;
        }

        /// <summary>
        /// Builds a rotation matrix for a rotation around the z-axis.
        /// </summary>
        /// <param name="angle">The counter-clockwise angle in radians.</param>
        /// <param name="result">The resulting Matrix4 instance.</param>
        public static void CreateRotationZ(double angle, out Matrix4X4 result)
        {
            double cos = System.Math.Cos(angle);
            double sin = System.Math.Sin(angle);

            result.Row0 = new Vector4(cos, sin, 0, 0);
            result.Row1 = new Vector4(-sin, cos, 0, 0);
            result.Row2 = Vector4.UnitZ;
            result.Row3 = Vector4.UnitW;
        }

        /// <summary>
        /// Builds a rotation matrix for a rotation around the z-axis.
        /// </summary>
        /// <param name="angle">The counter-clockwise angle in radians.</param>
        /// <returns>The resulting Matrix4 instance.</returns>
        public static Matrix4X4 CreateRotationZ(double angle)
        {
            Matrix4X4 result;
            CreateRotationZ(angle, out result);
            return result;
        }

        /// <summary>
        /// Build a rotation matrix to rotate about the given axis
        /// </summary>
        /// <param name="axis">the axis to rotate about</param>
        /// <param name="angle">angle in radians to rotate counter-clockwise (looking in the direction of the given axis)</param>
        /// <returns>A rotation matrix</returns>
        public static Matrix4X4 CreateRotation(Vector3 axis, double angle)
        {
            double cos = System.Math.Cos(-angle);
            double sin = System.Math.Sin(-angle);
            double t = 1.0 - cos;

            axis.Normalize();

            Matrix4X4 result;
            result.Row0 = new Vector4(t * axis.x * axis.x + cos, t * axis.x * axis.y - sin * axis.z, t * axis.x * axis.z + sin * axis.y, 0.0);
            result.Row1 = new Vector4(t * axis.x * axis.y + sin * axis.z, t * axis.y * axis.y + cos, t * axis.y * axis.z - sin * axis.x, 0.0);
            result.Row2 = new Vector4(t * axis.x * axis.z - sin * axis.y, t * axis.y * axis.z + sin * axis.x, t * axis.z * axis.z + cos, 0.0);
            result.Row3 = Vector4.UnitW;
            return result;
        }

        /// <summary>
        /// Build a rotation matrix from a quaternion
        /// </summary>
        /// <param name="q">the quaternion</param>
        /// <returns>A rotation matrix</returns>
        public static Matrix4X4 CreateRotation(Quaternion q)
        {
            Vector3 axis;
            double angle;
            q.ToAxisAngle(out axis, out angle);
            return CreateRotation(axis, angle);
        }

        /// <summary>
        /// Build a rotation matrix that will rotate from one direction to another
        /// </summary>
        /// <param name="startingDirection"></param>
        /// <param name="endingDirection"></param>
        /// <returns></returns>
        public static Matrix4X4 CreateRotation(Vector3 startingDirection, Vector3 endingDirection)
        {
            Quaternion q = new Quaternion(startingDirection, endingDirection);
            return CreateRotation(q);
        }

        #endregion

        #region CreateTranslation

        /// <summary>
        /// Creates a translation matrix.
        /// </summary>
        /// <param name="x">X translation.</param>
        /// <param name="y">Y translation.</param>
        /// <param name="z">Z translation.</param>
        /// <param name="result">The resulting Matrix4d instance.</param>
        public static void CreateTranslation(double x, double y, double z, out Matrix4X4 result)
        {
            result = Identity;
            result.Row3 = new Vector4(x, y, z, 1);
        }

        /// <summary>
        /// Creates a translation matrix.
        /// </summary>
        /// <param name="vector">The translation vector.</param>
        /// <param name="result">The resulting Matrix4d instance.</param>
        public static void CreateTranslation(ref Vector3 vector, out Matrix4X4 result)
        {
            result = Identity;
            result.Row3 = new Vector4(vector.x, vector.y, vector.z, 1);
        }

        /// <summary>
        /// Creates a translation matrix.
        /// </summary>
        /// <param name="x">X translation.</param>
        /// <param name="y">Y translation.</param>
        /// <param name="z">Z translation.</param>
        /// <returns>The resulting Matrix4d instance.</returns>
        public static Matrix4X4 CreateTranslation(double x, double y, double z)
        {
            Matrix4X4 result;
            CreateTranslation(x, y, z, out result);
            return result;
        }

        /// <summary>
        /// Creates a translation matrix.
        /// </summary>
        /// <param name="vector">The translation vector.</param>
        /// <returns>The resulting Matrix4d instance.</returns>
        public static Matrix4X4 CreateTranslation(Vector3 vector)
        {
            Matrix4X4 result;
            CreateTranslation(vector.x, vector.y, vector.z, out result);
            return result;
        }

        #endregion

        #region CreateOrthographic

        /// <summary>
        /// Creates an orthographic projection matrix.
        /// </summary>
        /// <param name="width">The width of the projection volume.</param>
        /// <param name="height">The height of the projection volume.</param>
        /// <param name="zNear">The near edge of the projection volume.</param>
        /// <param name="zFar">The far edge of the projection volume.</param>
        /// <param name="result">The resulting Matrix4d instance.</param>
        public static void CreateOrthographic(double width, double height, double zNear, double zFar, out Matrix4X4 result)
        {
            CreateOrthographicOffCenter(-width / 2, width / 2, -height / 2, height / 2, zNear, zFar, out result);
        }

        /// <summary>
        /// Creates an orthographic projection matrix.
        /// </summary>
        /// <param name="width">The width of the projection volume.</param>
        /// <param name="height">The height of the projection volume.</param>
        /// <param name="zNear">The near edge of the projection volume.</param>
        /// <param name="zFar">The far edge of the projection volume.</param>
        /// <rereturns>The resulting Matrix4d instance.</rereturns>
        public static Matrix4X4 CreateOrthographic(double width, double height, double zNear, double zFar)
        {
            Matrix4X4 result;
            CreateOrthographicOffCenter(-width / 2, width / 2, -height / 2, height / 2, zNear, zFar, out result);
            return result;
        }

        #endregion

        #region CreateOrthographicOffCenter

        /// <summary>
        /// Creates an orthographic projection matrix.
        /// </summary>
        /// <param name="left">The left edge of the projection volume.</param>
        /// <param name="right">The right edge of the projection volume.</param>
        /// <param name="bottom">The bottom edge of the projection volume.</param>
        /// <param name="top">The top edge of the projection volume.</param>
        /// <param name="zNear">The near edge of the projection volume.</param>
        /// <param name="zFar">The far edge of the projection volume.</param>
        /// <param name="result">The resulting Matrix4d instance.</param>
        public static void CreateOrthographicOffCenter(double left, double right, double bottom, double top, double zNear, double zFar, out Matrix4X4 result)
        {
            result = new Matrix4X4();

            double invRL = 1 / (right - left);
            double invTB = 1 / (top - bottom);
            double invFN = 1 / (zFar - zNear);

            result.M11 = 2 * invRL;
            result.M22 = 2 * invTB;
            result.M33 = -2 * invFN;

            result.M41 = -(right + left) * invRL;
            result.M42 = -(top + bottom) * invTB;
            result.M43 = -(zFar + zNear) * invFN;
            result.M44 = 1;
        }

        /// <summary>
        /// Creates an orthographic projection matrix.
        /// </summary>
        /// <param name="left">The left edge of the projection volume.</param>
        /// <param name="right">The right edge of the projection volume.</param>
        /// <param name="bottom">The bottom edge of the projection volume.</param>
        /// <param name="top">The top edge of the projection volume.</param>
        /// <param name="zNear">The near edge of the projection volume.</param>
        /// <param name="zFar">The far edge of the projection volume.</param>
        /// <returns>The resulting Matrix4d instance.</returns>
        public static Matrix4X4 CreateOrthographicOffCenter(double left, double right, double bottom, double top, double zNear, double zFar)
        {
            Matrix4X4 result;
            CreateOrthographicOffCenter(left, right, bottom, top, zNear, zFar, out result);
            return result;
        }

        #endregion

        #region CreatePerspectiveFieldOfView

        /// <summary>
        /// Creates a perspective projection matrix.
        /// </summary>
        /// <param name="fovYRadians">Angle of the field of view in the y direction (in radians)</param>
        /// <param name="aspectWidthOverHeight">Aspect ratio of the view (width / height)</param>
        /// <param name="zNear">Distance to the near clip plane</param>
        /// <param name="zFar">Distance to the far clip plane</param>
        /// <param name="result">A projection matrix that transforms camera space to raster space</param>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Thrown under the following conditions:
        /// <list type="bullet">
        /// <item>fovy is zero, less than zero or larger than Math.PI</item>
        /// <item>aspect is negative or zero</item>
        /// <item>zNear is negative or zero</item>
        /// <item>zFar is negative or zero</item>
        /// <item>zNear is larger than zFar</item>
        /// </list>
        /// </exception>
        public static void CreatePerspectiveFieldOfView(double fovYRadians, double aspectWidthOverHeight, double zNear, double zFar, out Matrix4X4 result)
        {
            if (fovYRadians <= 0 || fovYRadians > Math.PI)
                throw new ArgumentOutOfRangeException("fovy");
            if (aspectWidthOverHeight <= 0)
                throw new ArgumentOutOfRangeException("aspect");
            if (zNear <= 0)
                throw new ArgumentOutOfRangeException("zNear");
            if (zFar <= 0)
                throw new ArgumentOutOfRangeException("zFar");
            if (zNear >= zFar)
                throw new ArgumentOutOfRangeException("zNear");

            double yMax = zNear * System.Math.Tan(0.5 * fovYRadians);
            double yMin = -yMax;
            double xMin = yMin * aspectWidthOverHeight;
            double xMax = yMax * aspectWidthOverHeight;

            CreatePerspectiveOffCenter(xMin, xMax, yMin, yMax, zNear, zFar, out result);
        }

        /// <summary>
        /// Creates a perspective projection matrix.
        /// </summary>
        /// <param name="fovYRadians">Angle of the field of view in the y direction (in radians)</param>
        /// <param name="aspectWidthOverHeight">Aspect ratio of the view (width / height)</param>
        /// <param name="zNear">Distance to the near clip plane</param>
        /// <param name="zFar">Distance to the far clip plane</param>
        /// <returns>A projection matrix that transforms camera space to raster space</returns>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Thrown under the following conditions:
        /// <list type="bullet">
        /// <item>fovYRadians is zero, less than zero or larger than Math.PI</item>
        /// <item>aspect is negative or zero</item>
        /// <item>zNear is negative or zero</item>
        /// <item>zFar is negative or zero</item>
        /// <item>zNear is larger than zFar</item>
        /// </list>
        /// </exception>
        public static Matrix4X4 CreatePerspectiveFieldOfView(double fovYRadians, double aspectWidthOverHeight, double zNear, double zFar)
        {
            Matrix4X4 result;
            CreatePerspectiveFieldOfView(fovYRadians, aspectWidthOverHeight, zNear, zFar, out result);
            return result;
        }

        #endregion

        #region CreatePerspectiveOffCenter

        /// <summary>
        /// Creates an perspective projection matrix.
        /// </summary>
        /// <param name="left">Left edge of the view frustum</param>
        /// <param name="right">Right edge of the view frustum</param>
        /// <param name="bottom">Bottom edge of the view frustum</param>
        /// <param name="top">Top edge of the view frustum</param>
        /// <param name="zNear">Distance to the near clip plane</param>
        /// <param name="zFar">Distance to the far clip plane</param>
        /// <param name="result">A projection matrix that transforms camera space to raster space</param>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Thrown under the following conditions:
        /// <list type="bullet">
        /// <item>zNear is negative or zero</item>
        /// <item>zFar is negative or zero</item>
        /// <item>zNear is larger than zFar</item>
        /// </list>
        /// </exception>
        public static void CreatePerspectiveOffCenter(double left, double right, double bottom, double top, double zNear, double zFar, out Matrix4X4 result)
        {
            if (zNear <= 0)
            {
                throw new ArgumentOutOfRangeException("zNear");
            }
            if (zFar <= 0)
            {
                throw new ArgumentOutOfRangeException("zFar");
            }
            if (zNear >= zFar)
            {
                throw new ArgumentOutOfRangeException("zNear");
            }

            double x = (2.0 * zNear) / (right - left);
            double y = (2.0 * zNear) / (top - bottom);
            double a = (right + left) / (right - left);
            double b = (top + bottom) / (top - bottom);
            double c = -(zFar + zNear) / (zFar - zNear);
            double d = -(2.0 * zFar * zNear) / (zFar - zNear);

            result = new Matrix4X4(
                x, 0, 0, 0,
                0, y, 0, 0,
                a, b, c, -1,
                0, 0, d, 0
                );
        }

        /// <summary>
        /// Creates an perspective projection matrix.
        /// </summary>
        /// <param name="left">Left edge of the view frustum</param>
        /// <param name="right">Right edge of the view frustum</param>
        /// <param name="bottom">Bottom edge of the view frustum</param>
        /// <param name="top">Top edge of the view frustum</param>
        /// <param name="zNear">Distance to the near clip plane</param>
        /// <param name="zFar">Distance to the far clip plane</param>
        /// <returns>A projection matrix that transforms camera space to raster space</returns>
        /// <exception cref="System.ArgumentOutOfRangeException">
        /// Thrown under the following conditions:
        /// <list type="bullet">
        /// <item>zNear is negative or zero</item>
        /// <item>zFar is negative or zero</item>
        /// <item>zNear is larger than zFar</item>
        /// </list>
        /// </exception>
        public static Matrix4X4 CreatePerspectiveOffCenter(double left, double right, double bottom, double top, double zNear, double zFar)
        {
            Matrix4X4 result;
            CreatePerspectiveOffCenter(left, right, bottom, top, zNear, zFar, out result);
            return result;
        }

        #endregion

        #region CreateScale

        /// <summary>
        /// Build a scaling matrix
        /// </summary>
        /// <param name="scale">Single scale factor for x,y and z axes</param>
        /// <returns>A scaling matrix</returns>
        public static Matrix4X4 CreateScale(double scale)
        {
            return CreateScale(scale, scale, scale);
        }

        /// <summary>
        /// Build a scaling matrix
        /// </summary>
        /// <param name="scale">Scale factors for x,y and z axes</param>
        /// <returns>A scaling matrix</returns>
        public static Matrix4X4 CreateScale(Vector3 scale)
        {
            return CreateScale(scale.x, scale.y, scale.z);
        }

        /// <summary>
        /// Build a scaling matrix
        /// </summary>
        /// <param name="x">Scale factor for x-axis</param>
        /// <param name="y">Scale factor for y-axis</param>
        /// <param name="z">Scale factor for z-axis</param>
        /// <returns>A scaling matrix</returns>
        public static Matrix4X4 CreateScale(double x, double y, double z)
        {
            Matrix4X4 result;
            result.Row0 = Vector4.UnitX * x;
            result.Row1 = Vector4.UnitY * y;
            result.Row2 = Vector4.UnitZ * z;
            result.Row3 = Vector4.UnitW;
            return result;
        }

        #endregion

        #region Camera Helper Functions

        /// <summary>
        /// Build a world space to camera space matrix
        /// </summary>
        /// <param name="eye">Eye (camera) position in world space</param>
        /// <param name="target">Target position in world space</param>
        /// <param name="up">Up vector in world space (should not be parallel to the camera direction, that is target - eye)</param>
        /// <returns>A Matrix that transforms world space to camera space</returns>
        public static Matrix4X4 LookAt(Vector3 eye, Vector3 target, Vector3 up)
        {
            // There are lots of examples of look at code on the internet that don't do all these normalizes and also find the position
            // through several dot products.  The problem with them is that they have a bit of error in that all the vectors arn't normal and need to be.
            Vector3 z = Vector3.Normalize(eye - target);
            Vector3 x = Vector3.Normalize(Vector3.Cross(up, z));
            Vector3 y = Vector3.Normalize(Vector3.Cross(z, x));

            Matrix4X4 rot = new Matrix4X4(new Vector4(x.x, y.x, z.x, 0.0),
                                        new Vector4(x.y, y.y, z.y, 0.0),
                                        new Vector4(x.z, y.z, z.z, 0.0),
                                        Vector4.UnitW);

            Matrix4X4 trans = Matrix4X4.CreateTranslation(-eye);

            return trans * rot;
        }

        /// <summary>
        /// Build a world space to camera space matrix
        /// </summary>
        /// <param name="eyeX">Eye (camera) position in world space</param>
        /// <param name="eyeY">Eye (camera) position in world space</param>
        /// <param name="eyeZ">Eye (camera) position in world space</param>
        /// <param name="targetX">Target position in world space</param>
        /// <param name="targetY">Target position in world space</param>
        /// <param name="targetZ">Target position in world space</param>
        /// <param name="upX">Up vector in world space (should not be parallel to the camera direction, that is target - eye)</param>
        /// <param name="upY">Up vector in world space (should not be parallel to the camera direction, that is target - eye)</param>
        /// <param name="upZ">Up vector in world space (should not be parallel to the camera direction, that is target - eye)</param>
        /// <returns>A Matrix4 that transforms world space to camera space</returns>
        public static Matrix4X4 LookAt(double eyeX, double eyeY, double eyeZ, double targetX, double targetY, double targetZ, double upX, double upY, double upZ)
        {
            return LookAt(new Vector3(eyeX, eyeY, eyeZ), new Vector3(targetX, targetY, targetZ), new Vector3(upX, upY, upZ));
        }

        /// <summary>
        /// Build a projection matrix
        /// </summary>
        /// <param name="left">Left edge of the view frustum</param>
        /// <param name="right">Right edge of the view frustum</param>
        /// <param name="bottom">Bottom edge of the view frustum</param>
        /// <param name="top">Top edge of the view frustum</param>
        /// <param name="near">Distance to the near clip plane</param>
        /// <param name="far">Distance to the far clip plane</param>
        /// <returns>A projection matrix that transforms camera space to raster space</returns>
        public static Matrix4X4 Frustum(double left, double right, double bottom, double top, double near, double far)
        {
            double invRL = 1.0 / (right - left);
            double invTB = 1.0 / (top - bottom);
            double invFN = 1.0 / (far - near);
            return new Matrix4X4(new Vector4(2.0 * near * invRL, 0.0, 0.0, 0.0),
                               new Vector4(0.0, 2.0 * near * invTB, 0.0, 0.0),
                               new Vector4((right + left) * invRL, (top + bottom) * invTB, -(far + near) * invFN, -1.0),
                               new Vector4(0.0, 0.0, -2.0 * far * near * invFN, 0.0));
        }

        /// <summary>
        /// Build a projection matrix
        /// </summary>
        /// <param name="fovy">Angle of the field of view in the y direction (in radians)</param>
        /// <param name="aspect">Aspect ratio of the view (width / height)</param>
        /// <param name="near">Distance to the near clip plane</param>
        /// <param name="far">Distance to the far clip plane</param>
        /// <returns>A projection matrix that transforms camera space to raster space</returns>
        public static Matrix4X4 Perspective(double fovy, double aspect, double near, double far)
        {
            double yMax = near * System.Math.Tan(0.5f * fovy);
            double yMin = -yMax;
            double xMin = yMin * aspect;
            double xMax = yMax * aspect;

            return Frustum(xMin, xMax, yMin, yMax, near, far);
        }

        #endregion

        #region Multiply Functions

        /// <summary>
        /// Multiplies two instances.
        /// </summary>
        /// <param name="left">The left operand of the multiplication.</param>
        /// <param name="right">The right operand of the multiplication.</param>
        /// <returns>A new instance that is the result of the multiplication</returns>
        public static Matrix4X4 Mult(Matrix4X4 left, Matrix4X4 right)
        {
            Matrix4X4 result;
            Mult(ref left, ref right, out result);
            return result;
        }

        /// <summary>
        /// Multiplies two instances.
        /// </summary>
        /// <param name="left">The left operand of the multiplication.</param>
        /// <param name="right">The right operand of the multiplication.</param>
        /// <param name="result">A new instance that is the result of the multiplication</param>
        public static void Mult(ref Matrix4X4 left, ref Matrix4X4 right, out Matrix4X4 result)
        {
            result = new Matrix4X4();
            result.M11 = left.M11 * right.M11 + left.M12 * right.M21 + left.M13 * right.M31 + left.M14 * right.M41;
            result.M12 = left.M11 * right.M12 + left.M12 * right.M22 + left.M13 * right.M32 + left.M14 * right.M42;
            result.M13 = left.M11 * right.M13 + left.M12 * right.M23 + left.M13 * right.M33 + left.M14 * right.M43;
            result.M14 = left.M11 * right.M14 + left.M12 * right.M24 + left.M13 * right.M34 + left.M14 * right.M44;
            result.M21 = left.M21 * right.M11 + left.M22 * right.M21 + left.M23 * right.M31 + left.M24 * right.M41;
            result.M22 = left.M21 * right.M12 + left.M22 * right.M22 + left.M23 * right.M32 + left.M24 * right.M42;
            result.M23 = left.M21 * right.M13 + left.M22 * right.M23 + left.M23 * right.M33 + left.M24 * right.M43;
            result.M24 = left.M21 * right.M14 + left.M22 * right.M24 + left.M23 * right.M34 + left.M24 * right.M44;
            result.M31 = left.M31 * right.M11 + left.M32 * right.M21 + left.M33 * right.M31 + left.M34 * right.M41;
            result.M32 = left.M31 * right.M12 + left.M32 * right.M22 + left.M33 * right.M32 + left.M34 * right.M42;
            result.M33 = left.M31 * right.M13 + left.M32 * right.M23 + left.M33 * right.M33 + left.M34 * right.M43;
            result.M34 = left.M31 * right.M14 + left.M32 * right.M24 + left.M33 * right.M34 + left.M34 * right.M44;
            result.M41 = left.M41 * right.M11 + left.M42 * right.M21 + left.M43 * right.M31 + left.M44 * right.M41;
            result.M42 = left.M41 * right.M12 + left.M42 * right.M22 + left.M43 * right.M32 + left.M44 * right.M42;
            result.M43 = left.M41 * right.M13 + left.M42 * right.M23 + left.M43 * right.M33 + left.M44 * right.M43;
            result.M44 = left.M41 * right.M14 + left.M42 * right.M24 + left.M43 * right.M34 + left.M44 * right.M44;
        }

        #endregion

        #region Invert Functions

        /// <summary>
        /// Calculate the inverse of the given matrix
        /// </summary>
        /// <param name="mat">The matrix to invert</param>
        /// <returns>The inverse of the given matrix if it has one, or the input if it is singular</returns>
        /// <exception cref="InvalidOperationException">Thrown if the Matrix4d is singular.</exception>
        public static Matrix4X4 Invert(Matrix4X4 mat)
        {
            int[] colIdx = { 0, 0, 0, 0 };
            int[] rowIdx = { 0, 0, 0, 0 };
            int[] pivotIdx = { -1, -1, -1, -1 };

            // convert the matrix to an array for easy looping
            double[,] inverse = {{mat.Row0.x, mat.Row0.y, mat.Row0.z, mat.Row0.w}, 
                                {mat.Row1.x, mat.Row1.y, mat.Row1.z, mat.Row1.w}, 
                                {mat.Row2.x, mat.Row2.y, mat.Row2.z, mat.Row2.w}, 
                                {mat.Row3.x, mat.Row3.y, mat.Row3.z, mat.Row3.w} };
            int icol = 0;
            int irow = 0;
            for (int i = 0; i < 4; i++)
            {
                // Find the largest pivot value
                double maxPivot = 0.0;
                for (int j = 0; j < 4; j++)
                {
                    if (pivotIdx[j] != 0)
                    {
                        for (int k = 0; k < 4; ++k)
                        {
                            if (pivotIdx[k] == -1)
                            {
                                double absVal = System.Math.Abs(inverse[j, k]);
                                if (absVal > maxPivot)
                                {
                                    maxPivot = absVal;
                                    irow = j;
                                    icol = k;
                                }
                            }
                            else if (pivotIdx[k] > 0)
                            {
                                return mat;
                            }
                        }
                    }
                }

                ++(pivotIdx[icol]);

                // Swap rows over so pivot is on diagonal
                if (irow != icol)
                {
                    for (int k = 0; k < 4; ++k)
                    {
                        double f = inverse[irow, k];
                        inverse[irow, k] = inverse[icol, k];
                        inverse[icol, k] = f;
                    }
                }

                rowIdx[i] = irow;
                colIdx[i] = icol;

                double pivot = inverse[icol, icol];
                // check for singular matrix
                if (pivot == 0.0)
                {
                    throw new InvalidOperationException("Matrix is singular and cannot be inverted.");
                    //return mat;
                }

                // Scale row so it has a unit diagonal
                double oneOverPivot = 1.0 / pivot;
                inverse[icol, icol] = 1.0;
                for (int k = 0; k < 4; ++k)
                    inverse[icol, k] *= oneOverPivot;

                // Do elimination of non-diagonal elements
                for (int j = 0; j < 4; ++j)
                {
                    // check this isn't on the diagonal
                    if (icol != j)
                    {
                        double f = inverse[j, icol];
                        inverse[j, icol] = 0.0;
                        for (int k = 0; k < 4; ++k)
                            inverse[j, k] -= inverse[icol, k] * f;
                    }
                }
            }

            for (int j = 3; j >= 0; --j)
            {
                int ir = rowIdx[j];
                int ic = colIdx[j];
                for (int k = 0; k < 4; ++k)
                {
                    double f = inverse[k, ir];
                    inverse[k, ir] = inverse[k, ic];
                    inverse[k, ic] = f;
                }
            }

            mat.Row0 = new Vector4(inverse[0, 0], inverse[0, 1], inverse[0, 2], inverse[0, 3]);
            mat.Row1 = new Vector4(inverse[1, 0], inverse[1, 1], inverse[1, 2], inverse[1, 3]);
            mat.Row2 = new Vector4(inverse[2, 0], inverse[2, 1], inverse[2, 2], inverse[2, 3]);
            mat.Row3 = new Vector4(inverse[3, 0], inverse[3, 1], inverse[3, 2], inverse[3, 3]);
            return mat;
        }

        #endregion

        #region Transpose

        /// <summary>
        /// Calculate the transpose of the given matrix
        /// </summary>
        /// <param name="mat">The matrix to transpose</param>
        /// <returns>The transpose of the given matrix</returns>
        public static Matrix4X4 Transpose(Matrix4X4 mat)
        {
            return new Matrix4X4(mat.Column0, mat.Column1, mat.Column2, mat.Column3);
        }


        /// <summary>
        /// Calculate the transpose of the given matrix
        /// </summary>
        /// <param name="mat">The matrix to transpose</param>
        /// <param name="result">The result of the calculation</param>
        public static void Transpose(ref Matrix4X4 mat, out Matrix4X4 result)
        {
            result.Row0 = mat.Column0;
            result.Row1 = mat.Column1;
            result.Row2 = mat.Column2;
            result.Row3 = mat.Column3;
        }

        #endregion

        #endregion

        #region Operators

        /// <summary>
        /// Matrix multiplication
        /// </summary>
        /// <param name="left">left-hand operand</param>
        /// <param name="right">right-hand operand</param>
        /// <returns>A new Matrix44 which holds the result of the multiplication</returns>
        public static Matrix4X4 operator *(Matrix4X4 left, Matrix4X4 right)
        {
            return Matrix4X4.Mult(left, right);
        }

        /// <summary>
        /// Compares two instances for equality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left equals right; false otherwise.</returns>
        public static bool operator ==(Matrix4X4 left, Matrix4X4 right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Compares two instances for inequality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left does not equal right; false otherwise.</returns>
        public static bool operator !=(Matrix4X4 left, Matrix4X4 right)
        {
            return !left.Equals(right);
        }

        #endregion

        #region Overrides

        #region public override string ToString()

        /// <summary>
        /// Returns a System.String that represents the current Matrix44.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("{0},  \n{1},  \n{2},  \n{3}", Row0, Row1, Row2, Row3);
        }

        #endregion

        #region public override int GetHashCode()

        /// <summary>
        /// Returns the hashcode for this instance.
        /// </summary>
        /// <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
        public override int GetHashCode()
        {
            return new { Row0, Row1, Row2, Row3 }.GetHashCode();
        }

        #endregion

        #region public override bool Equals(object obj)

        /// <summary>
        /// Indicates whether this instance and a specified object are equal.
        /// </summary>
        /// <param name="obj">The object to compare to.</param>
        /// <returns>True if the instances are equal; false otherwise.</returns>
        public override bool Equals(object obj)
        {
            if (!(obj is Matrix4X4))
                return false;

            return this.Equals((Matrix4X4)obj);
        }

        #endregion

        #endregion

        #endregion

        #region IEquatable<Matrix4d> Members

        /// <summary>Indicates whether the current matrix is equal to another matrix.</summary>
        /// <param name="other">An matrix to compare with this matrix.</param>
        /// <returns>true if the current matrix is equal to the matrix parameter; otherwise, false.</returns>
        public bool Equals(Matrix4X4 other)
        {
            return
                Row0 == other.Row0 &&
                Row1 == other.Row1 &&
                Row2 == other.Row2 &&
                Row3 == other.Row3;
        }

        #endregion

        public float[] GetAsFloatArray()
        {
            float[] contents = new float[16];
            contents[0] = (float)Row0[0]; contents[1] = (float)Row0[1]; contents[2] = (float)Row0[2]; contents[3] = (float)Row0[3];
            contents[4] = (float)Row1[0]; contents[5] = (float)Row1[1]; contents[6] = (float)Row1[2]; contents[7] = (float)Row1[3];
            contents[8] = (float)Row2[0]; contents[9] = (float)Row2[1]; contents[10] = (float)Row2[2]; contents[11] = (float)Row2[3];
            contents[12] = (float)Row3[0]; contents[13] = (float)Row3[1]; contents[14] = (float)Row3[2]; contents[15] = (float)Row3[3];

            return contents;
        }

        public double[] GetAsDoubleArray()
        {
            double[] contents = new double[16];
            contents[0] = Row0[0]; contents[1] = Row0[1]; contents[2] = Row0[2]; contents[3] = Row0[3];
            contents[4] = Row1[0]; contents[5] = Row1[1]; contents[6] = Row1[2]; contents[7] = Row1[3];
            contents[8] = Row2[0]; contents[9] = Row2[1]; contents[10] = Row2[2]; contents[11] = Row2[3];
            contents[12] = Row3[0]; contents[13] = Row3[1]; contents[14] = Row3[2]; contents[15] = Row3[3];

            return contents;
        }
    }
#endif
}

#endregion //Matrix4x4@VectorMath.cs
#region OutlineRenderer.cs

namespace MatterHackers.Agg
{
#if true
    //===================================================distance_interpolator0
    public class distance_interpolator0
    {
        int m_dx;
        int m_dy;
        int m_dist;

        //---------------------------------------------------------------------
        public distance_interpolator0() { }
        public distance_interpolator0(int x1, int y1, int x2, int y2, int x, int y)
        {
            unchecked
            {
                m_dx = (LineAABasics.line_mr(x2) - LineAABasics.line_mr(x1));
                m_dy = (LineAABasics.line_mr(y2) - LineAABasics.line_mr(y1));
                m_dist = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy -
                       (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx);

                m_dx <<= LineAABasics.line_mr_subpixel_shift;
                m_dy <<= LineAABasics.line_mr_subpixel_shift;
            }
        }

        //---------------------------------------------------------------------
        public void inc_x() { m_dist += m_dy; }
        public int dist() { return m_dist; }
    };

    //==================================================distance_interpolator00
    public class distance_interpolator00
    {
        int m_dx1;
        int m_dy1;
        int m_dx2;
        int m_dy2;
        int m_dist1;
        int m_dist2;

        //---------------------------------------------------------------------
        public distance_interpolator00() { }
        public distance_interpolator00(int xc, int yc,
                                int x1, int y1, int x2, int y2,
                                int x, int y)
        {
            m_dx1 = (LineAABasics.line_mr(x1) - LineAABasics.line_mr(xc));
            m_dy1 = (LineAABasics.line_mr(y1) - LineAABasics.line_mr(yc));
            m_dx2 = (LineAABasics.line_mr(x2) - LineAABasics.line_mr(xc));
            m_dy2 = (LineAABasics.line_mr(y2) - LineAABasics.line_mr(yc));
            m_dist1 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x1)) * m_dy1 -
                    (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y1)) * m_dx1);
            m_dist2 = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(x2)) * m_dy2 -
                    (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(y2)) * m_dx2);

            m_dx1 <<= LineAABasics.line_mr_subpixel_shift;
            m_dy1 <<= LineAABasics.line_mr_subpixel_shift;
            m_dx2 <<= LineAABasics.line_mr_subpixel_shift;
            m_dy2 <<= LineAABasics.line_mr_subpixel_shift;
        }

        //---------------------------------------------------------------------
        public void inc_x() { m_dist1 += m_dy1; m_dist2 += m_dy2; }
        public int dist1() { return m_dist1; }
        public int dist2() { return m_dist2; }
    };

    //===================================================distance_interpolator1
    public class distance_interpolator1
    {
        int m_dx;
        int m_dy;
        int m_dist;

        //---------------------------------------------------------------------
        public distance_interpolator1() { }
        public distance_interpolator1(int x1, int y1, int x2, int y2, int x, int y)
        {
            m_dx = (x2 - x1);
            m_dy = (y2 - y1);
            m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
                          (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

            m_dx <<= LineAABasics.line_subpixel_shift;
            m_dy <<= LineAABasics.line_subpixel_shift;
        }

        //---------------------------------------------------------------------
        public void inc_x() { m_dist += m_dy; }
        public void dec_x() { m_dist -= m_dy; }
        public void inc_y() { m_dist -= m_dx; }
        public void dec_y() { m_dist += m_dx; }

        //---------------------------------------------------------------------
        public void inc_x(int dy)
        {
            m_dist += m_dy;
            if (dy > 0) m_dist -= m_dx;
            if (dy < 0) m_dist += m_dx;
        }

        //---------------------------------------------------------------------
        public void dec_x(int dy)
        {
            m_dist -= m_dy;
            if (dy > 0) m_dist -= m_dx;
            if (dy < 0) m_dist += m_dx;
        }

        //---------------------------------------------------------------------
        public void inc_y(int dx)
        {
            m_dist -= m_dx;
            if (dx > 0) m_dist += m_dy;
            if (dx < 0) m_dist -= m_dy;
        }

        public void dec_y(int dx)
        //---------------------------------------------------------------------
        {
            m_dist += m_dx;
            if (dx > 0) m_dist += m_dy;
            if (dx < 0) m_dist -= m_dy;
        }

        //---------------------------------------------------------------------
        public int dist() { return m_dist; }
        public int dx() { return m_dx; }
        public int dy() { return m_dy; }
    };

    //===================================================distance_interpolator2
    public class distance_interpolator2
    {
        int m_dx;
        int m_dy;
        int m_dx_start;
        int m_dy_start;

        int m_dist;
        int m_dist_start;

        //---------------------------------------------------------------------
        public distance_interpolator2() { }
        public distance_interpolator2(int x1, int y1, int x2, int y2,
                               int sx, int sy, int x, int y)
        {
            m_dx = (x2 - x1);
            m_dy = (y2 - y1);
            m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));
            m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));

            m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
                          (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

            m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -
                         (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);

            m_dx <<= LineAABasics.line_subpixel_shift;
            m_dy <<= LineAABasics.line_subpixel_shift;
            m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
            m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
        }

        public distance_interpolator2(int x1, int y1, int x2, int y2,
                               int ex, int ey, int x, int y, int none)
        {
            m_dx = (x2 - x1);
            m_dy = (y2 - y1);
            m_dx_start = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));
            m_dy_start = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));

            m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
                          (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

            m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_start -
                         (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_start);

            m_dx <<= LineAABasics.line_subpixel_shift;
            m_dy <<= LineAABasics.line_subpixel_shift;
            m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
            m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
        }


        //---------------------------------------------------------------------
        public void inc_x() { m_dist += m_dy; m_dist_start += m_dy_start; }
        public void dec_x() { m_dist -= m_dy; m_dist_start -= m_dy_start; }
        public void inc_y() { m_dist -= m_dx; m_dist_start -= m_dx_start; }
        public void dec_y() { m_dist += m_dx; m_dist_start += m_dx_start; }

        //---------------------------------------------------------------------
        public void inc_x(int dy)
        {
            m_dist += m_dy;
            m_dist_start += m_dy_start;
            if (dy > 0)
            {
                m_dist -= m_dx;
                m_dist_start -= m_dx_start;
            }
            if (dy < 0)
            {
                m_dist += m_dx;
                m_dist_start += m_dx_start;
            }
        }

        //---------------------------------------------------------------------
        public void dec_x(int dy)
        {
            m_dist -= m_dy;
            m_dist_start -= m_dy_start;
            if (dy > 0)
            {
                m_dist -= m_dx;
                m_dist_start -= m_dx_start;
            }
            if (dy < 0)
            {
                m_dist += m_dx;
                m_dist_start += m_dx_start;
            }
        }

        //---------------------------------------------------------------------
        public void inc_y(int dx)
        {
            m_dist -= m_dx;
            m_dist_start -= m_dx_start;
            if (dx > 0)
            {
                m_dist += m_dy;
                m_dist_start += m_dy_start;
            }
            if (dx < 0)
            {
                m_dist -= m_dy;
                m_dist_start -= m_dy_start;
            }
        }

        //---------------------------------------------------------------------
        public void dec_y(int dx)
        {
            m_dist += m_dx;
            m_dist_start += m_dx_start;
            if (dx > 0)
            {
                m_dist += m_dy;
                m_dist_start += m_dy_start;
            }
            if (dx < 0)
            {
                m_dist -= m_dy;
                m_dist_start -= m_dy_start;
            }
        }

        //---------------------------------------------------------------------
        public int dist() { return m_dist; }
        public int dist_start() { return m_dist_start; }
        public int dist_end() { return m_dist_start; }

        //---------------------------------------------------------------------
        public int dx() { return m_dx; }
        public int dy() { return m_dy; }
        public int dx_start() { return m_dx_start; }
        public int dy_start() { return m_dy_start; }
        public int dx_end() { return m_dx_start; }
        public int dy_end() { return m_dy_start; }
    };

    //===================================================distance_interpolator3
    public class distance_interpolator3
    {
        int m_dx;
        int m_dy;
        int m_dx_start;
        int m_dy_start;
        int m_dx_end;
        int m_dy_end;

        int m_dist;
        int m_dist_start;
        int m_dist_end;

        //---------------------------------------------------------------------
        public distance_interpolator3() { }
        public distance_interpolator3(
            int x1, int y1, int x2, int y2,
            int sx, int sy, int ex, int ey,
            int x, int y
            )
        {
            unchecked
            {
                m_dx = (x2 - x1);
                m_dy = (y2 - y1);
                m_dx_start = (LineAABasics.line_mr(sx) - LineAABasics.line_mr(x1));
                m_dy_start = (LineAABasics.line_mr(sy) - LineAABasics.line_mr(y1));
                m_dx_end = (LineAABasics.line_mr(ex) - LineAABasics.line_mr(x2));
                m_dy_end = (LineAABasics.line_mr(ey) - LineAABasics.line_mr(y2));

                m_dist = (agg_basics.iround((double)(x + LineAABasics.line_subpixel_scale / 2 - x2) * (double)(m_dy) -
                              (double)(y + LineAABasics.line_subpixel_scale / 2 - y2) * (double)(m_dx)));

                m_dist_start = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sx)) * m_dy_start -
                             (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(sy)) * m_dx_start);

                m_dist_end = ((LineAABasics.line_mr(x + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ex)) * m_dy_end -
                           (LineAABasics.line_mr(y + LineAABasics.line_subpixel_scale / 2) - LineAABasics.line_mr(ey)) * m_dx_end);

                m_dx <<= LineAABasics.line_subpixel_shift;
                m_dy <<= LineAABasics.line_subpixel_shift;
                m_dx_start <<= LineAABasics.line_mr_subpixel_shift;
                m_dy_start <<= LineAABasics.line_mr_subpixel_shift;
                m_dx_end <<= LineAABasics.line_mr_subpixel_shift;
                m_dy_end <<= LineAABasics.line_mr_subpixel_shift;
            }
        }

        void inc_x() { m_dist += m_dy; m_dist_start += m_dy_start; m_dist_end += m_dy_end; }
        void dec_x() { m_dist -= m_dy; m_dist_start -= m_dy_start; m_dist_end -= m_dy_end; }
        void inc_y() { m_dist -= m_dx; m_dist_start -= m_dx_start; m_dist_end -= m_dx_end; }
        void dec_y() { m_dist += m_dx; m_dist_start += m_dx_start; m_dist_end += m_dx_end; }

        public void inc_x(int dy)
        {
            m_dist += m_dy;
            m_dist_start += m_dy_start;
            m_dist_end += m_dy_end;
            if (dy > 0)
            {
                m_dist -= m_dx;
                m_dist_start -= m_dx_start;
                m_dist_end -= m_dx_end;
            }
            if (dy < 0)
            {
                m_dist += m_dx;
                m_dist_start += m_dx_start;
                m_dist_end += m_dx_end;
            }
        }

        public void dec_x(int dy)
        {
            m_dist -= m_dy;
            m_dist_start -= m_dy_start;
            m_dist_end -= m_dy_end;
            if (dy > 0)
            {
                m_dist -= m_dx;
                m_dist_start -= m_dx_start;
                m_dist_end -= m_dx_end;
            }
            if (dy < 0)
            {
                m_dist += m_dx;
                m_dist_start += m_dx_start;
                m_dist_end += m_dx_end;
            }
        }

        public void inc_y(int dx)
        {
            m_dist -= m_dx;
            m_dist_start -= m_dx_start;
            m_dist_end -= m_dx_end;
            if (dx > 0)
            {
                m_dist += m_dy;
                m_dist_start += m_dy_start;
                m_dist_end += m_dy_end;
            }
            if (dx < 0)
            {
                m_dist -= m_dy;
                m_dist_start -= m_dy_start;
                m_dist_end -= m_dy_end;
            }
        }

        public void dec_y(int dx)
        {
            m_dist += m_dx;
            m_dist_start += m_dx_start;
            m_dist_end += m_dx_end;
            if (dx > 0)
            {
                m_dist += m_dy;
                m_dist_start += m_dy_start;
                m_dist_end += m_dy_end;
            }
            if (dx < 0)
            {
                m_dist -= m_dy;
                m_dist_start -= m_dy_start;
                m_dist_end -= m_dy_end;
            }
        }

        public int dist() { return m_dist; }
        public int dist_start() { return m_dist_start; }
        public int dist_end() { return m_dist_end; }

        int dx() { return m_dx; }
        int dy() { return m_dy; }
        public int dx_start() { return m_dx_start; }
        public int dy_start() { return m_dy_start; }
        public int dx_end() { return m_dx_end; }
        public int dy_end() { return m_dy_end; }
    };

    //================================================line_interpolator_aa_base
    public class line_interpolator_aa_base
    {
        protected line_parameters m_lp;
        protected dda2_line_interpolator m_li;
        protected OutlineRenderer m_ren;
        int m_len;
        protected int m_x;
        protected int m_y;
        protected int m_old_x;
        protected int m_old_y;
        protected int m_count;
        protected int m_width;
        protected int m_max_extent;
        protected int m_step;
        protected int[] m_dist = new int[max_half_width + 1];
        protected byte[] m_covers = new byte[max_half_width * 2 + 4];
        //typedef Renderer renderer_type;

        protected const int max_half_width = 64;

        public line_interpolator_aa_base(OutlineRenderer ren, line_parameters lp)
        {
            m_lp = lp;
            m_li = new dda2_line_interpolator(lp.vertical ? LineAABasics.line_dbl_hr(lp.x2 - lp.x1) : LineAABasics.line_dbl_hr(lp.y2 - lp.y1),
                lp.vertical ? Math.Abs(lp.y2 - lp.y1) : Math.Abs(lp.x2 - lp.x1) + 1);
            m_ren = ren;
            m_len = ((lp.vertical == (lp.inc > 0)) ? -lp.len : lp.len);
            m_x = (lp.x1 >> LineAABasics.line_subpixel_shift);
            m_y = (lp.y1 >> LineAABasics.line_subpixel_shift);
            m_old_x = (m_x);
            m_old_y = (m_y);
            m_count = ((lp.vertical ? Math.Abs((lp.y2 >> LineAABasics.line_subpixel_shift) - m_y) :
                                   Math.Abs((lp.x2 >> LineAABasics.line_subpixel_shift) - m_x)));
            m_width = (ren.subpixel_width());
            //m_max_extent(m_width >> (line_subpixel_shift - 2));
            m_max_extent = ((m_width + LineAABasics.line_subpixel_mask) >> LineAABasics.line_subpixel_shift);
            m_step = 0;

            dda2_line_interpolator li = new dda2_line_interpolator(0,
                lp.vertical ? (lp.dy << LineAABasics.line_subpixel_shift) : (lp.dx << LineAABasics.line_subpixel_shift),
                lp.len);

            int i;
            int stop = m_width + LineAABasics.line_subpixel_scale * 2;
            for (i = 0; i < max_half_width; ++i)
            {
                m_dist[i] = li.y();
                if (m_dist[i] >= stop) break;
                li.Next();
            }
            m_dist[i++] = 0x7FFF0000;
        }

        public int step_hor_base(distance_interpolator1 di)
        {
            m_li.Next();
            m_x += m_lp.inc;
            m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if (m_lp.inc > 0) di.inc_x(m_y - m_old_y);
            else di.dec_x(m_y - m_old_y);

            m_old_y = m_y;

            return di.dist() / m_len;
        }

        public int step_hor_base(distance_interpolator2 di)
        {
            m_li.Next();
            m_x += m_lp.inc;
            m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if (m_lp.inc > 0) di.inc_x(m_y - m_old_y);
            else di.dec_x(m_y - m_old_y);

            m_old_y = m_y;

            return di.dist() / m_len;
        }

        public int step_hor_base(distance_interpolator3 di)
        {
            m_li.Next();
            m_x += m_lp.inc;
            m_y = (m_lp.y1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if (m_lp.inc > 0) di.inc_x(m_y - m_old_y);
            else di.dec_x(m_y - m_old_y);

            m_old_y = m_y;

            return di.dist() / m_len;
        }

        public int step_ver_base(distance_interpolator1 di)
        {
            m_li.Next();
            m_y += m_lp.inc;
            m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if (m_lp.inc > 0) di.inc_y(m_x - m_old_x);
            else di.dec_y(m_x - m_old_x);

            m_old_x = m_x;

            return di.dist() / m_len;
        }

        public int step_ver_base(distance_interpolator2 di)
        {
            m_li.Next();
            m_y += m_lp.inc;
            m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if (m_lp.inc > 0) di.inc_y(m_x - m_old_x);
            else di.dec_y(m_x - m_old_x);

            m_old_x = m_x;

            return di.dist() / m_len;
        }

        public int step_ver_base(distance_interpolator3 di)
        {
            m_li.Next();
            m_y += m_lp.inc;
            m_x = (m_lp.x1 + m_li.y()) >> LineAABasics.line_subpixel_shift;

            if (m_lp.inc > 0) di.inc_y(m_x - m_old_x);
            else di.dec_y(m_x - m_old_x);

            m_old_x = m_x;

            return di.dist() / m_len;
        }

        public bool vertical() { return m_lp.vertical; }
        public int width() { return m_width; }
        public int count() { return m_count; }

    };

    //====================================================line_interpolator_aa0
    public class line_interpolator_aa0 : line_interpolator_aa_base
    {
        distance_interpolator1 m_di;
        //typedef Renderer renderer_type;
        //typedef line_interpolator_aa_base<Renderer> base_type;

        //---------------------------------------------------------------------
        public line_interpolator_aa0(OutlineRenderer ren, line_parameters lp)
            : base(ren, lp)
        {
            m_di = new distance_interpolator1(lp.x1, lp.y1, lp.x2, lp.y2,
                 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);

            m_li.adjust_forward();
        }

        //---------------------------------------------------------------------
        public bool step_hor()
        {
            int dist;
            int dy;
            int s1 = step_hor_base(m_di);
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            m_covers[Offset1++] = (byte)m_ren.cover(s1);

            dy = 1;
            while ((dist = base.m_dist[dy] - s1) <= base.m_width)
            {
                m_covers[Offset1++] = (byte)base.m_ren.cover(dist);
                ++dy;
            }

            dy = 1;
            while ((dist = base.m_dist[dy] + s1) <= base.m_width)
            {
                m_covers[--Offset0] = (byte)base.m_ren.cover(dist);
                ++dy;
            }
            base.m_ren.blend_solid_vspan(base.m_x, base.m_y - dy + 1, Offset1 - Offset0, m_covers, Offset0);
            return ++base.m_step < base.m_count;
        }

        //---------------------------------------------------------------------
        public bool step_ver()
        {
            int dist;
            int dx;
            int s1 = base.step_ver_base(m_di);
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            m_covers[Offset1++] = (byte)m_ren.cover(s1);

            dx = 1;
            while ((dist = base.m_dist[dx] - s1) <= base.m_width)
            {
                m_covers[Offset1++] = (byte)base.m_ren.cover(dist);
                ++dx;
            }

            dx = 1;
            while ((dist = base.m_dist[dx] + s1) <= base.m_width)
            {
                m_covers[--Offset0] = (byte)base.m_ren.cover(dist);
                ++dx;
            }
            base.m_ren.blend_solid_hspan(base.m_x - dx + 1, base.m_y, Offset1 - Offset0, m_covers, Offset0);
            return ++base.m_step < base.m_count;
        }
    };

    //====================================================line_interpolator_aa1
    public class line_interpolator_aa1 : line_interpolator_aa_base
    {
        distance_interpolator2 m_di;
        //typedef Renderer renderer_type;
        //typedef line_interpolator_aa_base<Renderer> base_type;

        //---------------------------------------------------------------------
        public line_interpolator_aa1(OutlineRenderer ren, line_parameters lp,
                              int sx, int sy)
            :
            base(ren, lp)
        {
            m_di = new distance_interpolator2(lp.x1, lp.y1, lp.x2, lp.y2, sx, sy,
                 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);

            int dist1_start;
            int dist2_start;

            int npix = 1;

            if (lp.vertical)
            {
                do
                {
                    base.m_li.Prev();
                    base.m_y -= lp.inc;
                    base.m_x = (base.m_lp.x1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if (lp.inc > 0) m_di.dec_y(base.m_x - base.m_old_x);
                    else m_di.inc_y(base.m_x - base.m_old_x);

                    base.m_old_x = base.m_x;

                    dist1_start = dist2_start = m_di.dist_start();

                    int dx = 0;
                    if (dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start += m_di.dy_start();
                        dist2_start -= m_di.dy_start();
                        if (dist1_start < 0) ++npix;
                        if (dist2_start < 0) ++npix;
                        ++dx;
                    }
                    while (base.m_dist[dx] <= base.m_width);
                    --base.m_step;
                    if (npix == 0) break;
                    npix = 0;
                }
                while (base.m_step >= -base.m_max_extent);
            }
            else
            {
                do
                {
                    base.m_li.Prev();
                    base.m_x -= lp.inc;
                    base.m_y = (base.m_lp.y1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if (lp.inc > 0) m_di.dec_x(base.m_y - base.m_old_y);
                    else m_di.inc_x(base.m_y - base.m_old_y);

                    base.m_old_y = base.m_y;

                    dist1_start = dist2_start = m_di.dist_start();

                    int dy = 0;
                    if (dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start -= m_di.dx_start();
                        dist2_start += m_di.dx_start();
                        if (dist1_start < 0) ++npix;
                        if (dist2_start < 0) ++npix;
                        ++dy;
                    }
                    while (base.m_dist[dy] <= base.m_width);
                    --base.m_step;
                    if (npix == 0) break;
                    npix = 0;
                }
                while (base.m_step >= -base.m_max_extent);
            }
            base.m_li.adjust_forward();
        }

        //---------------------------------------------------------------------
        public bool step_hor()
        {
            int dist_start;
            int dist;
            int dy;
            int s1 = base.step_hor_base(m_di);

            dist_start = m_di.dist_start();
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            m_covers[Offset1] = 0;
            if (dist_start <= 0)
            {
                m_covers[Offset1] = (byte)base.m_ren.cover(s1);
            }
            ++Offset1;

            dy = 1;
            while ((dist = base.m_dist[dy] - s1) <= base.m_width)
            {
                dist_start -= m_di.dx_start();
                m_covers[Offset1] = 0;
                if (dist_start <= 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(dist);
                }
                ++Offset1;
                ++dy;
            }

            dy = 1;
            dist_start = m_di.dist_start();
            while ((dist = base.m_dist[dy] + s1) <= base.m_width)
            {
                dist_start += m_di.dx_start();
                m_covers[--Offset0] = 0;
                if (dist_start <= 0)
                {
                    m_covers[Offset0] = (byte)base.m_ren.cover(dist);
                }
                ++dy;
            }

            int len = Offset1 - Offset0;
            base.m_ren.blend_solid_vspan(base.m_x, base.m_y - dy + 1, len, m_covers, Offset0);
            return ++base.m_step < base.m_count;
        }

        //---------------------------------------------------------------------
        public bool step_ver()
        {
            int dist_start;
            int dist;
            int dx;
            int s1 = base.step_ver_base(m_di);
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            dist_start = m_di.dist_start();

            m_covers[Offset1] = 0;
            if (dist_start <= 0)
            {
                m_covers[Offset1] = (byte)base.m_ren.cover(s1);
            }
            ++Offset1;

            dx = 1;
            while ((dist = base.m_dist[dx] - s1) <= base.m_width)
            {
                dist_start += m_di.dy_start();
                m_covers[Offset1] = 0;
                if (dist_start <= 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(dist);
                }
                ++Offset1;
                ++dx;
            }

            dx = 1;
            dist_start = m_di.dist_start();
            while ((dist = base.m_dist[dx] + s1) <= base.m_width)
            {
                dist_start -= m_di.dy_start();
                m_covers[--Offset0] = 0;
                if (dist_start <= 0)
                {
                    m_covers[Offset0] = (byte)base.m_ren.cover(dist);
                }
                ++dx;
            }
            base.m_ren.blend_solid_hspan(base.m_x - dx + 1, base.m_y, Offset1 - Offset0, m_covers, Offset0);

            return ++base.m_step < base.m_count;
        }
    };

    //====================================================line_interpolator_aa2
    public class line_interpolator_aa2 : line_interpolator_aa_base
    {
        distance_interpolator2 m_di;
        //typedef Renderer renderer_type;
        //typedef line_interpolator_aa_base<Renderer> base_type;

        //---------------------------------------------------------------------
        public line_interpolator_aa2(OutlineRenderer ren, line_parameters lp, int ex, int ey)
            : base(ren, lp)
        {
            m_di = new distance_interpolator2(lp.x1, lp.y1, lp.x2, lp.y2, ex, ey,
                 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask,
                 0);
            base.m_li.adjust_forward();
            base.m_step -= base.m_max_extent;
        }

        //---------------------------------------------------------------------
        public bool step_hor()
        {
            int dist_end;
            int dist;
            int dy;
            int s1 = base.step_hor_base(m_di);
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            dist_end = m_di.dist_end();

            int npix = 0;
            m_covers[Offset1] = 0;
            if (dist_end > 0)
            {
                m_covers[Offset1] = (byte)base.m_ren.cover(s1);
                ++npix;
            }
            ++Offset1;

            dy = 1;
            while ((dist = base.m_dist[dy] - s1) <= base.m_width)
            {
                dist_end -= m_di.dx_end();
                m_covers[Offset1] = 0;
                if (dist_end > 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++Offset1;
                ++dy;
            }

            dy = 1;
            dist_end = m_di.dist_end();
            while ((dist = base.m_dist[dy] + s1) <= base.m_width)
            {
                dist_end += m_di.dx_end();
                m_covers[--Offset0] = 0;
                if (dist_end > 0)
                {
                    m_covers[Offset0] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++dy;
            }
            base.m_ren.blend_solid_vspan(base.m_x,
                                               base.m_y - dy + 1,
                                               Offset1 - Offset0, m_covers,
                                               Offset0);
            return npix != 0 && ++base.m_step < base.m_count;
        }

        //---------------------------------------------------------------------
        public bool step_ver()
        {
            int dist_end;
            int dist;
            int dx;
            int s1 = base.step_ver_base(m_di);
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            dist_end = m_di.dist_end();

            int npix = 0;
            m_covers[Offset1] = 0;
            if (dist_end > 0)
            {
                m_covers[Offset1] = (byte)base.m_ren.cover(s1);
                ++npix;
            }
            ++Offset1;

            dx = 1;
            while ((dist = base.m_dist[dx] - s1) <= base.m_width)
            {
                dist_end += m_di.dy_end();
                m_covers[Offset1] = 0;
                if (dist_end > 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++Offset1;
                ++dx;
            }

            dx = 1;
            dist_end = m_di.dist_end();
            while ((dist = base.m_dist[dx] + s1) <= base.m_width)
            {
                dist_end -= m_di.dy_end();
                m_covers[--Offset0] = 0;
                if (dist_end > 0)
                {
                    m_covers[Offset0] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++dx;
            }
            base.m_ren.blend_solid_hspan(base.m_x - dx + 1,
                                               base.m_y,
                                               Offset1 - Offset0, m_covers,
                                               Offset0);
            return npix != 0 && ++base.m_step < base.m_count;
        }
    };

    //====================================================line_interpolator_aa3
    public class line_interpolator_aa3 : line_interpolator_aa_base
    {
        distance_interpolator3 m_di;
        //typedef Renderer renderer_type;
        //typedef line_interpolator_aa_base<Renderer> base_type;

        //---------------------------------------------------------------------
        public line_interpolator_aa3(OutlineRenderer ren, line_parameters lp,
                              int sx, int sy, int ex, int ey)
            :
            base(ren, lp)
        {
            m_di = new distance_interpolator3(lp.x1, lp.y1, lp.x2, lp.y2, sx, sy, ex, ey,
                 lp.x1 & ~LineAABasics.line_subpixel_mask, lp.y1 & ~LineAABasics.line_subpixel_mask);
            int dist1_start;
            int dist2_start;
            int npix = 1;
            if (lp.vertical)
            {
                do
                {
                    base.m_li.Prev();
                    base.m_y -= lp.inc;
                    base.m_x = (base.m_lp.x1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if (lp.inc > 0) m_di.dec_y(base.m_x - base.m_old_x);
                    else m_di.inc_y(base.m_x - base.m_old_x);

                    base.m_old_x = base.m_x;

                    dist1_start = dist2_start = m_di.dist_start();

                    int dx = 0;
                    if (dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start += m_di.dy_start();
                        dist2_start -= m_di.dy_start();
                        if (dist1_start < 0) ++npix;
                        if (dist2_start < 0) ++npix;
                        ++dx;
                    }
                    while (base.m_dist[dx] <= base.m_width);
                    if (npix == 0) break;
                    npix = 0;
                }
                while (--base.m_step >= -base.m_max_extent);
            }
            else
            {
                do
                {
                    base.m_li.Prev();
                    base.m_x -= lp.inc;
                    base.m_y = (base.m_lp.y1 + base.m_li.y()) >> LineAABasics.line_subpixel_shift;

                    if (lp.inc > 0) m_di.dec_x(base.m_y - base.m_old_y);
                    else m_di.inc_x(base.m_y - base.m_old_y);

                    base.m_old_y = base.m_y;

                    dist1_start = dist2_start = m_di.dist_start();

                    int dy = 0;
                    if (dist1_start < 0) ++npix;
                    do
                    {
                        dist1_start -= m_di.dx_start();
                        dist2_start += m_di.dx_start();
                        if (dist1_start < 0) ++npix;
                        if (dist2_start < 0) ++npix;
                        ++dy;
                    }
                    while (base.m_dist[dy] <= base.m_width);
                    if (npix == 0) break;
                    npix = 0;
                }
                while (--base.m_step >= -base.m_max_extent);
            }
            base.m_li.adjust_forward();
            base.m_step -= base.m_max_extent;
        }


        //---------------------------------------------------------------------
        public bool step_hor()
        {
            int dist_start;
            int dist_end;
            int dist;
            int dy;
            int s1 = base.step_hor_base(m_di);
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            dist_start = m_di.dist_start();
            dist_end = m_di.dist_end();

            int npix = 0;
            m_covers[Offset1] = 0;
            if (dist_end > 0)
            {
                if (dist_start <= 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(s1);
                }
                ++npix;
            }
            ++Offset1;

            dy = 1;
            while ((dist = base.m_dist[dy] - s1) <= base.m_width)
            {
                dist_start -= m_di.dx_start();
                dist_end -= m_di.dx_end();
                m_covers[Offset1] = 0;
                if (dist_end > 0 && dist_start <= 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++Offset1;
                ++dy;
            }

            dy = 1;
            dist_start = m_di.dist_start();
            dist_end = m_di.dist_end();
            while ((dist = base.m_dist[dy] + s1) <= base.m_width)
            {
                dist_start += m_di.dx_start();
                dist_end += m_di.dx_end();
                m_covers[--Offset0] = 0;
                if (dist_end > 0 && dist_start <= 0)
                {
                    m_covers[Offset0] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++dy;
            }
            base.m_ren.blend_solid_vspan(base.m_x,
                                               base.m_y - dy + 1,
                                               Offset1 - Offset0, m_covers,
                                               Offset0);
            return npix != 0 && ++base.m_step < base.m_count;
        }

        //---------------------------------------------------------------------
        public bool step_ver()
        {
            int dist_start;
            int dist_end;
            int dist;
            int dx;
            int s1 = base.step_ver_base(m_di);
            int Offset0 = max_half_width + 2;
            int Offset1 = Offset0;

            dist_start = m_di.dist_start();
            dist_end = m_di.dist_end();

            int npix = 0;
            m_covers[Offset1] = 0;
            if (dist_end > 0)
            {
                if (dist_start <= 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(s1);
                }
                ++npix;
            }
            ++Offset1;

            dx = 1;
            while ((dist = base.m_dist[dx] - s1) <= base.m_width)
            {
                dist_start += m_di.dy_start();
                dist_end += m_di.dy_end();
                m_covers[Offset1] = 0;
                if (dist_end > 0 && dist_start <= 0)
                {
                    m_covers[Offset1] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++Offset1;
                ++dx;
            }

            dx = 1;
            dist_start = m_di.dist_start();
            dist_end = m_di.dist_end();
            while ((dist = base.m_dist[dx] + s1) <= base.m_width)
            {
                dist_start -= m_di.dy_start();
                dist_end -= m_di.dy_end();
                m_covers[--Offset0] = 0;
                if (dist_end > 0 && dist_start <= 0)
                {
                    m_covers[Offset0] = (byte)base.m_ren.cover(dist);
                    ++npix;
                }
                ++dx;
            }
            base.m_ren.blend_solid_hspan(base.m_x - dx + 1,
                                               base.m_y,
                                               Offset1 - Offset0, m_covers,
                                               Offset0);
            return npix != 0 && ++base.m_step < base.m_count;
        }
    };


    //==========================================================line_profile_aa
    //
    // See Implementation agg_line_profile_aa.cpp 
    // 
    public class LineProfileAnitAlias
    {
        const int subpixel_shift = 8;
        const int subpixel_scale = 1 << subpixel_shift;
        const int subpixel_mask = subpixel_scale - 1;

        const int aa_shift = 8;
        const int aa_scale = 1 << aa_shift;
        const int aa_mask = aa_scale - 1;

        ArrayPOD<byte> m_profile = new ArrayPOD<byte>();
        byte[] m_gamma = new byte[aa_scale];
        int m_subpixel_width;
        double m_min_width;
        double m_smoother_width;

        //---------------------------------------------------------------------

        //---------------------------------------------------------------------
        public LineProfileAnitAlias()
        {
            m_subpixel_width = (0);
            m_min_width = (1.0);
            m_smoother_width = (1.0);

            int i;
            for (i = 0; i < aa_scale; i++) m_gamma[i] = (byte)i;
        }

        //---------------------------------------------------------------------
        public LineProfileAnitAlias(double w, IGammaFunction gamma_function)
        {
            m_subpixel_width = (0);
            m_min_width = (1.0);
            m_smoother_width = (1.0);
            gamma(gamma_function);
            width(w);
        }

        //---------------------------------------------------------------------
        public void min_width(double w) { m_min_width = w; }
        public void smoother_width(double w) { m_smoother_width = w; }

        //---------------------------------------------------------------------
        public void gamma(IGammaFunction gamma_function)
        {
            int i;
            for (i = 0; i < aa_scale; i++)
            {
                m_gamma[i] = (byte)(agg_basics.uround(gamma_function.GetGamma((double)(i) / aa_mask) * aa_mask));
            }
        }

        public void width(double w)
        {
            if (w < 0.0) w = 0.0;

            if (w < m_smoother_width) w += w;
            else w += m_smoother_width;

            w *= 0.5;

            w -= m_smoother_width;
            double s = m_smoother_width;
            if (w < 0.0)
            {
                s += w;
                w = 0.0;
            }
            set(w, s);
        }

        public int profile_size() { return m_profile.Size(); }
        public int subpixel_width() { return m_subpixel_width; }

        //---------------------------------------------------------------------
        public double min_width() { return m_min_width; }
        public double smoother_width() { return m_smoother_width; }

        //---------------------------------------------------------------------
        public byte value(int dist)
        {
            return m_profile.Array[dist + subpixel_scale * 2];
        }

        private byte[] profile(double w)
        {
            m_subpixel_width = (int)agg_basics.uround(w * subpixel_scale);
            int size = m_subpixel_width + subpixel_scale * 6;
            if (size > m_profile.Size())
            {
                m_profile.Resize(size);
            }
            return m_profile.Array;
        }

        private void set(double center_width, double smoother_width)
        {
            double base_val = 1.0;
            if (center_width == 0.0) center_width = 1.0 / subpixel_scale;
            if (smoother_width == 0.0) smoother_width = 1.0 / subpixel_scale;

            double width = center_width + smoother_width;
            if (width < m_min_width)
            {
                double k = width / m_min_width;
                base_val *= k;
                center_width /= k;
                smoother_width /= k;
            }

            byte[] ch = profile(center_width + smoother_width);
            int chIndex = 0;

            int subpixel_center_width = (int)(center_width * subpixel_scale);
            int subpixel_smoother_width = (int)(smoother_width * subpixel_scale);

            int ch_center = subpixel_scale * 2;
            int ch_smoother = ch_center + subpixel_center_width;

            int i;

            int val = m_gamma[(int)(base_val * aa_mask)];
            chIndex = ch_center;
            for (i = 0; i < subpixel_center_width; i++)
            {
                ch[chIndex++] = (byte)val;
            }

            for (i = 0; i < subpixel_smoother_width; i++)
            {
                ch[ch_smoother++] =
                    m_gamma[(int)((base_val -
                                      base_val *
                                      ((double)(i) / subpixel_smoother_width)) * aa_mask)];
            }

            int n_smoother = ch.Length -
                                  subpixel_smoother_width -
                                  subpixel_center_width -
                                  subpixel_scale * 2;

            val = m_gamma[0];
            for (i = 0; i < n_smoother; i++)
            {
                ch[ch_smoother++] = (byte)val;
            }

            chIndex = ch_center;
            for (i = 0; i < subpixel_scale * 2; i++)
            {
                ch[--chIndex] = ch[ch_center++];
            }

            for (i = 0; i < ch.Length; i++)
            {
                m_profile.Array[i] = ch[i];
            }
        }
    };

    public class ellipse_bresenham_interpolator
    {
        int m_rx2;
        int m_ry2;
        int m_two_rx2;
        int m_two_ry2;
        int m_dx;
        int m_dy;
        int m_inc_x;
        int m_inc_y;
        int m_cur_f;

        public ellipse_bresenham_interpolator(int rx, int ry)
        {
            m_rx2 = (rx * rx);
            m_ry2 = (ry * ry);
            m_two_rx2 = (m_rx2 << 1);
            m_two_ry2 = (m_ry2 << 1);
            m_dx = (0);
            m_dy = (0);
            m_inc_x = (0);
            m_inc_y = (-ry * m_two_rx2);
            m_cur_f = (0);
        }

        public int dx() { return m_dx; }
        public int dy() { return m_dy; }

        public void Next()
        {
            int mx, my, mxy, min_m;
            int fx, fy, fxy;

            mx = fx = m_cur_f + m_inc_x + m_ry2;
            if (mx < 0) mx = -mx;

            my = fy = m_cur_f + m_inc_y + m_rx2;
            if (my < 0) my = -my;

            mxy = fxy = m_cur_f + m_inc_x + m_ry2 + m_inc_y + m_rx2;
            if (mxy < 0) mxy = -mxy;

            min_m = mx;
            bool flag = true;

            if (min_m > my)
            {
                min_m = my;
                flag = false;
            }

            m_dx = m_dy = 0;

            if (min_m > mxy)
            {
                m_inc_x += m_two_ry2;
                m_inc_y += m_two_rx2;
                m_cur_f = fxy;
                m_dx = 1;
                m_dy = 1;
                return;
            }

            if (flag)
            {
                m_inc_x += m_two_ry2;
                m_cur_f = fx;
                m_dx = 1;
                return;
            }

            m_inc_y += m_two_rx2;
            m_cur_f = fy;
            m_dy = 1;
        }
    };

    public abstract class LineRenderer
    {
        private RGBA_Bytes m_color;

        public delegate bool CompareFunction(int value);
        public RGBA_Bytes color() { return m_color; }

        public void color(IColorType c) { m_color = c.GetAsRGBA_Bytes(); }
        public abstract void semidot(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2);
        public abstract void semidot_hline(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2, int x1, int y1, int x2);
        public abstract void pie(int xc, int yc, int x1, int y1, int x2, int y2);
        public abstract void line0(line_parameters lp);
        public abstract void line1(line_parameters lp, int sx, int sy);
        public abstract void line2(line_parameters lp, int ex, int ey);
        public abstract void line3(line_parameters lp, int sx, int sy, int ex, int ey);
    }

    //======================================================renderer_outline_aa
    public class OutlineRenderer : LineRenderer
    {
        private IImageByte destImageSurface;
        LineProfileAnitAlias lineProfile;
        RectangleInt clippingRectangle;
        bool doClipping;
        protected const int max_half_width = 64;

#if false
        public int min_x() { throw new System.NotImplementedException(); }
        public int min_y() { throw new System.NotImplementedException(); }
        public int max_x() { throw new System.NotImplementedException(); }
        public int max_y() { throw new System.NotImplementedException(); }
        public void gamma(IGammaFunction gamma_function) { throw new System.NotImplementedException(); }
        public bool sweep_scanline(IScanlineCache sl) { throw new System.NotImplementedException(); }
        public void reset() { throw new System.NotImplementedException(); }
#endif

        //---------------------------------------------------------------------
        public OutlineRenderer(IImageByte destImage, LineProfileAnitAlias profile)
        {
            destImageSurface = destImage;
            lineProfile = profile;
            clippingRectangle = new RectangleInt(0, 0, 0, 0);
            doClipping = false;
        }

        public void attach(IImageByte ren) { destImageSurface = ren; }

        //---------------------------------------------------------------------
        public void profile(LineProfileAnitAlias prof) { lineProfile = prof; }
        public LineProfileAnitAlias profile() { return lineProfile; }

        //---------------------------------------------------------------------
        public int subpixel_width() { return lineProfile.subpixel_width(); }

        //---------------------------------------------------------------------
        public void reset_clipping() { doClipping = false; }
        public void clip_box(double x1, double y1, double x2, double y2)
        {
            clippingRectangle.Left = line_coord_sat.conv(x1);
            clippingRectangle.Bottom = line_coord_sat.conv(y1);
            clippingRectangle.Right = line_coord_sat.conv(x2);
            clippingRectangle.Top = line_coord_sat.conv(y2);
            doClipping = true;
        }

        //---------------------------------------------------------------------
        public int cover(int d)
        {
            return lineProfile.value(d);
        }

        public void blend_solid_hspan(int x, int y, int len, byte[] covers, int coversOffset)
        {
            destImageSurface.blend_solid_hspan(x, y, len, color(), covers, coversOffset);
        }

        public void blend_solid_vspan(int x, int y, int len, byte[] covers, int coversOffset)
        {
            destImageSurface.blend_solid_vspan(x, y, len, color(), covers, coversOffset);
        }

        public static bool accurate_join_only() { return false; }

        public override void semidot_hline(CompareFunction cmp,
                           int xc1, int yc1, int xc2, int yc2,
                           int x1, int y1, int x2)
        {
            byte[] covers = new byte[max_half_width * 2 + 4];
            int Offset0 = 0;
            int Offset1 = 0;
            int x = x1 << LineAABasics.line_subpixel_shift;
            int y = y1 << LineAABasics.line_subpixel_shift;
            int w = subpixel_width();
            distance_interpolator0 di = new distance_interpolator0(xc1, yc1, xc2, yc2, x, y);
            x += LineAABasics.line_subpixel_scale / 2;
            y += LineAABasics.line_subpixel_scale / 2;

            int x0 = x1;
            int dx = x - xc1;
            int dy = y - yc1;
            do
            {
                int d = (int)(agg_math.fast_sqrt(dx * dx + dy * dy));
                covers[Offset1] = 0;
                if (cmp(di.dist()) && d <= w)
                {
                    covers[Offset1] = (byte)cover(d);
                }
                ++Offset1;
                dx += LineAABasics.line_subpixel_scale;
                di.inc_x();
            }
            while (++x1 <= x2);
            destImageSurface.blend_solid_hspan(x0, y1,
                                     Offset1 - Offset0,
                                     color(), covers,
                                     Offset0);
        }

        public override void semidot(CompareFunction cmp, int xc1, int yc1, int xc2, int yc2)
        {
            if (doClipping && ClipLiangBarsky.clipping_flags(xc1, yc1, clippingRectangle) != 0) return;

            int r = ((subpixel_width() + LineAABasics.line_subpixel_mask) >> LineAABasics.line_subpixel_shift);
            if (r < 1) r = 1;
            ellipse_bresenham_interpolator ei = new ellipse_bresenham_interpolator(r, r);
            int dx = 0;
            int dy = -r;
            int dy0 = dy;
            int dx0 = dx;
            int x = xc1 >> LineAABasics.line_subpixel_shift;
            int y = yc1 >> LineAABasics.line_subpixel_shift;

            do
            {
                dx += ei.dx();
                dy += ei.dy();

                if (dy != dy0)
                {
                    semidot_hline(cmp, xc1, yc1, xc2, yc2, x - dx0, y + dy0, x + dx0);
                    semidot_hline(cmp, xc1, yc1, xc2, yc2, x - dx0, y - dy0, x + dx0);
                }
                dx0 = dx;
                dy0 = dy;
                ei.Next();
            }
            while (dy < 0);
            semidot_hline(cmp, xc1, yc1, xc2, yc2, x - dx0, y + dy0, x + dx0);
        }

        public void pie_hline(int xc, int yc, int xp1, int yp1, int xp2, int yp2,
                       int xh1, int yh1, int xh2)
        {
            if (doClipping && ClipLiangBarsky.clipping_flags(xc, yc, clippingRectangle) != 0) return;

            byte[] covers = new byte[max_half_width * 2 + 4];
            int index0 = 0;
            int index1 = 0;
            int x = xh1 << LineAABasics.line_subpixel_shift;
            int y = yh1 << LineAABasics.line_subpixel_shift;
            int w = subpixel_width();

            distance_interpolator00 di = new distance_interpolator00(xc, yc, xp1, yp1, xp2, yp2, x, y);
            x += LineAABasics.line_subpixel_scale / 2;
            y += LineAABasics.line_subpixel_scale / 2;

            int xh0 = xh1;
            int dx = x - xc;
            int dy = y - yc;
            do
            {
                int d = (int)(agg_math.fast_sqrt(dx * dx + dy * dy));
                covers[index1] = 0;
                if (di.dist1() <= 0 && di.dist2() > 0 && d <= w)
                {
                    covers[index1] = (byte)cover(d);
                }
                ++index1;
                dx += LineAABasics.line_subpixel_scale;
                di.inc_x();
            }
            while (++xh1 <= xh2);
            destImageSurface.blend_solid_hspan(xh0, yh1, index1 - index0, color(), covers, index0);
        }

        public override void pie(int xc, int yc, int x1, int y1, int x2, int y2)
        {
            int r = ((subpixel_width() + LineAABasics.line_subpixel_mask) >> LineAABasics.line_subpixel_shift);
            if (r < 1) r = 1;
            ellipse_bresenham_interpolator ei = new ellipse_bresenham_interpolator(r, r);
            int dx = 0;
            int dy = -r;
            int dy0 = dy;
            int dx0 = dx;
            int x = xc >> LineAABasics.line_subpixel_shift;
            int y = yc >> LineAABasics.line_subpixel_shift;

            do
            {
                dx += ei.dx();
                dy += ei.dy();

                if (dy != dy0)
                {
                    pie_hline(xc, yc, x1, y1, x2, y2, x - dx0, y + dy0, x + dx0);
                    pie_hline(xc, yc, x1, y1, x2, y2, x - dx0, y - dy0, x + dx0);
                }
                dx0 = dx;
                dy0 = dy;
                ei.Next();
            }
            while (dy < 0);
            pie_hline(xc, yc, x1, y1, x2, y2, x - dx0, y + dy0, x + dx0);
        }

        public void line0_no_clip(line_parameters lp)
        {
            if (lp.len > LineAABasics.line_max_length)
            {
                line_parameters lp1, lp2;
                lp.divide(out lp1, out lp2);
                line0_no_clip(lp1);
                line0_no_clip(lp2);
                return;
            }

            line_interpolator_aa0 li = new line_interpolator_aa0(this, lp);
            if (li.count() != 0)
            {
                if (li.vertical())
                {
                    while (li.step_ver()) ;
                }
                else
                {
                    while (li.step_hor()) ;
                }
            }
        }

        public override void line0(line_parameters lp)
        {
            if (doClipping)
            {
                int x1 = lp.x1;
                int y1 = lp.y1;
                int x2 = lp.x2;
                int y2 = lp.y2;
                int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
                if ((flags & 4) == 0)
                {
                    if (flags != 0)
                    {
                        line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
                                           agg_basics.uround(agg_math.calc_distance(x1, y1, x2, y2)));
                        line0_no_clip(lp2);
                    }
                    else
                    {
                        line0_no_clip(lp);
                    }
                }
            }
            else
            {
                line0_no_clip(lp);
            }
        }

        public void line1_no_clip(line_parameters lp, int sx, int sy)
        {
            if (lp.len > LineAABasics.line_max_length)
            {
                line_parameters lp1, lp2;
                lp.divide(out lp1, out lp2);
                line1_no_clip(lp1, (lp.x1 + sx) >> 1, (lp.y1 + sy) >> 1);
                line1_no_clip(lp2, lp1.x2 + (lp1.y2 - lp1.y1), lp1.y2 - (lp1.x2 - lp1.x1));
                return;
            }

            LineAABasics.fix_degenerate_bisectrix_start(lp, ref sx, ref sy);
            line_interpolator_aa1 li = new line_interpolator_aa1(this, lp, sx, sy);
            if (li.vertical())
            {
                while (li.step_ver()) ;
            }
            else
            {
                while (li.step_hor()) ;
            }
        }

        public override void line1(line_parameters lp, int sx, int sy)
        {
            if (doClipping)
            {
                int x1 = lp.x1;
                int y1 = lp.y1;
                int x2 = lp.x2;
                int y2 = lp.y2;
                int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
                if ((flags & 4) == 0)
                {
                    if (flags != 0)
                    {
                        line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
                                           agg_basics.uround(agg_math.calc_distance(x1, y1, x2, y2)));
                        if (((int)flags & 1) != 0)
                        {
                            sx = x1 + (y2 - y1);
                            sy = y1 - (x2 - x1);
                        }
                        else
                        {
                            while (Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)
                            {
                                sx = (lp.x1 + sx) >> 1;
                                sy = (lp.y1 + sy) >> 1;
                            }
                        }
                        line1_no_clip(lp2, sx, sy);
                    }
                    else
                    {
                        line1_no_clip(lp, sx, sy);
                    }
                }
            }
            else
            {
                line1_no_clip(lp, sx, sy);
            }
        }

        public void line2_no_clip(line_parameters lp, int ex, int ey)
        {
            if (lp.len > LineAABasics.line_max_length)
            {
                line_parameters lp1, lp2;
                lp.divide(out lp1, out lp2);
                line2_no_clip(lp1, lp1.x2 + (lp1.y2 - lp1.y1), lp1.y2 - (lp1.x2 - lp1.x1));
                line2_no_clip(lp2, (lp.x2 + ex) >> 1, (lp.y2 + ey) >> 1);
                return;
            }

            LineAABasics.fix_degenerate_bisectrix_end(lp, ref ex, ref ey);
            line_interpolator_aa2 li = new line_interpolator_aa2(this, lp, ex, ey);
            if (li.vertical())
            {
                while (li.step_ver()) ;
            }
            else
            {
                while (li.step_hor()) ;
            }
        }

        public override void line2(line_parameters lp, int ex, int ey)
        {
            if (doClipping)
            {
                int x1 = lp.x1;
                int y1 = lp.y1;
                int x2 = lp.x2;
                int y2 = lp.y2;
                int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
                if ((flags & 4) == 0)
                {
                    if (flags != 0)
                    {
                        line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
                                           agg_basics.uround(agg_math.calc_distance(x1, y1, x2, y2)));
                        if ((flags & 2) != 0)
                        {
                            ex = x2 + (y2 - y1);
                            ey = y2 - (x2 - x1);
                        }
                        else
                        {
                            while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)
                            {
                                ex = (lp.x2 + ex) >> 1;
                                ey = (lp.y2 + ey) >> 1;
                            }
                        }
                        line2_no_clip(lp2, ex, ey);
                    }
                    else
                    {
                        line2_no_clip(lp, ex, ey);
                    }
                }
            }
            else
            {
                line2_no_clip(lp, ex, ey);
            }
        }

        public void line3_no_clip(line_parameters lp,
                           int sx, int sy, int ex, int ey)
        {
            if (lp.len > LineAABasics.line_max_length)
            {
                line_parameters lp1, lp2;
                lp.divide(out lp1, out lp2);
                int mx = lp1.x2 + (lp1.y2 - lp1.y1);
                int my = lp1.y2 - (lp1.x2 - lp1.x1);
                line3_no_clip(lp1, (lp.x1 + sx) >> 1, (lp.y1 + sy) >> 1, mx, my);
                line3_no_clip(lp2, mx, my, (lp.x2 + ex) >> 1, (lp.y2 + ey) >> 1);
                return;
            }

            LineAABasics.fix_degenerate_bisectrix_start(lp, ref sx, ref sy);
            LineAABasics.fix_degenerate_bisectrix_end(lp, ref ex, ref ey);
            line_interpolator_aa3 li = new line_interpolator_aa3(this, lp, sx, sy, ex, ey);
            if (li.vertical())
            {
                while (li.step_ver()) ;
            }
            else
            {
                while (li.step_hor()) ;
            }
        }

        public override void line3(line_parameters lp,
                   int sx, int sy, int ex, int ey)
        {
            if (doClipping)
            {
                int x1 = lp.x1;
                int y1 = lp.y1;
                int x2 = lp.x2;
                int y2 = lp.y2;
                int flags = ClipLiangBarsky.clip_line_segment(ref x1, ref y1, ref x2, ref y2, clippingRectangle);
                if ((flags & 4) == 0)
                {
                    if (flags != 0)
                    {
                        line_parameters lp2 = new line_parameters(x1, y1, x2, y2,
                            agg_basics.uround(agg_math.calc_distance(x1, y1, x2, y2)));
                        if ((flags & 1) != 0)
                        {
                            sx = x1 + (y2 - y1);
                            sy = y1 - (x2 - x1);
                        }
                        else
                        {
                            while (Math.Abs(sx - lp.x1) + Math.Abs(sy - lp.y1) > lp2.len)
                            {
                                sx = (lp.x1 + sx) >> 1;
                                sy = (lp.y1 + sy) >> 1;
                            }
                        }
                        if ((flags & 2) != 0)
                        {
                            ex = x2 + (y2 - y1);
                            ey = y2 - (x2 - x1);
                        }
                        else
                        {
                            while (Math.Abs(ex - lp.x2) + Math.Abs(ey - lp.y2) > lp2.len)
                            {
                                ex = (lp.x2 + ex) >> 1;
                                ey = (lp.y2 + ey) >> 1;
                            }
                        }
                        line3_no_clip(lp2, sx, sy, ex, ey);
                    }
                    else
                    {
                        line3_no_clip(lp, sx, sy, ex, ey);
                    }
                }
            }
            else
            {
                line3_no_clip(lp, sx, sy, ex, ey);
            }
        }
    };
#endif
}

#endregion //OutlineRenderer.cs
#region PathStorage.cs


//----------------------------------------------------------------------------
//using System;
//using System.Collections.Generic;
//using MatterHackers.VectorMath;

namespace MatterHackers.Agg.VertexSource
{
    //---------------------------------------------------------------path_base
    // A container to store vertices with their flags. 
    // A path consists of a number of contours separated with "move_to" 
    // commands. The path storage can keep and maintain more than one
    // path. 
    // To navigate to the beginning of a particular path, use rewind(path_id);
    // Where path_id is what start_new_path() returns. So, when you call
    // start_new_path() you need to store its return value somewhere else
    // to navigate to the path afterwards.
    //
    // See also: vertex_source concept
    //------------------------------------------------------------------------
    public class PathStorage : IVertexSource, IVertexDest
    {

        #region InternalVertexStorage
        private class VertexStorage
        {
            int m_num_vertices;
            int m_allocated_vertices;
            double[] m_coord_x;
            double[] m_coord_y;
            ShapePath.FlagsAndCommand[] m_CommandAndFlags;

            public void free_all()
            {
                m_coord_x = null;
                m_coord_y = null;
                m_CommandAndFlags = null;

                m_num_vertices = 0;
            }

            public int size()
            {
                return m_num_vertices;
            }

            public VertexStorage()
            {
            }

            public void remove_all()
            {
                m_num_vertices = 0;
            }

            public void AddVertex(double x, double y, ShapePath.FlagsAndCommand CommandAndFlags)
            {
                allocate_if_required(m_num_vertices);
                m_coord_x[m_num_vertices] = x;
                m_coord_y[m_num_vertices] = y;
                m_CommandAndFlags[m_num_vertices] = CommandAndFlags;

                m_num_vertices++;
            }

            public void modify_vertex(int index, double x, double y)
            {
                m_coord_x[index] = x;
                m_coord_y[index] = y;
            }

            public void modify_vertex(int index, double x, double y, ShapePath.FlagsAndCommand CommandAndFlags)
            {
                m_coord_x[index] = x;
                m_coord_y[index] = y;
                m_CommandAndFlags[index] = CommandAndFlags;
            }

            public void modify_command(int index, ShapePath.FlagsAndCommand CommandAndFlags)
            {
                m_CommandAndFlags[index] = CommandAndFlags;
            }

            public void swap_vertices(int v1, int v2)
            {
                double val;

                val = m_coord_x[v1]; m_coord_x[v1] = m_coord_x[v2]; m_coord_x[v2] = val;
                val = m_coord_y[v1]; m_coord_y[v1] = m_coord_y[v2]; m_coord_y[v2] = val;
                ShapePath.FlagsAndCommand cmd = m_CommandAndFlags[v1];
                m_CommandAndFlags[v1] = m_CommandAndFlags[v2];
                m_CommandAndFlags[v2] = cmd;
            }

            public ShapePath.FlagsAndCommand last_command()
            {
                if (m_num_vertices != 0)
                {
                    return command(m_num_vertices - 1);
                }

                return ShapePath.FlagsAndCommand.CommandStop;
            }

            public ShapePath.FlagsAndCommand last_vertex(out double x, out double y)
            {
                if (m_num_vertices != 0)
                {
                    return vertex((int)(m_num_vertices - 1), out x, out y);
                }

                x = new double();
                y = new double();
                return ShapePath.FlagsAndCommand.CommandStop;
            }

            public ShapePath.FlagsAndCommand prev_vertex(out double x, out double y)
            {
                if (m_num_vertices > 1)
                {
                    return vertex((int)(m_num_vertices - 2), out x, out y);
                }

                x = new double();
                y = new double();
                return ShapePath.FlagsAndCommand.CommandStop;
            }

            public double last_x()
            {
                if (m_num_vertices > 0)
                {
                    int index = (int)(m_num_vertices - 1);
                    return m_coord_x[index];
                }

                return new double();
            }

            public double last_y()
            {
                if (m_num_vertices > 0)
                {
                    int index = (int)(m_num_vertices - 1);
                    return m_coord_y[index];
                }
                return new double();
            }

            public int total_vertices()
            {
                return m_num_vertices;
            }

            public ShapePath.FlagsAndCommand vertex(int index, out double x, out double y)
            {
                x = m_coord_x[index];
                y = m_coord_y[index];
                return m_CommandAndFlags[index];
            }

            public ShapePath.FlagsAndCommand command(int index)
            {
                return m_CommandAndFlags[index];
            }

            private void allocate_if_required(int indexToAdd)
            {
                if (indexToAdd < m_num_vertices)
                {
                    return;
                }

                while (indexToAdd >= m_allocated_vertices)
                {
                    int newSize = m_allocated_vertices + 256;
                    double[] newX = new double[newSize];
                    double[] newY = new double[newSize];
                    ShapePath.FlagsAndCommand[] newCmd = new ShapePath.FlagsAndCommand[newSize];

                    if (m_coord_x != null)
                    {
                        for (int i = 0; i < m_num_vertices; i++)
                        {
                            newX[i] = m_coord_x[i];
                            newY[i] = m_coord_y[i];
                            newCmd[i] = m_CommandAndFlags[i];
                        }
                    }

                    m_coord_x = newX;
                    m_coord_y = newY;
                    m_CommandAndFlags = newCmd;

                    m_allocated_vertices = newSize;
                }
            }
        }
        #endregion

        private VertexStorage vertices;
        private int iteratorIndex;

        public PathStorage()
        {
            vertices = new VertexStorage();
        }

        public void add(Vector2 vertex)
        {
            throw new System.NotImplementedException();
        }

        public void Add(double x, double y, ShapePath.FlagsAndCommand flagsAndCommand)
        {
            vertices.AddVertex(x, y, flagsAndCommand);
        }

        public int size()
        {
            return vertices.size();
        }

        public Vector2 this[int i]
        {
            get
            {
                throw new NotImplementedException("make this work");
            }
        }

        public void remove_all() { vertices.remove_all(); iteratorIndex = 0; }
        public void free_all() { vertices.free_all(); iteratorIndex = 0; }

        public bool Equals(IVertexSource other, double maxError = .0001, bool oldStyle = true)
        {
            if (oldStyle)
            {
                return OldEqualsOldStyle(this, other, maxError);
            }
            else
            {
                return OldEqualsNewStyle(this, other, maxError);
            }
        }

        static public bool OldEqualsOldStyle(IVertexSource control, IVertexSource test, double maxError = .0001)
        {
            control.rewind(0);
            double controlX;
            double controlY;
            ShapePath.FlagsAndCommand controlFlagsAndCommand = control.vertex(out controlX, out controlY);

            test.rewind(0);
            double testX;
            double testY;
            ShapePath.FlagsAndCommand otherFlagsAndCommand = test.vertex(out testX, out testY);

            int index = 1;
            if (controlFlagsAndCommand == otherFlagsAndCommand && controlX == testX && agg_basics.is_equal_eps(controlY, testY, .000000001))
            {
                while (controlFlagsAndCommand != ShapePath.FlagsAndCommand.CommandStop)
                {
                    controlFlagsAndCommand = control.vertex(out controlX, out controlY);
                    otherFlagsAndCommand = test.vertex(out testX, out testY);
                    if (controlFlagsAndCommand != otherFlagsAndCommand
                        || controlX < testX - maxError || controlX > testX + maxError
                        || controlY < testY - maxError || controlY > testY + maxError)
                    {
                        return false;
                    }
                    index++;
                }

                return true;
            }

            return false;
        }

        static public bool OldEqualsNewStyle(IVertexSource control, IVertexSource test, double maxError = .0001)
        {
            control.rewind(0);
            double controlX;
            double controlY;
            ShapePath.FlagsAndCommand controlFlagsAndCommand = control.vertex(out controlX, out controlY);

            int index = 0;
            foreach (VertexData vertexData in test.Vertices())
            {
                if (controlFlagsAndCommand != vertexData.command
                    || controlX < vertexData.position.x - maxError || controlX > vertexData.position.x + maxError
                    || controlY < vertexData.position.y - maxError || controlY > vertexData.position.y + maxError)
                {
                    return false;
                }
                controlFlagsAndCommand = control.vertex(out controlX, out controlY);
                index++;
            }

            if (controlFlagsAndCommand == ShapePath.FlagsAndCommand.CommandStop)
            {
                return true;
            }

            return false;
        }

        // Make path functions
        //--------------------------------------------------------------------
        public int start_new_path()
        {
            if (!ShapePath.is_stop(vertices.last_command()))
            {
                vertices.AddVertex(0.0, 0.0, ShapePath.FlagsAndCommand.CommandStop);
            }
            return vertices.total_vertices();
        }


        public void rel_to_abs(ref double x, ref double y)
        {
            if (vertices.total_vertices() != 0)
            {
                double x2;
                double y2;
                if (ShapePath.is_vertex(vertices.last_vertex(out x2, out y2)))
                {
                    x += x2;
                    y += y2;
                }
            }
        }

        public void MoveTo(double x, double y)
        {
            vertices.AddVertex(x, y, ShapePath.FlagsAndCommand.CommandMoveTo);
        }

        public void LineTo(double x, double y)
        {
            vertices.AddVertex(x, y, ShapePath.FlagsAndCommand.CommandLineTo);
        }

        public void HorizontalLineTo(double x)
        {
            vertices.AddVertex(x, GetLastY(), ShapePath.FlagsAndCommand.CommandLineTo);
        }

        public void VerticalLineTo(double y)
        {
            vertices.AddVertex(GetLastX(), y, ShapePath.FlagsAndCommand.CommandLineTo);
        }

        /*
        public void arc_to(double rx, double ry,
                                   double angle,
                                   bool large_arc_flag,
                                   bool sweep_flag,
                                   double x, double y)
        {
            if(m_vertices.total_vertices() && is_vertex(m_vertices.last_command()))
            {
                double epsilon = 1e-30;
                double x0 = 0.0;
                double y0 = 0.0;
                m_vertices.last_vertex(&x0, &y0);

                rx = fabs(rx);
                ry = fabs(ry);

                // Ensure radii are valid
                //-------------------------
                if(rx < epsilon || ry < epsilon) 
                {
                    line_to(x, y);
                    return;
                }

                if(calc_distance(x0, y0, x, y) < epsilon)
                {
                    // If the endpoints (x, y) and (x0, y0) are identical, then this
                    // is equivalent to omitting the elliptical arc segment entirely.
                    return;
                }
                bezier_arc_svg a(x0, y0, rx, ry, angle, large_arc_flag, sweep_flag, x, y);
                if(a.radii_ok())
                {
                    join_path(a);
                }
                else
                {
                    line_to(x, y);
                }
            }
            else
            {
                move_to(x, y);
            }
        }

        public void arc_rel(double rx, double ry,
                                    double angle,
                                    bool large_arc_flag,
                                    bool sweep_flag,
                                    double dx, double dy)
        {
            rel_to_abs(&dx, &dy);
            arc_to(rx, ry, angle, large_arc_flag, sweep_flag, dx, dy);
        }
         */

        /// <summary>
        /// Draws a quadratic B�zier curve from the current point to (x,y) using (xControl,yControl) as the control point.
        /// </summary>
        /// <param name="xControl"></param>
        /// <param name="yControl"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void curve3(double xControl, double yControl,
                                   double x, double y)
        {
            vertices.AddVertex(xControl, yControl, ShapePath.FlagsAndCommand.CommandCurve3);
            vertices.AddVertex(x, y, ShapePath.FlagsAndCommand.CommandCurve3);
        }

        /// <summary>
        /// Draws a quadratic B�zier curve from the current point to (x,y) using (xControl,yControl) as the control point.
        /// </summary>
        /// <param name="xControl"></param>
        /// <param name="yControl"></param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void curve3_rel(double dx_ctrl, double dy_ctrl, double dx_to, double dy_to)
        {
            rel_to_abs(ref dx_ctrl, ref dy_ctrl);
            rel_to_abs(ref dx_to, ref dy_to);
            vertices.AddVertex(dx_ctrl, dy_ctrl, ShapePath.FlagsAndCommand.CommandCurve3);
            vertices.AddVertex(dx_to, dy_to, ShapePath.FlagsAndCommand.CommandCurve3);
        }

        /// <summary>
        /// <para>Draws a quadratic B�zier curve from the current point to (x,y).</para>
        /// <para>The control point is assumed to be the reflection of the control point on the previous command relative to the current point.</para>
        /// <para>(If there is no previous command or if the previous command was not a curve, assume the control point is coincident with the current point.)</para>
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void curve3(double x, double y)
        {
            double x0;
            double y0;
            if (ShapePath.is_vertex(vertices.last_vertex(out x0, out y0)))
            {
                double x_ctrl;
                double y_ctrl;
                ShapePath.FlagsAndCommand cmd = vertices.prev_vertex(out x_ctrl, out y_ctrl);
                if (ShapePath.is_curve(cmd))
                {
                    x_ctrl = x0 + x0 - x_ctrl;
                    y_ctrl = y0 + y0 - y_ctrl;
                }
                else
                {
                    x_ctrl = x0;
                    y_ctrl = y0;
                }
                curve3(x_ctrl, y_ctrl, x, y);
            }
        }

        /// <summary>
        /// <para>Draws a quadratic B�zier curve from the current point to (x,y).</para>
        /// <para>The control point is assumed to be the reflection of the control point on the previous command relative to the current point.</para>
        /// <para>(If there is no previous command or if the previous command was not a curve, assume the control point is coincident with the current point.)</para>
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        public void curve3_rel(double dx_to, double dy_to)
        {
            rel_to_abs(ref dx_to, ref dy_to);
            curve3(dx_to, dy_to);
        }

        public void curve4(double x_ctrl1, double y_ctrl1,
                                   double x_ctrl2, double y_ctrl2,
                                   double x_to, double y_to)
        {
            vertices.AddVertex(x_ctrl1, y_ctrl1, ShapePath.FlagsAndCommand.CommandCurve4);
            vertices.AddVertex(x_ctrl2, y_ctrl2, ShapePath.FlagsAndCommand.CommandCurve4);
            vertices.AddVertex(x_to, y_to, ShapePath.FlagsAndCommand.CommandCurve4);
        }

        public void curve4_rel(double dx_ctrl1, double dy_ctrl1,
                                       double dx_ctrl2, double dy_ctrl2,
                                       double dx_to, double dy_to)
        {
            rel_to_abs(ref dx_ctrl1, ref dy_ctrl1);
            rel_to_abs(ref dx_ctrl2, ref dy_ctrl2);
            rel_to_abs(ref dx_to, ref dy_to);
            vertices.AddVertex(dx_ctrl1, dy_ctrl1, ShapePath.FlagsAndCommand.CommandCurve4);
            vertices.AddVertex(dx_ctrl2, dy_ctrl2, ShapePath.FlagsAndCommand.CommandCurve4);
            vertices.AddVertex(dx_to, dy_to, ShapePath.FlagsAndCommand.CommandCurve4);
        }

        public void curve4(double x_ctrl2, double y_ctrl2,
                                   double x_to, double y_to)
        {
            double x0;
            double y0;
            if (ShapePath.is_vertex(last_vertex(out x0, out y0)))
            {
                double x_ctrl1;
                double y_ctrl1;
                ShapePath.FlagsAndCommand cmd = prev_vertex(out x_ctrl1, out y_ctrl1);
                if (ShapePath.is_curve(cmd))
                {
                    x_ctrl1 = x0 + x0 - x_ctrl1;
                    y_ctrl1 = y0 + y0 - y_ctrl1;
                }
                else
                {
                    x_ctrl1 = x0;
                    y_ctrl1 = y0;
                }
                curve4(x_ctrl1, y_ctrl1, x_ctrl2, y_ctrl2, x_to, y_to);
            }
        }

        public void curve4_rel(double dx_ctrl2, double dy_ctrl2,
                                       double dx_to, double dy_to)
        {
            rel_to_abs(ref dx_ctrl2, ref dy_ctrl2);
            rel_to_abs(ref dx_to, ref dy_to);
            curve4(dx_ctrl2, dy_ctrl2, dx_to, dy_to);
        }

        public int total_vertices()
        {
            return vertices.total_vertices();
        }

        public ShapePath.FlagsAndCommand last_vertex(out double x, out double y)
        {
            return vertices.last_vertex(out x, out y);
        }

        public ShapePath.FlagsAndCommand prev_vertex(out double x, out double y)
        {
            return vertices.prev_vertex(out x, out y);
        }

        public double GetLastX()
        {
            return vertices.last_x();
        }

        public double GetLastY()
        {
            return vertices.last_y();
        }

        public ShapePath.FlagsAndCommand vertex(int index, out double x, out double y)
        {
            return vertices.vertex(index, out x, out y);
        }

        public ShapePath.FlagsAndCommand command(int index)
        {
            return vertices.command(index);
        }

        public void modify_vertex(int index, double x, double y)
        {
            vertices.modify_vertex(index, x, y);
        }

        public void modify_vertex(int index, double x, double y, ShapePath.FlagsAndCommand PathAndFlags)
        {
            vertices.modify_vertex(index, x, y, PathAndFlags);
        }

        public void modify_command(int index, ShapePath.FlagsAndCommand PathAndFlags)
        {
            vertices.modify_command(index, PathAndFlags);
        }

        public IEnumerable<VertexData> Vertices()
        {
            int count = vertices.total_vertices();
            for (int i = 0; i < count; i++)
            {
                double x = 0;
                double y = 0;
                ShapePath.FlagsAndCommand command = vertices.vertex(i, out x, out y);
                yield return new VertexData(command, new Vector2(x, y));
            }

            yield return new VertexData(ShapePath.FlagsAndCommand.CommandStop, new Vector2(0, 0));
        }

        public virtual void rewind(int pathId)
        {
            iteratorIndex = pathId;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            if (iteratorIndex >= vertices.total_vertices())
            {
                x = 0;
                y = 0;
                return ShapePath.FlagsAndCommand.CommandStop;
            }

            return vertices.vertex(iteratorIndex++, out x, out y);
        }

        // Arrange the orientation of a polygon, all polygons in a path, 
        // or in all paths. After calling arrange_orientations() or 
        // arrange_orientations_all_paths(), all the polygons will have 
        // the same orientation, i.e. path_flags_cw or path_flags_ccw
        //--------------------------------------------------------------------
        public int arrange_polygon_orientation(int start, ShapePath.FlagsAndCommand orientation)
        {
            if (orientation == ShapePath.FlagsAndCommand.FlagNone) return start;

            // Skip all non-vertices at the beginning
            while (start < vertices.total_vertices() &&
                  !ShapePath.is_vertex(vertices.command(start))) ++start;

            // Skip all insignificant move_to
            while (start + 1 < vertices.total_vertices() &&
                  ShapePath.is_move_to(vertices.command(start)) &&
                  ShapePath.is_move_to(vertices.command(start + 1))) ++start;

            // Find the last vertex
            int end = start + 1;
            while (end < vertices.total_vertices() &&
                  !ShapePath.is_next_poly(vertices.command(end))) ++end;

            if (end - start > 2)
            {
                if (perceive_polygon_orientation(start, end) != orientation)
                {
                    // Invert polygon, set orientation flag, and skip all end_poly
                    invert_polygon(start, end);
                    ShapePath.FlagsAndCommand PathAndFlags;
                    while (end < vertices.total_vertices() &&
                          ShapePath.is_end_poly(PathAndFlags = vertices.command(end)))
                    {
                        vertices.modify_command(end++, PathAndFlags | orientation);// Path.set_orientation(cmd, orientation));
                    }
                }
            }
            return end;
        }

        public int arrange_orientations(int start, ShapePath.FlagsAndCommand orientation)
        {
            if (orientation != ShapePath.FlagsAndCommand.FlagNone)
            {
                while (start < vertices.total_vertices())
                {
                    start = arrange_polygon_orientation(start, orientation);
                    if (ShapePath.is_stop(vertices.command(start)))
                    {
                        ++start;
                        break;
                    }
                }
            }
            return start;
        }

        public void arrange_orientations_all_paths(ShapePath.FlagsAndCommand orientation)
        {
            if (orientation != ShapePath.FlagsAndCommand.FlagNone)
            {
                int start = 0;
                while (start < vertices.total_vertices())
                {
                    start = arrange_orientations(start, orientation);
                }
            }
        }

        // Flip all vertices horizontally or vertically, 
        // between x1 and x2, or between y1 and y2 respectively
        //--------------------------------------------------------------------
        public void flip_x(double x1, double x2)
        {
            int i;
            double x, y;
            for (i = 0; i < vertices.total_vertices(); i++)
            {
                ShapePath.FlagsAndCommand PathAndFlags = vertices.vertex(i, out x, out y);
                if (ShapePath.is_vertex(PathAndFlags))
                {
                    vertices.modify_vertex(i, x2 - x + x1, y);
                }
            }
        }

        public void flip_y(double y1, double y2)
        {
            int i;
            double x, y;
            for (i = 0; i < vertices.total_vertices(); i++)
            {
                ShapePath.FlagsAndCommand PathAndFlags = vertices.vertex(i, out x, out y);
                if (ShapePath.is_vertex(PathAndFlags))
                {
                    vertices.modify_vertex(i, x, y2 - y + y1);
                }
            }
        }

        public void end_poly()
        {
            close_polygon(ShapePath.FlagsAndCommand.FlagClose);
        }

        public void end_poly(ShapePath.FlagsAndCommand flags)
        {
            if (ShapePath.is_vertex(vertices.last_command()))
            {
                vertices.AddVertex(0.0, 0.0, ShapePath.FlagsAndCommand.CommandEndPoly | flags);
            }
        }


        public void ClosePolygon()
        {
            close_polygon(ShapePath.FlagsAndCommand.FlagNone);
        }

        public void close_polygon(ShapePath.FlagsAndCommand flags)
        {
            end_poly(ShapePath.FlagsAndCommand.FlagClose | flags);
        }

        // Concatenate path. The path is added as is.
        public void concat_path(IVertexSource vs)
        {
            concat_path(vs, 0);
        }

        public void concat_path(IVertexSource vs, int path_id)
        {
            double x, y;
            ShapePath.FlagsAndCommand PathAndFlags;
            vs.rewind(path_id);
            while (!ShapePath.is_stop(PathAndFlags = vs.vertex(out x, out y)))
            {
                vertices.AddVertex(x, y, PathAndFlags);
            }
        }

        //--------------------------------------------------------------------
        // Join path. The path is joined with the existing one, that is, 
        // it behaves as if the pen of a plotter was always down (drawing)
        //template<class VertexSource> 
        public void join_path(PathStorage vs)
        {
            join_path(vs, 0);

        }

        public void join_path(PathStorage vs, int path_id)
        {
            double x, y;
            vs.rewind(path_id);
            ShapePath.FlagsAndCommand PathAndFlags = vs.vertex(out x, out y);
            if (!ShapePath.is_stop(PathAndFlags))
            {
                if (ShapePath.is_vertex(PathAndFlags))
                {
                    double x0, y0;
                    ShapePath.FlagsAndCommand PathAndFlags0 = last_vertex(out x0, out y0);
                    if (ShapePath.is_vertex(PathAndFlags0))
                    {
                        if (agg_math.calc_distance(x, y, x0, y0) > agg_math.vertex_dist_epsilon)
                        {
                            if (ShapePath.is_move_to(PathAndFlags)) PathAndFlags = ShapePath.FlagsAndCommand.CommandLineTo;
                            vertices.AddVertex(x, y, PathAndFlags);
                        }
                    }
                    else
                    {
                        if (ShapePath.is_stop(PathAndFlags0))
                        {
                            PathAndFlags = ShapePath.FlagsAndCommand.CommandMoveTo;
                        }
                        else
                        {
                            if (ShapePath.is_move_to(PathAndFlags)) PathAndFlags = ShapePath.FlagsAndCommand.CommandLineTo;
                        }
                        vertices.AddVertex(x, y, PathAndFlags);
                    }
                }
                while (!ShapePath.is_stop(PathAndFlags = vs.vertex(out x, out y)))
                {
                    vertices.AddVertex(x, y, ShapePath.is_move_to(PathAndFlags) ?
                                                    ShapePath.FlagsAndCommand.CommandLineTo :
                                                    PathAndFlags);
                }
            }
        }

        /*
        // Concatenate polygon/polyline. 
        //--------------------------------------------------------------------
        void concat_poly(T* data, int num_points, bool closed)
        {
            poly_plain_adaptor<T> poly(data, num_points, closed);
            concat_path(poly);
        }

        // Join polygon/polyline continuously.
        //--------------------------------------------------------------------
        void join_poly(T* data, int num_points, bool closed)
        {
            poly_plain_adaptor<T> poly(data, num_points, closed);
            join_path(poly);
        }
         */

        //--------------------------------------------------------------------
        public void translate(double dx, double dy)
        {
            translate(dx, dy, 0);
        }

        public void translate(double dx, double dy, int path_id)
        {
            int num_ver = vertices.total_vertices();
            for (; path_id < num_ver; path_id++)
            {
                double x, y;
                ShapePath.FlagsAndCommand PathAndFlags = vertices.vertex(path_id, out x, out y);
                if (ShapePath.is_stop(PathAndFlags)) break;
                if (ShapePath.is_vertex(PathAndFlags))
                {
                    x += dx;
                    y += dy;
                    vertices.modify_vertex(path_id, x, y);
                }
            }
        }

        public void translate_all_paths(double dx, double dy)
        {
            int index;
            int num_ver = vertices.total_vertices();
            for (index = 0; index < num_ver; index++)
            {
                double x, y;
                if (ShapePath.is_vertex(vertices.vertex(index, out x, out y)))
                {
                    x += dx;
                    y += dy;
                    vertices.modify_vertex(index, x, y);
                }
            }
        }

        //--------------------------------------------------------------------
        public void transform(Transform.Affine trans)
        {
            transform(trans, 0);
        }

        public void transform(Transform.Affine trans, int path_id)
        {
            int num_ver = vertices.total_vertices();
            for (; path_id < num_ver; path_id++)
            {
                double x, y;
                ShapePath.FlagsAndCommand PathAndFlags = vertices.vertex(path_id, out x, out y);
                if (ShapePath.is_stop(PathAndFlags)) break;
                if (ShapePath.is_vertex(PathAndFlags))
                {
                    trans.transform(ref x, ref y);
                    vertices.modify_vertex(path_id, x, y);
                }
            }
        }

        //--------------------------------------------------------------------
        public void transform_all_paths(Transform.Affine trans)
        {
            int index;
            int num_ver = vertices.total_vertices();
            for (index = 0; index < num_ver; index++)
            {
                double x, y;
                if (ShapePath.is_vertex(vertices.vertex(index, out x, out y)))
                {
                    trans.transform(ref x, ref y);
                    vertices.modify_vertex(index, x, y);
                }
            }
        }

        public void invert_polygon(int start)
        {
            // Skip all non-vertices at the beginning
            while (start < vertices.total_vertices() &&
                  !ShapePath.is_vertex(vertices.command(start))) ++start;

            // Skip all insignificant move_to
            while (start + 1 < vertices.total_vertices() &&
                  ShapePath.is_move_to(vertices.command(start)) &&
                  ShapePath.is_move_to(vertices.command(start + 1))) ++start;

            // Find the last vertex
            int end = start + 1;
            while (end < vertices.total_vertices() &&
                  !ShapePath.is_next_poly(vertices.command(end))) ++end;

            invert_polygon(start, end);
        }

        private ShapePath.FlagsAndCommand perceive_polygon_orientation(int start, int end)
        {
            // Calculate signed area (double area to be exact)
            //---------------------
            int np = end - start;
            double area = 0.0;
            int i;
            for (i = 0; i < np; i++)
            {
                double x1, y1, x2, y2;
                vertices.vertex(start + i, out x1, out y1);
                vertices.vertex(start + (i + 1) % np, out x2, out y2);
                area += x1 * y2 - y1 * x2;
            }
            return (area < 0.0) ? ShapePath.FlagsAndCommand.FlagCW : ShapePath.FlagsAndCommand.FlagCCW;
        }

        private void invert_polygon(int start, int end)
        {
            int i;
            ShapePath.FlagsAndCommand tmp_PathAndFlags = vertices.command(start);

            --end; // Make "end" inclusive

            // Shift all commands to one position
            for (i = start; i < end; i++)
            {
                vertices.modify_command(i, vertices.command(i + 1));
            }

            // Assign starting command to the ending command
            vertices.modify_command(end, tmp_PathAndFlags);

            // Reverse the polygon
            while (end > start)
            {
                vertices.swap_vertices(start++, end--);
            }
        }

        public void ShareVertexData(PathStorage pathStorageToShareFrom)
        {
            vertices = pathStorageToShareFrom.vertices;
        }
    }
}

#endregion //PathStorage.cs
#region Perspective.cs

//----------------------------------------------------------------------------
// Anti-Grain Geometry - Version 2.4
// Copyright (C) 2002-2005 Maxim Shemanarev (http://www.antigrain.com)
//
// Permission to copy, use, modify, sell and distribute this software 
// is granted provided this copyright notice appears in all copies. 
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//----------------------------------------------------------------------------
// Contact: mcseem@antigrain.com
//          mcseemagg@yahoo.com
//          http://www.antigrain.com
//----------------------------------------------------------------------------
//
// Perspective 2D transformations
//
//----------------------------------------------------------------------------
//using System;

namespace MatterHackers.Agg.Transform
{
    //=======================================================trans_perspective
    public sealed class Perspective : ITransform
    {
        static public readonly double affine_epsilon = 1e-14;
        public double sx, shy, w0, shx, sy, w1, tx, ty, w2;

        //-------------------------------------------------------ruction
        // Identity matrix
        public Perspective()
        {
            sx = (1); shy = (0); w0 = (0);
            shx = (0); sy = (1); w1 = (0);
            tx = (0); ty = (0); w2 = (1);
        }

        // Custom matrix
        public Perspective(double v0, double v1, double v2,
                          double v3, double v4, double v5,
                          double v6, double v7, double v8)
        {
            sx = (v0); shy = (v1); w0 = (v2);
            shx = (v3); sy = (v4); w1 = (v5);
            tx = (v6); ty = (v7); w2 = (v8);
        }

        // Custom matrix from m[9]
        public Perspective(double[] m)
        {
            sx = (m[0]); shy = (m[1]); w0 = (m[2]);
            shx = (m[3]); sy = (m[4]); w1 = (m[5]);
            tx = (m[6]); ty = (m[7]); w2 = (m[8]);
        }

        // From affine
        public Perspective(Affine a)
        {
            sx = (a.sx); shy = (a.shy); w0 = (0);
            shx = (a.shx); sy = (a.sy); w1 = (0);
            tx = (a.tx); ty = (a.ty); w2 = (1);
        }

        // From trans_perspective
        public Perspective(Perspective a)
        {
            sx = (a.sx); shy = (a.shy); w0 = a.w0;
            shx = (a.shx); sy = (a.sy); w1 = a.w1;
            tx = (a.tx); ty = (a.ty); w2 = a.w2;
        }

        // Rectangle to quadrilateral
        public Perspective(double x1, double y1, double x2, double y2, double[] quad)
        {
            rect_to_quad(x1, y1, x2, y2, quad);
        }

        // Quadrilateral to rectangle
        public Perspective(double[] quad, double x1, double y1, double x2, double y2)
        {
            quad_to_rect(quad, x1, y1, x2, y2);
        }

        // Arbitrary quadrilateral transformations
        public Perspective(double[] src, double[] dst)
        {
            quad_to_quad(src, dst);
        }

        public void Set(Perspective Other)
        {
            sx = Other.sx;
            shy = Other.shy;
            w0 = Other.w0;
            shx = Other.shx;
            sy = Other.sy;
            w1 = Other.w1;
            tx = Other.tx;
            ty = Other.ty;
            w2 = Other.w2;
        }

        //-------------------------------------- Quadrilateral transformations
        // The arguments are double[8] that are mapped to quadrilaterals:
        // x1,y1, x2,y2, x3,y3, x4,y4
        public bool quad_to_quad(double[] qs, double[] qd)
        {
            Perspective p = new Perspective();
            if (!quad_to_square(qs)) return false;
            if (!p.square_to_quad(qd)) return false;
            multiply(p);
            return true;
        }

        public bool rect_to_quad(double x1, double y1, double x2, double y2, double[] q)
        {
            double[] r = new double[8];
            r[0] = r[6] = x1;
            r[2] = r[4] = x2;
            r[1] = r[3] = y1;
            r[5] = r[7] = y2;
            return quad_to_quad(r, q);
        }

        public bool quad_to_rect(double[] q, double x1, double y1, double x2, double y2)
        {
            double[] r = new double[8];
            r[0] = r[6] = x1;
            r[2] = r[4] = x2;
            r[1] = r[3] = y1;
            r[5] = r[7] = y2;
            return quad_to_quad(q, r);
        }

        // Map square (0,0,1,1) to the quadrilateral and vice versa
        public bool square_to_quad(double[] q)
        {
            double dx = q[0] - q[2] + q[4] - q[6];
            double dy = q[1] - q[3] + q[5] - q[7];
            if (dx == 0.0 && dy == 0.0)
            {
                // Affine case (parallelogram)
                //---------------
                sx = q[2] - q[0];
                shy = q[3] - q[1];
                w0 = 0.0;
                shx = q[4] - q[2];
                sy = q[5] - q[3];
                w1 = 0.0;
                tx = q[0];
                ty = q[1];
                w2 = 1.0;
            }
            else
            {
                double dx1 = q[2] - q[4];
                double dy1 = q[3] - q[5];
                double dx2 = q[6] - q[4];
                double dy2 = q[7] - q[5];
                double den = dx1 * dy2 - dx2 * dy1;
                if (den == 0.0)
                {
                    // Singular case
                    //---------------
                    sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;
                    return false;
                }
                // General case
                //---------------
                double u = (dx * dy2 - dy * dx2) / den;
                double v = (dy * dx1 - dx * dy1) / den;
                sx = q[2] - q[0] + u * q[2];
                shy = q[3] - q[1] + u * q[3];
                w0 = u;
                shx = q[6] - q[0] + v * q[6];
                sy = q[7] - q[1] + v * q[7];
                w1 = v;
                tx = q[0];
                ty = q[1];
                w2 = 1.0;
            }
            return true;
        }

        public bool quad_to_square(double[] q)
        {
            if (!square_to_quad(q)) return false;
            invert();
            return true;
        }


        //--------------------------------------------------------- Operations
        public Perspective from_affine(Affine a)
        {
            sx = a.sx; shy = a.shy; w0 = 0;
            shx = a.shx; sy = a.sy; w1 = 0;
            tx = a.tx; ty = a.ty; w2 = 1;
            return this;
        }

        // Reset - load an identity matrix
        public Perspective reset()
        {
            sx = 1; shy = 0; w0 = 0;
            shx = 0; sy = 1; w1 = 0;
            tx = 0; ty = 0; w2 = 1;
            return this;
        }

        // Invert matrix. Returns false in degenerate case
        public bool invert()
        {
            double d0 = sy * w2 - w1 * ty;
            double d1 = w0 * ty - shy * w2;
            double d2 = shy * w1 - w0 * sy;
            double d = sx * d0 + shx * d1 + tx * d2;
            if (d == 0.0)
            {
                sx = shy = w0 = shx = sy = w1 = tx = ty = w2 = 0.0;
                return false;
            }
            d = 1.0 / d;
            Perspective a = new Perspective(this);
            sx = d * d0;
            shy = d * d1;
            w0 = d * d2;
            shx = d * (a.w1 * a.tx - a.shx * a.w2);
            sy = d * (a.sx * a.w2 - a.w0 * a.tx);
            w1 = d * (a.w0 * a.shx - a.sx * a.w1);
            tx = d * (a.shx * a.ty - a.sy * a.tx);
            ty = d * (a.shy * a.tx - a.sx * a.ty);
            w2 = d * (a.sx * a.sy - a.shy * a.shx);
            return true;
        }

        // Direct transformations operations
        public Perspective translate(double x, double y)
        {
            tx += x;
            ty += y;
            return this;
        }

        public Perspective rotate(double a)
        {
            multiply(Affine.NewRotation(a));
            return this;
        }

        public Perspective scale(double s)
        {
            multiply(Affine.NewScaling(s));
            return this;
        }

        public Perspective scale(double x, double y)
        {
            multiply(Affine.NewScaling(x, y));
            return this;
        }

        public Perspective multiply(Perspective a)
        {
            Perspective b = new Perspective(this);
            sx = a.sx * b.sx + a.shx * b.shy + a.tx * b.w0;
            shx = a.sx * b.shx + a.shx * b.sy + a.tx * b.w1;
            tx = a.sx * b.tx + a.shx * b.ty + a.tx * b.w2;
            shy = a.shy * b.sx + a.sy * b.shy + a.ty * b.w0;
            sy = a.shy * b.shx + a.sy * b.sy + a.ty * b.w1;
            ty = a.shy * b.tx + a.sy * b.ty + a.ty * b.w2;
            w0 = a.w0 * b.sx + a.w1 * b.shy + a.w2 * b.w0;
            w1 = a.w0 * b.shx + a.w1 * b.sy + a.w2 * b.w1;
            w2 = a.w0 * b.tx + a.w1 * b.ty + a.w2 * b.w2;
            return this;
        }

        //------------------------------------------------------------------------
        public Perspective multiply(Affine a)
        {
            Perspective b = new Perspective(this);
            sx = a.sx * b.sx + a.shx * b.shy + a.tx * b.w0;
            shx = a.sx * b.shx + a.shx * b.sy + a.tx * b.w1;
            tx = a.sx * b.tx + a.shx * b.ty + a.tx * b.w2;
            shy = a.shy * b.sx + a.sy * b.shy + a.ty * b.w0;
            sy = a.shy * b.shx + a.sy * b.sy + a.ty * b.w1;
            ty = a.shy * b.tx + a.sy * b.ty + a.ty * b.w2;
            return this;
        }

        //------------------------------------------------------------------------
        public Perspective premultiply(Perspective b)
        {
            Perspective a = new Perspective(this);
            sx = a.sx * b.sx + a.shx * b.shy + a.tx * b.w0;
            shx = a.sx * b.shx + a.shx * b.sy + a.tx * b.w1;
            tx = a.sx * b.tx + a.shx * b.ty + a.tx * b.w2;
            shy = a.shy * b.sx + a.sy * b.shy + a.ty * b.w0;
            sy = a.shy * b.shx + a.sy * b.sy + a.ty * b.w1;
            ty = a.shy * b.tx + a.sy * b.ty + a.ty * b.w2;
            w0 = a.w0 * b.sx + a.w1 * b.shy + a.w2 * b.w0;
            w1 = a.w0 * b.shx + a.w1 * b.sy + a.w2 * b.w1;
            w2 = a.w0 * b.tx + a.w1 * b.ty + a.w2 * b.w2;
            return this;
        }

        //------------------------------------------------------------------------
        public Perspective premultiply(Affine b)
        {
            Perspective a = new Perspective(this);
            sx = a.sx * b.sx + a.shx * b.shy;
            shx = a.sx * b.shx + a.shx * b.sy;
            tx = a.sx * b.tx + a.shx * b.ty + a.tx;
            shy = a.shy * b.sx + a.sy * b.shy;
            sy = a.shy * b.shx + a.sy * b.sy;
            ty = a.shy * b.tx + a.sy * b.ty + a.ty;
            w0 = a.w0 * b.sx + a.w1 * b.shy;
            w1 = a.w0 * b.shx + a.w1 * b.sy;
            w2 = a.w0 * b.tx + a.w1 * b.ty + a.w2;
            return this;
        }

        //------------------------------------------------------------------------
        public Perspective multiply_inv(Perspective m)
        {
            Perspective t = m;
            t.invert();
            return multiply(t);
        }

        //------------------------------------------------------------------------
        public Perspective trans_perspectivemultiply_inv(Affine m)
        {
            Affine t = m;
            t.invert();
            return multiply(t);
        }

        //------------------------------------------------------------------------
        public Perspective premultiply_inv(Perspective m)
        {
            Perspective t = m;
            t.invert();
            Set(t.multiply(this));
            return this;
        }

        // Multiply inverse of "m" by "this" and assign the result to "this"
        public Perspective premultiply_inv(Affine m)
        {
            Perspective t = new Perspective(m);
            t.invert();
            Set(t.multiply(this));
            return this;
        }

        //--------------------------------------------------------- Load/Store
        public void store_to(double[] m)
        {
            m[0] = sx; m[1] = shy; m[2] = w0;
            m[3] = shx; m[4] = sy; m[5] = w1;
            m[6] = tx; m[7] = ty; m[8] = w2;
        }

        //------------------------------------------------------------------------
        public Perspective load_from(double[] m)
        {
            sx = m[0]; shy = m[1]; w0 = m[2];
            shx = m[3]; sy = m[4]; w1 = m[5];
            tx = m[6]; ty = m[7]; w2 = m[8];
            return this;
        }

        //---------------------------------------------------------- Operators
        // Multiply the matrix by another one and return the result in a separate matrix.
        public static Perspective operator *(Perspective a, Perspective b)
        {
            Perspective temp = a;
            temp.multiply(b);

            return temp;
        }

        // Multiply the matrix by another one and return the result in a separate matrix.
        public static Perspective operator *(Perspective a, Affine b)
        {
            Perspective temp = a;
            temp.multiply(b);

            return temp;
        }

        // Multiply the matrix by inverse of another one and return the result in a separate matrix.
        public static Perspective operator /(Perspective a, Perspective b)
        {
            Perspective temp = a;
            temp.multiply_inv(b);

            return temp;
        }

        // Calculate and return the inverse matrix
        public static Perspective operator ~(Perspective b)
        {
            Perspective ret = b;
            ret.invert();
            return ret;
        }

        // Equal operator with default epsilon
        public static bool operator ==(Perspective a, Perspective b)
        {
            return a.is_equal(b, affine_epsilon);
        }

        // Not Equal operator with default epsilon
        public static bool operator !=(Perspective a, Perspective b)
        {
            return !a.is_equal(b, affine_epsilon);
        }

        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        //---------------------------------------------------- Transformations
        // Direct transformation of x and y
        public void transform(ref double px, ref double py)
        {
            double x = px;
            double y = py;
            double m = 1.0 / (x * w0 + y * w1 + w2);
            px = m * (x * sx + y * shx + tx);
            py = m * (x * shy + y * sy + ty);
        }

        // Direct transformation of x and y, affine part only
        public void transform_affine(ref double x, ref double y)
        {
            double tmp = x;
            x = tmp * sx + y * shx + tx;
            y = tmp * shy + y * sy + ty;
        }

        // Direct transformation of x and y, 2x2 matrix only, no translation
        public void transform_2x2(ref double x, ref double y)
        {
            double tmp = x;
            x = tmp * sx + y * shx;
            y = tmp * shy + y * sy;
        }

        // Inverse transformation of x and y. It works slow because
        // it explicitly inverts the matrix on every call. For massive 
        // operations it's better to invert() the matrix and then use 
        // direct transformations. 
        public void inverse_transform(ref double x, ref double y)
        {
            Perspective t = new Perspective(this);
            if (t.invert()) t.transform(ref x, ref y);
        }


        //---------------------------------------------------------- Auxiliary
        public double determinant()
        {
            return sx * (sy * w2 - ty * w1) +
                   shx * (ty * w0 - shy * w2) +
                   tx * (shy * w1 - sy * w0);
        }
        public double determinant_reciprocal()
        {
            return 1.0 / determinant();
        }

        public bool is_valid() { return is_valid(affine_epsilon); }
        public bool is_valid(double epsilon)
        {
            return Math.Abs(sx) > epsilon && Math.Abs(sy) > epsilon && Math.Abs(w2) > epsilon;
        }

        public bool is_identity() { return is_identity(affine_epsilon); }
        public bool is_identity(double epsilon)
        {
            return agg_basics.is_equal_eps(sx, 1.0, epsilon) &&
                   agg_basics.is_equal_eps(shy, 0.0, epsilon) &&
                   agg_basics.is_equal_eps(w0, 0.0, epsilon) &&
                   agg_basics.is_equal_eps(shx, 0.0, epsilon) &&
                   agg_basics.is_equal_eps(sy, 1.0, epsilon) &&
                   agg_basics.is_equal_eps(w1, 0.0, epsilon) &&
                   agg_basics.is_equal_eps(tx, 0.0, epsilon) &&
                   agg_basics.is_equal_eps(ty, 0.0, epsilon) &&
                   agg_basics.is_equal_eps(w2, 1.0, epsilon);
        }

        public bool is_equal(Perspective m)
        {
            return is_equal(m, affine_epsilon);
        }

        public bool is_equal(Perspective m, double epsilon)
        {
            return agg_basics.is_equal_eps(sx, m.sx, epsilon) &&
                   agg_basics.is_equal_eps(shy, m.shy, epsilon) &&
                   agg_basics.is_equal_eps(w0, m.w0, epsilon) &&
                   agg_basics.is_equal_eps(shx, m.shx, epsilon) &&
                   agg_basics.is_equal_eps(sy, m.sy, epsilon) &&
                   agg_basics.is_equal_eps(w1, m.w1, epsilon) &&
                   agg_basics.is_equal_eps(tx, m.tx, epsilon) &&
                   agg_basics.is_equal_eps(ty, m.ty, epsilon) &&
                   agg_basics.is_equal_eps(w2, m.w2, epsilon);
        }

        // Determine the major affine parameters. Use with caution 
        // considering possible degenerate cases.
        public double scale()
        {
            double x = 0.707106781 * sx + 0.707106781 * shx;
            double y = 0.707106781 * shy + 0.707106781 * sy;
            return Math.Sqrt(x * x + y * y);
        }
        public double rotation()
        {
            double x1 = 0.0;
            double y1 = 0.0;
            double x2 = 1.0;
            double y2 = 0.0;
            transform(ref x1, ref y1);
            transform(ref x2, ref y2);
            return Math.Atan2(y2 - y1, x2 - x1);
        }
        public void translation(out double dx, out double dy)
        {
            dx = tx;
            dy = ty;
        }
        public void scaling(out double x, out double y)
        {
            double x1 = 0.0;
            double y1 = 0.0;
            double x2 = 1.0;
            double y2 = 1.0;
            Perspective t = new Perspective(this);
            t *= Affine.NewRotation(-rotation());
            t.transform(ref x1, ref y1);
            t.transform(ref x2, ref y2);
            x = x2 - x1;
            y = y2 - y1;
        }
        public void scaling_abs(out double x, out double y)
        {
            x = Math.Sqrt(sx * sx + shx * shx);
            y = Math.Sqrt(shy * shy + sy * sy);
        }

        //--------------------------------------------------------------------
        public sealed class iterator_x
        {
            double den;
            double den_step;
            double nom_x;
            double nom_x_step;
            double nom_y;
            double nom_y_step;

            public double x;
            public double y;

            public iterator_x() { }
            public iterator_x(double px, double py, double step, Perspective m)
            {
                den = (px * m.w0 + py * m.w1 + m.w2);
                den_step = (m.w0 * step);
                nom_x = (px * m.sx + py * m.shx + m.tx);
                nom_x_step = (step * m.sx);
                nom_y = (px * m.shy + py * m.sy + m.ty);
                nom_y_step = (step * m.shy);
                x = (nom_x / den);
                y = (nom_y / den);
            }

            public static iterator_x operator ++(iterator_x a)
            {
                a.den += a.den_step;
                a.nom_x += a.nom_x_step;
                a.nom_y += a.nom_y_step;
                double d = 1.0 / a.den;
                a.x = a.nom_x * d;
                a.y = a.nom_y * d;

                return a;
            }
        };

        //--------------------------------------------------------------------
        public iterator_x begin(double x, double y, double step)
        {
            return new iterator_x(x, y, step, this);
        }
    };
}

#endregion //Perspective.cs
#region PluginFinder.cs

//using System;
//using System.Collections.Generic;
//using System.Linq;
//using System.Text;
//using System.IO;
//using System.Reflection;

namespace MatterHackers.Agg
{
    public class PluginFinder<BaseClassToFind>
    {
        public List<BaseClassToFind> Plugins;

        public PluginFinder(string searchDirectory = null, IComparer<BaseClassToFind> sorter = null)
        {
            string searchPath = null;
            if (searchDirectory == null)
            {
                //searchPath = System.IO.Path.GetDirectoryName(System.Reflection.Assembly.GetExecutingAssembly().Location);
            }
            else
            {
                searchPath = System.IO.Path.GetFullPath(searchDirectory);
            }

            Plugins = FindAndAddPlugins(searchPath);
            if (sorter != null)
            {
                Plugins.Sort(sorter);
            }
        }

        public List<BaseClassToFind> FindAndAddPlugins(string searchDirectory)
        {
            List<BaseClassToFind> factoryList = new List<BaseClassToFind>();
            if (System.IO.Directory.Exists(searchDirectory))
            {
                //string[] files = Directory.GetFiles(searchDirectory, "*_HalFactory.dll");
                string[] dllFiles = System.IO.Directory.GetFiles(searchDirectory, "*.dll");
                string[] exeFiles = System.IO.Directory.GetFiles(searchDirectory, "*.exe");

                List<string> allFiles = new List<string>();
                allFiles.AddRange(dllFiles);
                allFiles.AddRange(exeFiles);
                string[] files = allFiles.ToArray();

                foreach (string file in files)
                {
                    try
                    {
                        Assembly assembly = Assembly.Load(file);

                        foreach (Type type in assembly.GetTypes())
                        {
                            if (type == null || !type.IsClass || !type.IsPublic)
                            {
                                continue;
                            }

                            if (type.BaseType == typeof(BaseClassToFind))
                            {
                                factoryList.Add((BaseClassToFind)Activator.CreateInstance(type));
                            }
                        }
                    }
                    catch (ReflectionTypeLoadException)
                    {
                    }
                    catch (BadImageFormatException)
                    {
                    }
                    catch (NotSupportedException)
                    {
                    }
                }
            }

            return factoryList;
        }
    }
}

#endregion //PluginFinder.cs
#region Point2D.cs
namespace MatterHackers.Agg
{
    public struct Point2D
    {
        public int x, y;

        public Point2D(int newX, int newY)
        {
            x = newX;
            y = newY;
        }

        public void Set(int inX, int inY)
        {
            x = inX;
            y = inY;
        }

        static public Point2D operator +(Point2D A, Point2D B)
        {
            Point2D temp = new Point2D();
            temp.x = A.x + B.x;
            temp.y = A.y + B.y;
            return temp;
        }

        static public Point2D operator -(Point2D A, Point2D B)
        {
            Point2D temp = new Point2D();
            temp.x = A.x - B.x;
            temp.y = A.y - B.y;
            return temp;
        }

        static public Point2D operator *(Point2D A, Point2D B)
        {
            Point2D temp = new Point2D();
            temp.x = A.x * B.x;
            temp.y = A.y * B.y;
            return temp;
        }

        static public Point2D operator *(Point2D A, int B)
        {
            Point2D temp = new Point2D();
            temp.x = A.x * B;
            temp.y = A.y * B;
            return temp;
        }

        static public Point2D operator *(int B, Point2D A)
        {
            Point2D temp = new Point2D();
            temp.x = A.x * B;
            temp.y = A.y * B;
            return temp;
        }

        static public Point2D operator /(Point2D A, Point2D B)
        {
            Point2D temp = new Point2D();
            temp.x = A.x / B.x;
            temp.y = A.y / B.y;
            return temp;
        }

        static public Point2D operator /(Point2D A, int B)
        {
            Point2D temp = new Point2D();
            temp.x = A.x / B;
            temp.y = A.y / B;
            return temp;
        }

        static public Point2D operator /(int B, Point2D A)
        {
            Point2D temp = new Point2D();
            temp.x = A.x / B;
            temp.y = A.y / B;
            return temp;
        }

        // are they the same within the error value?
        public bool Equals(Point2D OtherVector)
        {
            if (x == OtherVector.x && y == OtherVector.y)
            {
                return true;
            }

            return false;
        }

        public override bool Equals(System.Object obj)
        {
            // If parameter is null return false.
            if (obj == null)
            {
                return false;
            }

            // If parameter cannot be cast to Point return false.
            Point2D p = (Point2D)obj;
            if ((System.Object)p == null)
            {
                return false;
            }

            // Return true if the fields match:
            return (x == p.x) && (y == p.y);
        }

        public override int GetHashCode()
        {
            return new { x, y }.GetHashCode();
        }

        public static bool operator ==(Point2D a, Point2D b)
        {
            return a.Equals(b);
        }

        public static bool operator !=(Point2D a, Point2D b)
        {
            return !a.Equals(b);
        }

        public Point2D GetNormal()
        {
            Point2D normal = this;
            normal.Normalize();
            return normal;
        }

        public Point2D GetPerpendicular()
        {
            Point2D temp = new Point2D(y, -x);

            return temp;
        }

        public Point2D GetPerpendicularNormal()
        {
            Point2D Perpendicular = GetPerpendicular();
            Perpendicular.Normalize();
            return Perpendicular;
        }

        public double GetLength()
        {
            return System.Math.Sqrt((x * x) + (y * y));
        }

        public double GetLengthSquared()
        {
            return Dot(this);
        }

        public static double GetDistanceBetween(Point2D A, Point2D B)
        {
            return (double)System.Math.Sqrt(GetDistanceBetweenSquared(A, B));
        }

        public static double GetDistanceBetweenSquared(Point2D A, Point2D B)
        {
            return ((A.x - B.x) * (A.x - B.x) + (A.y - B.y) * (A.y - B.y));
        }

        public double GetSquaredDistanceTo(Point2D Other)
        {
            return ((x - Other.x) * (x - Other.x) + (y - Other.y) * (y - Other.y));
        }

        static public double Range0To2PI(double Value)
        {
            if (Value < 0)
            {
                Value += 2 * (double)System.Math.PI;
            }

            if (Value >= 2 * (double)System.Math.PI)
            {
                Value -= 2 * (double)System.Math.PI;
            }

            if (Value < 0 || Value > 2 * System.Math.PI) throw new Exception("Value >= 0 && Value <= 2 * PI");

            return Value;
        }

        static public double GetDeltaAngle(double StartAngle, double EndAngle)
        {
            if (StartAngle != Range0To2PI(StartAngle)) throw new Exception("StartAngle == Range0To2PI(StartAngle)");
            if (EndAngle != Range0To2PI(EndAngle)) throw new Exception("EndAngle   == Range0To2PI(EndAngle)");

            double DeltaAngle = EndAngle - StartAngle;
            if (DeltaAngle > System.Math.PI)
            {
                DeltaAngle -= 2 * (double)System.Math.PI;
            }

            if (DeltaAngle < -System.Math.PI)
            {
                DeltaAngle += 2 * (double)System.Math.PI;
            }

            return DeltaAngle;
        }

        public double GetAngle0To2PI()
        {
            return (double)Range0To2PI((double)System.Math.Atan2((double)y, (double)x));
        }

        public double GetDeltaAngle(Point2D A)
        {
            return (double)GetDeltaAngle(GetAngle0To2PI(), A.GetAngle0To2PI());
        }

        public void Normalize()
        {
            double Length;

            Length = GetLength();

            if (Length == 0) throw new Exception("Length != 0.f");

            if (Length != 0.0f)
            {
                double InversLength = 1.0f / Length;
                x = (int)(x * InversLength + .5);
                y = (int)(y * InversLength + .5);
            }
        }

        public void Normalize(double Length)
        {
            if (Length == 0) throw new Exception("Length == 0.f");

            if (Length != 0.0f)
            {
                double InversLength = 1.0f / Length;
                x = (int)(x * InversLength + .5);
                y = (int)(y * InversLength + .5);
            }
        }

        public double NormalizeAndReturnLength()
        {
            double Length;

            Length = GetLength();

            if (Length != 0.0f)
            {
                double InversLength = 1.0f / Length;
                x = (int)(x * InversLength + .5);
                y = (int)(y * InversLength + .5);
            }

            return Length;
        }

        public void Zero()
        {
            x = 0;
            y = 0;
        }

        public void Negate()
        {
            x = -x;
            y = -y;
        }

        public double Dot(Point2D B)
        {
            return (x * B.x + y * B.y);
        }

        public double Cross(Point2D B)
        {
            return x * B.y - y * B.x;
        }
    };
}

#endregion //Point2D.cs
#region Quaternion.cs

namespace MatterHackers.VectorMath
{
    /// <summary>
    /// Represents a double-precision Quaternion.
    /// </summary>
    //[Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public struct Quaternion : IEquatable<Quaternion>
    {
        #region Fields

        Vector3 xyz;
        double w;

        #endregion

        #region Constructors

        /// <summary>
        /// Construct a new Quaterniond from vector and w components
        /// </summary>
        /// <param name="v">The vector part</param>
        /// <param name="w">The w part</param>
        public Quaternion(Vector3 v, double w)
        {
            this.xyz = v;
            this.w = w;
        }

        /// <summary>
        /// Construct a new Quaterniond
        /// </summary>
        /// <param name="x">The x component</param>
        /// <param name="y">The y component</param>
        /// <param name="z">The z component</param>
        /// <param name="w">The w component</param>
        public Quaternion(double x, double y, double z, double w)
            : this(new Vector3(x, y, z), w)
        { }

        /// <summary>
        /// Construct a quaternion that rotates from one direction to another
        /// </summary>
        /// <param name="startingDirection"></param>
        /// <param name="endingDirection"></param>
        public Quaternion(Vector3 startingDirection, Vector3 endingDirection)
        {
            this.xyz = Vector3.Cross(startingDirection, endingDirection);
            this.w = Math.Sqrt(Math.Pow(startingDirection.Length, 2) * Math.Pow(endingDirection.Length, 2)) + Vector3.Dot(startingDirection, endingDirection);
            Normalize();
        }

        #endregion

        #region Public Members

        #region Properties

        /// <summary>
        /// Gets or sets an OpenTK.Vector3d with the X, Y and Z components of this instance.
        /// </summary>
        public Vector3 Xyz { get { return xyz; } set { xyz = value; } }

        /// <summary>
        /// Gets or sets the X component of this instance.
        /// </summary>
        public double X { get { return xyz.x; } set { xyz.x = value; } }

        /// <summary>
        /// Gets or sets the Y component of this instance.
        /// </summary>
        public double Y { get { return xyz.y; } set { xyz.y = value; } }

        /// <summary>
        /// Gets or sets the Z component of this instance.
        /// </summary>
        public double Z { get { return xyz.z; } set { xyz.z = value; } }

        /// <summary>
        /// Gets or sets the W component of this instance.
        /// </summary>
        public double W { get { return w; } set { w = value; } }

        #endregion

        #region Instance

        #region ToAxisAngle

        /// <summary>
        /// Convert the current quaternion to axis angle representation
        /// </summary>
        /// <param name="axis">The resultant axis</param>
        /// <param name="angle">The resultant angle</param>
        public void ToAxisAngle(out Vector3 axis, out double angle)
        {
            Vector4 result = ToAxisAngle();
            axis = result.Xyz;
            angle = result.w;
        }

        /// <summary>
        /// Convert this instance to an axis-angle representation.
        /// </summary>
        /// <returns>A Vector4 that is the axis-angle representation of this quaternion.</returns>
        public Vector4 ToAxisAngle()
        {
            Quaternion q = this;
            if (q.W > 1.0f)
                q.Normalize();

            Vector4 result = new Vector4();

            result.w = 2.0f * (float)System.Math.Acos(q.W); // angle
            float den = (float)System.Math.Sqrt(1.0 - q.W * q.W);
            if (den > 0.0001f)
            {
                result.Xyz = q.Xyz / den;
            }
            else
            {
                // This occurs when the angle is zero. 
                // Not a problem: just set an arbitrary normalized axis.
                result.Xyz = Vector3.UnitX;
            }

            return result;
        }

        #endregion

        #region public double Length

        /// <summary>
        /// Gets the length (magnitude) of the Quaterniond.
        /// </summary>
        /// <seealso cref="LengthSquared"/>
        public double Length
        {
            get
            {
                return (double)System.Math.Sqrt(W * W + Xyz.LengthSquared);
            }
        }

        #endregion

        #region public double LengthSquared

        /// <summary>
        /// Gets the square of the Quaterniond length (magnitude).
        /// </summary>
        public double LengthSquared
        {
            get
            {
                return W * W + Xyz.LengthSquared;
            }
        }

        #endregion

        #region public void Normalize()

        /// <summary>
        /// Scales the Quaterniond to unit length.
        /// </summary>
        public void Normalize()
        {
            double scale = 1.0f / this.Length;
            Xyz *= scale;
            W *= scale;
        }

        #endregion

        #region public void Conjugate()

        /// <summary>
        /// Convert this Quaterniond to its conjugate
        /// </summary>
        public void Conjugate()
        {
            Xyz = -Xyz;
        }

        #endregion

        #endregion

        #region Static

        #region Fields

        /// <summary>
        /// Defines the identity quaternion.
        /// </summary>
        public readonly static Quaternion Identity = new Quaternion(0, 0, 0, 1);

        #endregion

        #region Add

        /// <summary>
        /// Add two quaternions
        /// </summary>
        /// <param name="left">The first operand</param>
        /// <param name="right">The second operand</param>
        /// <returns>The result of the addition</returns>
        public static Quaternion Add(Quaternion left, Quaternion right)
        {
            return new Quaternion(
                left.Xyz + right.Xyz,
                left.W + right.W);
        }

        /// <summary>
        /// Add two quaternions
        /// </summary>
        /// <param name="left">The first operand</param>
        /// <param name="right">The second operand</param>
        /// <param name="result">The result of the addition</param>
        public static void Add(ref Quaternion left, ref Quaternion right, out Quaternion result)
        {
            result = new Quaternion(
                left.Xyz + right.Xyz,
                left.W + right.W);
        }

        #endregion

        #region Sub

        /// <summary>
        /// Subtracts two instances.
        /// </summary>
        /// <param name="left">The left instance.</param>
        /// <param name="right">The right instance.</param>
        /// <returns>The result of the operation.</returns>
        public static Quaternion Sub(Quaternion left, Quaternion right)
        {
            return new Quaternion(
                left.Xyz - right.Xyz,
                left.W - right.W);
        }

        /// <summary>
        /// Subtracts two instances.
        /// </summary>
        /// <param name="left">The left instance.</param>
        /// <param name="right">The right instance.</param>
        /// <param name="result">The result of the operation.</param>
        public static void Sub(ref Quaternion left, ref Quaternion right, out Quaternion result)
        {
            result = new Quaternion(
                left.Xyz - right.Xyz,
                left.W - right.W);
        }

        #endregion

        #region Mult

        /// <summary>
        /// Multiplies two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>A new instance containing the result of the calculation.</returns>
        [Obsolete("Use Multiply instead.")]
        public static Quaternion Mult(Quaternion left, Quaternion right)
        {
            return new Quaternion(
                right.W * left.Xyz + left.W * right.Xyz + Vector3.Cross(left.Xyz, right.Xyz),
                left.W * right.W - Vector3.Dot(left.Xyz, right.Xyz));
        }

        /// <summary>
        /// Multiplies two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <param name="result">A new instance containing the result of the calculation.</param>
        [Obsolete("Use Multiply instead.")]
        public static void Mult(ref Quaternion left, ref Quaternion right, out Quaternion result)
        {
            result = new Quaternion(
                right.W * left.Xyz + left.W * right.Xyz + Vector3.Cross(left.Xyz, right.Xyz),
                left.W * right.W - Vector3.Dot(left.Xyz, right.Xyz));
        }

        /// <summary>
        /// Multiplies two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>A new instance containing the result of the calculation.</returns>
        public static Quaternion Multiply(Quaternion left, Quaternion right)
        {
            Quaternion result;
            Multiply(ref left, ref right, out result);
            return result;
        }

        /// <summary>
        /// Multiplies two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <param name="result">A new instance containing the result of the calculation.</param>
        public static void Multiply(ref Quaternion left, ref Quaternion right, out Quaternion result)
        {
            result = new Quaternion(
                right.W * left.Xyz + left.W * right.Xyz + Vector3.Cross(left.Xyz, right.Xyz),
                left.W * right.W - Vector3.Dot(left.Xyz, right.Xyz));
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="quaternion">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <param name="result">A new instance containing the result of the calculation.</param>
        public static void Multiply(ref Quaternion quaternion, double scale, out Quaternion result)
        {
            result = new Quaternion(quaternion.X * scale, quaternion.Y * scale, quaternion.Z * scale, quaternion.W * scale);
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="quaternion">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>A new instance containing the result of the calculation.</returns>
        public static Quaternion Multiply(Quaternion quaternion, double scale)
        {
            return new Quaternion(quaternion.X * scale, quaternion.Y * scale, quaternion.Z * scale, quaternion.W * scale);
        }

        #endregion

        #region Conjugate

        /// <summary>
        /// Get the conjugate of the given Quaterniond
        /// </summary>
        /// <param name="q">The Quaterniond</param>
        /// <returns>The conjugate of the given Quaterniond</returns>
        public static Quaternion Conjugate(Quaternion q)
        {
            return new Quaternion(-q.Xyz, q.W);
        }

        /// <summary>
        /// Get the conjugate of the given Quaterniond
        /// </summary>
        /// <param name="q">The Quaterniond</param>
        /// <param name="result">The conjugate of the given Quaterniond</param>
        public static void Conjugate(ref Quaternion q, out Quaternion result)
        {
            result = new Quaternion(-q.Xyz, q.W);
        }

        #endregion

        #region Invert

        /// <summary>
        /// Get the inverse of the given Quaterniond
        /// </summary>
        /// <param name="q">The Quaterniond to invert</param>
        /// <returns>The inverse of the given Quaterniond</returns>
        public static Quaternion Invert(Quaternion q)
        {
            Quaternion result;
            Invert(ref q, out result);
            return result;
        }

        /// <summary>
        /// Get the inverse of the given Quaterniond
        /// </summary>
        /// <param name="q">The Quaterniond to invert</param>
        /// <param name="result">The inverse of the given Quaterniond</param>
        public static void Invert(ref Quaternion q, out Quaternion result)
        {
            double lengthSq = q.LengthSquared;
            if (lengthSq != 0.0)
            {
                double i = 1.0f / lengthSq;
                result = new Quaternion(q.Xyz * -i, q.W * i);
            }
            else
            {
                result = q;
            }
        }

        #endregion

        #region Normalize

        /// <summary>
        /// Scale the given Quaterniond to unit length
        /// </summary>
        /// <param name="q">The Quaterniond to normalize</param>
        /// <returns>The normalized Quaterniond</returns>
        public static Quaternion Normalize(Quaternion q)
        {
            Quaternion result;
            Normalize(ref q, out result);
            return result;
        }

        /// <summary>
        /// Scale the given Quaterniond to unit length
        /// </summary>
        /// <param name="q">The Quaterniond to normalize</param>
        /// <param name="result">The normalized Quaterniond</param>
        public static void Normalize(ref Quaternion q, out Quaternion result)
        {
            double scale = 1.0f / q.Length;
            result = new Quaternion(q.Xyz * scale, q.W * scale);
        }

        #endregion

        #region FromEulerAngles

        public static Quaternion FromEulerAngles(Vector3 rotation)
        {
            Quaternion xRotation = FromAxisAngle(Vector3.UnitX, rotation.x);
            Quaternion yRotation = FromAxisAngle(Vector3.UnitY, rotation.y);
            Quaternion zRotation = FromAxisAngle(Vector3.UnitZ, rotation.z);

            //return xRotation * yRotation * zRotation;
            return zRotation * yRotation * xRotation;
        }

        #endregion

        #region FromAxisAngle

        /// <summary>
        /// Build a Quaterniond from the given axis and angle
        /// </summary>
        /// <param name="axis">The axis to rotate about</param>
        /// <param name="angle">The rotation angle in radians</param>
        /// <returns></returns>
        public static Quaternion FromAxisAngle(Vector3 axis, double angle)
        {
            if (axis.LengthSquared == 0.0f)
            {
                return Identity;
            }

            Quaternion result = Identity;

            angle *= 0.5f;
            axis.Normalize();
            result.Xyz = axis * (double)System.Math.Sin(angle);
            result.W = (double)System.Math.Cos(angle);

            return Normalize(result);
        }

        #endregion

        #region Slerp

        /// <summary>
        /// Do Spherical linear interpolation between two quaternions 
        /// </summary>
        /// <param name="q1">The first Quaterniond</param>
        /// <param name="q2">The second Quaterniond</param>
        /// <param name="blend">The blend factor</param>
        /// <returns>A smooth blend between the given quaternions</returns>
        public static Quaternion Slerp(Quaternion q1, Quaternion q2, double blend)
        {
            // if either input is zero, return the other.
            if (q1.LengthSquared == 0.0f)
            {
                if (q2.LengthSquared == 0.0f)
                {
                    return Identity;
                }
                return q2;
            }
            else if (q2.LengthSquared == 0.0f)
            {
                return q1;
            }


            double cosHalfAngle = q1.W * q2.W + Vector3.Dot(q1.Xyz, q2.Xyz);

            if (cosHalfAngle >= 1.0f || cosHalfAngle <= -1.0f)
            {
                // angle = 0.0f, so just return one input.
                return q1;
            }
            else if (cosHalfAngle < 0.0f)
            {
                q2.Xyz = -q2.Xyz;
                q2.W = -q2.W;
                cosHalfAngle = -cosHalfAngle;
            }

            double blendA;
            double blendB;
            if (cosHalfAngle < 0.99f)
            {
                // do proper slerp for big angles
                double halfAngle = (double)System.Math.Acos(cosHalfAngle);
                double sinHalfAngle = (double)System.Math.Sin(halfAngle);
                double oneOverSinHalfAngle = 1.0f / sinHalfAngle;
                blendA = (double)System.Math.Sin(halfAngle * (1.0f - blend)) * oneOverSinHalfAngle;
                blendB = (double)System.Math.Sin(halfAngle * blend) * oneOverSinHalfAngle;
            }
            else
            {
                // do lerp if angle is really small.
                blendA = 1.0f - blend;
                blendB = blend;
            }

            Quaternion result = new Quaternion(blendA * q1.Xyz + blendB * q2.Xyz, blendA * q1.W + blendB * q2.W);
            if (result.LengthSquared > 0.0f)
                return Normalize(result);
            else
                return Identity;
        }

        #endregion

        #endregion

        #region Operators

        /// <summary>
        /// Adds two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Quaternion operator +(Quaternion left, Quaternion right)
        {
            left.Xyz += right.Xyz;
            left.W += right.W;
            return left;
        }

        /// <summary>
        /// Subtracts two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Quaternion operator -(Quaternion left, Quaternion right)
        {
            left.Xyz -= right.Xyz;
            left.W -= right.W;
            return left;
        }

        /// <summary>
        /// Multiplies two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Quaternion operator *(Quaternion left, Quaternion right)
        {
            Multiply(ref left, ref right, out left);
            return left;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="quaternion">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>A new instance containing the result of the calculation.</returns>
        public static Quaternion operator *(Quaternion quaternion, double scale)
        {
            Multiply(ref quaternion, scale, out quaternion);
            return quaternion;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="quaternion">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>A new instance containing the result of the calculation.</returns>
        public static Quaternion operator *(double scale, Quaternion quaternion)
        {
            return new Quaternion(quaternion.X * scale, quaternion.Y * scale, quaternion.Z * scale, quaternion.W * scale);
        }

        /// <summary>
        /// Compares two instances for equality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left equals right; false otherwise.</returns>
        public static bool operator ==(Quaternion left, Quaternion right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Compares two instances for inequality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left does not equal right; false otherwise.</returns>
        public static bool operator !=(Quaternion left, Quaternion right)
        {
            return !left.Equals(right);
        }

        #endregion

        #region Overrides

        #region public override string ToString()

        /// <summary>
        /// Returns a System.String that represents the current Quaterniond.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("V: {0}, W: {1}", Xyz, W);
        }

        #endregion

        #region public override bool Equals (object o)

        /// <summary>
        /// Compares this object instance to another object for equality. 
        /// </summary>
        /// <param name="other">The other object to be used in the comparison.</param>
        /// <returns>True if both objects are Quaternions of equal value. Otherwise it returns false.</returns>
        public override bool Equals(object other)
        {
            if (other is Quaternion == false) return false;
            return this == (Quaternion)other;
        }

        #endregion

        #region public override int GetHashCode ()

        /// <summary>
        /// Provides the hash code for this object. 
        /// </summary>
        /// <returns>A hash code formed from the bitwise XOR of this objects members.</returns>
        public override int GetHashCode()
        {
            return new { Xyz.x, Xyz.y, Xyz.z, W }.GetHashCode();
        }

        #endregion

        #endregion

        #endregion

        #region IEquatable<Quaterniond> Members

        /// <summary>
        /// Compares this Quaterniond instance to another Quaterniond for equality. 
        /// </summary>
        /// <param name="other">The other Quaterniond to be used in the comparison.</param>
        /// <returns>True if both instances are equal; false otherwise.</returns>
        public bool Equals(Quaternion other)
        {
            return Xyz == other.Xyz && W == other.W;
        }

        #endregion
    }
}

#endregion //Quaternion.cs
#region quicksort.cs

namespace MatterHackers.Agg
{
    public class QuickSort_cell_aa
    {
        public QuickSort_cell_aa()
        {
        }

        public void Sort(cell_aa[] dataToSort)
        {
            Sort(dataToSort, 0, (int)(dataToSort.Length - 1));
        }

        public void Sort(cell_aa[] dataToSort, int beg, int end)
        {
            if (end == beg)
            {
                return;
            }
            else
            {
                int pivot = getPivotPoint(dataToSort, beg, end);
                if (pivot > beg)
                {
                    Sort(dataToSort, beg, pivot - 1);
                }

                if (pivot < end)
                {
                    Sort(dataToSort, pivot + 1, end);
                }
            }
        }

        private int getPivotPoint(cell_aa[] dataToSort, int begPoint, int endPoint)
        {
            int pivot = begPoint;
            int m = begPoint + 1;
            int n = endPoint;
            while ((m < endPoint)
                && dataToSort[pivot].x >= dataToSort[m].x)
            {
                m++;
            }

            while ((n > begPoint) && (dataToSort[pivot].x <= dataToSort[n].x))
            {
                n--;
            }
            while (m < n)
            {
                cell_aa temp = dataToSort[m];
                dataToSort[m] = dataToSort[n];
                dataToSort[n] = temp;

                while ((m < endPoint) && (dataToSort[pivot].x >= dataToSort[m].x))
                {
                    m++;
                }

                while ((n > begPoint) && (dataToSort[pivot].x <= dataToSort[n].x))
                {
                    n--;
                }

            }
            if (pivot != n)
            {
                cell_aa temp2 = dataToSort[n];
                dataToSort[n] = dataToSort[pivot];
                dataToSort[pivot] = temp2;

            }
            return n;
        }
    }

    public class QuickSort_range_adaptor_uint
    {
        public QuickSort_range_adaptor_uint()
        {
        }

        public void Sort(VectorPOD_RangeAdaptor dataToSort)
        {
            Sort(dataToSort, 0, (int)(dataToSort.size() - 1));
        }

        public void Sort(VectorPOD_RangeAdaptor dataToSort, int beg, int end)
        {
            if (end == beg)
            {
                return;
            }
            else
            {
                int pivot = getPivotPoint(dataToSort, beg, end);
                if (pivot > beg)
                {
                    Sort(dataToSort, beg, pivot - 1);
                }

                if (pivot < end)
                {
                    Sort(dataToSort, pivot + 1, end);
                }
            }
        }

        private int getPivotPoint(VectorPOD_RangeAdaptor dataToSort, int begPoint, int endPoint)
        {
            int pivot = begPoint;
            int m = begPoint + 1;
            int n = endPoint;
            while ((m < endPoint)
                && dataToSort[pivot] >= dataToSort[m])
            {
                m++;
            }

            while ((n > begPoint) && (dataToSort[pivot] <= dataToSort[n]))
            {
                n--;
            }
            while (m < n)
            {
                int temp = dataToSort[m];
                dataToSort[m] = dataToSort[n];
                dataToSort[n] = temp;

                while ((m < endPoint) && (dataToSort[pivot] >= dataToSort[m]))
                {
                    m++;
                }

                while ((n > begPoint) && (dataToSort[pivot] <= dataToSort[n]))
                {
                    n--;
                }

            }
            if (pivot != n)
            {
                int temp2 = dataToSort[n];
                dataToSort[n] = dataToSort[pivot];
                dataToSort[pivot] = temp2;

            }
            return n;
        }
    }
}

#endregion //quicksort.cs
#region RasterBufferAccessors.cs

namespace MatterHackers.Agg
{
    public interface IImageBufferAccessor
    {
        byte[] span(int x, int y, int len, out int bufferIndex);
        byte[] next_x(out int bufferByteOffset);
        byte[] next_y(out int bufferByteOffset);

        IImageByte SourceImage
        {
            get;
        }
    };

    public class ImageBufferAccessorCommon : IImageBufferAccessor
    {
        protected IImageByte m_SourceImage;
        protected int m_x, m_x0, m_y, m_DistanceBetweenPixelsInclusive;
        protected byte[] m_Buffer;
        protected int m_CurrentBufferOffset = -1;
        int m_Width;

        public ImageBufferAccessorCommon(IImageByte pixf)
        {
            attach(pixf);
        }

        void attach(IImageByte pixf)
        {
            m_SourceImage = pixf;
            m_Buffer = m_SourceImage.GetBuffer();
            m_Width = m_SourceImage.Width;
            m_DistanceBetweenPixelsInclusive = m_SourceImage.GetBytesBetweenPixelsInclusive();
        }

        public IImageByte SourceImage
        {
            get
            {
                return m_SourceImage;
            }
        }

        private byte[] pixel(out int bufferByteOffset)
        {
            int x = m_x;
            int y = m_y;
            unchecked
            {
                if ((uint)x >= (uint)m_SourceImage.Width)
                {
                    if (x < 0)
                    {
                        x = 0;
                    }
                    else
                    {
                        x = (int)m_SourceImage.Width - 1;
                    }
                }

                if ((uint)y >= (uint)m_SourceImage.Height)
                {
                    if (y < 0)
                    {
                        y = 0;
                    }
                    else
                    {
                        y = (int)m_SourceImage.Height - 1;
                    }
                }
            }

            bufferByteOffset = m_SourceImage.GetBufferOffsetXY(x, y);
            return m_SourceImage.GetBuffer();
        }

        public byte[] span(int x, int y, int len, out int bufferOffset)
        {
            m_x = m_x0 = x;
            m_y = y;
            unchecked
            {
                if ((uint)y < (uint)m_SourceImage.Height
                    && x >= 0 && x + len <= (int)m_SourceImage.Width)
                {
                    bufferOffset = m_SourceImage.GetBufferOffsetXY(x, y);
                    m_Buffer = m_SourceImage.GetBuffer();
                    m_CurrentBufferOffset = bufferOffset;
                    return m_Buffer;
                }
            }

            m_CurrentBufferOffset = -1;
            return pixel(out bufferOffset);
        }

        public byte[] next_x(out int bufferOffset)
        {
            // this is the code (managed) that the original agg used.  
            // It looks like it doesn't check x but, It should be a bit faster and is valid 
            // because "span" checked the whole length for good x.
            if (m_CurrentBufferOffset != -1)
            {
                m_CurrentBufferOffset += m_DistanceBetweenPixelsInclusive;
                bufferOffset = m_CurrentBufferOffset;
                return m_Buffer;
            }
            ++m_x;
            return pixel(out bufferOffset);
        }

        public byte[] next_y(out int bufferOffset)
        {
            ++m_y;
            m_x = m_x0;
            if (m_CurrentBufferOffset != -1
                && (uint)m_y < (uint)m_SourceImage.Height)
            {
                m_CurrentBufferOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
                m_SourceImage.GetBuffer();
                bufferOffset = m_CurrentBufferOffset; ;
                return m_Buffer;
            }

            m_CurrentBufferOffset = -1;
            return pixel(out bufferOffset);
        }
    };

    public sealed class ImageBufferAccessorClip : ImageBufferAccessorCommon
    {
        byte[] m_OutsideBufferColor;

        public ImageBufferAccessorClip(IImageByte sourceImage, RGBA_Bytes bk)
            : base(sourceImage)
        {
            m_OutsideBufferColor = new byte[4];
            m_OutsideBufferColor[0] = bk.red;
            m_OutsideBufferColor[1] = bk.green;
            m_OutsideBufferColor[2] = bk.blue;
            m_OutsideBufferColor[3] = bk.alpha;
        }

        private byte[] pixel(out int bufferByteOffset)
        {
            unchecked
            {
                if (((uint)m_x < (uint)m_SourceImage.Width)
                    && ((uint)m_y < (uint)m_SourceImage.Height))
                {
                    bufferByteOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
                    return m_SourceImage.GetBuffer();
                }
            }

            bufferByteOffset = 0;
            return m_OutsideBufferColor;
        }
    };

    /*
        //--------------------------------------------------image_accessor_no_clip
        template<class PixFmt> class image_accessor_no_clip
        {
        public:
            typedef PixFmt   pixfmt_type;
            typedef typename pixfmt_type::color_type color_type;
            typedef typename pixfmt_type::order_type order_type;
            typedef typename pixfmt_type::value_type value_type;
            enum pix_width_e { pix_width = pixfmt_type::pix_width };

            image_accessor_no_clip() {}
            explicit image_accessor_no_clip(pixfmt_type& pixf) : 
                m_pixf(&pixf) 
            {}

            void attach(pixfmt_type& pixf)
            {
                m_pixf = &pixf;
            }

            byte* span(int x, int y, int)
            {
                m_x = x;
                m_y = y;
                return m_pix_ptr = m_pixf->pix_ptr(x, y);
            }

            byte* next_x()
            {
                return m_pix_ptr += pix_width;
            }

            byte* next_y()
            {
                ++m_y;
                return m_pix_ptr = m_pixf->pix_ptr(m_x, m_y);
            }

        private:
            pixfmt_type* m_pixf;
            int                m_x, m_y;
            byte*       m_pix_ptr;
        };
     */

    public sealed class ImageBufferAccessorClamp : ImageBufferAccessorCommon
    {
        public ImageBufferAccessorClamp(IImageByte pixf)
            : base(pixf)
        {
        }

        private byte[] pixel(out int bufferByteOffset)
        {
            int x = m_x;
            int y = m_y;
            unchecked
            {
                if ((uint)x >= (uint)m_SourceImage.Width)
                {
                    if (x < 0)
                    {
                        x = 0;
                    }
                    else
                    {
                        x = (int)m_SourceImage.Width - 1;
                    }
                }

                if ((uint)y >= (uint)m_SourceImage.Height)
                {
                    if (y < 0)
                    {
                        y = 0;
                    }
                    else
                    {
                        y = (int)m_SourceImage.Height - 1;
                    }
                }
            }

            bufferByteOffset = m_SourceImage.GetBufferOffsetXY(x, y);
            return m_SourceImage.GetBuffer();
        }
    };
    /*

        //-----------------------------------------------------image_accessor_wrap
        template<class PixFmt, class WrapX, class WrapY> class image_accessor_wrap
        {
        public:
            typedef PixFmt   pixfmt_type;
            typedef typename pixfmt_type::color_type color_type;
            typedef typename pixfmt_type::order_type order_type;
            typedef typename pixfmt_type::value_type value_type;
            enum pix_width_e { pix_width = pixfmt_type::pix_width };

            image_accessor_wrap() {}
            explicit image_accessor_wrap(pixfmt_type& pixf) : 
                m_pixf(&pixf), 
                m_wrap_x(pixf.Width), 
                m_wrap_y(pixf.Height)
            {}

            void attach(pixfmt_type& pixf)
            {
                m_pixf = &pixf;
            }

            byte* span(int x, int y, int)
            {
                m_x = x;
                m_row_ptr = m_pixf->row_ptr(m_wrap_y(y));
                return m_row_ptr + m_wrap_x(x) * pix_width;
            }

            byte* next_x()
            {
                int x = ++m_wrap_x;
                return m_row_ptr + x * pix_width;
            }

            byte* next_y()
            {
                m_row_ptr = m_pixf->row_ptr(++m_wrap_y);
                return m_row_ptr + m_wrap_x(m_x) * pix_width;
            }

        private:
            pixfmt_type* m_pixf;
            byte*       m_row_ptr;
            int                m_x;
            WrapX              m_wrap_x;
            WrapY              m_wrap_y;
        };




        //--------------------------------------------------------wrap_mode_repeat
        class wrap_mode_repeat
        {
        public:
            wrap_mode_repeat() {}
            wrap_mode_repeat(int size) : 
                m_size(size), 
                m_add(size * (0x3FFFFFFF / size)),
                m_value(0)
            {}

            int operator() (int v)
            { 
                return m_value = (int(v) + m_add) % m_size; 
            }

            int operator++ ()
            {
                ++m_value;
                if(m_value >= m_size) m_value = 0;
                return m_value;
            }
        private:
            int m_size;
            int m_add;
            int m_value;
        };


        //---------------------------------------------------wrap_mode_repeat_pow2
        class wrap_mode_repeat_pow2
        {
        public:
            wrap_mode_repeat_pow2() {}
            wrap_mode_repeat_pow2(int size) : m_value(0)
            {
                m_mask = 1;
                while(m_mask < size) m_mask = (m_mask << 1) | 1;
                m_mask >>= 1;
            }
            int operator() (int v)
            { 
                return m_value = int(v) & m_mask;
            }
            int operator++ ()
            {
                ++m_value;
                if(m_value > m_mask) m_value = 0;
                return m_value;
            }
        private:
            int m_mask;
            int m_value;
        };


        //----------------------------------------------wrap_mode_repeat_auto_pow2
        class wrap_mode_repeat_auto_pow2
        {
        public:
            wrap_mode_repeat_auto_pow2() {}
            wrap_mode_repeat_auto_pow2(int size) :
                m_size(size),
                m_add(size * (0x3FFFFFFF / size)),
                m_mask((m_size & (m_size-1)) ? 0 : m_size-1),
                m_value(0)
            {}

            int operator() (int v) 
            { 
                if(m_mask) return m_value = int(v) & m_mask;
                return m_value = (int(v) + m_add) % m_size;
            }
            int operator++ ()
            {
                ++m_value;
                if(m_value >= m_size) m_value = 0;
                return m_value;
            }

        private:
            int m_size;
            int m_add;
            int m_mask;
            int m_value;
        };


        //-------------------------------------------------------wrap_mode_reflect
        class wrap_mode_reflect
        {
        public:
            wrap_mode_reflect() {}
            wrap_mode_reflect(int size) : 
                m_size(size), 
                m_size2(size * 2),
                m_add(m_size2 * (0x3FFFFFFF / m_size2)),
                m_value(0)
            {}

            int operator() (int v)
            { 
                m_value = (int(v) + m_add) % m_size2;
                if(m_value >= m_size) return m_size2 - m_value - 1;
                return m_value;
            }

            int operator++ ()
            {
                ++m_value;
                if(m_value >= m_size2) m_value = 0;
                if(m_value >= m_size) return m_size2 - m_value - 1;
                return m_value;
            }
        private:
            int m_size;
            int m_size2;
            int m_add;
            int m_value;
        };



        //--------------------------------------------------wrap_mode_reflect_pow2
        class wrap_mode_reflect_pow2
        {
        public:
            wrap_mode_reflect_pow2() {}
            wrap_mode_reflect_pow2(int size) : m_value(0)
            {
                m_mask = 1;
                m_size = 1;
                while(m_mask < size) 
                {
                    m_mask = (m_mask << 1) | 1;
                    m_size <<= 1;
                }
            }
            int operator() (int v)
            { 
                m_value = int(v) & m_mask;
                if(m_value >= m_size) return m_mask - m_value;
                return m_value;
            }
            int operator++ ()
            {
                ++m_value;
                m_value &= m_mask;
                if(m_value >= m_size) return m_mask - m_value;
                return m_value;
            }
        private:
            int m_size;
            int m_mask;
            int m_value;
        };



        //---------------------------------------------wrap_mode_reflect_auto_pow2
        class wrap_mode_reflect_auto_pow2
        {
        public:
            wrap_mode_reflect_auto_pow2() {}
            wrap_mode_reflect_auto_pow2(int size) :
                m_size(size),
                m_size2(size * 2),
                m_add(m_size2 * (0x3FFFFFFF / m_size2)),
                m_mask((m_size2 & (m_size2-1)) ? 0 : m_size2-1),
                m_value(0)
            {}

            int operator() (int v) 
            { 
                m_value = m_mask ? int(v) & m_mask : 
                                  (int(v) + m_add) % m_size2;
                if(m_value >= m_size) return m_size2 - m_value - 1;
                return m_value;            
            }
            int operator++ ()
            {
                ++m_value;
                if(m_value >= m_size2) m_value = 0;
                if(m_value >= m_size) return m_size2 - m_value - 1;
                return m_value;
            }

        private:
            int m_size;
            int m_size2;
            int m_add;
            int m_mask;
            int m_value;
        };
     */

    public interface IImageBufferAccessorFloat
    {
        float[] span(int x, int y, int len, out int bufferIndex);
        float[] next_x(out int bufferFloatOffset);
        float[] next_y(out int bufferFloatOffset);

        IImageFloat SourceImage
        {
            get;
        }
    };

    public class ImageBufferAccessorCommonFloat : IImageBufferAccessorFloat
    {
        protected IImageFloat m_SourceImage;
        protected int m_x, m_x0, m_y, m_DistanceBetweenPixelsInclusive;
        protected float[] m_Buffer;
        protected int m_CurrentBufferOffset = -1;
        int m_Width;

        public ImageBufferAccessorCommonFloat(IImageFloat pixf)
        {
            attach(pixf);
        }

        void attach(IImageFloat pixf)
        {
            m_SourceImage = pixf;
            m_Buffer = m_SourceImage.GetBuffer();
            m_Width = m_SourceImage.Width;
            m_DistanceBetweenPixelsInclusive = m_SourceImage.GetFloatsBetweenPixelsInclusive();
        }

        public IImageFloat SourceImage
        {
            get
            {
                return m_SourceImage;
            }
        }

        private float[] pixel(out int bufferFloatOffset)
        {
            int x = m_x;
            int y = m_y;
            unchecked
            {
                if ((uint)x >= (uint)m_SourceImage.Width)
                {
                    if (x < 0)
                    {
                        x = 0;
                    }
                    else
                    {
                        x = (int)m_SourceImage.Width - 1;
                    }
                }

                if ((uint)y >= (uint)m_SourceImage.Height)
                {
                    if (y < 0)
                    {
                        y = 0;
                    }
                    else
                    {
                        y = (int)m_SourceImage.Height - 1;
                    }
                }
            }

            bufferFloatOffset = m_SourceImage.GetBufferOffsetXY(x, y);
            return m_SourceImage.GetBuffer();
        }

        public float[] span(int x, int y, int len, out int bufferOffset)
        {
            m_x = m_x0 = x;
            m_y = y;
            unchecked
            {
                if ((uint)y < (uint)m_SourceImage.Height
                    && x >= 0 && x + len <= (int)m_SourceImage.Width)
                {
                    bufferOffset = m_SourceImage.GetBufferOffsetXY(x, y);
                    m_Buffer = m_SourceImage.GetBuffer();
                    m_CurrentBufferOffset = bufferOffset;
                    return m_Buffer;
                }
            }

            m_CurrentBufferOffset = -1;
            return pixel(out bufferOffset);
        }

        public float[] next_x(out int bufferOffset)
        {
            // this is the code (managed) that the original agg used.  
            // It looks like it doesn't check x but, It should be a bit faster and is valid 
            // because "span" checked the whole length for good x.
            if (m_CurrentBufferOffset != -1)
            {
                m_CurrentBufferOffset += m_DistanceBetweenPixelsInclusive;
                bufferOffset = m_CurrentBufferOffset;
                return m_Buffer;
            }
            ++m_x;
            return pixel(out bufferOffset);
        }

        public float[] next_y(out int bufferOffset)
        {
            ++m_y;
            m_x = m_x0;
            if (m_CurrentBufferOffset != -1
                && (uint)m_y < (uint)m_SourceImage.Height)
            {
                m_CurrentBufferOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
                bufferOffset = m_CurrentBufferOffset;
                return m_Buffer;
            }

            m_CurrentBufferOffset = -1;
            return pixel(out bufferOffset);
        }
    };

    public sealed class ImageBufferAccessorClipFloat : ImageBufferAccessorCommonFloat
    {
        float[] m_OutsideBufferColor;

        public ImageBufferAccessorClipFloat(IImageFloat sourceImage, RGBA_Floats bk)
            : base(sourceImage)
        {
            m_OutsideBufferColor = new float[4];
            m_OutsideBufferColor[0] = bk.red;
            m_OutsideBufferColor[1] = bk.green;
            m_OutsideBufferColor[2] = bk.blue;
            m_OutsideBufferColor[3] = bk.alpha;
        }

        private float[] pixel(out int bufferFloatOffset)
        {
            unchecked
            {
                if (((uint)m_x < (uint)m_SourceImage.Width)
                    && ((uint)m_y < (uint)m_SourceImage.Height))
                {
                    bufferFloatOffset = m_SourceImage.GetBufferOffsetXY(m_x, m_y);
                    return m_SourceImage.GetBuffer();
                }
            }

            bufferFloatOffset = 0;
            return m_OutsideBufferColor;
        }

        //public void background_color(IColorType bk)
        //{
        //  m_pixf.make_pix(m_pBackBufferColor, bk);
        //}
    };
}

#endregion //RasterBufferAccessors.cs
#region Ray.cs

namespace MatterHackers.VectorMath
{
    [Flags]
    public enum IntersectionType { None = 0, FrontFace = 1, BackFace = 2, Both = FrontFace | BackFace };

    /// <summary>
    /// a virtual ray that is casted from a begin Position in a certain Direction.
    /// </summary>
    public class Ray
    {
        public static double sameSurfaceOffset = .00001;

        public Vector3 origin;
        public Vector3 direction;
        public double minDistanceToConsider;
        public double maxDistanceToConsider;
        public Vector3 oneOverDirection;
        public bool isShadowRay;
        public IntersectionType intersectionType;

        public enum Sign { negative = 1, positive = 0 };
        public Sign[] sign = new Sign[3];

        public Ray(Vector3 origin, Vector3 direction, double minDistanceToConsider = 0, double maxDistanceToConsider = double.PositiveInfinity, IntersectionType intersectionType = IntersectionType.FrontFace)
        {
            this.origin = origin;
            this.direction = direction;
            this.minDistanceToConsider = minDistanceToConsider;
            this.maxDistanceToConsider = maxDistanceToConsider;
            this.intersectionType = intersectionType;
            oneOverDirection = 1 / direction;

            sign[0] = (oneOverDirection.x < 0) ? Sign.negative : Sign.positive;
            sign[1] = (oneOverDirection.y < 0) ? Sign.negative : Sign.positive;
            sign[2] = (oneOverDirection.z < 0) ? Sign.negative : Sign.positive;
        }

        public Ray(Ray rayToCopy)
        {
            origin = rayToCopy.origin;
            direction = rayToCopy.direction;
            minDistanceToConsider = rayToCopy.minDistanceToConsider;
            maxDistanceToConsider = rayToCopy.maxDistanceToConsider;
            oneOverDirection = rayToCopy.oneOverDirection;
            isShadowRay = rayToCopy.isShadowRay;
            intersectionType = rayToCopy.intersectionType;
            sign[0] = rayToCopy.sign[0];
            sign[1] = rayToCopy.sign[1];
            sign[2] = rayToCopy.sign[2];
        }

        public bool Intersection(AxisAlignedBoundingBox bounds)
        {
            Ray ray = this;
            // we calculate distance to the intersection with the x planes of the box
            double minDistFound = (bounds[(int)ray.sign[0]].x - ray.origin.x) * ray.oneOverDirection.x;
            double maxDistFound = (bounds[1 - (int)ray.sign[0]].x - ray.origin.x) * ray.oneOverDirection.x;

            // now find the distance to the y planes of the box
            double minDistToY = (bounds[(int)ray.sign[1]].y - ray.origin.y) * ray.oneOverDirection.y;
            double maxDistToY = (bounds[1 - (int)ray.sign[1]].y - ray.origin.y) * ray.oneOverDirection.y;

            if ((minDistFound > maxDistToY) || (minDistToY > maxDistFound))
            {
                return false;
            }

            if (minDistToY > minDistFound)
            {
                minDistFound = minDistToY;
            }

            if (maxDistToY < maxDistFound)
            {
                maxDistFound = maxDistToY;
            }

            // and finaly the z planes
            double minDistToZ = (bounds[(int)ray.sign[2]].z - ray.origin.z) * ray.oneOverDirection.z;
            double maxDistToZ = (bounds[1 - (int)ray.sign[2]].z - ray.origin.z) * ray.oneOverDirection.z;

            if ((minDistFound > maxDistToZ) || (minDistToZ > maxDistFound))
            {
                return false;
            }

            if (minDistToZ > minDistFound)
            {
                minDistFound = minDistToZ;
            }

            if (maxDistToZ < maxDistFound)
            {
                maxDistFound = maxDistToZ;
            }

            bool withinDistanceToConsider = (minDistFound < ray.maxDistanceToConsider) && (maxDistFound > ray.minDistanceToConsider);
            return withinDistanceToConsider;
        }
    }
}

#endregion //Ray.cs
#region RectangleDouble.cs
namespace MatterHackers.Agg
{
    public struct RectangleDouble
    {
        public double Left, Bottom, Right, Top;

        public static readonly RectangleDouble ZeroIntersection = new RectangleDouble(double.MaxValue, double.MaxValue, double.MinValue, double.MinValue);

        public RectangleDouble(double left, double bottom, double right, double top)
        {
            this.Left = left;
            this.Bottom = bottom;
            this.Right = right;
            this.Top = top;
        }

        public RectangleDouble(RectangleInt intRect)
        {
            Left = intRect.Left;
            Bottom = intRect.Bottom;
            Right = intRect.Right;
            Top = intRect.Top;
        }

        public void SetRect(double left, double bottom, double right, double top)
        {
            init(left, bottom, right, top);
        }

        public static bool operator ==(RectangleDouble a, RectangleDouble b)
        {
            if (a.Left == b.Left && a.Bottom == b.Bottom && a.Right == b.Right && a.Top == b.Top)
            {
                return true;
            }

            return false;
        }

        public static bool operator !=(RectangleDouble a, RectangleDouble b)
        {
            if (a.Left != b.Left || a.Bottom != b.Bottom || a.Right != b.Right || a.Top != b.Top)
            {
                return true;
            }

            return false;
        }

        public override int GetHashCode()
        {
            return new { x1 = Left, x2 = Right, y1 = Bottom, y2 = Top }.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj.GetType() == typeof(RectangleDouble))
            {
                return this == (RectangleDouble)obj;
            }
            return false;
        }

        public bool Equals(RectangleDouble other, double epsilon)
        {
            return Math.Abs(Left - other.Left) <= epsilon
                && Math.Abs(Bottom - other.Bottom) <= epsilon
                && Math.Abs(Right - other.Right) <= epsilon
                && Math.Abs(Top - other.Top) <= epsilon;
        }

        public void init(double left, double bottom, double right, double top)
        {
            Left = left;
            Bottom = bottom;
            Right = right;
            Top = top;
        }

        // This function assumes the rect is normalized
        //[JsonIgnoreAttribute]
        public double Width
        {
            get
            {
                return Right - Left;
            }
        }

        // This function assumes the rect is normalized
        //[JsonIgnoreAttribute]
        public double Height
        {
            get
            {
                return Top - Bottom;
            }
        }

        public RectangleDouble normalize()
        {
            double t;
            if (Left > Right) { t = Left; Left = Right; Right = t; }
            if (Bottom > Top) { t = Bottom; Bottom = Top; Top = t; }
            return this;
        }

        public bool clip(RectangleDouble r)
        {
            if (Right > r.Right) Right = r.Right;
            if (Top > r.Top) Top = r.Top;
            if (Left < r.Left) Left = r.Left;
            if (Bottom < r.Bottom) Bottom = r.Bottom;
            return Left <= Right && Bottom <= Top;
        }

        public bool is_valid()
        {
            return Left <= Right && Bottom <= Top;
        }

        public bool Contains(double x, double y)
        {
            return (x >= Left && x <= Right && y >= Bottom && y <= Top);
        }

        public bool Contains(RectangleDouble innerRect)
        {
            if (Contains(innerRect.Left, innerRect.Bottom) && Contains(innerRect.Right, innerRect.Top))
            {
                return true;
            }

            return false;
        }

        public bool Contains(Vector2 position)
        {
            return Contains(position.x, position.y);
        }

        public bool IntersectRectangles(RectangleDouble rectToCopy, RectangleDouble rectToIntersectWith)
        {
            Left = rectToCopy.Left;
            Bottom = rectToCopy.Bottom;
            Right = rectToCopy.Right;
            Top = rectToCopy.Top;

            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public bool IntersectWithRectangle(RectangleDouble rectToIntersectWith)
        {
            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public void unite_rectangles(RectangleDouble r1, RectangleDouble r2)
        {
            Left = r1.Left;
            Bottom = r1.Bottom;
            Right = r1.Right;
            Right = r1.Top;
            if (Right < r2.Right) Right = r2.Right;
            if (Top < r2.Top) Top = r2.Top;
            if (Left > r2.Left) Left = r2.Left;
            if (Bottom > r2.Bottom) Bottom = r2.Bottom;
        }

        public void ExpandToInclude(RectangleDouble rectToInclude)
        {
            if (Right < rectToInclude.Right) Right = rectToInclude.Right;
            if (Top < rectToInclude.Top) Top = rectToInclude.Top;
            if (Left > rectToInclude.Left) Left = rectToInclude.Left;
            if (Bottom > rectToInclude.Bottom) Bottom = rectToInclude.Bottom;
        }

        public void ExpandToInclude(double x, double y)
        {
            if (Right < x) Right = x;
            if (Top < y) Top = y;
            if (Left > x) Left = x;
            if (Bottom > y) Bottom = y;
        }

        public void Inflate(double inflateSize)
        {
            Left = Left - inflateSize;
            Bottom = Bottom - inflateSize;
            Right = Right + inflateSize;
            Top = Top + inflateSize;
        }

        public void Offset(Vector2 offset)
        {
            Offset(offset.x, offset.y);
        }

        public void Offset(double x, double y)
        {
            Left = Left + x;
            Bottom = Bottom + y;
            Right = Right + x;
            Top = Top + y;
        }

        static public RectangleDouble operator *(RectangleDouble a, double b)
        {
            return new RectangleDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
        }

        static public RectangleDouble operator *(double b, RectangleDouble a)
        {
            return new RectangleDouble(a.Left * b, a.Bottom * b, a.Right * b, a.Top * b);
        }

        public double XCenter
        {
            get { return (Right - Left) / 2; }
        }

        public void Inflate(BorderDouble borderDouble)
        {
            Left -= borderDouble.Left;
            Right += borderDouble.Right;
            Bottom -= borderDouble.Bottom;
            Top += borderDouble.Top;
        }

        public void Deflate(BorderDouble borderDouble)
        {
            Left += borderDouble.Left;
            Right -= borderDouble.Right;
            Bottom += borderDouble.Bottom;
            Top -= borderDouble.Top;
        }

        public override string ToString()
        {
            return string.Format("L:{0}, B:{1}, R:{2}, T:{3}", Left, Bottom, Right, Top);
        }
    }
}

#endregion //RectangleDouble.cs
#region RectangleInt.cs

namespace MatterHackers.Agg
{
    public struct RectangleInt
    {
        public int Left, Bottom, Right, Top;

        public RectangleInt(int left, int bottom, int right, int top)
        {
            Left = left;
            Bottom = bottom;
            Right = right;
            Top = top;
        }

        public void SetRect(int left, int bottom, int right, int top)
        {
            init(left, bottom, right, top);
        }

        public void init(int x1_, int y1_, int x2_, int y2_)
        {
            Left = x1_;
            Bottom = y1_;
            Right = x2_;
            Top = y2_;
        }

        // This function assumes the rect is normalized
        //[JsonIgnoreAttribute]
        public int Width
        {
            get
            {
                return Right - Left;
            }
        }

        // This function assumes the rect is normalized
        //[JsonIgnoreAttribute]
        public int Height
        {
            get
            {
                return Top - Bottom;
            }
        }

        public RectangleInt normalize()
        {
            int t;
            if (Left > Right) { t = Left; Left = Right; Right = t; }
            if (Bottom > Top) { t = Bottom; Bottom = Top; Top = t; }
            return this;
        }

        public void ExpandToInclude(RectangleInt rectToInclude)
        {
            if (Right < rectToInclude.Right) Right = rectToInclude.Right;
            if (Top < rectToInclude.Top) Top = rectToInclude.Top;
            if (Left > rectToInclude.Left) Left = rectToInclude.Left;
            if (Bottom > rectToInclude.Bottom) Bottom = rectToInclude.Bottom;
        }

        public bool clip(RectangleInt r)
        {
            if (Right > r.Right) Right = r.Right;
            if (Top > r.Top) Top = r.Top;
            if (Left < r.Left) Left = r.Left;
            if (Bottom < r.Bottom) Bottom = r.Bottom;
            return Left <= Right && Bottom <= Top;
        }

        public bool is_valid()
        {
            return Left <= Right && Bottom <= Top;
        }

        public bool hit_test(int x, int y)
        {
            return (x >= Left && x <= Right && y >= Bottom && y <= Top);
        }

        public bool IntersectRectangles(RectangleInt rectToCopy, RectangleInt rectToIntersectWith)
        {
            Left = rectToCopy.Left;
            Bottom = rectToCopy.Bottom;
            Right = rectToCopy.Right;
            Top = rectToCopy.Top;

            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public bool IntersectWithRectangle(RectangleInt rectToIntersectWith)
        {
            if (Left < rectToIntersectWith.Left) Left = rectToIntersectWith.Left;
            if (Bottom < rectToIntersectWith.Bottom) Bottom = rectToIntersectWith.Bottom;
            if (Right > rectToIntersectWith.Right) Right = rectToIntersectWith.Right;
            if (Top > rectToIntersectWith.Top) Top = rectToIntersectWith.Top;

            if (Left < Right && Bottom < Top)
            {
                return true;
            }

            return false;
        }

        public static bool DoIntersect(RectangleInt rect1, RectangleInt rect2)
        {
            int x1 = rect1.Left;
            int y1 = rect1.Bottom;
            int x2 = rect1.Right;
            int y2 = rect1.Top;

            if (x1 < rect2.Left) x1 = rect2.Left;
            if (y1 < rect2.Bottom) y1 = rect2.Bottom;
            if (x2 > rect2.Right) x2 = rect2.Right;
            if (y2 > rect2.Top) y2 = rect2.Top;

            if (x1 < x2 && y1 < y2)
            {
                return true;
            }

            return false;
        }


        //---------------------------------------------------------unite_rectangles
        public void unite_rectangles(RectangleInt r1, RectangleInt r2)
        {
            Left = r1.Left;
            Bottom = r1.Bottom;
            Right = r1.Right;
            Right = r1.Top;
            if (Right < r2.Right) Right = r2.Right;
            if (Top < r2.Top) Top = r2.Top;
            if (Left > r2.Left) Left = r2.Left;
            if (Bottom > r2.Bottom) Bottom = r2.Bottom;
        }

        public void Inflate(int inflateSize)
        {
            Left = Left - inflateSize;
            Bottom = Bottom - inflateSize;
            Right = Right + inflateSize;
            Top = Top + inflateSize;
        }

        public void Offset(int x, int y)
        {
            Left = Left + x;
            Bottom = Bottom + y;
            Right = Right + x;
            Top = Top + y;
        }

        public override int GetHashCode()
        {
            return new { x1 = Left, x2 = Right, y1 = Bottom, y2 = Top }.GetHashCode();
        }

        public static bool ClipRects(RectangleInt pBoundingRect, ref RectangleInt pSourceRect, ref RectangleInt pDestRect)
        {
            // clip off the top so we don't write into random memory
            if (pDestRect.Top < pBoundingRect.Top)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Height != pDestRect.Height)
                {
                    throw new Exception("source and dest rects must have the same height");
                }

                pSourceRect.Top += pBoundingRect.Top - pDestRect.Top;
                pDestRect.Top = pBoundingRect.Top;
                if (pDestRect.Top >= pDestRect.Bottom)
                {
                    return false;
                }
            }
            // clip off the bottom
            if (pDestRect.Bottom > pBoundingRect.Bottom)
            {
                // This type of clipping only works when we arenst scaling an image...
                // If we are scaling an image, the source and desst sizes won't match
                if (pSourceRect.Height != pDestRect.Height)
                {
                    throw new Exception("source and dest rects must have the same height");
                }

                pSourceRect.Bottom -= pDestRect.Bottom - pBoundingRect.Bottom;
                pDestRect.Bottom = pBoundingRect.Bottom;
                if (pDestRect.Bottom <= pDestRect.Top)
                {
                    return false;
                }
            }

            // clip off the left
            if (pDestRect.Left < pBoundingRect.Left)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Width != pDestRect.Width)
                {
                    throw new Exception("source and dest rects must have the same width");
                }

                pSourceRect.Left += pBoundingRect.Left - pDestRect.Left;
                pDestRect.Left = pBoundingRect.Left;
                if (pDestRect.Left >= pDestRect.Right)
                {
                    return false;
                }
            }
            // clip off the right
            if (pDestRect.Right > pBoundingRect.Right)
            {
                // This type of clipping only works when we aren't scaling an image...
                // If we are scaling an image, the source and dest sizes won't match
                if (pSourceRect.Width != pDestRect.Width)
                {
                    throw new Exception("source and dest rects must have the same width");
                }

                pSourceRect.Right -= pDestRect.Right - pBoundingRect.Right;
                pDestRect.Right = pBoundingRect.Right;
                if (pDestRect.Right <= pDestRect.Left)
                {
                    return false;
                }
            }

            return true;
        }


        //***************************************************************************************************************************************************
        public static bool ClipRect(RectangleInt pBoundingRect, ref RectangleInt pDestRect)
        {
            // clip off the top so we don't write into random memory
            if (pDestRect.Top < pBoundingRect.Top)
            {
                pDestRect.Top = pBoundingRect.Top;
                if (pDestRect.Top >= pDestRect.Bottom)
                {
                    return false;
                }
            }
            // clip off the bottom
            if (pDestRect.Bottom > pBoundingRect.Bottom)
            {
                pDestRect.Bottom = pBoundingRect.Bottom;
                if (pDestRect.Bottom <= pDestRect.Top)
                {
                    return false;
                }
            }

            // clip off the left
            if (pDestRect.Left < pBoundingRect.Left)
            {
                pDestRect.Left = pBoundingRect.Left;
                if (pDestRect.Left >= pDestRect.Right)
                {
                    return false;
                }
            }

            // clip off the right
            if (pDestRect.Right > pBoundingRect.Right)
            {
                pDestRect.Right = pBoundingRect.Right;
                if (pDestRect.Right <= pDestRect.Left)
                {
                    return false;
                }
            }

            return true;
        }
    }
}

#endregion //RectangleInt.cs
#region RecursiveBlur.cs


//----------------------------------------------------------------------------
//
// The Stack Blur Algorithm was invented by Mario Klingemann, 
// mario@quasimondo.com and described here:
// http://incubator.quasimondo.com/processing/fast_blur_deluxe.php
// (search phrase "Stackblur: Fast But Goodlooking"). 
// The major improvement is that there's no more division table
// that was very expensive to create for large blur radii. Insted, 
// for 8-bit per channel and radius not exceeding 254 the division is 
// replaced by multiplication and shift. 
//
//----------------------------------------------------------------------------

namespace MatterHackers.Agg.Image
{
#if true
    public struct RGBA_Ints
    {
        public int r;
        public int g;
        public int b;
        public int a;
    };

    struct stack_blur_tables
    {
        public static ushort[] g_stack_blur8_mul = 
        {
            512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
            454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
            482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
            437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
            497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
            320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
            446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
            329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
            505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
            399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
            324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
            268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
            451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
            385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
            332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
            289,287,285,282,280,278,275,273,271,269,267,265,263,261,259
        };

        public static byte[] g_stack_blur8_shr = 
        {
              9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
             17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
             19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
             20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
             21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
             21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
             22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
             22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
             23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
             23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
             23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
             23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
             24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24
        };
    };

    //==============================================================stack_blur
    public class stack_blur
    {
        //private VectorPOD<RGBA_Ints> m_buff;
        //private VectorPOD<int> m_stack;
        //int base_mask = 255;

        enum order_e
        {
            R = 2,
            G = 1,
            B = 0,
            A = 3
        };

        public void blur_x(IImageByte img, int radius)
        {
            throw new NotImplementedException();
#if false
            if(radius < 1) return;

            int x, y, xp, i;
            int stack_ptr;
            int stack_start;

            color_type      pix;
            color_type*     stack_pix;
            calculator_type sum;
            calculator_type sum_in;
            calculator_type sum_out;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int div = radius * 2 + 1;

            int div_sum = (radius + 1) * (radius + 1);
            int mul_sum = 0;
            int shr_sum = 0;
            int max_val = base_mask;

            if(max_val <= 255 && radius < 255)
            {
                mul_sum = stack_blur_tables.g_stack_blur8_mul[radius];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[radius];
            }

            m_buf.allocate(w, 128);
            m_stack.allocate(div, 32);

            for(y = 0; y < h; y++)
            {
                sum.clear();
                sum_in.clear();
                sum_out.clear();

                pix = img.pixel(0, y);
                for(i = 0; i <= radius; i++)
                {
                    m_stack[i] = pix;
                    sum.add(pix, i + 1);
                    sum_out.add(pix);
                }
                for(i = 1; i <= radius; i++)
                {
                    pix = img.pixel((i > wm) ? wm : i, y);
                    m_stack[i + radius] = pix;
                    sum.add(pix, radius + 1 - i);
                    sum_in.add(pix);
                }

                stack_ptr = radius;
                for(x = 0; x < w; x++)
                {
                    if(mul_sum) sum.calc_pix(m_buf[x], mul_sum, shr_sum);
                    else        sum.calc_pix(m_buf[x], div_sum);

                    sum.sub(sum_out);
           
                    stack_start = stack_ptr + div - radius;
                    if(stack_start >= div) stack_start -= div;
                    stack_pix = &m_stack[stack_start];

                    sum_out.sub(*stack_pix);

                    xp = x + radius + 1;
                    if(xp > wm) xp = wm;
                    pix = img.pixel(xp, y);
            
                    *stack_pix = pix;
            
                    sum_in.add(pix);
                    sum.add(sum_in);
            
                    ++stack_ptr;
                    if(stack_ptr >= div) stack_ptr = 0;
                    stack_pix = &m_stack[stack_ptr];

                    sum_out.add(*stack_pix);
                    sum_in.sub(*stack_pix);
                }
                img.copy_color_hspan(0, y, w, &m_buf[0]);
            }
#endif
        }

        public void blur_y(IImageByte img, int radius)
        {
            FormatTransposer img2 = new FormatTransposer(img);
            blur_x(img2, radius);
        }

        public void blur(ImageBuffer img, int radius)
        {
            blur_x(img, radius);
            FormatTransposer img2 = new FormatTransposer(img);
            blur_x(img2, radius);
        }


        void stack_blur_gray8(ImageBuffer img, int rx, int ry)
        {
            throw new NotImplementedException();
#if false
            int x, y, xp, yp, i;
            int stack_ptr;
            int stack_start;

            byte* src_pix_ptr;
                  byte* dst_pix_ptr;
            int pix;
            int stack_pix;
            int sum;
            int sum_in;
            int sum_out;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int hm  = h - 1;

            int div;
            int mul_sum;
            int shr_sum;

            pod_vector<byte> stack;

            if(rx > 0)
            {
                if(rx > 254) rx = 254;
                div = rx * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[rx];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[rx];
                stack.allocate(div);

                for(y = 0; y < h; y++)
                {
                    sum = sum_in = sum_out = 0;

                    src_pix_ptr = img.pix_ptr(0, y);
                    pix = *src_pix_ptr;
                    for(i = 0; i <= rx; i++)
                    {
                        stack[i] = pix;
                        sum     += pix * (i + 1);
                        sum_out += pix;
                    }
                    for(i = 1; i <= rx; i++)
                    {
                        if(i <= wm) src_pix_ptr += Img::pix_step; 
                        pix = *src_pix_ptr; 
                        stack[i + rx] = pix;
                        sum    += pix * (rx + 1 - i);
                        sum_in += pix;
                    }

                    stack_ptr = rx;
                    xp = rx;
                    if(xp > wm) xp = wm;
                    src_pix_ptr = img.pix_ptr(xp, y);
                    dst_pix_ptr = img.pix_ptr(0, y);
                    for(x = 0; x < w; x++)
                    {
                        *dst_pix_ptr = (sum * mul_sum) >> shr_sum;
                        dst_pix_ptr += Img::pix_step;

                        sum -= sum_out;
           
                        stack_start = stack_ptr + div - rx;
                        if(stack_start >= div) stack_start -= div;
                        sum_out -= stack[stack_start];

                        if(xp < wm) 
                        {
                            src_pix_ptr += Img::pix_step;
                            pix = *src_pix_ptr;
                            ++xp;
                        }
            
                        stack[stack_start] = pix;
            
                        sum_in += pix;
                        sum    += sum_in;
            
                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix = stack[stack_ptr];

                        sum_out += stack_pix;
                        sum_in  -= stack_pix;
                    }
                }
            }

            if(ry > 0)
            {
                if(ry > 254) ry = 254;
                div = ry * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[ry];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[ry];
                stack.allocate(div);

                int stride = img.stride();
                for(x = 0; x < w; x++)
                {
                    sum = sum_in = sum_out = 0;

                    src_pix_ptr = img.pix_ptr(x, 0);
                    pix = *src_pix_ptr;
                    for(i = 0; i <= ry; i++)
                    {
                        stack[i] = pix;
                        sum     += pix * (i + 1);
                        sum_out += pix;
                    }
                    for(i = 1; i <= ry; i++)
                    {
                        if(i <= hm) src_pix_ptr += stride; 
                        pix = *src_pix_ptr; 
                        stack[i + ry] = pix;
                        sum    += pix * (ry + 1 - i);
                        sum_in += pix;
                    }

                    stack_ptr = ry;
                    yp = ry;
                    if(yp > hm) yp = hm;
                    src_pix_ptr = img.pix_ptr(x, yp);
                    dst_pix_ptr = img.pix_ptr(x, 0);
                    for(y = 0; y < h; y++)
                    {
                        *dst_pix_ptr = (sum * mul_sum) >> shr_sum;
                        dst_pix_ptr += stride;

                        sum -= sum_out;
           
                        stack_start = stack_ptr + div - ry;
                        if(stack_start >= div) stack_start -= div;
                        sum_out -= stack[stack_start];

                        if(yp < hm) 
                        {
                            src_pix_ptr += stride;
                            pix = *src_pix_ptr;
                            ++yp;
                        }
            
                        stack[stack_start] = pix;
            
                        sum_in += pix;
                        sum    += sum_in;
            
                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix = stack[stack_ptr];

                        sum_out += stack_pix;
                        sum_in  -= stack_pix;
                    }
                }
            }
#endif
        }

        public void Blur(ImageBuffer img, int rx, int ry)
        {
            switch (img.BitDepth)
            {
                case 24:
                    stack_blur_bgr24(img, rx, ry);
                    break;

                case 32:
                    stack_blur_bgra32(img, rx, ry);
                    break;

                default:
                    throw new NotImplementedException();
            }
        }

        private void stack_blur_bgr24(ImageBuffer img, int rx, int ry)
        {
            throw new NotImplementedException();
#if false
            //typedef typename Img::color_type color_type;
            //typedef typename Img::order_type order_type;

            int x, y, xp, yp, i;
            int stack_ptr;
            int stack_start;

            byte* src_pix_ptr;
                  byte* dst_pix_ptr;
            color_type*  stack_pix_ptr;

            int sum_r;
            int sum_g;
            int sum_b;
            int sum_in_r;
            int sum_in_g;
            int sum_in_b;
            int sum_out_r;
            int sum_out_g;
            int sum_out_b;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int hm  = h - 1;

            int div;
            int mul_sum;
            int shr_sum;

            pod_vector<color_type> stack;

            if(rx > 0)
            {
                if(rx > 254) rx = 254;
                div = rx * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[rx];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[rx];
                stack.allocate(div);

                for(y = 0; y < h; y++)
                {
                    sum_r = 
                    sum_g = 
                    sum_b = 
                    sum_in_r = 
                    sum_in_g = 
                    sum_in_b = 
                    sum_out_r = 
                    sum_out_g = 
                    sum_out_b = 0;

                    src_pix_ptr = img.pix_ptr(0, y);
                    for(i = 0; i <= rx; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                    }
                    for(i = 1; i <= rx; i++)
                    {
                        if(i <= wm) src_pix_ptr += Img::pix_width; 
                        stack_pix_ptr = &stack[i + rx];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (rx + 1 - i);
                        sum_g           += src_pix_ptr[G] * (rx + 1 - i);
                        sum_b           += src_pix_ptr[B] * (rx + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                    }

                    stack_ptr = rx;
                    xp = rx;
                    if(xp > wm) xp = wm;
                    src_pix_ptr = img.pix_ptr(xp, y);
                    dst_pix_ptr = img.pix_ptr(0, y);
                    for(x = 0; x < w; x++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr   += Img::pix_width;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;
           
                        stack_start = stack_ptr + div - rx;
                        if(stack_start >= div) stack_start -= div;
                        stack_pix_ptr = &stack[stack_start];

                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;

                        if(xp < wm) 
                        {
                            src_pix_ptr += Img::pix_width;
                            ++xp;
                        }
            
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
            
                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;
            
                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                    }
                }
            }

            if(ry > 0)
            {
                if(ry > 254) ry = 254;
                div = ry * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[ry];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[ry];
                stack.allocate(div);

                int stride = img.stride();
                for(x = 0; x < w; x++)
                {
                    sum_r = 
                    sum_g = 
                    sum_b = 
                    sum_in_r = 
                    sum_in_g = 
                    sum_in_b = 
                    sum_out_r = 
                    sum_out_g = 
                    sum_out_b = 0;

                    src_pix_ptr = img.pix_ptr(x, 0);
                    for(i = 0; i <= ry; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                    }
                    for(i = 1; i <= ry; i++)
                    {
                        if(i <= hm) src_pix_ptr += stride; 
                        stack_pix_ptr = &stack[i + ry];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        sum_r           += src_pix_ptr[R] * (ry + 1 - i);
                        sum_g           += src_pix_ptr[G] * (ry + 1 - i);
                        sum_b           += src_pix_ptr[B] * (ry + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                    }

                    stack_ptr = ry;
                    yp = ry;
                    if(yp > hm) yp = hm;
                    src_pix_ptr = img.pix_ptr(x, yp);
                    dst_pix_ptr = img.pix_ptr(x, 0);
                    for(y = 0; y < h; y++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr += stride;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;
           
                        stack_start = stack_ptr + div - ry;
                        if(stack_start >= div) stack_start -= div;

                        stack_pix_ptr = &stack[stack_start];
                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;

                        if(yp < hm) 
                        {
                            src_pix_ptr += stride;
                            ++yp;
                        }
            
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
            
                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;
            
                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                    }
                }
            }
#endif
        }

        private void stack_blur_bgra32(ImageBuffer img, int rx, int ry)
        {
            throw new NotImplementedException();
#if false
            //typedef typename Img::color_type color_type;
            //typedef typename Img::order_type order_type;

            int x, y, xp, yp, i;
            int stack_ptr;
            int stack_start;

            byte* src_pix_ptr;
                  byte* dst_pix_ptr;
            color_type*  stack_pix_ptr;

            int sum_r;
            int sum_g;
            int sum_b;
            int sum_a;
            int sum_in_r;
            int sum_in_g;
            int sum_in_b;
            int sum_in_a;
            int sum_out_r;
            int sum_out_g;
            int sum_out_b;
            int sum_out_a;

            int w   = img.width();
            int h   = img.height();
            int wm  = w - 1;
            int hm  = h - 1;

            int div;
            int mul_sum;
            int shr_sum;

            pod_vector<color_type> stack;

            if(rx > 0)
            {
                if(rx > 254) rx = 254;
                div = rx * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[rx];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[rx];
                stack.allocate(div);

                for(y = 0; y < h; y++)
                {
                    sum_r = 
                    sum_g = 
                    sum_b = 
                    sum_a = 
                    sum_in_r = 
                    sum_in_g = 
                    sum_in_b = 
                    sum_in_a = 
                    sum_out_r = 
                    sum_out_g = 
                    sum_out_b = 
                    sum_out_a = 0;

                    src_pix_ptr = img.pix_ptr(0, y);
                    for(i = 0; i <= rx; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_a           += src_pix_ptr[A] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                        sum_out_a       += src_pix_ptr[A];
                    }
                    for(i = 1; i <= rx; i++)
                    {
                        if(i <= wm) src_pix_ptr += Img::pix_width; 
                        stack_pix_ptr = &stack[i + rx];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (rx + 1 - i);
                        sum_g           += src_pix_ptr[G] * (rx + 1 - i);
                        sum_b           += src_pix_ptr[B] * (rx + 1 - i);
                        sum_a           += src_pix_ptr[A] * (rx + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                        sum_in_a        += src_pix_ptr[A];
                    }

                    stack_ptr = rx;
                    xp = rx;
                    if(xp > wm) xp = wm;
                    src_pix_ptr = img.pix_ptr(xp, y);
                    dst_pix_ptr = img.pix_ptr(0, y);
                    for(x = 0; x < w; x++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr[A] = (sum_a * mul_sum) >> shr_sum;
                        dst_pix_ptr += Img::pix_width;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;
                        sum_a -= sum_out_a;
           
                        stack_start = stack_ptr + div - rx;
                        if(stack_start >= div) stack_start -= div;
                        stack_pix_ptr = &stack[stack_start];

                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;
                        sum_out_a -= stack_pix_ptr->a;

                        if(xp < wm) 
                        {
                            src_pix_ptr += Img::pix_width;
                            ++xp;
                        }
            
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
            
                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_in_a += src_pix_ptr[A];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;
                        sum_a    += sum_in_a;
            
                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_out_a += stack_pix_ptr->a;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                        sum_in_a  -= stack_pix_ptr->a;
                    }
                }
            }

            if(ry > 0)
            {
                if(ry > 254) ry = 254;
                div = ry * 2 + 1;
                mul_sum = stack_blur_tables.g_stack_blur8_mul[ry];
                shr_sum = stack_blur_tables.g_stack_blur8_shr[ry];
                stack.allocate(div);

                int stride = img.stride();
                for(x = 0; x < w; x++)
                {
                    sum_r = 
                    sum_g = 
                    sum_b = 
                    sum_a = 
                    sum_in_r = 
                    sum_in_g = 
                    sum_in_b = 
                    sum_in_a = 
                    sum_out_r = 
                    sum_out_g = 
                    sum_out_b = 
                    sum_out_a = 0;

                    src_pix_ptr = img.pix_ptr(x, 0);
                    for(i = 0; i <= ry; i++)
                    {
                        stack_pix_ptr    = &stack[i];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (i + 1);
                        sum_g           += src_pix_ptr[G] * (i + 1);
                        sum_b           += src_pix_ptr[B] * (i + 1);
                        sum_a           += src_pix_ptr[A] * (i + 1);
                        sum_out_r       += src_pix_ptr[R];
                        sum_out_g       += src_pix_ptr[G];
                        sum_out_b       += src_pix_ptr[B];
                        sum_out_a       += src_pix_ptr[A];
                    }
                    for(i = 1; i <= ry; i++)
                    {
                        if(i <= hm) src_pix_ptr += stride; 
                        stack_pix_ptr = &stack[i + ry];
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
                        sum_r           += src_pix_ptr[R] * (ry + 1 - i);
                        sum_g           += src_pix_ptr[G] * (ry + 1 - i);
                        sum_b           += src_pix_ptr[B] * (ry + 1 - i);
                        sum_a           += src_pix_ptr[A] * (ry + 1 - i);
                        sum_in_r        += src_pix_ptr[R];
                        sum_in_g        += src_pix_ptr[G];
                        sum_in_b        += src_pix_ptr[B];
                        sum_in_a        += src_pix_ptr[A];
                    }

                    stack_ptr = ry;
                    yp = ry;
                    if(yp > hm) yp = hm;
                    src_pix_ptr = img.pix_ptr(x, yp);
                    dst_pix_ptr = img.pix_ptr(x, 0);
                    for(y = 0; y < h; y++)
                    {
                        dst_pix_ptr[R] = (sum_r * mul_sum) >> shr_sum;
                        dst_pix_ptr[G] = (sum_g * mul_sum) >> shr_sum;
                        dst_pix_ptr[B] = (sum_b * mul_sum) >> shr_sum;
                        dst_pix_ptr[A] = (sum_a * mul_sum) >> shr_sum;
                        dst_pix_ptr += stride;

                        sum_r -= sum_out_r;
                        sum_g -= sum_out_g;
                        sum_b -= sum_out_b;
                        sum_a -= sum_out_a;
           
                        stack_start = stack_ptr + div - ry;
                        if(stack_start >= div) stack_start -= div;

                        stack_pix_ptr = &stack[stack_start];
                        sum_out_r -= stack_pix_ptr->r;
                        sum_out_g -= stack_pix_ptr->g;
                        sum_out_b -= stack_pix_ptr->b;
                        sum_out_a -= stack_pix_ptr->a;

                        if(yp < hm) 
                        {
                            src_pix_ptr += stride;
                            ++yp;
                        }
            
                        stack_pix_ptr->r = src_pix_ptr[R];
                        stack_pix_ptr->g = src_pix_ptr[G];
                        stack_pix_ptr->b = src_pix_ptr[B];
                        stack_pix_ptr->a = src_pix_ptr[A];
            
                        sum_in_r += src_pix_ptr[R];
                        sum_in_g += src_pix_ptr[G];
                        sum_in_b += src_pix_ptr[B];
                        sum_in_a += src_pix_ptr[A];
                        sum_r    += sum_in_r;
                        sum_g    += sum_in_g;
                        sum_b    += sum_in_b;
                        sum_a    += sum_in_a;
            
                        ++stack_ptr;
                        if(stack_ptr >= div) stack_ptr = 0;
                        stack_pix_ptr = &stack[stack_ptr];

                        sum_out_r += stack_pix_ptr->r;
                        sum_out_g += stack_pix_ptr->g;
                        sum_out_b += stack_pix_ptr->b;
                        sum_out_a += stack_pix_ptr->a;
                        sum_in_r  -= stack_pix_ptr->r;
                        sum_in_g  -= stack_pix_ptr->g;
                        sum_in_b  -= stack_pix_ptr->b;
                        sum_in_a  -= stack_pix_ptr->a;
                    }
                }
            }
#endif
        }
    }

    //====================================================stack_blur_calc_rgba
    struct stack_blur_calc_rgba
    {
        int r, g, b, a;

        void clear()
        {
            r = g = b = a = 0;
        }

        void add(RGBA_Ints v)
        {
            r += v.r;
            g += v.g;
            b += v.b;
            a += v.a;
        }

        void add(RGBA_Ints v, int k)
        {
            r += v.r * k;
            g += v.g * k;
            b += v.b * k;
            a += v.a * k;
        }

        void sub(RGBA_Ints v)
        {
            r -= v.r;
            g -= v.g;
            b -= v.b;
            a -= v.a;
        }

        void calc_pix(RGBA_Ints v, int div)
        {
            v.r = (int)(r / div);
            v.g = (int)(g / div);
            v.b = (int)(b / div);
            v.a = (int)(a / div);
        }

        void calc_pix(RGBA_Ints v, int mul, int shr)
        {
            v.r = (int)((r * mul) >> shr);
            v.g = (int)((g * mul) >> shr);
            v.b = (int)((b * mul) >> shr);
            v.a = (int)((a * mul) >> shr);
        }
    };


    //=====================================================stack_blur_calc_rgb
    struct stack_blur_calc_rgb
    {
        int r, g, b;

        void clear()
        {
            r = g = b = 0;
        }

        void add(RGBA_Ints v)
        {
            r += v.r;
            g += v.g;
            b += v.b;
        }

        void add(RGBA_Ints v, int k)
        {
            r += v.r * k;
            g += v.g * k;
            b += v.b * k;
        }

        void sub(RGBA_Ints v)
        {
            r -= v.r;
            g -= v.g;
            b -= v.b;
        }

        void calc_pix(RGBA_Ints v, int div)
        {
            v.r = (int)(r / div);
            v.g = (int)(g / div);
            v.b = (int)(b / div);
        }

        void calc_pix(RGBA_Ints v, int mul, int shr)
        {
            v.r = (int)((r * mul) >> shr);
            v.g = (int)((g * mul) >> shr);
            v.b = (int)((b * mul) >> shr);
        }
    };


    //====================================================stack_blur_calc_gray
    struct stack_blur_calc_gray
    {
        int v;

        void clear()
        {
            v = 0;
        }

        void add(RGBA_Ints a)
        {
            v += a.r;
        }

        void add(RGBA_Ints a, int k)
        {
            v += a.r * k;
        }

        void sub(RGBA_Ints a)
        {
            v -= a.r;
        }

        void calc_pix(RGBA_Ints a, int div)
        {
            a.r = (int)(v / div);
        }

        void calc_pix(RGBA_Ints a, int mul, int shr)
        {
            a.r = (int)((v * mul) >> shr);
        }
    };
#endif

    public abstract class RecursizeBlurCalculator
    {
        public double r, g, b, a;

        public abstract RecursizeBlurCalculator CreateNew();

        public abstract void from_pix(RGBA_Bytes c);

        public abstract void calc(double b1, double b2, double b3, double b4,
            RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4);

        public abstract void to_pix(ref RGBA_Bytes c);
    };

    //===========================================================recursive_blur
    public sealed class RecursiveBlur
    {
        VectorPOD<RecursizeBlurCalculator> m_sum1;
        VectorPOD<RecursizeBlurCalculator> m_sum2;
        VectorPOD<RGBA_Bytes> m_buf;
        RecursizeBlurCalculator m_RecursizeBlurCalculatorFactory;

        public RecursiveBlur(RecursizeBlurCalculator recursizeBluerCalculatorFactory)
        {
            m_sum1 = new VectorPOD<RecursizeBlurCalculator>();
            m_sum2 = new VectorPOD<RecursizeBlurCalculator>();
            m_buf = new VectorPOD<RGBA_Bytes>();
            m_RecursizeBlurCalculatorFactory = recursizeBluerCalculatorFactory;
        }

        public void blur_x(IImageByte img, double radius)
        {
            if (radius < 0.62) return;
            if (img.Width < 3) return;

            double s = (double)(radius * 0.5);
            double q = (double)((s < 2.5) ?
                                    3.97156 - 4.14554 * Math.Sqrt(1 - 0.26891 * s) :
                                    0.98711 * s - 0.96330);

            double q2 = (double)(q * q);
            double q3 = (double)(q2 * q);

            double b0 = (double)(1.0 / (1.578250 +
                                            2.444130 * q +
                                            1.428100 * q2 +
                                            0.422205 * q3));

            double b1 = (double)(2.44413 * q +
                                      2.85619 * q2 +
                                      1.26661 * q3);

            double b2 = (double)(-1.42810 * q2 +
                                     -1.26661 * q3);

            double b3 = (double)(0.422205 * q3);

            double b = (double)(1 - (b1 + b2 + b3) * b0);

            b1 *= b0;
            b2 *= b0;
            b3 *= b0;

            int w = img.Width;
            int h = img.Height;
            int wm = (int)w - 1;
            int x, y;

            int StartCreatingAt = (int)m_sum1.size();
            m_sum1.Resize(w);
            m_sum2.Resize(w);
            m_buf.Allocate(w);

            RecursizeBlurCalculator[] Sum1Array = m_sum1.Array;
            RecursizeBlurCalculator[] Sum2Array = m_sum2.Array;
            RGBA_Bytes[] BufferArray = m_buf.Array;

            for (int i = StartCreatingAt; i < w; i++)
            {
                Sum1Array[i] = m_RecursizeBlurCalculatorFactory.CreateNew();
                Sum2Array[i] = m_RecursizeBlurCalculatorFactory.CreateNew();
            }

            for (y = 0; y < h; y++)
            {
                RecursizeBlurCalculator c = m_RecursizeBlurCalculatorFactory;
                c.from_pix(img.GetPixel(0, y));
                Sum1Array[0].calc(b, b1, b2, b3, c, c, c, c);
                c.from_pix(img.GetPixel(1, y));
                Sum1Array[1].calc(b, b1, b2, b3, c, Sum1Array[0], Sum1Array[0], Sum1Array[0]);
                c.from_pix(img.GetPixel(2, y));
                Sum1Array[2].calc(b, b1, b2, b3, c, Sum1Array[1], Sum1Array[0], Sum1Array[0]);

                for (x = 3; x < w; ++x)
                {
                    c.from_pix(img.GetPixel(x, y));
                    Sum1Array[x].calc(b, b1, b2, b3, c, Sum1Array[x - 1], Sum1Array[x - 2], Sum1Array[x - 3]);
                }

                Sum2Array[wm].calc(b, b1, b2, b3, Sum1Array[wm], Sum1Array[wm], Sum1Array[wm], Sum1Array[wm]);
                Sum2Array[wm - 1].calc(b, b1, b2, b3, Sum1Array[wm - 1], Sum2Array[wm], Sum2Array[wm], Sum2Array[wm]);
                Sum2Array[wm - 2].calc(b, b1, b2, b3, Sum1Array[wm - 2], Sum2Array[wm - 1], Sum2Array[wm], Sum2Array[wm]);
                Sum2Array[wm].to_pix(ref BufferArray[wm]);
                Sum2Array[wm - 1].to_pix(ref BufferArray[wm - 1]);
                Sum2Array[wm - 2].to_pix(ref BufferArray[wm - 2]);

                for (x = wm - 3; x >= 0; --x)
                {
                    Sum2Array[x].calc(b, b1, b2, b3, Sum1Array[x], Sum2Array[x + 1], Sum2Array[x + 2], Sum2Array[x + 3]);
                    Sum2Array[x].to_pix(ref BufferArray[x]);
                }

                img.copy_color_hspan(0, y, w, BufferArray, 0);
            }
        }

        public void blur_y(IImageByte img, double radius)
        {
            FormatTransposer img2 = new FormatTransposer(img);
            blur_x(img2, radius);
        }

        public void blur(IImageByte img, double radius)
        {
            blur_x(img, radius);
            blur_y(img, radius);
        }
    };

    //=================================================recursive_blur_calc_rgb
    public sealed class recursive_blur_calc_rgb : RecursizeBlurCalculator
    {
        public override RecursizeBlurCalculator CreateNew()
        {
            return new recursive_blur_calc_rgb();
        }

        public override void from_pix(RGBA_Bytes c)
        {
            r = c.red;
            g = c.green;
            b = c.blue;
        }

        public override void calc(double b1, double b2, double b3, double b4,
            RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4)
        {
            r = b1 * c1.r + b2 * c2.r + b3 * c3.r + b4 * c4.r;
            g = b1 * c1.g + b2 * c2.g + b3 * c3.g + b4 * c4.g;
            b = b1 * c1.b + b2 * c2.b + b3 * c3.b + b4 * c4.b;
        }

        public override void to_pix(ref RGBA_Bytes c)
        {
            c.red = (byte)agg_basics.uround(r);
            c.green = (byte)agg_basics.uround(g);
            c.blue = (byte)agg_basics.uround(b);
        }
    };

    //=================================================recursive_blur_calc_rgba
    public sealed class recursive_blur_calc_rgba : RecursizeBlurCalculator
    {
        public override RecursizeBlurCalculator CreateNew()
        {
            return new recursive_blur_calc_rgba();
        }

        public override void from_pix(RGBA_Bytes c)
        {
            r = c.red;
            g = c.green;
            b = c.blue;
            a = c.alpha;
        }

        public override void calc(double b1, double b2, double b3, double b4,
            RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4)
        {
            r = b1 * c1.r + b2 * c2.r + b3 * c3.r + b4 * c4.r;
            g = b1 * c1.g + b2 * c2.g + b3 * c3.g + b4 * c4.g;
            b = b1 * c1.b + b2 * c2.b + b3 * c3.b + b4 * c4.b;
            a = b1 * c1.a + b2 * c2.a + b3 * c3.a + b4 * c4.a;
        }

        public override void to_pix(ref RGBA_Bytes c)
        {
            c.red = (byte)agg_basics.uround(r);
            c.green = (byte)agg_basics.uround(g);
            c.blue = (byte)agg_basics.uround(b);
            c.alpha = (byte)agg_basics.uround(a);
        }
    };

    //================================================recursive_blur_calc_gray
    public sealed class recursive_blur_calc_gray : RecursizeBlurCalculator
    {
        public override RecursizeBlurCalculator CreateNew()
        {
            return new recursive_blur_calc_gray();
        }

        public override void from_pix(RGBA_Bytes c)
        {
            r = c.red;
        }

        public override void calc(double b1, double b2, double b3, double b4,
            RecursizeBlurCalculator c1, RecursizeBlurCalculator c2, RecursizeBlurCalculator c3, RecursizeBlurCalculator c4)
        {
            r = b1 * c1.r + b2 * c2.r + b3 * c3.r + b4 * c4.r;
        }

        public override void to_pix(ref RGBA_Bytes c)
        {
            c.red = (byte)agg_basics.uround(r);
        }
    };
}

#endregion //RecursiveBlur.cs
#region rgb.cs


//----------------------------------------------------------------------------
//
// Adaptation for high precision colors has been sponsored by 
// Liberty Technology Systems, Inc., visit http://lib-sys.com
//
// Liberty Technology Systems, Inc. is the provider of
// PostScript and PDF technology for software developers.
// 
//----------------------------------------------------------------------------
//using System;
//using MatterHackers.Agg;

namespace MatterHackers.Agg.Image
{
    /*
        //=========================================================multiplier_rgba
        template<class ColorT, class Order> struct multiplier_rgba
        {
            typedef typename ColorT::value_type value_type;
            typedef typename ColorT::calc_type calc_type;

            //--------------------------------------------------------------------
            static void premultiply(value_type* p)
            {
                calc_type a = p[Order::A];
                if(a < ColorT::base_mask)
                {
                    if(a == 0)
                    {
                        p[Order::R] = p[Order::G] = p[Order::B] = 0;
                        return;
                    }
                    p[Order::R] = value_type((p[Order::R] * a + ColorT::base_mask) >> ColorT::base_shift);
                    p[Order::G] = value_type((p[Order::G] * a + ColorT::base_mask) >> ColorT::base_shift);
                    p[Order::B] = value_type((p[Order::B] * a + ColorT::base_mask) >> ColorT::base_shift);
                }
            }


            //--------------------------------------------------------------------
            static void demultiply(value_type* p)
            {
                calc_type a = p[Order::A];
                if(a < ColorT::base_mask)
                {
                    if(a == 0)
                    {
                        p[Order::R] = p[Order::G] = p[Order::B] = 0;
                        return;
                    }
                    calc_type r = (calc_type(p[Order::R]) * ColorT::base_mask) / a;
                    calc_type g = (calc_type(p[Order::G]) * ColorT::base_mask) / a;
                    calc_type b = (calc_type(p[Order::B]) * ColorT::base_mask) / a;
                    p[Order::R] = value_type((r > ColorT::base_mask) ? ColorT::base_mask : r);
                    p[Order::G] = value_type((g > ColorT::base_mask) ? ColorT::base_mask : g);
                    p[Order::B] = value_type((b > ColorT::base_mask) ? ColorT::base_mask : b);
                }
            }
        };

        //=====================================================apply_gamma_dir_rgba
        template<class ColorT, class Order, class GammaLut> class apply_gamma_dir_rgba
        {
        public:
            typedef typename ColorT::value_type value_type;

            apply_gamma_dir_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

            void operator () (value_type* p)
            {
                p[Order::R] = m_gamma.dir(p[Order::R]);
                p[Order::G] = m_gamma.dir(p[Order::G]);
                p[Order::B] = m_gamma.dir(p[Order::B]);
            }

        private:
            const GammaLut& m_gamma;
        };

        //=====================================================apply_gamma_inv_rgba
        template<class ColorT, class Order, class GammaLut> class apply_gamma_inv_rgba
        {
        public:
            typedef typename ColorT::value_type value_type;

            apply_gamma_inv_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

            void operator () (value_type* p)
            {
                p[Order::R] = m_gamma.inv(p[Order::R]);
                p[Order::G] = m_gamma.inv(p[Order::G]);
                p[Order::B] = m_gamma.inv(p[Order::B]);
            }

        private:
            const GammaLut& m_gamma;
        };

       //=============================================================blender_rgba
        template<class ColorT, class Order> struct blender_rgba
        {
            typedef ColorT color_type;
            typedef Order order_type;
            typedef typename color_type::value_type value_type;
            typedef typename color_type::calc_type calc_type;
            enum base_scale_e 
            { 
                base_shift = color_type::base_shift,
                base_mask  = color_type::base_mask
            };

            //--------------------------------------------------------------------
            static void blend_pix(value_type* p, 
                                             int cr, int cg, int cb,
                                             int alpha, 
                                             int cover=0)
            {
                calc_type r = p[Order::R];
                calc_type g = p[Order::G];
                calc_type b = p[Order::B];
                calc_type a = p[Order::A];
                p[Order::R] = (value_type)(((cr - r) * alpha + (r << base_shift)) >> base_shift);
                p[Order::G] = (value_type)(((cg - g) * alpha + (g << base_shift)) >> base_shift);
                p[Order::B] = (value_type)(((cb - b) * alpha + (b << base_shift)) >> base_shift);
                p[Order::A] = (value_type)((alpha + a) - ((alpha * a + base_mask) >> base_shift));
            }
        };
     */
    public class BlenderBaseBGR
    {
        public int NumPixelBits { get { return 24; } }
        public const byte base_mask = 255;
    };

    public sealed class BlenderBGR : BlenderBaseBGR, IRecieveBlenderByte
    {
        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], 255);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                bufferOffset += 3;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            unchecked
            {
                int r = buffer[bufferOffset + ImageBuffer.OrderR];
                int g = buffer[bufferOffset + ImageBuffer.OrderG];
                int b = buffer[bufferOffset + ImageBuffer.OrderB];
                buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
            }
        }

        public void BlendPixels(byte[] destBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                int cover = covers[coversIndex];
                if (cover == 255)
                {
                    do
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
                        bufferOffset += 3;
                    }
                    while (--count != 0);
                }
                else
                {
                    do
                    {
                        sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                        bufferOffset += 3;
                        ++sourceColorsOffset;
                    }
                    while (--count != 0);
                }
            }
            else
            {
                do
                {
                    int cover = covers[coversIndex++];
                    if (cover == 255)
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                    }
                    else
                    {
                        RGBA_Bytes color = sourceColors[sourceColorsOffset];
                        color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, color);
                    }
                    bufferOffset += 3;
                    ++sourceColorsOffset;
                }
                while (--count != 0);
            }
        }
    };

    public sealed class BlenderGammaBGR : BlenderBaseBGR, IRecieveBlenderByte
    {
        private GammaLookUpTable m_gamma;

        public BlenderGammaBGR()
        {
            m_gamma = new GammaLookUpTable();
        }

        public BlenderGammaBGR(GammaLookUpTable g)
        {
            m_gamma = g;
        }

        public void gamma(GammaLookUpTable g)
        {
            m_gamma = g;
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], 255);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv(sourceColor.red);
            buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv(sourceColor.green);
            buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv(sourceColor.blue);
        }

        public void BlendPixel(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            unchecked
            {
                int r = buffer[bufferOffset + ImageBuffer.OrderR];
                int g = buffer[bufferOffset + ImageBuffer.OrderG];
                int b = buffer[bufferOffset + ImageBuffer.OrderB];
                buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv((byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift));
                buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv((byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift));
                buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv((byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift));
            }
        }

        public void BlendPixels(byte[] buffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
        {
            throw new NotImplementedException();
        }
    };

    public sealed class BlenderPreMultBGR : BlenderBaseBGR, IRecieveBlenderByte
    {
        static int[] m_Saturate9BitToByte = new int[1 << 9];

        public BlenderPreMultBGR()
        {
            if (m_Saturate9BitToByte[2] == 0)
            {
                for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
                {
                    m_Saturate9BitToByte[i] = Math.Min(i, 255);
                }
            }
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], 255);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                bufferOffset += 3;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            if (sourceColor.alpha == 255)
            {
                pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
            }
            else
            {
                int OneOverAlpha = base_mask - sourceColor.alpha;
                unchecked
                {
                    int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                    int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                    int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                }
            }
        }

        public void BlendPixels(byte[] destBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                int cover = covers[coversIndex];
                if (cover == 255)
                {
                    do
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
                        bufferOffset += 3;
                    }
                    while (--count != 0);
                }
                else
                {
                    do
                    {
                        sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                        bufferOffset += 3;
                        ++sourceColorsOffset;
                    }
                    while (--count != 0);
                }
            }
            else
            {
                do
                {
                    int cover = covers[coversIndex++];
                    if (cover == 255)
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                    }
                    else
                    {
                        RGBA_Bytes color = sourceColors[sourceColorsOffset];
                        color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, color);
                    }
                    bufferOffset += 3;
                    ++sourceColorsOffset;
                }
                while (--count != 0);
            }
        }
    };
    /*
//======================================================blender_rgba_plain
template<class ColorT, class Order> struct blender_rgba_plain
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e { base_shift = color_type::base_shift };

    //--------------------------------------------------------------------
    static void blend_pix(value_type* p, 
                                     int cr, int cg, int cb,
                                     int alpha,
                                     int cover=0)
    {
        if(alpha == 0) return;
        calc_type a = p[Order::A];
        calc_type r = p[Order::R] * a;
        calc_type g = p[Order::G] * a;
        calc_type b = p[Order::B] * a;
        a = ((alpha + a) << base_shift) - alpha * a;
        p[Order::A] = (value_type)(a >> base_shift);
        p[Order::R] = (value_type)((((cr << base_shift) - r) * alpha + (r << base_shift)) / a);
        p[Order::G] = (value_type)((((cg << base_shift) - g) * alpha + (g << base_shift)) / a);
        p[Order::B] = (value_type)((((cb << base_shift) - b) * alpha + (b << base_shift)) / a);
    }
};

//=========================================================comp_op_rgba_clear
template<class ColorT, class Order> struct comp_op_rgba_clear
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    static void blend_pix(value_type* p, 
                                     int, int, int, int,
                                     int cover)
    {
        if(cover < 255)
        {
            cover = 255 - cover;
            p[Order::R] = (value_type)((p[Order::R] * cover + 255) >> rgba8.base_shift);
            p[Order::G] = (value_type)((p[Order::G] * cover + 255) >> rgba8.base_shift);
            p[Order::B] = (value_type)((p[Order::B] * cover + 255) >> rgba8.base_shift);
            p[Order::A] = (value_type)((p[Order::A] * cover + 255) >> rgba8.base_shift);
        }
        else
        {
            p[0] = p[1] = p[2] = p[3] = 0; 
        }
    }
};

//===========================================================comp_op_rgba_src
template<class ColorT, class Order> struct comp_op_rgba_src
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;

    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            int alpha = 255 - cover;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));
        }
        else
        {
            p[Order::R] = sr;
            p[Order::G] = sg;
            p[Order::B] = sb;
            p[Order::A] = sa;
        }
    }
};

//===========================================================comp_op_rgba_dst
template<class ColorT, class Order> struct comp_op_rgba_dst
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;

    static void blend_pix(value_type*, 
                                     int, int, int, 
                                     int, int)
    {
    }
};

//======================================================comp_op_rgba_src_over
template<class ColorT, class Order> struct comp_op_rgba_src_over
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    //   Dca' = Sca + Dca.(1 - Sa)
    //   Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        calc_type s1a = base_mask - sa;
        p[Order::R] = (value_type)(sr + ((p[Order::R] * s1a + base_mask) >> base_shift));
        p[Order::G] = (value_type)(sg + ((p[Order::G] * s1a + base_mask) >> base_shift));
        p[Order::B] = (value_type)(sb + ((p[Order::B] * s1a + base_mask) >> base_shift));
        p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
    }
};

//======================================================comp_op_rgba_dst_over
template<class ColorT, class Order> struct comp_op_rgba_dst_over
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca + Sca.(1 - Da)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        calc_type d1a = base_mask - p[Order::A];
        p[Order::R] = (value_type)(p[Order::R] + ((sr * d1a + base_mask) >> base_shift));
        p[Order::G] = (value_type)(p[Order::G] + ((sg * d1a + base_mask) >> base_shift));
        p[Order::B] = (value_type)(p[Order::B] + ((sb * d1a + base_mask) >> base_shift));
        p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
    }
};

//======================================================comp_op_rgba_src_in
template<class ColorT, class Order> struct comp_op_rgba_src_in
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.Da
    // Da'  = Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        calc_type da = p[Order::A];
        if(cover < 255)
        {
            int alpha = 255 - cover;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
        }
        else
        {
            p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
            p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
        }
    }
};

//======================================================comp_op_rgba_dst_in
template<class ColorT, class Order> struct comp_op_rgba_dst_in
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca.Sa
    // Da'  = Sa.Da 
    static void blend_pix(value_type* p, 
                                     int, int, int, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sa = base_mask - ((cover * (base_mask - sa) + 255) >> 8);
        }
        p[Order::R] = (value_type)((p[Order::R] * sa + base_mask) >> base_shift);
        p[Order::G] = (value_type)((p[Order::G] * sa + base_mask) >> base_shift);
        p[Order::B] = (value_type)((p[Order::B] * sa + base_mask) >> base_shift);
        p[Order::A] = (value_type)((p[Order::A] * sa + base_mask) >> base_shift);
    }
};

//======================================================comp_op_rgba_src_out
template<class ColorT, class Order> struct comp_op_rgba_src_out
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.(1 - Da)
    // Da'  = Sa.(1 - Da) 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        calc_type da = base_mask - p[Order::A];
        if(cover < 255)
        {
            int alpha = 255 - cover;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
        }
        else
        {
            p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
            p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
        }
    }
};

//======================================================comp_op_rgba_dst_out
template<class ColorT, class Order> struct comp_op_rgba_dst_out
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca.(1 - Sa) 
    // Da'  = Da.(1 - Sa) 
    static void blend_pix(value_type* p, 
                                     int, int, int, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sa = (sa * cover + 255) >> 8;
        }
        sa = base_mask - sa;
        p[Order::R] = (value_type)((p[Order::R] * sa + base_shift) >> base_shift);
        p[Order::G] = (value_type)((p[Order::G] * sa + base_shift) >> base_shift);
        p[Order::B] = (value_type)((p[Order::B] * sa + base_shift) >> base_shift);
        p[Order::A] = (value_type)((p[Order::A] * sa + base_shift) >> base_shift);
    }
};

//=====================================================comp_op_rgba_src_atop
template<class ColorT, class Order> struct comp_op_rgba_src_atop
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.Da + Dca.(1 - Sa)
    // Da'  = Da
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        calc_type da = p[Order::A];
        sa = base_mask - sa;
        p[Order::R] = (value_type)((sr * da + p[Order::R] * sa + base_mask) >> base_shift);
        p[Order::G] = (value_type)((sg * da + p[Order::G] * sa + base_mask) >> base_shift);
        p[Order::B] = (value_type)((sb * da + p[Order::B] * sa + base_mask) >> base_shift);
    }
};

//=====================================================comp_op_rgba_dst_atop
template<class ColorT, class Order> struct comp_op_rgba_dst_atop
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca.Sa + Sca.(1 - Da)
    // Da'  = Sa 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        calc_type da = base_mask - p[Order::A];
        if(cover < 255)
        {
            int alpha = 255 - cover;
            sr = (p[Order::R] * sa + sr * da + base_mask) >> base_shift;
            sg = (p[Order::G] * sa + sg * da + base_mask) >> base_shift;
            sb = (p[Order::B] * sa + sb * da + base_mask) >> base_shift;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));

        }
        else
        {
            p[Order::R] = (value_type)((p[Order::R] * sa + sr * da + base_mask) >> base_shift);
            p[Order::G] = (value_type)((p[Order::G] * sa + sg * da + base_mask) >> base_shift);
            p[Order::B] = (value_type)((p[Order::B] * sa + sb * da + base_mask) >> base_shift);
            p[Order::A] = (value_type)sa;
        }
    }
};

//=========================================================comp_op_rgba_xor
template<class ColorT, class Order> struct comp_op_rgba_xor
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - 2.Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type s1a = base_mask - sa;
            calc_type d1a = base_mask - p[Order::A];
            p[Order::R] = (value_type)((p[Order::R] * s1a + sr * d1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((p[Order::G] * s1a + sg * d1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((p[Order::B] * s1a + sb * d1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask/2) >> (base_shift - 1)));
        }
    }
};

//=========================================================comp_op_rgba_plus
template<class ColorT, class Order> struct comp_op_rgba_plus
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca + Dca
    // Da'  = Sa + Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R] + sr;
            calc_type dg = p[Order::G] + sg;
            calc_type db = p[Order::B] + sb;
            calc_type da = p[Order::A] + sa;
            p[Order::R] = (dr > base_mask) ? (value_type)base_mask : dr;
            p[Order::G] = (dg > base_mask) ? (value_type)base_mask : dg;
            p[Order::B] = (db > base_mask) ? (value_type)base_mask : db;
            p[Order::A] = (da > base_mask) ? (value_type)base_mask : da;
        }
    }
};

//========================================================comp_op_rgba_minus
template<class ColorT, class Order> struct comp_op_rgba_minus
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca - Sca
    // Da' = 1 - (1 - Sa).(1 - Da)
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R] - sr;
            calc_type dg = p[Order::G] - sg;
            calc_type db = p[Order::B] - sb;
            p[Order::R] = (dr > base_mask) ? 0 : dr;
            p[Order::G] = (dg > base_mask) ? 0 : dg;
            p[Order::B] = (db > base_mask) ? 0 : db;
            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
            //p[Order::A] = (value_type)(base_mask - (((base_mask - sa) * (base_mask - p[Order::A]) + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_multiply
template<class ColorT, class Order> struct comp_op_rgba_multiply
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type s1a = base_mask - sa;
            calc_type d1a = base_mask - p[Order::A];
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            p[Order::R] = (value_type)((sr * dr + sr * d1a + dr * s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg * dg + sg * d1a + dg * s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb * db + sb * d1a + db * s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_screen
template<class ColorT, class Order> struct comp_op_rgba_screen
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca + Dca - Sca.Dca
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            calc_type da = p[Order::A];
            p[Order::R] = (value_type)(sr + dr - ((sr * dr + base_mask) >> base_shift));
            p[Order::G] = (value_type)(sg + dg - ((sg * dg + base_mask) >> base_shift));
            p[Order::B] = (value_type)(sb + db - ((sb * db + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_overlay
template<class ColorT, class Order> struct comp_op_rgba_overlay
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if 2.Dca < Da
    //   Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da' = Sa + Da - Sa.Da
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            calc_type sada = sa * p[Order::A];

            p[Order::R] = (value_type)(((2*dr < da) ? 
                2*sr*dr + sr*d1a + dr*s1a : 
                sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

            p[Order::G] = (value_type)(((2*dg < da) ? 
                2*sg*dg + sg*d1a + dg*s1a : 
                sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

            p[Order::B] = (value_type)(((2*db < da) ? 
                2*sb*db + sb*d1a + db*s1a : 
                sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};


template<class T> inline T sd_min(T a, T b) { return (a < b) ? a : b; }
template<class T> inline T sd_max(T a, T b) { return (a > b) ? a : b; }

//=====================================================comp_op_rgba_darken
template<class ColorT, class Order> struct comp_op_rgba_darken
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = min(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a = base_mask - p[Order::A];
            calc_type s1a = base_mask - sa;
            calc_type dr  = p[Order::R];
            calc_type dg  = p[Order::G];
            calc_type db  = p[Order::B];
            calc_type da  = p[Order::A];

            p[Order::R] = (value_type)((sd_min(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sd_min(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sd_min(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_lighten
template<class ColorT, class Order> struct comp_op_rgba_lighten
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = max(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a = base_mask - p[Order::A];
            calc_type s1a = base_mask - sa;
            calc_type dr  = p[Order::R];
            calc_type dg  = p[Order::G];
            calc_type db  = p[Order::B];
            calc_type da  = p[Order::A];

            p[Order::R] = (value_type)((sd_max(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sd_max(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sd_max(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_color_dodge
template<class ColorT, class Order> struct comp_op_rgba_color_dodge
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if Sca.Da + Dca.Sa >= Sa.Da
    //   Dca' = Sa.Da + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = Dca.Sa/(1-Sca/Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
    //
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            long_type drsa = dr * sa;
            long_type dgsa = dg * sa;
            long_type dbsa = db * sa;
            long_type srda = sr * da;
            long_type sgda = sg * da;
            long_type sbda = sb * da;
            long_type sada = sa * da;

            p[Order::R] = (value_type)((srda + drsa >= sada) ? 
                (sada + sr * d1a + dr * s1a + base_mask) >> base_shift :
                drsa / (base_mask - (sr << base_shift) / sa) + ((sr * d1a + dr * s1a + base_mask) >> base_shift));

            p[Order::G] = (value_type)((sgda + dgsa >= sada) ? 
                (sada + sg * d1a + dg * s1a + base_mask) >> base_shift :
                dgsa / (base_mask - (sg << base_shift) / sa) + ((sg * d1a + dg * s1a + base_mask) >> base_shift));

            p[Order::B] = (value_type)((sbda + dbsa >= sada) ? 
                (sada + sb * d1a + db * s1a + base_mask) >> base_shift :
                dbsa / (base_mask - (sb << base_shift) / sa) + ((sb * d1a + db * s1a + base_mask) >> base_shift));

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_color_burn
template<class ColorT, class Order> struct comp_op_rgba_color_burn
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if Sca.Da + Dca.Sa <= Sa.Da
    //   Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = Sa.(Sca.Da + Dca.Sa - Sa.Da)/Sca + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            long_type drsa = dr * sa;
            long_type dgsa = dg * sa;
            long_type dbsa = db * sa;
            long_type srda = sr * da;
            long_type sgda = sg * da;
            long_type sbda = sb * da;
            long_type sada = sa * da;

            p[Order::R] = (value_type)(((srda + drsa <= sada) ? 
                sr * d1a + dr * s1a :
                sa * (srda + drsa - sada) / sr + sr * d1a + dr * s1a + base_mask) >> base_shift);

            p[Order::G] = (value_type)(((sgda + dgsa <= sada) ? 
                sg * d1a + dg * s1a :
                sa * (sgda + dgsa - sada) / sg + sg * d1a + dg * s1a + base_mask) >> base_shift);

            p[Order::B] = (value_type)(((sbda + dbsa <= sada) ? 
                sb * d1a + db * s1a :
                sa * (sbda + dbsa - sada) / sb + sb * d1a + db * s1a + base_mask) >> base_shift);

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_hard_light
template<class ColorT, class Order> struct comp_op_rgba_hard_light
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if 2.Sca < Sa
    //    Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //    Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da'  = Sa + Da - Sa.Da
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            calc_type sada = sa * da;

            p[Order::R] = (value_type)(((2*sr < sa) ? 
                2*sr*dr + sr*d1a + dr*s1a : 
                sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

            p[Order::G] = (value_type)(((2*sg < sa) ? 
                2*sg*dg + sg*d1a + dg*s1a : 
                sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

            p[Order::B] = (value_type)(((2*sb < sa) ? 
                2*sb*db + sb*d1a + db*s1a : 
                sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_soft_light
template<class ColorT, class Order> struct comp_op_rgba_soft_light
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if 2.Sca < Sa
    //   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise if 8.Dca <= Da
    //   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa).(3 - 8.Dca/Da)) + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = (Dca.Sa + ((Dca/Da)^(0.5).Da - Dca).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da'  = Sa + Da - Sa.Da 

    static void blend_pix(value_type* p, 
                                     int r, int g, int b, 
                                     int a, int cover)
    {
        double sr = double(r * cover) / (base_mask * 255);
        double sg = double(g * cover) / (base_mask * 255);
        double sb = double(b * cover) / (base_mask * 255);
        double sa = double(a * cover) / (base_mask * 255);
        if(sa > 0)
        {
            double dr = double(p[Order::R]) / base_mask;
            double dg = double(p[Order::G]) / base_mask;
            double db = double(p[Order::B]) / base_mask;
            double da = double(p[Order::A] ? p[Order::A] : 1) / base_mask;
            if(cover < 255)
            {
                a = (a * cover + 255) >> 8;
            }

            if(2*sr < sa)       dr = dr*(sa + (1 - dr/da)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
            else if(8*dr <= da) dr = dr*(sa + (1 - dr/da)*(2*sr - sa)*(3 - 8*dr/da)) + sr*(1 - da) + dr*(1 - sa);
            else                dr = (dr*sa + (sqrt(dr/da)*da - dr)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);

            if(2*sg < sa)       dg = dg*(sa + (1 - dg/da)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
            else if(8*dg <= da) dg = dg*(sa + (1 - dg/da)*(2*sg - sa)*(3 - 8*dg/da)) + sg*(1 - da) + dg*(1 - sa);
            else                dg = (dg*sa + (sqrt(dg/da)*da - dg)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);

            if(2*sb < sa)       db = db*(sa + (1 - db/da)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
            else if(8*db <= da) db = db*(sa + (1 - db/da)*(2*sb - sa)*(3 - 8*db/da)) + sb*(1 - da) + db*(1 - sa);
            else                db = (db*sa + (sqrt(db/da)*da - db)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);

            p[Order::R] = (value_type)uround(dr * base_mask);
            p[Order::G] = (value_type)uround(dg * base_mask);
            p[Order::B] = (value_type)uround(db * base_mask);
            p[Order::A] = (value_type)(a + p[Order::A] - ((a * p[Order::A] + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_difference
template<class ColorT, class Order> struct comp_op_rgba_difference
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_scale = color_type::base_scale,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca + Dca - 2.min(Sca.Da, Dca.Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            calc_type da = p[Order::A];
            p[Order::R] = (value_type)(sr + dr - ((2 * sd_min(sr*da, dr*sa) + base_mask) >> base_shift));
            p[Order::G] = (value_type)(sg + dg - ((2 * sd_min(sg*da, dg*sa) + base_mask) >> base_shift));
            p[Order::B] = (value_type)(sb + db - ((2 * sd_min(sb*da, db*sa) + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_exclusion
template<class ColorT, class Order> struct comp_op_rgba_exclusion
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a = base_mask - p[Order::A];
            calc_type s1a = base_mask - sa;
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            calc_type da = p[Order::A];
            p[Order::R] = (value_type)((sr*da + dr*sa - 2*sr*dr + sr*d1a + dr*s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg*da + dg*sa - 2*sg*dg + sg*d1a + dg*s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb*da + db*sa - 2*sb*db + sb*d1a + db*s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_contrast
template<class ColorT, class Order> struct comp_op_rgba_contrast
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };


    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        long_type dr = p[Order::R];
        long_type dg = p[Order::G];
        long_type db = p[Order::B];
        int       da = p[Order::A];
        long_type d2a = da >> 1;
        int s2a = sa >> 1;

        int r = (int)((((dr - d2a) * int((sr - s2a)*2 + base_mask)) >> base_shift) + d2a); 
        int g = (int)((((dg - d2a) * int((sg - s2a)*2 + base_mask)) >> base_shift) + d2a); 
        int b = (int)((((db - d2a) * int((sb - s2a)*2 + base_mask)) >> base_shift) + d2a); 

        r = (r < 0) ? 0 : r;
        g = (g < 0) ? 0 : g;
        b = (b < 0) ? 0 : b;

        p[Order::R] = (value_type)((r > da) ? da : r);
        p[Order::G] = (value_type)((g > da) ? da : g);
        p[Order::B] = (value_type)((b > da) ? da : b);
    }
};

//=====================================================comp_op_rgba_invert
template<class ColorT, class Order> struct comp_op_rgba_invert
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = (Da - Dca) * Sa + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        sa = (sa * cover + 255) >> 8;
        if(sa)
        {
            calc_type da = p[Order::A];
            calc_type dr = ((da - p[Order::R]) * sa + base_mask) >> base_shift;
            calc_type dg = ((da - p[Order::G]) * sa + base_mask) >> base_shift;
            calc_type db = ((da - p[Order::B]) * sa + base_mask) >> base_shift;
            calc_type s1a = base_mask - sa;
            p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
            p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
            p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=================================================comp_op_rgba_invert_rgb
template<class ColorT, class Order> struct comp_op_rgba_invert_rgb
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = (Da - Dca) * Sca + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type da = p[Order::A];
            calc_type dr = ((da - p[Order::R]) * sr + base_mask) >> base_shift;
            calc_type dg = ((da - p[Order::G]) * sg + base_mask) >> base_shift;
            calc_type db = ((da - p[Order::B]) * sb + base_mask) >> base_shift;
            calc_type s1a = base_mask - sa;
            p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
            p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
            p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};


     * //======================================================comp_op_table_rgba
template<class ColorT, class Order> struct comp_op_table_rgba
{
    typedef typename ColorT::value_type value_type;
    typedef void (*comp_op_func_type)(value_type* p, 
                                      int cr, 
                                      int cg, 
                                      int cb,
                                      int ca,
                                      int cover);
    static comp_op_func_type g_comp_op_func[];
};

//==========================================================g_comp_op_func
template<class ColorT, class Order> 
typename comp_op_table_rgba<ColorT, Order>::comp_op_func_type
comp_op_table_rgba<ColorT, Order>::g_comp_op_func[] = 
{
    comp_op_rgba_clear      <ColorT,Order>::blend_pix,
    comp_op_rgba_src        <ColorT,Order>::blend_pix,
    comp_op_rgba_dst        <ColorT,Order>::blend_pix,
    comp_op_rgba_src_over   <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_over   <ColorT,Order>::blend_pix,
    comp_op_rgba_src_in     <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_in     <ColorT,Order>::blend_pix,
    comp_op_rgba_src_out    <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_out    <ColorT,Order>::blend_pix,
    comp_op_rgba_src_atop   <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_atop   <ColorT,Order>::blend_pix,
    comp_op_rgba_xor        <ColorT,Order>::blend_pix,
    comp_op_rgba_plus       <ColorT,Order>::blend_pix,
    comp_op_rgba_minus      <ColorT,Order>::blend_pix,
    comp_op_rgba_multiply   <ColorT,Order>::blend_pix,
    comp_op_rgba_screen     <ColorT,Order>::blend_pix,
    comp_op_rgba_overlay    <ColorT,Order>::blend_pix,
    comp_op_rgba_darken     <ColorT,Order>::blend_pix,
    comp_op_rgba_lighten    <ColorT,Order>::blend_pix,
    comp_op_rgba_color_dodge<ColorT,Order>::blend_pix,
    comp_op_rgba_color_burn <ColorT,Order>::blend_pix,
    comp_op_rgba_hard_light <ColorT,Order>::blend_pix,
    comp_op_rgba_soft_light <ColorT,Order>::blend_pix,
    comp_op_rgba_difference <ColorT,Order>::blend_pix,
    comp_op_rgba_exclusion  <ColorT,Order>::blend_pix,
    comp_op_rgba_contrast   <ColorT,Order>::blend_pix,
    comp_op_rgba_invert     <ColorT,Order>::blend_pix,
    comp_op_rgba_invert_rgb <ColorT,Order>::blend_pix,
    0
};


//==============================================================comp_op_e
enum comp_op_e
{
    comp_op_clear,         //----comp_op_clear
    comp_op_src,           //----comp_op_src
    comp_op_dst,           //----comp_op_dst
    comp_op_src_over,      //----comp_op_src_over
    comp_op_dst_over,      //----comp_op_dst_over
    comp_op_src_in,        //----comp_op_src_in
    comp_op_dst_in,        //----comp_op_dst_in
    comp_op_src_out,       //----comp_op_src_out
    comp_op_dst_out,       //----comp_op_dst_out
    comp_op_src_atop,      //----comp_op_src_atop
    comp_op_dst_atop,      //----comp_op_dst_atop
    comp_op_xor,           //----comp_op_xor
    comp_op_plus,          //----comp_op_plus
    comp_op_minus,         //----comp_op_minus
    comp_op_multiply,      //----comp_op_multiply
    comp_op_screen,        //----comp_op_screen
    comp_op_overlay,       //----comp_op_overlay
    comp_op_darken,        //----comp_op_darken
    comp_op_lighten,       //----comp_op_lighten
    comp_op_color_dodge,   //----comp_op_color_dodge
    comp_op_color_burn,    //----comp_op_color_burn
    comp_op_hard_light,    //----comp_op_hard_light
    comp_op_soft_light,    //----comp_op_soft_light
    comp_op_difference,    //----comp_op_difference
    comp_op_exclusion,     //----comp_op_exclusion
    comp_op_contrast,      //----comp_op_contrast
    comp_op_invert,        //----comp_op_invert
    comp_op_invert_rgb,    //----comp_op_invert_rgb

    end_of_comp_op_e
};







//====================================================comp_op_adaptor_rgba
template<class ColorT, class Order> struct comp_op_adaptor_rgba
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
            (p, (cr * ca + base_mask) >> base_shift, 
                (cg * ca + base_mask) >> base_shift,
                (cb * ca + base_mask) >> base_shift,
                 ca, cover);
    }
};

//=========================================comp_op_adaptor_clip_to_dst_rgba
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        cr = (cr * ca + base_mask) >> base_shift;
        cg = (cg * ca + base_mask) >> base_shift;
        cb = (cb * ca + base_mask) >> base_shift;
        int da = p[Order::A];
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
            (p, (cr * da + base_mask) >> base_shift, 
                (cg * da + base_mask) >> base_shift, 
                (cb * da + base_mask) >> base_shift, 
                (ca * da + base_mask) >> base_shift, 
                cover);
    }
};

//================================================comp_op_adaptor_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_rgba_pre
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op](p, cr, cg, cb, ca, cover);
    }
};

//=====================================comp_op_adaptor_clip_to_dst_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba_pre
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        int da = p[Order::A];
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
            (p, (cr * da + base_mask) >> base_shift, 
                (cg * da + base_mask) >> base_shift, 
                (cb * da + base_mask) >> base_shift, 
                (ca * da + base_mask) >> base_shift, 
                cover);
    }
};

//=======================================================comp_adaptor_rgba
template<class BlenderPre> struct comp_adaptor_rgba
{
    typedef typename BlenderPre::order_type order_type;
    typedef typename BlenderPre::color_type color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        BlenderPre::blend_pix(p, 
                              (cr * ca + base_mask) >> base_shift, 
                              (cg * ca + base_mask) >> base_shift,
                              (cb * ca + base_mask) >> base_shift,
                              ca, cover);
    }
};

//==========================================comp_adaptor_clip_to_dst_rgba
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba
{
    typedef typename BlenderPre::order_type order_type;
    typedef typename BlenderPre::color_type color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        cr = (cr * ca + base_mask) >> base_shift;
        cg = (cg * ca + base_mask) >> base_shift;
        cb = (cb * ca + base_mask) >> base_shift;
        int da = p[OrderA];
        BlenderPre::blend_pix(p, 
                              (cr * da + base_mask) >> base_shift, 
                              (cg * da + base_mask) >> base_shift, 
                              (cb * da + base_mask) >> base_shift, 
                              (ca * da + base_mask) >> base_shift, 
                              cover);
    }
};

//======================================comp_adaptor_clip_to_dst_rgba_pre
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba_pre
{
    typedef typename BlenderPre::order_type order_type;
    typedef typename BlenderPre::color_type color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        int da = p[OrderA];
        BlenderPre::blend_pix(p, 
                              (cr * da + base_mask) >> base_shift, 
                              (cg * da + base_mask) >> base_shift, 
                              (cb * da + base_mask) >> base_shift, 
                              (ca * da + base_mask) >> base_shift, 
                              cover);
    }
};




*/
}


#endregion //rgb.cs
#region rgba.cs

namespace MatterHackers.Agg.Image
{
    /*
        //=========================================================multiplier_rgba
        template<class ColorT, class Order> struct multiplier_rgba
        {
            typedef typename ColorT::value_type value_type;
            typedef typename ColorT::calc_type calc_type;

            //--------------------------------------------------------------------
            static void premultiply(value_type* p)
            {
                calc_type a = p[Order::A];
                if(a < ColorT::base_mask)
                {
                    if(a == 0)
                    {
                        p[Order::R] = p[Order::G] = p[Order::B] = 0;
                        return;
                    }
                    p[Order::R] = value_type((p[Order::R] * a + ColorT::base_mask) >> ColorT::base_shift);
                    p[Order::G] = value_type((p[Order::G] * a + ColorT::base_mask) >> ColorT::base_shift);
                    p[Order::B] = value_type((p[Order::B] * a + ColorT::base_mask) >> ColorT::base_shift);
                }
            }


            //--------------------------------------------------------------------
            static void demultiply(value_type* p)
            {
                calc_type a = p[Order::A];
                if(a < ColorT::base_mask)
                {
                    if(a == 0)
                    {
                        p[Order::R] = p[Order::G] = p[Order::B] = 0;
                        return;
                    }
                    calc_type r = (calc_type(p[Order::R]) * ColorT::base_mask) / a;
                    calc_type g = (calc_type(p[Order::G]) * ColorT::base_mask) / a;
                    calc_type b = (calc_type(p[Order::B]) * ColorT::base_mask) / a;
                    p[Order::R] = value_type((r > ColorT::base_mask) ? ColorT::base_mask : r);
                    p[Order::G] = value_type((g > ColorT::base_mask) ? ColorT::base_mask : g);
                    p[Order::B] = value_type((b > ColorT::base_mask) ? ColorT::base_mask : b);
                }
            }
        };

        //=====================================================apply_gamma_dir_rgba
        template<class ColorT, class Order, class GammaLut> class apply_gamma_dir_rgba
        {
        public:
            typedef typename ColorT::value_type value_type;

            apply_gamma_dir_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

            void operator () (value_type* p)
            {
                p[Order::R] = m_gamma.dir(p[Order::R]);
                p[Order::G] = m_gamma.dir(p[Order::G]);
                p[Order::B] = m_gamma.dir(p[Order::B]);
            }

        private:
            const GammaLut& m_gamma;
        };

        //=====================================================apply_gamma_inv_rgba
        template<class ColorT, class Order, class GammaLut> class apply_gamma_inv_rgba
        {
        public:
            typedef typename ColorT::value_type value_type;

            apply_gamma_inv_rgba(const GammaLut& gamma) : m_gamma(gamma) {}

            void operator () (value_type* p)
            {
                p[Order::R] = m_gamma.inv(p[Order::R]);
                p[Order::G] = m_gamma.inv(p[Order::G]);
                p[Order::B] = m_gamma.inv(p[Order::B]);
            }

        private:
            const GammaLut& m_gamma;
        };
    

        //=============================================================blender_rgba
        template<class ColorT, class Order> struct blender_rgba
        {
            typedef ColorT color_type;
            typedef Order order_type;
            typedef typename color_type::value_type value_type;
            typedef typename color_type::calc_type calc_type;
            enum base_scale_e 
            { 
                base_shift = color_type::base_shift,
                base_mask  = color_type::base_mask
            };

            //--------------------------------------------------------------------
            static void blend_pix(value_type* p, 
                                             int cr, int cg, int cb,
                                             int alpha, 
                                             int cover=0)
            {
                calc_type r = p[Order::R];
                calc_type g = p[Order::G];
                calc_type b = p[Order::B];
                calc_type a = p[Order::A];
                p[Order::R] = (value_type)(((cr - r) * alpha + (r << base_shift)) >> base_shift);
                p[Order::G] = (value_type)(((cg - g) * alpha + (g << base_shift)) >> base_shift);
                p[Order::B] = (value_type)(((cb - b) * alpha + (b << base_shift)) >> base_shift);
                p[Order::A] = (value_type)((alpha + a) - ((alpha * a + base_mask) >> base_shift));
            }
        };
     */

    interface goodInterfaceThinking // TODO: switch to an interface more like this for blenders.
    {
        int NumPixelBits { get; }

        RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset);

        void SetPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count);
        void SetPixels(byte[] buffer, int bufferOffset, RGBA_Bytes[] sourceColors, int sourceColorsOffset, int count);

        void BlendPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count);
        void BlendPixels(byte[] buffer, int bufferOffset, RGBA_Bytes[] sourceColors, int sourceColorsOffset, int count);

        // and we need some that use coverage values
        void BlendPixels(byte[] buffer, int bufferOffset, RGBA_Bytes[] sourceColors, int sourceColorsOffset, byte sourceCover, int count);
        void BlendPixels(byte[] buffer, int bufferOffset, RGBA_Bytes[] sourceColors, int sourceColorsOffset, byte[] sourceCovers, int sourceCoversOffset, int count);
    };

    public interface IRecieveBlenderByte
    {
        int NumPixelBits { get; }

        RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset);

        void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count);

        void BlendPixel(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor);
        void BlendPixels(byte[] buffer, int bufferOffset, RGBA_Bytes[] sourceColors, int sourceColorsOffset, byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count);
    }

    public interface IRecieveBlenderFloat
    {
        int NumPixelBits { get; }

        RGBA_Floats PixelToColorRGBA_Floats(float[] buffer, int bufferOffset);
        void CopyPixels(float[] buffer, int bufferOffset, RGBA_Floats sourceColor, int count);

        void BlendPixel(float[] buffer, int bufferOffset, RGBA_Floats sourceColor);
        void BlendPixels(float[] buffer, int bufferOffset,
            RGBA_Floats[] sourceColors, int sourceColorsOffset,
            byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count);
    }

    public class BlenderBase8888
    {
        public int NumPixelBits { get { return 32; } }

        public const byte base_mask = 255;
    };

    public class BlenderBaseBGRAFloat
    {
        public int NumPixelBits { get { return 128; } }

        public const byte base_mask = 255;
    };

    public sealed class BlenderBGRA : BlenderBase8888, IRecieveBlenderByte
    {
        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
                bufferOffset += 4;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            //unsafe
            {
                unchecked
                {
                    if (sourceColor.alpha == 255)
                    {
                        buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.red);
                        buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);
                        buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.blue);
                        buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);
                    }
                    else
                    {
                        int r = buffer[bufferOffset + ImageBuffer.OrderR];
                        int g = buffer[bufferOffset + ImageBuffer.OrderG];
                        int b = buffer[bufferOffset + ImageBuffer.OrderB];
                        int a = buffer[bufferOffset + ImageBuffer.OrderA];
                        buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                        buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                        buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                        buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift));
                    }
                }
            }
        }

        public void BlendPixels(byte[] destBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                int cover = covers[coversIndex];
                if (cover == 255)
                {
                    do
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
                        bufferOffset += 4;
                    }
                    while (--count != 0);
                }
                else
                {
                    do
                    {
                        sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                        bufferOffset += 4;
                        ++sourceColorsOffset;
                    }
                    while (--count != 0);
                }
            }
            else
            {
                do
                {
                    int cover = covers[coversIndex++];
                    if (cover == 255)
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                    }
                    else
                    {
                        RGBA_Bytes color = sourceColors[sourceColorsOffset];
                        color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, color);
                    }
                    bufferOffset += 4;
                    ++sourceColorsOffset;
                }
                while (--count != 0);
            }
        }
    }

    public sealed class BlenderRGBA : BlenderBase8888, IRecieveBlenderByte
    {
        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderA]);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.blue;
                buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
                bufferOffset += 4;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            //unsafe
            {
                unchecked
                {
                    if (sourceColor.alpha == 255)
                    {
                        buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.red);
                        buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);
                        buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.blue);
                        buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);
                    }
                    else
                    {
                        int r = buffer[bufferOffset + ImageBuffer.OrderB];
                        int g = buffer[bufferOffset + ImageBuffer.OrderG];
                        int b = buffer[bufferOffset + ImageBuffer.OrderR];
                        int a = buffer[bufferOffset + ImageBuffer.OrderA];
                        buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                        buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                        buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift);
                        buffer[bufferOffset + ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift));
                    }
                }
            }
        }

        public void BlendPixels(byte[] destBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                int cover = covers[coversIndex];
                if (cover == 255)
                {
                    do
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset++]);
                        bufferOffset += 4;
                    }
                    while (--count != 0);
                }
                else
                {
                    do
                    {
                        sourceColors[sourceColorsOffset].alpha = (byte)((sourceColors[sourceColorsOffset].alpha * cover + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                        bufferOffset += 4;
                        ++sourceColorsOffset;
                    }
                    while (--count != 0);
                }
            }
            else
            {
                do
                {
                    int cover = covers[coversIndex++];
                    if (cover == 255)
                    {
                        BlendPixel(destBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                    }
                    else
                    {
                        RGBA_Bytes color = sourceColors[sourceColorsOffset];
                        color.alpha = (byte)((color.alpha * (cover) + 255) >> 8);
                        BlendPixel(destBuffer, bufferOffset, color);
                    }
                    bufferOffset += 4;
                    ++sourceColorsOffset;
                }
                while (--count != 0);
            }
        }
    }

    public sealed class BlenderBGRAFloat : BlenderBaseBGRAFloat, IRecieveBlenderFloat
    {
        public RGBA_Floats PixelToColorRGBA_Floats(float[] buffer, int bufferOffset)
        {
            return new RGBA_Floats(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
        }

        public void CopyPixels(float[] buffer, int bufferOffset, RGBA_Floats sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
                bufferOffset += 4;
            }
            while (--count != 0);
        }

        public void BlendPixel(float[] buffer, int bufferOffset, RGBA_Floats sourceColor)
        {
            if (sourceColor.alpha == 1)
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.red);
                buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);
                buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.blue);
                buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);
            }
            else
            {
                float r = buffer[bufferOffset + ImageBuffer.OrderR];
                float g = buffer[bufferOffset + ImageBuffer.OrderG];
                float b = buffer[bufferOffset + ImageBuffer.OrderB];
                float a = buffer[bufferOffset + ImageBuffer.OrderA];
                buffer[bufferOffset + ImageBuffer.OrderR] = (sourceColor.red - r) * sourceColor.alpha + r;
                buffer[bufferOffset + ImageBuffer.OrderG] = (sourceColor.green - g) * sourceColor.alpha + g;
                buffer[bufferOffset + ImageBuffer.OrderB] = (sourceColor.blue - b) * sourceColor.alpha + b;
                buffer[bufferOffset + ImageBuffer.OrderA] = (sourceColor.alpha + a) - sourceColor.alpha * a;
            }
        }

        public void BlendPixels(float[] destBuffer, int bufferOffset,
            RGBA_Floats[] sourceColors, int sourceColorsOffset,
            byte[] covers, int coversIndex, bool firstCoverForAll, int count)
        {
            throw new NotImplementedException();
        }
    };

    public sealed class BlenderGammaBGRA : BlenderBase8888, IRecieveBlenderByte
    {
        private GammaLookUpTable m_gamma;

        public BlenderGammaBGRA()
        {
            m_gamma = new GammaLookUpTable();
        }

        public BlenderGammaBGRA(GammaLookUpTable g)
        {
            m_gamma = g;
        }

        public void gamma(GammaLookUpTable g)
        {
            m_gamma = g;
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv(sourceColor.red);
                buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv(sourceColor.green);
                buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv(sourceColor.blue);
                buffer[bufferOffset + ImageBuffer.OrderA] = m_gamma.inv(sourceColor.alpha);
                bufferOffset += 4;
            }
            while (--count != 0);
        }

        public void BlendPixel(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            unchecked
            {
                int r = buffer[bufferOffset + ImageBuffer.OrderR];
                int g = buffer[bufferOffset + ImageBuffer.OrderG];
                int b = buffer[bufferOffset + ImageBuffer.OrderB];
                int a = buffer[bufferOffset + ImageBuffer.OrderA];
                buffer[bufferOffset + ImageBuffer.OrderR] = m_gamma.inv((byte)(((sourceColor.red - r) * sourceColor.alpha + (r << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift));
                buffer[bufferOffset + ImageBuffer.OrderG] = m_gamma.inv((byte)(((sourceColor.green - g) * sourceColor.alpha + (g << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift));
                buffer[bufferOffset + ImageBuffer.OrderB] = m_gamma.inv((byte)(((sourceColor.blue - b) * sourceColor.alpha + (b << (int)RGBA_Bytes.base_shift)) >> (int)RGBA_Bytes.base_shift));
                buffer[ImageBuffer.OrderA] = (byte)((sourceColor.alpha + a) - ((sourceColor.alpha * a + base_mask) >> (int)RGBA_Bytes.base_shift));
            }
        }

        public void BlendPixels(byte[] buffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
        {
            throw new NotImplementedException();
        }
    };

    public sealed class BlenderPreMultBGRA : BlenderBase8888, IRecieveBlenderByte
    {
        static int[] m_Saturate9BitToByte = new int[1 << 9];

        public BlenderPreMultBGRA()
        {
            if (m_Saturate9BitToByte[2] == 0)
            {
                for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
                {
                    m_Saturate9BitToByte[i] = Math.Min(i, 255);
                }
            }
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            for (int i = 0; i < count; i++)
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
                bufferOffset += 4;
            }
        }

        public void BlendPixel(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            //unsafe
            {
                int oneOverAlpha = base_mask - sourceColor.alpha;
                unchecked
                {
#if false
					Vector4i sourceColors = new Vector4i(sourceColor.m_B, sourceColor.m_G, sourceColor.m_R, sourceColor.m_A);
					Vector4i destColors = new Vector4i(
						pDestBuffer[bufferOffset + ImageBuffer.OrderB],
					    pDestBuffer[bufferOffset + ImageBuffer.OrderG],
					    pDestBuffer[bufferOffset + ImageBuffer.OrderB],
					    pDestBuffer[bufferOffset + ImageBuffer.OrderA]);
					Vector4i oneOverAlphaV = new Vector4i(oneOverAlpha, oneOverAlpha, oneOverAlpha, oneOverAlpha);
					Vector4i rounding = new Vector4i(255, 255, 255, 255);
					Vector4i temp = destColors * oneOverAlphaV + rounding;
					temp = temp >> 8;
					temp = temp + sourceColors;
					Vector8us packed8Final = Vector4i.PackWithUnsignedSaturation(temp, temp);
					Vector16b packed16Final = Vector8us.SignedPackWithUnsignedSaturation(packed8Final, packed8Final);
					pDestBuffer[bufferOffset + ImageBuffer.OrderR] = packed16Final.V2;
					pDestBuffer[bufferOffset + ImageBuffer.OrderG] = packed16Final.V1;
					pDestBuffer[bufferOffset + ImageBuffer.OrderB] = packed16Final.V0;
					pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 255;
					            
#else
                    int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceColor.red];
                    int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceColor.green];
                    int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceColor.blue];
                    int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                    pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);
#endif
                }
            }
        }

        public void BlendPixels(byte[] pDestBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                //unsafe
                {
                    if (sourceCovers[sourceCoversOffset] == 255)
                    {
                        for (int i = 0; i < count; i++)
                        {
#if false
                                BlendPixel(pDestBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
#else
                            RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];
                            if (sourceColor.alpha == 255)
                            {
                                pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 255;
                            }
                            else
                            {
                                int OneOverAlpha = base_mask - sourceColor.alpha;
                                unchecked
                                {
                                    int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                                    int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                                    int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                                    int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);
                                }
                            }
#endif
                            sourceColorsOffset++;
                            bufferOffset += 4;
                        }
                    }
                    else
                    {
                        for (int i = 0; i < count; i++)
                        {
                            RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];
                            int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
                            if (alpha == 0)
                            {
                                continue;
                            }
                            else if (alpha == 255)
                            {
                                pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
                            }
                            else
                            {
                                int OneOverAlpha = base_mask - alpha;
                                unchecked
                                {
                                    int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                                    int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                                    int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                                    int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);
                                }
                            }
                            sourceColorsOffset++;
                            bufferOffset += 4;
                        }
                    }
                }
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];
                    int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
                    if (alpha == 255)
                    {
                        pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
                    }
                    else if (alpha > 0)
                    {
                        int OneOverAlpha = base_mask - alpha;
                        unchecked
                        {
                            int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                            int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                            int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                            int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                            pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);
                        }
                    }
                    sourceColorsOffset++;
                    sourceCoversOffset++;
                    bufferOffset += 4;
                }
            }
        }
    }

    public sealed class BlenderPolyColorPreMultBGRA : BlenderBase8888, IRecieveBlenderByte
    {
        static int[] m_Saturate9BitToByte = new int[1 << 9];
        RGBA_Bytes polyColor;

        public BlenderPolyColorPreMultBGRA(RGBA_Bytes polyColor)
        {
            this.polyColor = polyColor;

            if (m_Saturate9BitToByte[2] == 0)
            {
                for (int i = 0; i < m_Saturate9BitToByte.Length; i++)
                {
                    m_Saturate9BitToByte[i] = Math.Min(i, 255);
                }
            }
        }

        public RGBA_Bytes PixelToColorRGBA_Bytes(byte[] buffer, int bufferOffset)
        {
            return new RGBA_Bytes(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
        }

        public void CopyPixels(byte[] buffer, int bufferOffset, RGBA_Bytes sourceColor, int count)
        {
            for (int i = 0; i < count; i++)
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
                bufferOffset += 4;
            }
        }

        public void BlendPixel(byte[] pDestBuffer, int bufferOffset, RGBA_Bytes sourceColor)
        {
            //unsafe
            {
                int sourceA = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.alpha + 255) >> 8]);
                int oneOverAlpha = base_mask - sourceA;
                unchecked
                {
                    int sourceR = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.red + 255) >> 8]);
                    int sourceG = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.green + 255) >> 8]);
                    int sourceB = (byte)(m_Saturate9BitToByte[(polyColor.Alpha0To255 * sourceColor.blue + 255) >> 8]);

                    int destR = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * oneOverAlpha + 255) >> 8) + sourceR];
                    int destG = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * oneOverAlpha + 255) >> 8) + sourceG];
                    int destB = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * oneOverAlpha + 255) >> 8) + sourceB];
                    // TODO: calculated the correct dest alpha
                    //int destA = pDestBuffer[bufferOffset + ImageBuffer.OrderA];

                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)destR;
                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)destG;
                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)destB;
                    //pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(oneOverAlpha * (base_mask - a) + 255) >> 8]);
                }
            }
        }

        public void BlendPixels(byte[] pDestBuffer, int bufferOffset,
            RGBA_Bytes[] sourceColors, int sourceColorsOffset,
            byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                //unsafe
                {
                    if (sourceCovers[sourceCoversOffset] == 255)
                    {
                        for (int i = 0; i < count; i++)
                        {
                            BlendPixel(pDestBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                            sourceColorsOffset++;
                            bufferOffset += 4;
                        }
                    }
                    else
                    {
                        throw new NotImplementedException("need to consider the polyColor");
#if false
                        for (int i = 0; i < count; i++)
                        {
                            RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];
                            int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
                            if (alpha == 0)
                            {
                                continue;
                            }
                            else if (alpha == 255)
                            {
                                pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
                            }
                            else
                            {
                                int OneOverAlpha = base_mask - alpha;
                                unchecked
                                {
                                    int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                                    int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                                    int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                                    int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);
                                }
                            }
                            sourceColorsOffset++;
                            bufferOffset += 4;
                        }
#endif
                    }
                }
            }
            else
            {
                throw new NotImplementedException("need to consider the polyColor");
#if false
                for (int i = 0; i < count; i++)
                {
                    RGBA_Bytes sourceColor = sourceColors[sourceColorsOffset];
                    int alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
                    if (alpha == 255)
                    {
                        pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
                    }
                    else if (alpha > 0)
                    {
                        int OneOverAlpha = base_mask - alpha;
                        unchecked
                        {
                            int r = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + 255) >> 8) + sourceColor.red];
                            int g = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + 255) >> 8) + sourceColor.green];
                            int b = m_Saturate9BitToByte[((pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + 255) >> 8) + sourceColor.blue];
                            int a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                            pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)r;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)g;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)b;
                            pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)(base_mask - m_Saturate9BitToByte[(OneOverAlpha * (base_mask - a) + 255) >> 8]);
                        }
                    }
                    sourceColorsOffset++;
                    sourceCoversOffset++;
                    bufferOffset += 4;
                }
#endif
            }
        }
    };

    public sealed class BlenderPreMultBGRAFloat : BlenderBaseBGRAFloat, IRecieveBlenderFloat
    {
        public RGBA_Floats PixelToColorRGBA_Floats(float[] buffer, int bufferOffset)
        {
            throw new NotImplementedException();
            //return new RGBA_(buffer[bufferOffset + ImageBuffer.OrderR], buffer[bufferOffset + ImageBuffer.OrderG], buffer[bufferOffset + ImageBuffer.OrderB], buffer[bufferOffset + ImageBuffer.OrderA]);
        }

        public void SetPixels(float[] buffer, int bufferOffset, RGBA_Floats sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
                bufferOffset += 4;
            }
            while (--count != 0);
        }

        public void CopyPixels(float[] buffer, int bufferOffset, RGBA_Floats[] sourceColors, int sourceColorsOffset, int count)
        {
            throw new NotImplementedException();
        }

        public void CopyPixels(float[] buffer, int bufferOffset, RGBA_Floats sourceColor, int count)
        {
            do
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                buffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                buffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                buffer[bufferOffset + ImageBuffer.OrderA] = sourceColor.alpha;
                bufferOffset += 4;
            }
            while (--count != 0);
        }

        public void BlendPixel(float[] buffer, int bufferOffset, RGBA_Floats sourceColor)
        {
            if (sourceColor.alpha == 1)
            {
                buffer[bufferOffset + ImageBuffer.OrderR] = (byte)(sourceColor.red);
                buffer[bufferOffset + ImageBuffer.OrderG] = (byte)(sourceColor.green);
                buffer[bufferOffset + ImageBuffer.OrderB] = (byte)(sourceColor.blue);
                buffer[bufferOffset + ImageBuffer.OrderA] = (byte)(sourceColor.alpha);
            }
            else
            {
                float r = buffer[bufferOffset + ImageBuffer.OrderR];
                float g = buffer[bufferOffset + ImageBuffer.OrderG];
                float b = buffer[bufferOffset + ImageBuffer.OrderB];
                float a = buffer[bufferOffset + ImageBuffer.OrderA];
                buffer[bufferOffset + ImageBuffer.OrderR] = (sourceColor.red - r) * sourceColor.alpha + r;
                buffer[bufferOffset + ImageBuffer.OrderG] = (sourceColor.green - g) * sourceColor.alpha + g;
                buffer[bufferOffset + ImageBuffer.OrderB] = (sourceColor.blue - b) * sourceColor.alpha + b;
                buffer[bufferOffset + ImageBuffer.OrderA] = (sourceColor.alpha + a) - sourceColor.alpha * a;
            }
        }

        public void BlendPixels(float[] pDestBuffer, int bufferOffset,
            RGBA_Floats[] sourceColors, int sourceColorsOffset, int count)
        {
        }

        public void BlendPixels(float[] pDestBuffer, int bufferOffset,
            RGBA_Floats[] sourceColors, int sourceColorsOffset,
            byte sourceCovers, int count)
        {
        }

        public void BlendPixels(float[] pDestBuffer, int bufferOffset,
            RGBA_Floats[] sourceColors, int sourceColorsOffset,
            byte[] sourceCovers, int sourceCoversOffset, int count)
        {
        }

        public void BlendPixels(float[] pDestBuffer, int bufferOffset,
            RGBA_Floats[] sourceColors, int sourceColorsOffset,
            byte[] sourceCovers, int sourceCoversOffset, bool firstCoverForAll, int count)
        {
            if (firstCoverForAll)
            {
                //unsafe
                {
                    if (sourceCovers[sourceCoversOffset] == 255)
                    {
                        for (int i = 0; i < count; i++)
                        {
                            BlendPixel(pDestBuffer, bufferOffset, sourceColors[sourceColorsOffset]);
                            sourceColorsOffset++;
                            bufferOffset += 4;
                        }
                    }
                    else
                    {
                        for (int i = 0; i < count; i++)
                        {
                            RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];
                            float alpha = (sourceColor.alpha * sourceCovers[sourceCoversOffset] + 255) / 256;
                            if (alpha == 0)
                            {
                                continue;
                            }
                            else if (alpha == 255)
                            {
                                pDestBuffer[bufferOffset + ImageBuffer.OrderR] = (byte)sourceColor.red;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderG] = (byte)sourceColor.green;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderB] = (byte)sourceColor.blue;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (byte)alpha;
                            }
                            else
                            {
                                float OneOverAlpha = base_mask - alpha;
                                unchecked
                                {
                                    float r = pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha + sourceColor.red;
                                    float g = pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha + sourceColor.green;
                                    float b = pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha + sourceColor.blue;
                                    float a = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;
                                    pDestBuffer[bufferOffset + ImageBuffer.OrderA] = (1.0f - ((OneOverAlpha * (1.0f - a))));
                                }
                            }
                            sourceColorsOffset++;
                            bufferOffset += 4;
                        }
                    }
                }
            }
            else
            {
                for (int i = 0; i < count; i++)
                {
                    RGBA_Floats sourceColor = sourceColors[sourceColorsOffset];
                    if (sourceColor.alpha == 1 && sourceCovers[sourceCoversOffset] == 255)
                    {
                        pDestBuffer[bufferOffset + ImageBuffer.OrderR] = sourceColor.red;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderG] = sourceColor.green;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderB] = sourceColor.blue;
                        pDestBuffer[bufferOffset + ImageBuffer.OrderA] = 1;
                    }
                    else
                    {
                        // the cover is known to be less than opaque
                        float coverFloat = (sourceCovers[sourceCoversOffset] * (1.0f / 255.0f));
                        float alpha = sourceColor.alpha * coverFloat;
                        if (coverFloat > 0 && alpha > 0)
                        {
                            float OneOverAlpha = 1.0f - alpha;
                            unchecked
                            {
                                // the color is already pre multiplied by the alpha but not by the cover value so we only need to multiply th ecolor by the cover
                                float r = (pDestBuffer[bufferOffset + ImageBuffer.OrderR] * OneOverAlpha) + sourceColor.red * coverFloat;
                                float g = (pDestBuffer[bufferOffset + ImageBuffer.OrderG] * OneOverAlpha) + sourceColor.green * coverFloat;
                                float b = (pDestBuffer[bufferOffset + ImageBuffer.OrderB] * OneOverAlpha) + sourceColor.blue * coverFloat;

                                float destAlpha = pDestBuffer[bufferOffset + ImageBuffer.OrderA];
                                float a = (destAlpha + (1.0f - destAlpha) * sourceColor.alpha * coverFloat);
                                pDestBuffer[bufferOffset + ImageBuffer.OrderR] = r;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderG] = g;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderB] = b;
                                pDestBuffer[bufferOffset + ImageBuffer.OrderA] = a;
                            }
                        }
                    }
                    sourceColorsOffset++;
                    sourceCoversOffset++;
                    bufferOffset += 4;
                }
            }
        }
    };

    /*
//======================================================blender_rgba_plain
template<class ColorT, class Order> struct blender_rgba_plain
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e { base_shift = color_type::base_shift };

    //--------------------------------------------------------------------
    static void blend_pix(value_type* p, 
                                     int cr, int cg, int cb,
                                     int alpha,
                                     int cover=0)
    {
        if(alpha == 0) return;
        calc_type a = p[Order::A];
        calc_type r = p[Order::R] * a;
        calc_type g = p[Order::G] * a;
        calc_type b = p[Order::B] * a;
        a = ((alpha + a) << base_shift) - alpha * a;
        p[Order::A] = (value_type)(a >> base_shift);
        p[Order::R] = (value_type)((((cr << base_shift) - r) * alpha + (r << base_shift)) / a);
        p[Order::G] = (value_type)((((cg << base_shift) - g) * alpha + (g << base_shift)) / a);
        p[Order::B] = (value_type)((((cb << base_shift) - b) * alpha + (b << base_shift)) / a);
    }
};

//=========================================================comp_op_rgba_clear
template<class ColorT, class Order> struct comp_op_rgba_clear
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    static void blend_pix(value_type* p, 
                                     int, int, int, int,
                                     int cover)
    {
        if(cover < 255)
        {
            cover = 255 - cover;
            p[Order::R] = (value_type)((p[Order::R] * cover + 255) >> 8);
            p[Order::G] = (value_type)((p[Order::G] * cover + 255) >> 8);
            p[Order::B] = (value_type)((p[Order::B] * cover + 255) >> 8);
            p[Order::A] = (value_type)((p[Order::A] * cover + 255) >> 8);
        }
        else
        {
            p[0] = p[1] = p[2] = p[3] = 0; 
        }
    }
};

//===========================================================comp_op_rgba_src
template<class ColorT, class Order> struct comp_op_rgba_src
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;

    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            int alpha = 255 - cover;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));
        }
        else
        {
            p[Order::R] = sr;
            p[Order::G] = sg;
            p[Order::B] = sb;
            p[Order::A] = sa;
        }
    }
};

//===========================================================comp_op_rgba_dst
template<class ColorT, class Order> struct comp_op_rgba_dst
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;

    static void blend_pix(value_type*, 
                                     int, int, int, 
                                     int, int)
    {
    }
};

//======================================================comp_op_rgba_src_over
template<class ColorT, class Order> struct comp_op_rgba_src_over
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    //   Dca' = Sca + Dca.(1 - Sa)
    //   Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        calc_type s1a = base_mask - sa;
        p[Order::R] = (value_type)(sr + ((p[Order::R] * s1a + base_mask) >> base_shift));
        p[Order::G] = (value_type)(sg + ((p[Order::G] * s1a + base_mask) >> base_shift));
        p[Order::B] = (value_type)(sb + ((p[Order::B] * s1a + base_mask) >> base_shift));
        p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
    }
};

//======================================================comp_op_rgba_dst_over
template<class ColorT, class Order> struct comp_op_rgba_dst_over
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca + Sca.(1 - Da)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        calc_type d1a = base_mask - p[Order::A];
        p[Order::R] = (value_type)(p[Order::R] + ((sr * d1a + base_mask) >> base_shift));
        p[Order::G] = (value_type)(p[Order::G] + ((sg * d1a + base_mask) >> base_shift));
        p[Order::B] = (value_type)(p[Order::B] + ((sb * d1a + base_mask) >> base_shift));
        p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
    }
};

//======================================================comp_op_rgba_src_in
template<class ColorT, class Order> struct comp_op_rgba_src_in
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.Da
    // Da'  = Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        calc_type da = p[Order::A];
        if(cover < 255)
        {
            int alpha = 255 - cover;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
        }
        else
        {
            p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
            p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
        }
    }
};

//======================================================comp_op_rgba_dst_in
template<class ColorT, class Order> struct comp_op_rgba_dst_in
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca.Sa
    // Da'  = Sa.Da 
    static void blend_pix(value_type* p, 
                                     int, int, int, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sa = base_mask - ((cover * (base_mask - sa) + 255) >> 8);
        }
        p[Order::R] = (value_type)((p[Order::R] * sa + base_mask) >> base_shift);
        p[Order::G] = (value_type)((p[Order::G] * sa + base_mask) >> base_shift);
        p[Order::B] = (value_type)((p[Order::B] * sa + base_mask) >> base_shift);
        p[Order::A] = (value_type)((p[Order::A] * sa + base_mask) >> base_shift);
    }
};

//======================================================comp_op_rgba_src_out
template<class ColorT, class Order> struct comp_op_rgba_src_out
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.(1 - Da)
    // Da'  = Sa.(1 - Da) 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        calc_type da = base_mask - p[Order::A];
        if(cover < 255)
        {
            int alpha = 255 - cover;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((((sr * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((((sg * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((((sb * da + base_mask) >> base_shift) * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((((sa * da + base_mask) >> base_shift) * cover + 255) >> 8));
        }
        else
        {
            p[Order::R] = (value_type)((sr * da + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg * da + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb * da + base_mask) >> base_shift);
            p[Order::A] = (value_type)((sa * da + base_mask) >> base_shift);
        }
    }
};

//======================================================comp_op_rgba_dst_out
template<class ColorT, class Order> struct comp_op_rgba_dst_out
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca.(1 - Sa) 
    // Da'  = Da.(1 - Sa) 
    static void blend_pix(value_type* p, 
                                     int, int, int, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sa = (sa * cover + 255) >> 8;
        }
        sa = base_mask - sa;
        p[Order::R] = (value_type)((p[Order::R] * sa + base_shift) >> base_shift);
        p[Order::G] = (value_type)((p[Order::G] * sa + base_shift) >> base_shift);
        p[Order::B] = (value_type)((p[Order::B] * sa + base_shift) >> base_shift);
        p[Order::A] = (value_type)((p[Order::A] * sa + base_shift) >> base_shift);
    }
};

//=====================================================comp_op_rgba_src_atop
template<class ColorT, class Order> struct comp_op_rgba_src_atop
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.Da + Dca.(1 - Sa)
    // Da'  = Da
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        calc_type da = p[Order::A];
        sa = base_mask - sa;
        p[Order::R] = (value_type)((sr * da + p[Order::R] * sa + base_mask) >> base_shift);
        p[Order::G] = (value_type)((sg * da + p[Order::G] * sa + base_mask) >> base_shift);
        p[Order::B] = (value_type)((sb * da + p[Order::B] * sa + base_mask) >> base_shift);
    }
};

//=====================================================comp_op_rgba_dst_atop
template<class ColorT, class Order> struct comp_op_rgba_dst_atop
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca.Sa + Sca.(1 - Da)
    // Da'  = Sa 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        calc_type da = base_mask - p[Order::A];
        if(cover < 255)
        {
            int alpha = 255 - cover;
            sr = (p[Order::R] * sa + sr * da + base_mask) >> base_shift;
            sg = (p[Order::G] * sa + sg * da + base_mask) >> base_shift;
            sb = (p[Order::B] * sa + sb * da + base_mask) >> base_shift;
            p[Order::R] = (value_type)(((p[Order::R] * alpha + 255) >> 8) + ((sr * cover + 255) >> 8));
            p[Order::G] = (value_type)(((p[Order::G] * alpha + 255) >> 8) + ((sg * cover + 255) >> 8));
            p[Order::B] = (value_type)(((p[Order::B] * alpha + 255) >> 8) + ((sb * cover + 255) >> 8));
            p[Order::A] = (value_type)(((p[Order::A] * alpha + 255) >> 8) + ((sa * cover + 255) >> 8));

        }
        else
        {
            p[Order::R] = (value_type)((p[Order::R] * sa + sr * da + base_mask) >> base_shift);
            p[Order::G] = (value_type)((p[Order::G] * sa + sg * da + base_mask) >> base_shift);
            p[Order::B] = (value_type)((p[Order::B] * sa + sb * da + base_mask) >> base_shift);
            p[Order::A] = (value_type)sa;
        }
    }
};

//=========================================================comp_op_rgba_xor
template<class ColorT, class Order> struct comp_op_rgba_xor
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - 2.Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type s1a = base_mask - sa;
            calc_type d1a = base_mask - p[Order::A];
            p[Order::R] = (value_type)((p[Order::R] * s1a + sr * d1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((p[Order::G] * s1a + sg * d1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((p[Order::B] * s1a + sb * d1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask/2) >> (base_shift - 1)));
        }
    }
};

//=========================================================comp_op_rgba_plus
template<class ColorT, class Order> struct comp_op_rgba_plus
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca + Dca
    // Da'  = Sa + Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R] + sr;
            calc_type dg = p[Order::G] + sg;
            calc_type db = p[Order::B] + sb;
            calc_type da = p[Order::A] + sa;
            p[Order::R] = (dr > base_mask) ? (value_type)base_mask : dr;
            p[Order::G] = (dg > base_mask) ? (value_type)base_mask : dg;
            p[Order::B] = (db > base_mask) ? (value_type)base_mask : db;
            p[Order::A] = (da > base_mask) ? (value_type)base_mask : da;
        }
    }
};

//========================================================comp_op_rgba_minus
template<class ColorT, class Order> struct comp_op_rgba_minus
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Dca - Sca
    // Da' = 1 - (1 - Sa).(1 - Da)
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R] - sr;
            calc_type dg = p[Order::G] - sg;
            calc_type db = p[Order::B] - sb;
            p[Order::R] = (dr > base_mask) ? 0 : dr;
            p[Order::G] = (dg > base_mask) ? 0 : dg;
            p[Order::B] = (db > base_mask) ? 0 : db;
            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
            //p[Order::A] = (value_type)(base_mask - (((base_mask - sa) * (base_mask - p[Order::A]) + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_multiply
template<class ColorT, class Order> struct comp_op_rgba_multiply
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type s1a = base_mask - sa;
            calc_type d1a = base_mask - p[Order::A];
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            p[Order::R] = (value_type)((sr * dr + sr * d1a + dr * s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg * dg + sg * d1a + dg * s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb * db + sb * d1a + db * s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + p[Order::A] - ((sa * p[Order::A] + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_screen
template<class ColorT, class Order> struct comp_op_rgba_screen
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca + Dca - Sca.Dca
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            calc_type da = p[Order::A];
            p[Order::R] = (value_type)(sr + dr - ((sr * dr + base_mask) >> base_shift));
            p[Order::G] = (value_type)(sg + dg - ((sg * dg + base_mask) >> base_shift));
            p[Order::B] = (value_type)(sb + db - ((sb * db + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_overlay
template<class ColorT, class Order> struct comp_op_rgba_overlay
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if 2.Dca < Da
    //   Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da' = Sa + Da - Sa.Da
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            calc_type sada = sa * p[Order::A];

            p[Order::R] = (value_type)(((2*dr < da) ? 
                2*sr*dr + sr*d1a + dr*s1a : 
                sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

            p[Order::G] = (value_type)(((2*dg < da) ? 
                2*sg*dg + sg*d1a + dg*s1a : 
                sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

            p[Order::B] = (value_type)(((2*db < da) ? 
                2*sb*db + sb*d1a + db*s1a : 
                sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};


template<class T> inline T sd_min(T a, T b) { return (a < b) ? a : b; }
template<class T> inline T sd_max(T a, T b) { return (a > b) ? a : b; }

//=====================================================comp_op_rgba_darken
template<class ColorT, class Order> struct comp_op_rgba_darken
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = min(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a = base_mask - p[Order::A];
            calc_type s1a = base_mask - sa;
            calc_type dr  = p[Order::R];
            calc_type dg  = p[Order::G];
            calc_type db  = p[Order::B];
            calc_type da  = p[Order::A];

            p[Order::R] = (value_type)((sd_min(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sd_min(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sd_min(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_lighten
template<class ColorT, class Order> struct comp_op_rgba_lighten
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = max(Sca.Da, Dca.Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a = base_mask - p[Order::A];
            calc_type s1a = base_mask - sa;
            calc_type dr  = p[Order::R];
            calc_type dg  = p[Order::G];
            calc_type db  = p[Order::B];
            calc_type da  = p[Order::A];

            p[Order::R] = (value_type)((sd_max(sr * da, dr * sa) + sr * d1a + dr * s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sd_max(sg * da, dg * sa) + sg * d1a + dg * s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sd_max(sb * da, db * sa) + sb * d1a + db * s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_color_dodge
template<class ColorT, class Order> struct comp_op_rgba_color_dodge
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if Sca.Da + Dca.Sa >= Sa.Da
    //   Dca' = Sa.Da + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = Dca.Sa/(1-Sca/Sa) + Sca.(1 - Da) + Dca.(1 - Sa)
    //
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            long_type drsa = dr * sa;
            long_type dgsa = dg * sa;
            long_type dbsa = db * sa;
            long_type srda = sr * da;
            long_type sgda = sg * da;
            long_type sbda = sb * da;
            long_type sada = sa * da;

            p[Order::R] = (value_type)((srda + drsa >= sada) ? 
                (sada + sr * d1a + dr * s1a + base_mask) >> base_shift :
                drsa / (base_mask - (sr << base_shift) / sa) + ((sr * d1a + dr * s1a + base_mask) >> base_shift));

            p[Order::G] = (value_type)((sgda + dgsa >= sada) ? 
                (sada + sg * d1a + dg * s1a + base_mask) >> base_shift :
                dgsa / (base_mask - (sg << base_shift) / sa) + ((sg * d1a + dg * s1a + base_mask) >> base_shift));

            p[Order::B] = (value_type)((sbda + dbsa >= sada) ? 
                (sada + sb * d1a + db * s1a + base_mask) >> base_shift :
                dbsa / (base_mask - (sb << base_shift) / sa) + ((sb * d1a + db * s1a + base_mask) >> base_shift));

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_color_burn
template<class ColorT, class Order> struct comp_op_rgba_color_burn
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if Sca.Da + Dca.Sa <= Sa.Da
    //   Dca' = Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = Sa.(Sca.Da + Dca.Sa - Sa.Da)/Sca + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            long_type drsa = dr * sa;
            long_type dgsa = dg * sa;
            long_type dbsa = db * sa;
            long_type srda = sr * da;
            long_type sgda = sg * da;
            long_type sbda = sb * da;
            long_type sada = sa * da;

            p[Order::R] = (value_type)(((srda + drsa <= sada) ? 
                sr * d1a + dr * s1a :
                sa * (srda + drsa - sada) / sr + sr * d1a + dr * s1a + base_mask) >> base_shift);

            p[Order::G] = (value_type)(((sgda + dgsa <= sada) ? 
                sg * d1a + dg * s1a :
                sa * (sgda + dgsa - sada) / sg + sg * d1a + dg * s1a + base_mask) >> base_shift);

            p[Order::B] = (value_type)(((sbda + dbsa <= sada) ? 
                sb * d1a + db * s1a :
                sa * (sbda + dbsa - sada) / sb + sb * d1a + db * s1a + base_mask) >> base_shift);

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_hard_light
template<class ColorT, class Order> struct comp_op_rgba_hard_light
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if 2.Sca < Sa
    //    Dca' = 2.Sca.Dca + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //    Dca' = Sa.Da - 2.(Da - Dca).(Sa - Sca) + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da'  = Sa + Da - Sa.Da
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a  = base_mask - p[Order::A];
            calc_type s1a  = base_mask - sa;
            calc_type dr   = p[Order::R];
            calc_type dg   = p[Order::G];
            calc_type db   = p[Order::B];
            calc_type da   = p[Order::A];
            calc_type sada = sa * da;

            p[Order::R] = (value_type)(((2*sr < sa) ? 
                2*sr*dr + sr*d1a + dr*s1a : 
                sada - 2*(da - dr)*(sa - sr) + sr*d1a + dr*s1a + base_mask) >> base_shift);

            p[Order::G] = (value_type)(((2*sg < sa) ? 
                2*sg*dg + sg*d1a + dg*s1a : 
                sada - 2*(da - dg)*(sa - sg) + sg*d1a + dg*s1a + base_mask) >> base_shift);

            p[Order::B] = (value_type)(((2*sb < sa) ? 
                2*sb*db + sb*d1a + db*s1a : 
                sada - 2*(da - db)*(sa - sb) + sb*d1a + db*s1a + base_mask) >> base_shift);

            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_soft_light
template<class ColorT, class Order> struct comp_op_rgba_soft_light
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // if 2.Sca < Sa
    //   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise if 8.Dca <= Da
    //   Dca' = Dca.(Sa + (1 - Dca/Da).(2.Sca - Sa).(3 - 8.Dca/Da)) + Sca.(1 - Da) + Dca.(1 - Sa)
    // otherwise
    //   Dca' = (Dca.Sa + ((Dca/Da)^(0.5).Da - Dca).(2.Sca - Sa)) + Sca.(1 - Da) + Dca.(1 - Sa)
    // 
    // Da'  = Sa + Da - Sa.Da 

    static void blend_pix(value_type* p, 
                                     int r, int g, int b, 
                                     int a, int cover)
    {
        double sr = double(r * cover) / (base_mask * 255);
        double sg = double(g * cover) / (base_mask * 255);
        double sb = double(b * cover) / (base_mask * 255);
        double sa = double(a * cover) / (base_mask * 255);
        if(sa > 0)
        {
            double dr = double(p[Order::R]) / base_mask;
            double dg = double(p[Order::G]) / base_mask;
            double db = double(p[Order::B]) / base_mask;
            double da = double(p[Order::A] ? p[Order::A] : 1) / base_mask;
            if(cover < 255)
            {
                a = (a * cover + 255) >> 8;
            }

            if(2*sr < sa)       dr = dr*(sa + (1 - dr/da)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);
            else if(8*dr <= da) dr = dr*(sa + (1 - dr/da)*(2*sr - sa)*(3 - 8*dr/da)) + sr*(1 - da) + dr*(1 - sa);
            else                dr = (dr*sa + (sqrt(dr/da)*da - dr)*(2*sr - sa)) + sr*(1 - da) + dr*(1 - sa);

            if(2*sg < sa)       dg = dg*(sa + (1 - dg/da)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);
            else if(8*dg <= da) dg = dg*(sa + (1 - dg/da)*(2*sg - sa)*(3 - 8*dg/da)) + sg*(1 - da) + dg*(1 - sa);
            else                dg = (dg*sa + (sqrt(dg/da)*da - dg)*(2*sg - sa)) + sg*(1 - da) + dg*(1 - sa);

            if(2*sb < sa)       db = db*(sa + (1 - db/da)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);
            else if(8*db <= da) db = db*(sa + (1 - db/da)*(2*sb - sa)*(3 - 8*db/da)) + sb*(1 - da) + db*(1 - sa);
            else                db = (db*sa + (sqrt(db/da)*da - db)*(2*sb - sa)) + sb*(1 - da) + db*(1 - sa);

            p[Order::R] = (value_type)uround(dr * base_mask);
            p[Order::G] = (value_type)uround(dg * base_mask);
            p[Order::B] = (value_type)uround(db * base_mask);
            p[Order::A] = (value_type)(a + p[Order::A] - ((a * p[Order::A] + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_difference
template<class ColorT, class Order> struct comp_op_rgba_difference
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_scale = color_type::base_scale,
        base_mask  = color_type::base_mask
    };

    // Dca' = Sca + Dca - 2.min(Sca.Da, Dca.Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            calc_type da = p[Order::A];
            p[Order::R] = (value_type)(sr + dr - ((2 * sd_min(sr*da, dr*sa) + base_mask) >> base_shift));
            p[Order::G] = (value_type)(sg + dg - ((2 * sd_min(sg*da, dg*sa) + base_mask) >> base_shift));
            p[Order::B] = (value_type)(sb + db - ((2 * sd_min(sb*da, db*sa) + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_exclusion
template<class ColorT, class Order> struct comp_op_rgba_exclusion
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = (Sca.Da + Dca.Sa - 2.Sca.Dca) + Sca.(1 - Da) + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type d1a = base_mask - p[Order::A];
            calc_type s1a = base_mask - sa;
            calc_type dr = p[Order::R];
            calc_type dg = p[Order::G];
            calc_type db = p[Order::B];
            calc_type da = p[Order::A];
            p[Order::R] = (value_type)((sr*da + dr*sa - 2*sr*dr + sr*d1a + dr*s1a + base_mask) >> base_shift);
            p[Order::G] = (value_type)((sg*da + dg*sa - 2*sg*dg + sg*d1a + dg*s1a + base_mask) >> base_shift);
            p[Order::B] = (value_type)((sb*da + db*sa - 2*sb*db + sb*d1a + db*s1a + base_mask) >> base_shift);
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=====================================================comp_op_rgba_contrast
template<class ColorT, class Order> struct comp_op_rgba_contrast
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };


    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        long_type dr = p[Order::R];
        long_type dg = p[Order::G];
        long_type db = p[Order::B];
        int       da = p[Order::A];
        long_type d2a = da >> 1;
        int s2a = sa >> 1;

        int r = (int)((((dr - d2a) * int((sr - s2a)*2 + base_mask)) >> base_shift) + d2a); 
        int g = (int)((((dg - d2a) * int((sg - s2a)*2 + base_mask)) >> base_shift) + d2a); 
        int b = (int)((((db - d2a) * int((sb - s2a)*2 + base_mask)) >> base_shift) + d2a); 

        r = (r < 0) ? 0 : r;
        g = (g < 0) ? 0 : g;
        b = (b < 0) ? 0 : b;

        p[Order::R] = (value_type)((r > da) ? da : r);
        p[Order::G] = (value_type)((g > da) ? da : g);
        p[Order::B] = (value_type)((b > da) ? da : b);
    }
};

//=====================================================comp_op_rgba_invert
template<class ColorT, class Order> struct comp_op_rgba_invert
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = (Da - Dca) * Sa + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        sa = (sa * cover + 255) >> 8;
        if(sa)
        {
            calc_type da = p[Order::A];
            calc_type dr = ((da - p[Order::R]) * sa + base_mask) >> base_shift;
            calc_type dg = ((da - p[Order::G]) * sa + base_mask) >> base_shift;
            calc_type db = ((da - p[Order::B]) * sa + base_mask) >> base_shift;
            calc_type s1a = base_mask - sa;
            p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
            p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
            p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};

//=================================================comp_op_rgba_invert_rgb
template<class ColorT, class Order> struct comp_op_rgba_invert_rgb
{
    typedef ColorT color_type;
    typedef Order order_type;
    typedef typename color_type::value_type value_type;
    typedef typename color_type::calc_type calc_type;
    typedef typename color_type::long_type long_type;
    enum base_scale_e
    { 
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask
    };

    // Dca' = (Da - Dca) * Sca + Dca.(1 - Sa)
    // Da'  = Sa + Da - Sa.Da 
    static void blend_pix(value_type* p, 
                                     int sr, int sg, int sb, 
                                     int sa, int cover)
    {
        if(cover < 255)
        {
            sr = (sr * cover + 255) >> 8;
            sg = (sg * cover + 255) >> 8;
            sb = (sb * cover + 255) >> 8;
            sa = (sa * cover + 255) >> 8;
        }
        if(sa)
        {
            calc_type da = p[Order::A];
            calc_type dr = ((da - p[Order::R]) * sr + base_mask) >> base_shift;
            calc_type dg = ((da - p[Order::G]) * sg + base_mask) >> base_shift;
            calc_type db = ((da - p[Order::B]) * sb + base_mask) >> base_shift;
            calc_type s1a = base_mask - sa;
            p[Order::R] = (value_type)(dr + ((p[Order::R] * s1a + base_mask) >> base_shift));
            p[Order::G] = (value_type)(dg + ((p[Order::G] * s1a + base_mask) >> base_shift));
            p[Order::B] = (value_type)(db + ((p[Order::B] * s1a + base_mask) >> base_shift));
            p[Order::A] = (value_type)(sa + da - ((sa * da + base_mask) >> base_shift));
        }
    }
};





//======================================================comp_op_table_rgba
template<class ColorT, class Order> struct comp_op_table_rgba
{
    typedef typename ColorT::value_type value_type;
    typedef void (*comp_op_func_type)(value_type* p, 
                                      int cr, 
                                      int cg, 
                                      int cb,
                                      int ca,
                                      int cover);
    static comp_op_func_type g_comp_op_func[];
};

//==========================================================g_comp_op_func
template<class ColorT, class Order> 
typename comp_op_table_rgba<ColorT, Order>::comp_op_func_type
comp_op_table_rgba<ColorT, Order>::g_comp_op_func[] = 
{
    comp_op_rgba_clear      <ColorT,Order>::blend_pix,
    comp_op_rgba_src        <ColorT,Order>::blend_pix,
    comp_op_rgba_dst        <ColorT,Order>::blend_pix,
    comp_op_rgba_src_over   <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_over   <ColorT,Order>::blend_pix,
    comp_op_rgba_src_in     <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_in     <ColorT,Order>::blend_pix,
    comp_op_rgba_src_out    <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_out    <ColorT,Order>::blend_pix,
    comp_op_rgba_src_atop   <ColorT,Order>::blend_pix,
    comp_op_rgba_dst_atop   <ColorT,Order>::blend_pix,
    comp_op_rgba_xor        <ColorT,Order>::blend_pix,
    comp_op_rgba_plus       <ColorT,Order>::blend_pix,
    comp_op_rgba_minus      <ColorT,Order>::blend_pix,
    comp_op_rgba_multiply   <ColorT,Order>::blend_pix,
    comp_op_rgba_screen     <ColorT,Order>::blend_pix,
    comp_op_rgba_overlay    <ColorT,Order>::blend_pix,
    comp_op_rgba_darken     <ColorT,Order>::blend_pix,
    comp_op_rgba_lighten    <ColorT,Order>::blend_pix,
    comp_op_rgba_color_dodge<ColorT,Order>::blend_pix,
    comp_op_rgba_color_burn <ColorT,Order>::blend_pix,
    comp_op_rgba_hard_light <ColorT,Order>::blend_pix,
    comp_op_rgba_soft_light <ColorT,Order>::blend_pix,
    comp_op_rgba_difference <ColorT,Order>::blend_pix,
    comp_op_rgba_exclusion  <ColorT,Order>::blend_pix,
    comp_op_rgba_contrast   <ColorT,Order>::blend_pix,
    comp_op_rgba_invert     <ColorT,Order>::blend_pix,
    comp_op_rgba_invert_rgb <ColorT,Order>::blend_pix,
    0
};


//==============================================================comp_op_e
enum comp_op_e
{
    comp_op_clear,         //----comp_op_clear
    comp_op_src,           //----comp_op_src
    comp_op_dst,           //----comp_op_dst
    comp_op_src_over,      //----comp_op_src_over
    comp_op_dst_over,      //----comp_op_dst_over
    comp_op_src_in,        //----comp_op_src_in
    comp_op_dst_in,        //----comp_op_dst_in
    comp_op_src_out,       //----comp_op_src_out
    comp_op_dst_out,       //----comp_op_dst_out
    comp_op_src_atop,      //----comp_op_src_atop
    comp_op_dst_atop,      //----comp_op_dst_atop
    comp_op_xor,           //----comp_op_xor
    comp_op_plus,          //----comp_op_plus
    comp_op_minus,         //----comp_op_minus
    comp_op_multiply,      //----comp_op_multiply
    comp_op_screen,        //----comp_op_screen
    comp_op_overlay,       //----comp_op_overlay
    comp_op_darken,        //----comp_op_darken
    comp_op_lighten,       //----comp_op_lighten
    comp_op_color_dodge,   //----comp_op_color_dodge
    comp_op_color_burn,    //----comp_op_color_burn
    comp_op_hard_light,    //----comp_op_hard_light
    comp_op_soft_light,    //----comp_op_soft_light
    comp_op_difference,    //----comp_op_difference
    comp_op_exclusion,     //----comp_op_exclusion
    comp_op_contrast,      //----comp_op_contrast
    comp_op_invert,        //----comp_op_invert
    comp_op_invert_rgb,    //----comp_op_invert_rgb

    end_of_comp_op_e
};







//====================================================comp_op_adaptor_rgba
template<class ColorT, class Order> struct comp_op_adaptor_rgba
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
            (p, (cr * ca + base_mask) >> base_shift, 
                (cg * ca + base_mask) >> base_shift,
                (cb * ca + base_mask) >> base_shift,
                 ca, cover);
    }
};

//=========================================comp_op_adaptor_clip_to_dst_rgba
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        cr = (cr * ca + base_mask) >> base_shift;
        cg = (cg * ca + base_mask) >> base_shift;
        cb = (cb * ca + base_mask) >> base_shift;
        int da = p[Order::A];
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
            (p, (cr * da + base_mask) >> base_shift, 
                (cg * da + base_mask) >> base_shift, 
                (cb * da + base_mask) >> base_shift, 
                (ca * da + base_mask) >> base_shift, 
                cover);
    }
};

//================================================comp_op_adaptor_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_rgba_pre
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op](p, cr, cg, cb, ca, cover);
    }
};

//=====================================comp_op_adaptor_clip_to_dst_rgba_pre
template<class ColorT, class Order> struct comp_op_adaptor_clip_to_dst_rgba_pre
{
    typedef Order  order_type;
    typedef ColorT color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        int da = p[Order::A];
        comp_op_table_rgba<ColorT, Order>::g_comp_op_func[op]
            (p, (cr * da + base_mask) >> base_shift, 
                (cg * da + base_mask) >> base_shift, 
                (cb * da + base_mask) >> base_shift, 
                (ca * da + base_mask) >> base_shift, 
                cover);
    }
};

//=======================================================comp_adaptor_rgba
template<class BlenderPre> struct comp_adaptor_rgba
{
    typedef typename BlenderPre::order_type order_type;
    typedef typename BlenderPre::color_type color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        BlenderPre::blend_pix(p, 
                              (cr * ca + base_mask) >> base_shift, 
                              (cg * ca + base_mask) >> base_shift,
                              (cb * ca + base_mask) >> base_shift,
                              ca, cover);
    }
};

//==========================================comp_adaptor_clip_to_dst_rgba
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba
{
    typedef typename BlenderPre::order_type order_type;
    typedef typename BlenderPre::color_type color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        cr = (cr * ca + base_mask) >> base_shift;
        cg = (cg * ca + base_mask) >> base_shift;
        cb = (cb * ca + base_mask) >> base_shift;
        int da = p[ImageBuffer.OrderA];
        BlenderPre::blend_pix(p, 
                              (cr * da + base_mask) >> base_shift, 
                              (cg * da + base_mask) >> base_shift, 
                              (cb * da + base_mask) >> base_shift, 
                              (ca * da + base_mask) >> base_shift, 
                              cover);
    }
};

//======================================comp_adaptor_clip_to_dst_rgba_pre
template<class BlenderPre> struct comp_adaptor_clip_to_dst_rgba_pre
{
    typedef typename BlenderPre::order_type order_type;
    typedef typename BlenderPre::color_type color_type;
    typedef typename color_type::value_type value_type;
    enum base_scale_e
    {  
        base_shift = color_type::base_shift,
        base_mask  = color_type::base_mask 
    };

    static void blend_pix(int op, value_type* p, 
                                     int cr, int cg, int cb,
                                     int ca,
                                     int cover)
    {
        int da = p[ImageBuffer.OrderA];
        BlenderPre::blend_pix(p, 
                              (cr * da + base_mask) >> base_shift, 
                              (cg * da + base_mask) >> base_shift, 
                              (cb * da + base_mask) >> base_shift, 
                              (ca * da + base_mask) >> base_shift, 
                              cover);
    }
};

        //================================================pixfmt_custom_blend_rgba
        template<class Blender, class RenBuf> class pixfmt_custom_blend_rgba
        {
        public:
            //typedef RenBuf   rbuf_type;
            //typedef typename rbuf_type::row_data row_data;
            typedef Blender  blender_type;
            typedef typename blender_type::color_type color_type;
            typedef typename blender_type::order_type order_type;
            typedef typename color_type::value_type value_type;
            typedef typename color_type::calc_type calc_type;
            enum base_scale_e
            {
                base_shift = color_type::base_shift,
                base_scale = color_type::base_scale,
                base_mask  = color_type::base_mask,
                pix_width  = sizeof(value_type) * 4 
            };


            //--------------------------------------------------------------------
            pixfmt_custom_blend_rgba() : m_rbuf(0), m_comp_op(3) {}
            explicit pixfmt_custom_blend_rgba(rendering_buffer rb, int comp_op=3) : 
                m_rbuf(&rb),
                m_comp_op(comp_op)
            {}
            void attach(rendering_buffer rb) { m_rbuf = &rb; }

            //--------------------------------------------------------------------
            template<class PixFmt>
            bool attach(PixFmt& pixf, int x1, int y1, int x2, int y2)
            {
                rect_i r(x1, y1, x2, y2);
                if(r.clip(rect_i(0, 0, pixf.width()-1, pixf.height()-1)))
                {
                    int stride = pixf.stride();
                    m_rbuf->attach(pixf.pix_ptr(r.x1, stride < 0 ? r.y2 : r.y1), 
                                   (r.x2 - r.x1) + 1,
                                   (r.y2 - r.y1) + 1,
                                   stride);
                    return true;
                }
                return false;
            }

            //--------------------------------------------------------------------
            int width()  const { return m_rbuf->width();  }
            int height() const { return m_rbuf->height(); }
            int      stride() const { return m_rbuf->stride(); }

            //--------------------------------------------------------------------
                  byte* row_ptr(int y)       { return m_rbuf->row_ptr(y); }
            const byte* row_ptr(int y) const { return m_rbuf->row_ptr(y); }
            row_data     row(int y)     const { return m_rbuf->row(y); }

            //--------------------------------------------------------------------
            byte* pix_ptr(int x, int y)
            {
                return m_rbuf->row_ptr(y) + x * pix_width;
            }

            const byte* pix_ptr(int x, int y) const
            {
                return m_rbuf->row_ptr(y) + x * pix_width;
            }

            //--------------------------------------------------------------------
            void comp_op(int op) { m_comp_op = op; }
            int comp_op() const  { return m_comp_op; }

            //--------------------------------------------------------------------
            static void make_pix(byte* p, const color_type& c)
            {
                ((value_type*)p)[ImageBuffer.OrderR] = c.r;
                ((value_type*)p)[ImageBuffer.OrderG] = c.g;
                ((value_type*)p)[ImageBuffer.OrderB] = c.b;
                ((value_type*)p)[ImageBuffer.OrderA] = c.a;
            }

            //--------------------------------------------------------------------
            color_type pixel(int x, int y) const
            {
                const value_type* p = (value_type*)m_rbuf->row_ptr(y) + (x << 2);
                return color_type(p[ImageBuffer.OrderR], 
                                  p[ImageBuffer.OrderG], 
                                  p[ImageBuffer.OrderB], 
                                  p[ImageBuffer.OrderA]);
            }

            //--------------------------------------------------------------------
            unsafe void copy_pixel(int x, int y, byte* c)
            {
                blender_type::blend_pix(
                    m_comp_op, 
                    (value_type*)m_rbuf->row_ptr(x, y, 1) + (x << 2), 
                    c.r, c.g, c.b, c.a, 255);
            }

            //--------------------------------------------------------------------
            void blend_pixel(int x, int y, const color_type& c, byte cover)
            {
                blender_type::blend_pix(
                    m_comp_op, 
                    (value_type*)m_rbuf->row_ptr(x, y, 1) + (x << 2),
                    c.r, c.g, c.b, c.a, 
                    cover);
            }

            //--------------------------------------------------------------------
            void copy_hline(int x, int y, int len, const color_type& c)
            {
                value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
                do
                {
                    blender_type::blend_pix(m_comp_op, p, c.r, c.g, c.b, c.a, 255);
                    p += 4;
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void copy_vline(int x, int y, int len, const color_type& c)
            {
                do
                {
                    blender_type::blend_pix(
                        m_comp_op, 
                        (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2),
                        c.r, c.g, c.b, c.a, 255);
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void blend_hline(int x, int y, int len, 
                             const color_type& c, byte cover)
            {

                value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
                do
                {
                    blender_type::blend_pix(m_comp_op, p, c.r, c.g, c.b, c.a, cover);
                    p += 4;
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void blend_vline(int x, int y, int len, 
                             const color_type& c, byte cover)
            {

                do
                {
                    blender_type::blend_pix(
                        m_comp_op, 
                        (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2), 
                        c.r, c.g, c.b, c.a, 
                        cover);
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void blend_solid_hspan(int x, int y, int len, 
                                   const color_type& c, const byte* covers)
            {
                value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
                do 
                {
                    blender_type::blend_pix(m_comp_op, 
                                            p, c.r, c.g, c.b, c.a, 
                                            *covers++);
                    p += 4;
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void blend_solid_vspan(int x, int y, int len, 
                                   const color_type& c, const byte* covers)
            {
                do 
                {
                    blender_type::blend_pix(
                        m_comp_op, 
                        (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2), 
                        c.r, c.g, c.b, c.a, 
                        *covers++);
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void copy_color_hspan(int x, int y,
                                  int len, 
                                  const color_type* colors)
            {

                value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
                do 
                {
                    p[ImageBuffer.OrderR] = colors->r;
                    p[ImageBuffer.OrderG] = colors->g;
                    p[ImageBuffer.OrderB] = colors->b;
                    p[ImageBuffer.OrderA] = colors->a;
                    ++colors;
                    p += 4;
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void copy_color_vspan(int x, int y,
                                  int len, 
                                  const color_type* colors)
            {
                do 
                {
                    value_type* p = (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2);
                    p[ImageBuffer.OrderR] = colors->r;
                    p[ImageBuffer.OrderG] = colors->g;
                    p[ImageBuffer.OrderB] = colors->b;
                    p[ImageBuffer.OrderA] = colors->a;
                    ++colors;
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void blend_color_hspan(int x, int y, int len, 
                                   const color_type* colors, 
                                   const byte* covers)
            {
                value_type* p = (value_type*)m_rbuf->row_ptr(x, y, len) + (x << 2);
                do 
                {
                    blender_type::blend_pix(m_comp_op, 
                                            p, 
                                            colors->r, 
                                            colors->g, 
                                            colors->b, 
                                            colors->a, 
                                            covers ? *covers++ : cover);
                    p += 4;
                    ++colors;
                }
                while(--len);
            }

            //--------------------------------------------------------------------
            void blend_color_vspan(int x, int y, int len, 
                                   const color_type* colors, 
                                   const byte* covers,
                                   byte cover)
            {
                do 
                {
                    blender_type::blend_pix(
                        m_comp_op, 
                        (value_type*)m_rbuf->row_ptr(x, y++, 1) + (x << 2), 
                        colors->r,
                        colors->g,
                        colors->b,
                        colors->a,
                        covers ? *covers++ : cover);
                    ++colors;
                }
                while(--len);

            }

            //--------------------------------------------------------------------
            template<class Function> void for_each_pixel(Function f)
            {
                int y;
                for(y = 0; y < height(); ++y)
                {
                    row_data r = m_rbuf->row(y);
                    if(r.ptr)
                    {
                        int len = r.x2 - r.x1 + 1;
                        value_type* p = 
                            (value_type*)m_rbuf->row_ptr(r.x1, y, len) + (r.x1 << 2);
                        do
                        {
                            f(p);
                            p += 4;
                        }
                        while(--len);
                    }
                }
            }

            //--------------------------------------------------------------------
            void premultiply()
            {
                for_each_pixel(multiplier_rgba<color_type, order_type>::premultiply);
            }

            //--------------------------------------------------------------------
            void demultiply()
            {
                for_each_pixel(multiplier_rgba<color_type, order_type>::demultiply);
            }

            //--------------------------------------------------------------------
            template<class GammaLut> void apply_gamma_dir(const GammaLut& g)
            {
                for_each_pixel(apply_gamma_dir_rgba<color_type, order_type, GammaLut>(g));
            }

            //--------------------------------------------------------------------
            template<class GammaLut> void apply_gamma_inv(const GammaLut& g)
            {
                for_each_pixel(apply_gamma_inv_rgba<color_type, order_type, GammaLut>(g));
            }

            //--------------------------------------------------------------------
            template<class RenBuf2> void copy_from(const RenBuf2& from, 
                                                   int xdst, int ydst,
                                                   int xsrc, int ysrc,
                                                   int len)
            {
                const byte* p = from.row_ptr(ysrc);
                if(p)
                {
                    memmove(m_rbuf->row_ptr(xdst, ydst, len) + xdst * pix_width, 
                            p + xsrc * pix_width, 
                            len * pix_width);
                }
            }

            //--------------------------------------------------------------------
            template<class SrcPixelFormatRenderer> 
            void blend_from(const SrcPixelFormatRenderer& from, 
                            int xdst, int ydst,
                            int xsrc, int ysrc,
                            int len,
                            byte cover)
            {
                typedef typename SrcPixelFormatRenderer::order_type src_order;
                const value_type* psrc = (const value_type*)from.row_ptr(ysrc);
                if(psrc)
                {
                    psrc += xsrc << 2;
                    value_type* pdst = 
                        (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);

                    int incp = 4;
                    if(xdst > xsrc)
                    {
                        psrc += (len-1) << 2;
                        pdst += (len-1) << 2;
                        incp = -4;
                    }

                    do 
                    {
                        blender_type::blend_pix(m_comp_op, 
                                                pdst, 
                                                psrc[src_order::R],
                                                psrc[src_order::G],
                                                psrc[src_order::B],
                                                psrc[src_order::A],
                                                cover);
                        psrc += incp;
                        pdst += incp;
                    }
                    while(--len);
                }
            }

            //--------------------------------------------------------------------
            template<class SrcPixelFormatRenderer>
            void blend_from_color(const SrcPixelFormatRenderer& from, 
                                  const color_type& color,
                                  int xdst, int ydst,
                                  int xsrc, int ysrc,
                                  int len,
                                  byte cover)
            {
                typedef typename SrcPixelFormatRenderer::value_type src_value_type;
                const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
                if(psrc)
                {
                    value_type* pdst = 
                        (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
                    do 
                    {
                        blender_type::blend_pix(m_comp_op,
                                                pdst, 
                                                color.r, color.g, color.b, color.a,
                                                (*psrc * cover + base_mask) >> base_shift);
                        ++psrc;
                        pdst += 4;
                    }
                    while(--len);
                }
            }

            //--------------------------------------------------------------------
            template<class SrcPixelFormatRenderer>
            void blend_from_lut(const SrcPixelFormatRenderer& from, 
                                const color_type* color_lut,
                                int xdst, int ydst,
                                int xsrc, int ysrc,
                                int len,
                                byte cover)
            {
                typedef typename SrcPixelFormatRenderer::value_type src_value_type;
                const src_value_type* psrc = (src_value_type*)from.row_ptr(ysrc);
                if(psrc)
                {
                    value_type* pdst = 
                        (value_type*)m_rbuf->row_ptr(xdst, ydst, len) + (xdst << 2);
                    do 
                    {
                        const color_type& color = color_lut[*psrc];
                        blender_type::blend_pix(m_comp_op,
                                                pdst, 
                                                color.r, color.g, color.b, color.a,
                                                cover);
                        ++psrc;
                        pdst += 4;
                    }
                    while(--len);
                }
            }

        private:
            rendering_buffer m_rbuf;
            int m_comp_op;
        };




        //-----------------------------------------------------------------------
        typedef blender_rgba<rgba8, order_rgba> blender_rgba32; //----blender_rgba32
        typedef blender_rgba<rgba8, order_argb> blender_argb32; //----blender_argb32
        typedef blender_rgba<rgba8, order_abgr> blender_abgr32; //----blender_abgr32
        typedef blender_rgba<rgba8, order_bgra> blender_bgra32; //----blender_bgra32

        typedef blender_rgba_pre<rgba8, order_rgba> blender_rgba32_pre; //----blender_rgba32_pre
        typedef blender_rgba_pre<rgba8, order_argb> blender_argb32_pre; //----blender_argb32_pre
        typedef blender_rgba_pre<rgba8, order_abgr> blender_abgr32_pre; //----blender_abgr32_pre
        typedef blender_rgba_pre<rgba8, order_bgra> blender_bgra32_pre; //----blender_bgra32_pre

        typedef blender_rgba_plain<rgba8, order_rgba> blender_rgba32_plain; //----blender_rgba32_plain
        typedef blender_rgba_plain<rgba8, order_argb> blender_argb32_plain; //----blender_argb32_plain
        typedef blender_rgba_plain<rgba8, order_abgr> blender_abgr32_plain; //----blender_abgr32_plain
        typedef blender_rgba_plain<rgba8, order_bgra> blender_bgra32_plain; //----blender_bgra32_plain

        typedef blender_rgba<rgba16, order_rgba> blender_rgba64; //----blender_rgba64
        typedef blender_rgba<rgba16, order_argb> blender_argb64; //----blender_argb64
        typedef blender_rgba<rgba16, order_abgr> blender_abgr64; //----blender_abgr64
        typedef blender_rgba<rgba16, order_bgra> blender_bgra64; //----blender_bgra64

        typedef blender_rgba_pre<rgba16, order_rgba> blender_rgba64_pre; //----blender_rgba64_pre
        typedef blender_rgba_pre<rgba16, order_argb> blender_argb64_pre; //----blender_argb64_pre
        typedef blender_rgba_pre<rgba16, order_abgr> blender_abgr64_pre; //----blender_abgr64_pre
        typedef blender_rgba_pre<rgba16, order_bgra> blender_bgra64_pre; //----blender_bgra64_pre


        //-----------------------------------------------------------------------
        typedef int32u pixel32_type;
        typedef pixfmt_alpha_blend_rgba<blender_rgba32, rendering_buffer, pixel32_type> pixfmt_rgba32; //----pixfmt_rgba32
        typedef pixfmt_alpha_blend_rgba<blender_argb32, rendering_buffer, pixel32_type> pixfmt_argb32; //----pixfmt_argb32
        typedef pixfmt_alpha_blend_rgba<blender_abgr32, rendering_buffer, pixel32_type> pixfmt_abgr32; //----pixfmt_abgr32
        typedef pixfmt_alpha_blend_rgba<blender_bgra32, rendering_buffer, pixel32_type> pixfmt_bgra32; //----pixfmt_bgra32

        typedef pixfmt_alpha_blend_rgba<blender_rgba32_pre, rendering_buffer, pixel32_type> pixfmt_rgba32_pre; //----pixfmt_rgba32_pre
        typedef pixfmt_alpha_blend_rgba<blender_argb32_pre, rendering_buffer, pixel32_type> pixfmt_argb32_pre; //----pixfmt_argb32_pre
        typedef pixfmt_alpha_blend_rgba<blender_abgr32_pre, rendering_buffer, pixel32_type> pixfmt_abgr32_pre; //----pixfmt_abgr32_pre
        typedef pixfmt_alpha_blend_rgba<blender_bgra32_pre, rendering_buffer, pixel32_type> pixfmt_bgra32_pre; //----pixfmt_bgra32_pre

        typedef pixfmt_alpha_blend_rgba<blender_rgba32_plain, rendering_buffer, pixel32_type> pixfmt_rgba32_plain; //----pixfmt_rgba32_plain
        typedef pixfmt_alpha_blend_rgba<blender_argb32_plain, rendering_buffer, pixel32_type> pixfmt_argb32_plain; //----pixfmt_argb32_plain
        typedef pixfmt_alpha_blend_rgba<blender_abgr32_plain, rendering_buffer, pixel32_type> pixfmt_abgr32_plain; //----pixfmt_abgr32_plain
        typedef pixfmt_alpha_blend_rgba<blender_bgra32_plain, rendering_buffer, pixel32_type> pixfmt_bgra32_plain; //----pixfmt_bgra32_plain

        struct  pixel64_type { int16u c[4]; };
        typedef pixfmt_alpha_blend_rgba<blender_rgba64, rendering_buffer, pixel64_type> pixfmt_rgba64; //----pixfmt_rgba64
        typedef pixfmt_alpha_blend_rgba<blender_argb64, rendering_buffer, pixel64_type> pixfmt_argb64; //----pixfmt_argb64
        typedef pixfmt_alpha_blend_rgba<blender_abgr64, rendering_buffer, pixel64_type> pixfmt_abgr64; //----pixfmt_abgr64
        typedef pixfmt_alpha_blend_rgba<blender_bgra64, rendering_buffer, pixel64_type> pixfmt_bgra64; //----pixfmt_bgra64

        typedef pixfmt_alpha_blend_rgba<blender_rgba64_pre, rendering_buffer, pixel64_type> pixfmt_rgba64_pre; //----pixfmt_rgba64_pre
        typedef pixfmt_alpha_blend_rgba<blender_argb64_pre, rendering_buffer, pixel64_type> pixfmt_argb64_pre; //----pixfmt_argb64_pre
        typedef pixfmt_alpha_blend_rgba<blender_abgr64_pre, rendering_buffer, pixel64_type> pixfmt_abgr64_pre; //----pixfmt_abgr64_pre
        typedef pixfmt_alpha_blend_rgba<blender_bgra64_pre, rendering_buffer, pixel64_type> pixfmt_bgra64_pre; //----pixfmt_bgra64_pre
    */
}
//#endif


#endregion //rgba.cs
#region RootedObjectEventHandler.cs

namespace MatterHackers.Agg
{
#if false
    public interface IReceiveRootedWeakEvent
    {
        void RootedEvent(string eventType, EventArgs e);
    }

    public class RootedObjectWeakEventHandler
    {
        List<WeakReference> classesToCall = new List<WeakReference>();
        List<string> eventTypes = new List<string>();

        public void Register(IReceiveRootedWeakEvent objectToCall, string eventType)
        {
            classesToCall.Add(new WeakReference(objectToCall));
            eventTypes.Add(eventType);
        }

        public void Unregister(IReceiveRootedWeakEvent objectToCall)
        {
            for (int i = classesToCall.Count - 1; i >= 0; i--)
            {
                if (classesToCall[i].Target == objectToCall)
                {
                    classesToCall.RemoveAt(i);
                }
            }
        }

        public void CallEvents(Object sender, EventArgs e)
        {
            for(int i=classesToCall.Count-1; i>=0; i--)
            {
                IReceiveRootedWeakEvent reciever = classesToCall[i].Target as IReceiveRootedWeakEvent;
                if (reciever == null)
                {
                    classesToCall.RemoveAt(i);
                    eventTypes.RemoveAt(i);
                }
                else
                {
                    reciever.RootedEvent(eventTypes[i], e);
                }
            }
        }
    }
#endif

    public class RootedObjectEventHandler
    {
#if DEBUG
        private event EventHandler InternalEventForDebug;
        private List<EventHandler> DebugEventDelegates = new List<EventHandler>();

        private event EventHandler InternalEvent
        {
            //Wraps the PrivateClick event delegate so that we can track which events have been added and clear them if necessary            
            add
            {
                InternalEventForDebug += value;
                DebugEventDelegates.Add(value);
            }

            remove
            {
                InternalEventForDebug -= value;
                DebugEventDelegates.Remove(value);
            }
        }
#else
        EventHandler InternalEvent;
#endif

        public void RegisterEvent(EventHandler functionToCallOnEvent, ref EventHandler functionThatWillBeCalledToUnregisterEvent)
        {
            InternalEvent += functionToCallOnEvent;
            functionThatWillBeCalledToUnregisterEvent += (sender, e) =>
            {
                InternalEvent -= functionToCallOnEvent;
            };
        }

        public void UnregisterEvent(EventHandler functionToCallOnEvent, ref EventHandler functionThatWillBeCalledToUnregisterEvent)
        {
            InternalEvent -= functionToCallOnEvent;
            // After we remove it it will still be removed again in the functionThatWillBeCalledToUnregisterEvent
            // But it is valid to attempt remove more than once.
        }

        public void CallEvents(Object sender, EventArgs e)
        {
#if DEBUG
            if (InternalEventForDebug != null)
            {
                InternalEventForDebug(sender, e);
            }
#else
            if (InternalEvent != null)
            {
                InternalEvent(sender, e);
            }
#endif
        }
    }
}

#endregion //RootedObjectEventHandler.cs
#region RoundedRect.cs

namespace MatterHackers.Agg.VertexSource
{
    //------------------------------------------------------------rounded_rect
    //
    // See Implemantation agg_rounded_rect.cpp
    //
    public class RoundedRect : IVertexSource
    {
        RectangleDouble bounds;
        Vector2 leftBottomRadius;
        Vector2 rightBottomRadius;
        Vector2 rightTopRadius;
        Vector2 leftTopRadius;
        int state;
        arc currentProcessingArc = new arc();

        public RoundedRect(double left, double bottom, double right, double top, double radius)
        {
            bounds = new RectangleDouble(left, bottom, right, top);
            leftBottomRadius.x = radius;
            leftBottomRadius.y = radius;
            rightBottomRadius.x = radius;
            rightBottomRadius.y = radius;
            rightTopRadius.x = radius;
            rightTopRadius.y = radius;
            leftTopRadius.x = radius;
            leftTopRadius.y = radius;

            if (left > right)
            {
                bounds.Left = right;
                bounds.Right = left;
            }

            if (bottom > top)
            {
                bounds.Bottom = top;
                bounds.Top = bottom;
            }
        }

        public RoundedRect(RectangleDouble bounds, double r)
            : this(bounds.Left, bounds.Bottom, bounds.Right, bounds.Top, r)
        {
        }

        public RoundedRect(RectangleInt bounds, double r)
            : this(bounds.Left, bounds.Bottom, bounds.Right, bounds.Top, r)
        {
        }

        public void rect(double left, double bottom, double right, double top)
        {
            bounds = new RectangleDouble(left, bottom, right, top);
            if (left > right) { bounds.Left = right; bounds.Right = left; }
            if (bottom > top) { bounds.Bottom = top; bounds.Top = bottom; }
        }

        public void radius(double r)
        {
            leftBottomRadius.x = leftBottomRadius.y = rightBottomRadius.x = rightBottomRadius.y = rightTopRadius.x = rightTopRadius.y = leftTopRadius.x = leftTopRadius.y = r;
        }

        public void radius(double rx, double ry)
        {
            leftBottomRadius.x = rightBottomRadius.x = rightTopRadius.x = leftTopRadius.x = rx;
            leftBottomRadius.y = rightBottomRadius.y = rightTopRadius.y = leftTopRadius.y = ry;
        }

        public void radius(double leftBottomRadius, double rightBottomRadius, double rightTopRadius, double leftTopRadius)
        {
            this.leftBottomRadius = new Vector2(leftBottomRadius, leftBottomRadius);
            this.rightBottomRadius = new Vector2(rightBottomRadius, rightBottomRadius);
            this.rightTopRadius = new Vector2(rightTopRadius, rightTopRadius);
            this.leftTopRadius = new Vector2(leftTopRadius, leftTopRadius);
        }

        public void radius(double rx1, double ry1, double rx2, double ry2,
                              double rx3, double ry3, double rx4, double ry4)
        {
            leftBottomRadius.x = rx1; leftBottomRadius.y = ry1; rightBottomRadius.x = rx2; rightBottomRadius.y = ry2;
            rightTopRadius.x = rx3; rightTopRadius.y = ry3; leftTopRadius.x = rx4; leftTopRadius.y = ry4;
        }

        public void normalize_radius()
        {
            double dx = Math.Abs(bounds.Top - bounds.Bottom);
            double dy = Math.Abs(bounds.Right - bounds.Left);

            double k = 1.0;
            double t;
            t = dx / (leftBottomRadius.x + rightBottomRadius.x); if (t < k) k = t;
            t = dx / (rightTopRadius.x + leftTopRadius.x); if (t < k) k = t;
            t = dy / (leftBottomRadius.y + rightBottomRadius.y); if (t < k) k = t;
            t = dy / (rightTopRadius.y + leftTopRadius.y); if (t < k) k = t;

            if (k < 1.0)
            {
                leftBottomRadius.x *= k; leftBottomRadius.y *= k; rightBottomRadius.x *= k; rightBottomRadius.y *= k;
                rightTopRadius.x *= k; rightTopRadius.y *= k; leftTopRadius.x *= k; leftTopRadius.y *= k;
            }
        }

        public void approximation_scale(double s) { currentProcessingArc.approximation_scale(s); }
        public double approximation_scale() { return currentProcessingArc.approximation_scale(); }

        public IEnumerable<VertexData> Vertices()
        {
            currentProcessingArc.init(bounds.Left + leftBottomRadius.x, bounds.Bottom + leftBottomRadius.y, leftBottomRadius.x, leftBottomRadius.y, Math.PI, Math.PI + Math.PI * 0.5);
            foreach (VertexData vertexData in currentProcessingArc.Vertices())
            {
                if (ShapePath.is_stop(vertexData.command))
                {
                    break;
                }
                yield return vertexData;
            }
            currentProcessingArc.init(bounds.Right - rightBottomRadius.x, bounds.Bottom + rightBottomRadius.y, rightBottomRadius.x, rightBottomRadius.y, Math.PI + Math.PI * 0.5, 0.0);
            foreach (VertexData vertexData in currentProcessingArc.Vertices())
            {
                if (ShapePath.is_move_to(vertexData.command))
                {
                    // skip the initial moveto
                    continue;
                }
                if (ShapePath.is_stop(vertexData.command))
                {
                    break;
                }
                yield return vertexData;
            }

            currentProcessingArc.init(bounds.Right - rightTopRadius.x, bounds.Top - rightTopRadius.y, rightTopRadius.x, rightTopRadius.y, 0.0, Math.PI * 0.5);
            foreach (VertexData vertexData in currentProcessingArc.Vertices())
            {
                if (ShapePath.is_move_to(vertexData.command))
                {
                    // skip the initial moveto
                    continue;
                }
                if (ShapePath.is_stop(vertexData.command))
                {
                    break;
                }
                yield return vertexData;
            }

            currentProcessingArc.init(bounds.Left + leftTopRadius.x, bounds.Top - leftTopRadius.y, leftTopRadius.x, leftTopRadius.y, Math.PI * 0.5, Math.PI);
            foreach (VertexData vertexData in currentProcessingArc.Vertices())
            {
                if (ShapePath.is_move_to(vertexData.command))
                {
                    // skip the initial moveto
                    continue;
                }
                if (ShapePath.is_stop(vertexData.command))
                {
                    break;
                }
                yield return vertexData;
            }

            yield return new VertexData(ShapePath.FlagsAndCommand.CommandEndPoly | ShapePath.FlagsAndCommand.FlagClose | ShapePath.FlagsAndCommand.FlagCCW, new Vector2());
            yield return new VertexData(ShapePath.FlagsAndCommand.CommandStop, new Vector2());
        }

        public void rewind(int unused)
        {
            state = 0;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = 0;
            y = 0;
            ShapePath.FlagsAndCommand cmd = ShapePath.FlagsAndCommand.CommandStop;
            switch (state)
            {
                case 0:
                    currentProcessingArc.init(bounds.Left + leftBottomRadius.x, bounds.Bottom + leftBottomRadius.y, leftBottomRadius.x, leftBottomRadius.y,
                               Math.PI, Math.PI + Math.PI * 0.5);
                    currentProcessingArc.rewind(0);
                    state++;
                    goto case 1;

                case 1:
                    cmd = currentProcessingArc.vertex(out x, out y);
                    if (ShapePath.is_stop(cmd))
                    {
                        state++;
                    }
                    else
                    {
                        return cmd;
                    }
                    goto case 2;

                case 2:
                    currentProcessingArc.init(bounds.Right - rightBottomRadius.x, bounds.Bottom + rightBottomRadius.y, rightBottomRadius.x, rightBottomRadius.y,
                               Math.PI + Math.PI * 0.5, 0.0);
                    currentProcessingArc.rewind(0);
                    state++;
                    goto case 3;

                case 3:
                    cmd = currentProcessingArc.vertex(out x, out y);
                    if (ShapePath.is_stop(cmd))
                    {
                        state++;
                    }
                    else
                    {
                        return ShapePath.FlagsAndCommand.CommandLineTo;
                    }
                    goto case 4;

                case 4:
                    currentProcessingArc.init(bounds.Right - rightTopRadius.x, bounds.Top - rightTopRadius.y, rightTopRadius.x, rightTopRadius.y,
                               0.0, Math.PI * 0.5);
                    currentProcessingArc.rewind(0);
                    state++;
                    goto case 5;

                case 5:
                    cmd = currentProcessingArc.vertex(out x, out y);
                    if (ShapePath.is_stop(cmd))
                    {
                        state++;
                    }
                    else
                    {
                        return ShapePath.FlagsAndCommand.CommandLineTo;
                    }
                    goto case 6;

                case 6:
                    currentProcessingArc.init(bounds.Left + leftTopRadius.x, bounds.Top - leftTopRadius.y, leftTopRadius.x, leftTopRadius.y,
                               Math.PI * 0.5, Math.PI);
                    currentProcessingArc.rewind(0);
                    state++;
                    goto case 7;

                case 7:
                    cmd = currentProcessingArc.vertex(out x, out y);
                    if (ShapePath.is_stop(cmd))
                    {
                        state++;
                    }
                    else
                    {
                        return ShapePath.FlagsAndCommand.CommandLineTo;
                    }
                    goto case 8;

                case 8:
                    cmd = ShapePath.FlagsAndCommand.CommandEndPoly
                        | ShapePath.FlagsAndCommand.FlagClose
                        | ShapePath.FlagsAndCommand.FlagCCW;
                    state++;
                    break;
            }
            return cmd;
        }
    };
}


#endregion //RoundedRect.cs
#region ScanlineRasterizer.cs

namespace MatterHackers.Agg
{
    //==================================================rasterizer_scanline_aa
    // Polygon rasterizer that is used to render filled polygons with 
    // high-quality Anti-Aliasing. Internally, by default, the class uses 
    // integer coordinates in format 24.8, i.e. 24 bits for integer part 
    // and 8 bits for fractional - see poly_subpixel_shift. This class can be 
    // used in the following  way:
    //
    // 1. filling_rule(filling_rule_e ft) - optional.
    //
    // 2. gamma() - optional.
    //
    // 3. reset()
    //
    // 4. move_to(x, y) / line_to(x, y) - make the polygon. One can create 
    //    more than one contour, but each contour must consist of at least 3
    //    vertices, i.e. move_to(x1, y1); line_to(x2, y2); line_to(x3, y3);
    //    is the absolute minimum of vertices that define a triangle.
    //    The algorithm does not check either the number of vertices nor
    //    coincidence of their coordinates, but in the worst case it just 
    //    won't draw anything.
    //    The order of the vertices (clockwise or counterclockwise) 
    //    is important when using the non-zero filling rule (fill_non_zero).
    //    In this case the vertex order of all the contours must be the same
    //    if you want your intersecting polygons to be without "holes".
    //    You actually can use different vertices order. If the contours do not 
    //    intersect each other the order is not important anyway. If they do, 
    //    contours with the same vertex order will be rendered without "holes" 
    //    while the intersecting contours with different orders will have "holes".
    //
    // filling_rule() and gamma() can be called anytime before "sweeping".
    //------------------------------------------------------------------------
    public interface IRasterizer
    {
        int min_x();
        int min_y();
        int max_x();
        int max_y();

        void gamma(IGammaFunction gamma_function);

        bool sweep_scanline(IScanlineCache sl);
        void reset();
        void add_path(IVertexSource vs);
        void add_path(IVertexSource vs, int pathID);
        bool rewind_scanlines();
    }

    public sealed class ScanlineRasterizer : IRasterizer
    {
        private rasterizer_cells_aa m_outline;
        private VectorClipper m_VectorClipper;
        private int[] m_gamma = new int[(int)aa_scale_e.aa_scale];
        private agg_basics.filling_rule_e m_filling_rule;
        private bool m_auto_close;
        private int m_start_x;
        private int m_start_y;
        private status m_status;
        private int m_scan_y;

        public enum status
        {
            status_initial,
            status_move_to,
            status_line_to,
            status_closed
        };

        public enum aa_scale_e
        {
            aa_shift = 8,
            aa_scale = 1 << aa_shift,
            aa_mask = aa_scale - 1,
            aa_scale2 = aa_scale * 2,
            aa_mask2 = aa_scale2 - 1
        };

        public ScanlineRasterizer()
            : this(new VectorClipper())
        {
        }

        //--------------------------------------------------------------------
        public ScanlineRasterizer(VectorClipper rasterizer_sl_clip)
        {
            m_outline = new rasterizer_cells_aa();
            m_VectorClipper = rasterizer_sl_clip;
            m_filling_rule = MatterHackers.Agg.agg_basics.filling_rule_e.fill_non_zero;
            m_auto_close = true;
            m_start_x = 0;
            m_start_y = 0;
            m_status = status.status_initial;

            for (int i = 0; i < (int)aa_scale_e.aa_scale; i++)
            {
                m_gamma[i] = i;
            }
        }

        /*
        //--------------------------------------------------------------------
        public rasterizer_scanline_aa(IClipper rasterizer_sl_clip, IGammaFunction gamma_function)
        {
            m_outline = new rasterizer_cells_aa();
            m_clipper = rasterizer_sl_clip;
            m_filling_rule = filling_rule_e.fill_non_zero;
            m_auto_close = true;
            m_start_x = 0;
            m_start_y = 0;
            m_status = status.status_initial;

            gamma(gamma_function);
        }*/

        //--------------------------------------------------------------------
        public void reset()
        {
            m_outline.reset();
            m_status = status.status_initial;
        }

        public void reset_clipping()
        {
            reset();
            m_VectorClipper.reset_clipping();
        }

        public RectangleDouble GetVectorClipBox()
        {
            return new RectangleDouble(
                m_VectorClipper.downscale(m_VectorClipper.clipBox.Left),
                m_VectorClipper.downscale(m_VectorClipper.clipBox.Bottom),
                m_VectorClipper.downscale(m_VectorClipper.clipBox.Right),
                m_VectorClipper.downscale(m_VectorClipper.clipBox.Top));
        }

        public void SetVectorClipBox(RectangleDouble clippingRect)
        {
            SetVectorClipBox(clippingRect.Left, clippingRect.Bottom, clippingRect.Right, clippingRect.Top);
        }

        public void SetVectorClipBox(double x1, double y1, double x2, double y2)
        {
            reset();
            m_VectorClipper.clip_box(m_VectorClipper.upscale(x1), m_VectorClipper.upscale(y1),
                               m_VectorClipper.upscale(x2), m_VectorClipper.upscale(y2));
        }

        public void filling_rule(agg_basics.filling_rule_e filling_rule)
        {
            m_filling_rule = filling_rule;
        }

        public void auto_close(bool flag) { m_auto_close = flag; }

        //--------------------------------------------------------------------
        public void gamma(IGammaFunction gamma_function)
        {
            for (int i = 0; i < (int)aa_scale_e.aa_scale; i++)
            {
                m_gamma[i] = (int)agg_basics.uround(gamma_function.GetGamma((double)(i) / (int)aa_scale_e.aa_mask) * (int)aa_scale_e.aa_mask);
            }
        }

        /*
        //--------------------------------------------------------------------
        public int apply_gamma(int cover) 
        { 
        	return (int)m_gamma[cover];
        }
         */

        //--------------------------------------------------------------------
        void move_to(int x, int y)
        {
            if (m_outline.sorted()) reset();
            if (m_auto_close) close_polygon();
            m_VectorClipper.move_to(m_start_x = m_VectorClipper.downscale(x),
                              m_start_y = m_VectorClipper.downscale(y));
            m_status = status.status_move_to;
        }

        //------------------------------------------------------------------------
        void line_to(int x, int y)
        {
            m_VectorClipper.line_to(m_outline,
                              m_VectorClipper.downscale(x),
                              m_VectorClipper.downscale(y));
            m_status = status.status_line_to;
        }

        //------------------------------------------------------------------------
        public void move_to_d(double x, double y)
        {
            if (m_outline.sorted()) reset();
            if (m_auto_close) close_polygon();
            m_VectorClipper.move_to(m_start_x = m_VectorClipper.upscale(x),
                              m_start_y = m_VectorClipper.upscale(y));
            m_status = status.status_move_to;
        }

        //------------------------------------------------------------------------
        public void line_to_d(double x, double y)
        {
            m_VectorClipper.line_to(m_outline,
                              m_VectorClipper.upscale(x),
                              m_VectorClipper.upscale(y));
            m_status = status.status_line_to;
        }

        public void close_polygon()
        {
            if (m_status == status.status_line_to)
            {
                m_VectorClipper.line_to(m_outline, m_start_x, m_start_y);
                m_status = status.status_closed;
            }
        }

        void AddVertex(VertexData vertexData)
        {
            if (ShapePath.is_move_to(vertexData.command))
            {
                move_to_d(vertexData.position.x, vertexData.position.y);
            }
            else
            {
                if (ShapePath.is_vertex(vertexData.command))
                {
                    line_to_d(vertexData.position.x, vertexData.position.y);
                }
                else
                {
                    if (ShapePath.is_close(vertexData.command))
                    {
                        close_polygon();
                    }
                }
            }
        }
        //------------------------------------------------------------------------
        void edge(int x1, int y1, int x2, int y2)
        {
            if (m_outline.sorted()) reset();
            m_VectorClipper.move_to(m_VectorClipper.downscale(x1), m_VectorClipper.downscale(y1));
            m_VectorClipper.line_to(m_outline,
                              m_VectorClipper.downscale(x2),
                              m_VectorClipper.downscale(y2));
            m_status = status.status_move_to;
        }

        //------------------------------------------------------------------------
        void edge_d(double x1, double y1, double x2, double y2)
        {
            if (m_outline.sorted()) reset();
            m_VectorClipper.move_to(m_VectorClipper.upscale(x1), m_VectorClipper.upscale(y1));
            m_VectorClipper.line_to(m_outline,
                              m_VectorClipper.upscale(x2),
                              m_VectorClipper.upscale(y2));
            m_status = status.status_move_to;
        }

        //-------------------------------------------------------------------
        public void add_path(IVertexSource vs)
        {
            add_path(vs, 0);
        }

        public void add_path(IVertexSource vs, int pathID)
        {
#if false
            if (m_outline.sorted())
            {
                reset();
            }

            foreach (VertexData vertexData in vs.Vertices())
            {
                if(!ShapePath.is_stop(vertexData.command))
                {
                    AddVertex(new VertexData(vertexData.command, new Vector2(vertexData.position.x, vertexData.position.y)));
                }
            }
#else
            double x = 0;
            double y = 0;

            ShapePath.FlagsAndCommand PathAndFlags;
            vs.rewind(pathID);
            if (m_outline.sorted())
            {
                reset();
            }

            while (!ShapePath.is_stop(PathAndFlags = vs.vertex(out x, out y)))
            {
                AddVertex(new VertexData(PathAndFlags, new Vector2(x, y)));
            }
#endif
        }

        //--------------------------------------------------------------------
        public int min_x() { return m_outline.min_x(); }
        public int min_y() { return m_outline.min_y(); }
        public int max_x() { return m_outline.max_x(); }
        public int max_y() { return m_outline.max_y(); }

        //--------------------------------------------------------------------
        void sort()
        {
            if (m_auto_close) close_polygon();
            m_outline.sort_cells();
        }

        //------------------------------------------------------------------------
        public bool rewind_scanlines()
        {
            if (m_auto_close) close_polygon();
            m_outline.sort_cells();
            if (m_outline.total_cells() == 0)
            {
                return false;
            }
            m_scan_y = m_outline.min_y();
            return true;
        }

        //------------------------------------------------------------------------
        bool navigate_scanline(int y)
        {
            if (m_auto_close) close_polygon();
            m_outline.sort_cells();
            if (m_outline.total_cells() == 0 ||
               y < m_outline.min_y() ||
               y > m_outline.max_y())
            {
                return false;
            }
            m_scan_y = y;
            return true;
        }

        //--------------------------------------------------------------------
        public int calculate_alpha(int area)
        {
            int cover = area >> ((int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_shift * 2 + 1 - (int)aa_scale_e.aa_shift);

            if (cover < 0)
            {
                cover = -cover;
            }

            if (m_filling_rule == MatterHackers.Agg.agg_basics.filling_rule_e.fill_even_odd)
            {
                cover &= (int)aa_scale_e.aa_mask2;
                if (cover > (int)aa_scale_e.aa_scale)
                {
                    cover = (int)aa_scale_e.aa_scale2 - cover;
                }
            }

            if (cover > (int)aa_scale_e.aa_mask)
            {
                cover = (int)aa_scale_e.aa_mask;
            }

            return (int)m_gamma[cover];
        }

        //--------------------------------------------------------------------
        public bool sweep_scanline(IScanlineCache scanlineCache)
        {
            for (; ; )
            {
                if (m_scan_y > m_outline.max_y())
                {
                    return false;
                }

                scanlineCache.ResetSpans();
                int num_cells = (int)m_outline.scanline_num_cells(m_scan_y);
                cell_aa[] cells;
                int Offset;
                m_outline.scanline_cells(m_scan_y, out cells, out Offset);
                int cover = 0;

                while (num_cells != 0)
                {
                    cell_aa cur_cell = cells[Offset];
                    int x = cur_cell.x;
                    int area = cur_cell.area;
                    int alpha;

                    cover += cur_cell.cover;

                    //accumulate all cells with the same X
                    while (--num_cells != 0)
                    {
                        Offset++;
                        cur_cell = cells[Offset];
                        if (cur_cell.x != x)
                        {
                            break;
                        }

                        area += cur_cell.area;
                        cover += cur_cell.cover;
                    }

                    if (area != 0)
                    {
                        alpha = calculate_alpha((cover << ((int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_shift + 1)) - area);
                        if (alpha != 0)
                        {
                            scanlineCache.add_cell(x, alpha);
                        }
                        x++;
                    }

                    if ((num_cells != 0) && (cur_cell.x > x))
                    {
                        alpha = calculate_alpha(cover << ((int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_shift + 1));
                        if (alpha != 0)
                        {
                            scanlineCache.add_span(x, (cur_cell.x - x), alpha);
                        }
                    }
                }

                if (scanlineCache.num_spans() != 0) break;
                ++m_scan_y;
            }

            scanlineCache.finalize(m_scan_y);
            ++m_scan_y;
            return true;
        }

        //--------------------------------------------------------------------
        bool hit_test(int tx, int ty)
        {
            if (!navigate_scanline(ty)) return false;
            //scanline_hit_test sl(tx);
            //sweep_scanline(sl);
            //return sl.hit();
            return true;
        }
    };
}

#endregion //ScanlineRasterizer.cs
#region ScanlineRenderer.cs

namespace MatterHackers.Agg
{
    public class ScanlineRenderer
    {
        VectorPOD<RGBA_Bytes> tempSpanColors = new VectorPOD<RGBA_Bytes>();
        VectorPOD<RGBA_Floats> tempSpanColorsFloats = new VectorPOD<RGBA_Floats>();

        public void render_scanlines_aa_solid(IImageByte destImage, IRasterizer rasterizer, IScanlineCache scanLine, RGBA_Bytes color)
        {
            if (rasterizer.rewind_scanlines())
            {
                scanLine.reset(rasterizer.min_x(), rasterizer.max_x());
                while (rasterizer.sweep_scanline(scanLine))
                {
                    RenderSolidSingleScanLine(destImage, scanLine, color);
                }
            }
        }

        public void RenderSolid(IImageFloat destImage, IRasterizer rasterizer, IScanlineCache scanLine, RGBA_Floats color)
        {
            if (rasterizer.rewind_scanlines())
            {
                scanLine.reset(rasterizer.min_x(), rasterizer.max_x());
                while (rasterizer.sweep_scanline(scanLine))
                {
                    RenderSolidSingleScanLine(destImage, scanLine, color);
                }
            }
        }

        protected virtual void RenderSolidSingleScanLine(IImageByte destImage, IScanlineCache scanLine, RGBA_Bytes color)
        {
            int y = scanLine.y();
            int num_spans = scanLine.num_spans();
            ScanlineSpan scanlineSpan = scanLine.begin();

            byte[] ManagedCoversArray = scanLine.GetCovers();
            for (; ; )
            {
                int x = scanlineSpan.x;
                if (scanlineSpan.len > 0)
                {
                    destImage.blend_solid_hspan(x, y, scanlineSpan.len, color, ManagedCoversArray, scanlineSpan.cover_index);
                }
                else
                {
                    int x2 = (x - (int)scanlineSpan.len - 1);
                    destImage.blend_hline(x, y, x2, color, ManagedCoversArray[scanlineSpan.cover_index]);
                }
                if (--num_spans == 0) break;
                scanlineSpan = scanLine.GetNextScanlineSpan();
            }
        }

        private void RenderSolidSingleScanLine(IImageFloat destImage, IScanlineCache scanLine, RGBA_Floats color)
        {
            int y = scanLine.y();
            int num_spans = scanLine.num_spans();
            ScanlineSpan scanlineSpan = scanLine.begin();

            byte[] ManagedCoversArray = scanLine.GetCovers();
            for (; ; )
            {
                int x = scanlineSpan.x;
                if (scanlineSpan.len > 0)
                {
                    destImage.blend_solid_hspan(x, y, scanlineSpan.len, color, ManagedCoversArray, scanlineSpan.cover_index);
                }
                else
                {
                    int x2 = (x - (int)scanlineSpan.len - 1);
                    destImage.blend_hline(x, y, x2, color, ManagedCoversArray[scanlineSpan.cover_index]);
                }
                if (--num_spans == 0) break;
                scanlineSpan = scanLine.GetNextScanlineSpan();
            }
        }

        public void RenderSolidAllPaths(IImageByte destImage,
            IRasterizer ras,
            IScanlineCache sl,
            IVertexSource vs,
            RGBA_Bytes[] color_storage,
            int[] path_id,
            int num_paths)
        {
            for (int i = 0; i < num_paths; i++)
            {
                ras.reset();

                ras.add_path(vs, path_id[i]);

                render_scanlines_aa_solid(destImage, ras, sl, color_storage[i]);
            }
        }

        private void GenerateAndRenderSingleScanline(IScanlineCache scanLineCache, IImageByte destImage, span_allocator alloc, ISpanGenerator span_gen)
        {
            int y = scanLineCache.y();
            int num_spans = scanLineCache.num_spans();
            ScanlineSpan scanlineSpan = scanLineCache.begin();

            byte[] ManagedCoversArray = scanLineCache.GetCovers();
            for (; ; )
            {
                int x = scanlineSpan.x;
                int len = scanlineSpan.len;
                if (len < 0) len = -len;

                if (tempSpanColors.Capacity() < len)
                {
                    tempSpanColors.Capacity(len);
                }

                span_gen.generate(tempSpanColors.Array, 0, x, y, len);
                bool useFirstCoverForAll = scanlineSpan.len < 0;
                destImage.blend_color_hspan(x, y, len, tempSpanColors.Array, 0, ManagedCoversArray, scanlineSpan.cover_index, useFirstCoverForAll);

                if (--num_spans == 0) break;
                scanlineSpan = scanLineCache.GetNextScanlineSpan();
            }
        }

        private void GenerateAndRenderSingleScanline(IScanlineCache scanLineCache, IImageFloat destImageFloat, span_allocator alloc, ISpanGeneratorFloat span_gen)
        {
            int y = scanLineCache.y();
            int num_spans = scanLineCache.num_spans();
            ScanlineSpan scanlineSpan = scanLineCache.begin();

            byte[] ManagedCoversArray = scanLineCache.GetCovers();
            for (; ; )
            {
                int x = scanlineSpan.x;
                int len = scanlineSpan.len;
                if (len < 0) len = -len;

                if (tempSpanColorsFloats.Capacity() < len)
                {
                    tempSpanColorsFloats.Capacity(len);
                }

                span_gen.generate(tempSpanColorsFloats.Array, 0, x, y, len);
                bool useFirstCoverForAll = scanlineSpan.len < 0;
                destImageFloat.blend_color_hspan(x, y, len, tempSpanColorsFloats.Array, 0, ManagedCoversArray, scanlineSpan.cover_index, useFirstCoverForAll);

                if (--num_spans == 0) break;
                scanlineSpan = scanLineCache.GetNextScanlineSpan();
            }
        }

        public void GenerateAndRender(IRasterizer rasterizer, IScanlineCache scanlineCache, IImageByte destImage, span_allocator spanAllocator, ISpanGenerator spanGenerator)
        {
            if (rasterizer.rewind_scanlines())
            {
                scanlineCache.reset(rasterizer.min_x(), rasterizer.max_x());
                spanGenerator.prepare();
                while (rasterizer.sweep_scanline(scanlineCache))
                {
                    GenerateAndRenderSingleScanline(scanlineCache, destImage, spanAllocator, spanGenerator);
                }
            }
        }

        public void GenerateAndRender(IRasterizer rasterizer, IScanlineCache scanlineCache, IImageFloat destImage, span_allocator spanAllocator, ISpanGeneratorFloat spanGenerator)
        {
            if (rasterizer.rewind_scanlines())
            {
                scanlineCache.reset(rasterizer.min_x(), rasterizer.max_x());
                spanGenerator.prepare();
                while (rasterizer.sweep_scanline(scanlineCache))
                {
                    GenerateAndRenderSingleScanline(scanlineCache, destImage, spanAllocator, spanGenerator);
                }
            }
        }

        public void RenderCompound(rasterizer_compound_aa ras, IScanlineCache sl_aa, IScanlineCache sl_bin, IImageByte imageFormat, span_allocator alloc, IStyleHandler sh)
        {
#if false
            unsafe
            {
                if (ras.rewind_scanlines())
                {
                    int min_x = ras.min_x();
                    int len = ras.max_x() - min_x + 2;
                    sl_aa.reset(min_x, ras.max_x());
                    sl_bin.reset(min_x, ras.max_x());

                    //typedef typename BaseRenderer::color_type color_type;
                    ArrayPOD<RGBA_Bytes> color_span = alloc.allocate((int)len * 2);
                    byte[] ManagedCoversArray = sl_aa.GetCovers();
                    fixed (byte* pCovers = ManagedCoversArray)
                    {
                        fixed (RGBA_Bytes* pColorSpan = color_span.Array)
                        {
                            int mix_bufferOffset = len;
                            int num_spans;

                            int num_styles;
                            int style;
                            bool solid;
                            while ((num_styles = ras.sweep_styles()) > 0)
                            {
                                if (num_styles == 1)
                                {
                                    // Optimization for a single style. Happens often
                                    //-------------------------
                                    if (ras.sweep_scanline(sl_aa, 0))
                                    {
                                        style = ras.style(0);
                                        if (sh.is_solid(style))
                                        {
                                            // Just solid fill
                                            //-----------------------
                                            RenderSolidSingleScanLine(imageFormat, sl_aa, sh.color(style));
                                        }
                                        else
                                        {
                                            // Arbitrary span generator
                                            //-----------------------
                                            ScanlineSpan span_aa = sl_aa.Begin();
                                            num_spans = sl_aa.num_spans();
                                            for (; ; )
                                            {
                                                len = span_aa.len;
                                                sh.generate_span(pColorSpan,
                                                                 span_aa.x,
                                                                 sl_aa.y(),
                                                                 (int)len,
                                                                 style);

                                                imageFormat.blend_color_hspan(span_aa.x,
                                                                      sl_aa.y(),
                                                                      (int)span_aa.len,
                                                                      pColorSpan,
                                                                      &pCovers[span_aa.cover_index], 0);
                                                if (--num_spans == 0) break;
                                                span_aa = sl_aa.GetNextScanlineSpan();
                                            }
                                        }
                                    }
                                }
                                else // there are multiple styles
                                {
                                    if (ras.sweep_scanline(sl_bin, -1))
                                    {
                                        // Clear the spans of the mix_buffer
                                        //--------------------
                                        ScanlineSpan span_bin = sl_bin.Begin();
                                        num_spans = sl_bin.num_spans();
                                        for (; ; )
                                        {
                                            agg_basics.MemClear((byte*)&pColorSpan[mix_bufferOffset + span_bin.x - min_x],
                                                   span_bin.len * sizeof(RGBA_Bytes));

                                            if (--num_spans == 0) break;
                                            span_bin = sl_bin.GetNextScanlineSpan();
                                        }

                                        for (int i = 0; i < num_styles; i++)
                                        {
                                            style = ras.style(i);
                                            solid = sh.is_solid(style);

                                            if (ras.sweep_scanline(sl_aa, (int)i))
                                            {
                                                //IColorType* colors;
                                                //IColorType* cspan;
                                                //typename ScanlineAA::cover_type* covers;
                                                ScanlineSpan span_aa = sl_aa.Begin();
                                                num_spans = sl_aa.num_spans();
                                                if (solid)
                                                {
                                                    // Just solid fill
                                                    //-----------------------
                                                    for (; ; )
                                                    {
                                                        RGBA_Bytes c = sh.color(style);
                                                        len = span_aa.len;
                                                        RGBA_Bytes* colors = &pColorSpan[mix_bufferOffset + span_aa.x - min_x];
                                                        byte* covers = &pCovers[span_aa.cover_index];
                                                        do
                                                        {
                                                            if (*covers == cover_full)
                                                            {
                                                                *colors = c;
                                                            }
                                                            else
                                                            {
                                                                colors->add(c, *covers);
                                                            }
                                                            ++colors;
                                                            ++covers;
                                                        }
                                                        while (--len != 0);
                                                        if (--num_spans == 0) break;
                                                        span_aa = sl_aa.GetNextScanlineSpan();
                                                    }
                                                }
                                                else
                                                {
                                                    // Arbitrary span generator
                                                    //-----------------------
                                                    for (; ; )
                                                    {
                                                        len = span_aa.len;
                                                        RGBA_Bytes* colors = &pColorSpan[mix_bufferOffset + span_aa.x - min_x];
                                                        RGBA_Bytes* cspan = pColorSpan;
                                                        sh.generate_span(cspan,
                                                                         span_aa.x,
                                                                         sl_aa.y(),
                                                                         (int)len,
                                                                         style);
                                                        byte* covers = &pCovers[span_aa.cover_index];
                                                        do
                                                        {
                                                            if (*covers == cover_full)
                                                            {
                                                                *colors = *cspan;
                                                            }
                                                            else
                                                            {
                                                                colors->add(*cspan, *covers);
                                                            }
                                                            ++cspan;
                                                            ++colors;
                                                            ++covers;
                                                        }
                                                        while (--len != 0);
                                                        if (--num_spans == 0) break;
                                                        span_aa = sl_aa.GetNextScanlineSpan();
                                                    }
                                                }
                                            }
                                        }

                                        // Emit the blended result as a color hspan
                                        //-------------------------
                                        span_bin = sl_bin.Begin();
                                        num_spans = sl_bin.num_spans();
                                        for (; ; )
                                        {
                                            imageFormat.blend_color_hspan(span_bin.x,
                                                                  sl_bin.y(),
                                                                  (int)span_bin.len,
                                                                  &pColorSpan[mix_bufferOffset + span_bin.x - min_x],
                                                                  null,
                                                                  cover_full);
                                            if (--num_spans == 0) break;
                                            span_bin = sl_bin.GetNextScanlineSpan();
                                        }
                                    } // if(ras.sweep_scanline(sl_bin, -1))
                                } // if(num_styles == 1) ... else
                            } // while((num_styles = ras.sweep_styles()) > 0)
                        }
                    }
                } // if(ras.rewind_scanlines())
            }
#endif
        }
    }
}

#endregion //ScanlineRenderer.cs
#region ShapePath.cs

namespace MatterHackers.Agg
{
    public static class ShapePath
    {
        [Flags]
        public enum FlagsAndCommand
        {
            CommandStop = 0x00,
            CommandMoveTo = 0x01,
            CommandLineTo = 0x02,
            CommandCurve3 = 0x03,
            CommandCurve4 = 0x04,
            CommandEndPoly = 0x0F,
            CommandsMask = 0x0F,

            FlagNone = 0x00,
            FlagCCW = 0x10,
            FlagCW = 0x20,
            FlagClose = 0x40,
            FlagsMask = 0xF0
        };

        public static bool is_vertex(FlagsAndCommand c)
        {
            return c >= FlagsAndCommand.CommandMoveTo
                && c < FlagsAndCommand.CommandEndPoly;
        }

        public static bool is_drawing(FlagsAndCommand c)
        {
            return c >= FlagsAndCommand.CommandLineTo && c < FlagsAndCommand.CommandEndPoly;
        }

        public static bool is_stop(FlagsAndCommand c)
        {
            return c == FlagsAndCommand.CommandStop;
        }

        public static bool is_move_to(FlagsAndCommand c)
        {
            return c == FlagsAndCommand.CommandMoveTo;
        }

        public static bool is_line_to(FlagsAndCommand c)
        {
            return c == FlagsAndCommand.CommandLineTo;
        }

        public static bool is_curve(FlagsAndCommand c)
        {
            return c == FlagsAndCommand.CommandCurve3
                || c == FlagsAndCommand.CommandCurve4;
        }

        public static bool is_curve3(FlagsAndCommand c)
        {
            return c == FlagsAndCommand.CommandCurve3;
        }

        public static bool is_curve4(FlagsAndCommand c)
        {
            return c == FlagsAndCommand.CommandCurve4;
        }

        public static bool is_end_poly(FlagsAndCommand c)
        {
            return (c & FlagsAndCommand.CommandsMask) == FlagsAndCommand.CommandEndPoly;
        }

        public static bool is_close(FlagsAndCommand c)
        {
            return (c & ~(FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW)) ==
                   (FlagsAndCommand.CommandEndPoly | FlagsAndCommand.FlagClose);
        }

        public static bool is_next_poly(FlagsAndCommand c)
        {
            return is_stop(c) || is_move_to(c) || is_end_poly(c);
        }

        public static bool is_cw(FlagsAndCommand c)
        {
            return (c & FlagsAndCommand.FlagCW) != 0;
        }

        public static bool is_ccw(FlagsAndCommand c)
        {
            return (c & FlagsAndCommand.FlagCCW) != 0;
        }

        public static bool is_oriented(FlagsAndCommand c)
        {
            return (c & (FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW)) != 0;
        }

        public static bool is_closed(FlagsAndCommand c)
        {
            return (c & FlagsAndCommand.FlagClose) != 0;
        }

        public static FlagsAndCommand get_close_flag(FlagsAndCommand c)
        {
            return (FlagsAndCommand)(c & FlagsAndCommand.FlagClose);
        }

        public static FlagsAndCommand clear_orientation(FlagsAndCommand c)
        {
            return c & ~(FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW);
        }

        public static FlagsAndCommand get_orientation(FlagsAndCommand c)
        {
            return c & (FlagsAndCommand.FlagCW | FlagsAndCommand.FlagCCW);
        }

        /*
        //---------------------------------------------------------set_orientation
        public static path_flags_e set_orientation(int c, path_flags_e o)
        {
            return clear_orientation(c) | o;
        }
         */

        static public void shorten_path(MatterHackers.Agg.VertexSequence vs, double s)
        {
            shorten_path(vs, s, 0);
        }

        static public void shorten_path(VertexSequence vs, double s, int closed)
        {
            if (s > 0.0 && vs.size() > 1)
            {
                double d;
                int n = (int)(vs.size() - 2);
                while (n != 0)
                {
                    d = vs[n].dist;
                    if (d > s) break;
                    vs.RemoveLast();
                    s -= d;
                    --n;
                }
                if (vs.size() < 2)
                {
                    vs.remove_all();
                }
                else
                {
                    n = (int)vs.size() - 1;
                    VertexDistance prev = vs[n - 1];
                    VertexDistance last = vs[n];
                    d = (prev.dist - s) / prev.dist;
                    double x = prev.x + (last.x - prev.x) * d;
                    double y = prev.y + (last.y - prev.y) * d;
                    last.x = x;
                    last.y = y;
                    if (!prev.IsEqual(last)) vs.RemoveLast();
                    vs.close(closed != 0);
                }
            }
        }
    }
}

#endregion //ShapePath.cs
#region StringHelper.cs

namespace MatterHackers.Agg
{
    public static class StringHelper
    {
        public static string FormatWith(this string format, params object[] args)
        {
            if (format == null)
                throw new ArgumentNullException("format");
            return string.Format(format, args);
        }

        public static string FormatWith(this string format, IFormatProvider provider, params object[] args)
        {
            if (format == null)
                throw new ArgumentNullException("format");
            return string.Format(provider, format, args);
        }
    }
}

#endregion //StringHelper.cs
#region Stroke.cs

namespace MatterHackers.Agg.VertexSource
{
    public sealed class Stroke : VertexSourceAdapter
    {
        public Stroke(IVertexSource vertexSource, double inWidth = 1)
            : base(vertexSource, new StrokeGenerator())
        {
            width(inWidth);
        }

        public void line_cap(LineCap lc) { base.GetGenerator().line_cap(lc); }
        public void line_join(LineJoin lj) { base.GetGenerator().line_join(lj); }
        public void inner_join(InnerJoin ij) { base.GetGenerator().inner_join(ij); }

        public LineCap line_cap() { return base.GetGenerator().line_cap(); }
        public LineJoin line_join() { return base.GetGenerator().line_join(); }
        public InnerJoin inner_join() { return base.GetGenerator().inner_join(); }

        public double Width { get { return width(); } set { width(value); } }
        public void width(double w) { base.GetGenerator().width(w); }
        public void miter_limit(double ml) { base.GetGenerator().miter_limit(ml); }
        public void miter_limit_theta(double t) { base.GetGenerator().miter_limit_theta(t); }
        public void inner_miter_limit(double ml) { base.GetGenerator().inner_miter_limit(ml); }
        public void approximation_scale(double approxScale) { base.GetGenerator().approximation_scale(approxScale); }

        public double width() { return base.GetGenerator().width(); }
        public double miter_limit() { return base.GetGenerator().miter_limit(); }
        public double inner_miter_limit() { return base.GetGenerator().inner_miter_limit(); }
        public double approximation_scale() { return base.GetGenerator().approximation_scale(); }

        public void shorten(double s) { base.GetGenerator().shorten(s); }
        public double shorten() { return base.GetGenerator().shorten(); }
    }
}

#endregion //Stroke.cs
#region StrokeGenerator.cs

namespace MatterHackers.Agg.VertexSource
{
    class Vector2Container : VectorPOD<Vector2>, IVertexDest
    {

    }

    //============================================================vcgen_stroke
    class StrokeGenerator : IGenerator
    {
        StrokeMath m_stroker;

        VertexSequence m_src_vertices;
        Vector2Container m_out_vertices;

        double m_shorten;
        int m_closed;
        StrokeMath.status_e m_status;
        StrokeMath.status_e m_prev_status;

        int m_src_vertex;
        int m_out_vertex;

        public StrokeGenerator()
        {
            m_stroker = new StrokeMath();
            m_src_vertices = new VertexSequence();
            m_out_vertices = new Vector2Container();
            m_status = StrokeMath.status_e.initial;
        }

        public void line_cap(LineCap lc) { m_stroker.line_cap(lc); }
        public void line_join(LineJoin lj) { m_stroker.line_join(lj); }
        public void inner_join(InnerJoin ij) { m_stroker.inner_join(ij); }

        public LineCap line_cap() { return m_stroker.line_cap(); }
        public LineJoin line_join() { return m_stroker.line_join(); }
        public InnerJoin inner_join() { return m_stroker.inner_join(); }

        public void width(double w) { m_stroker.width(w); }
        public void miter_limit(double ml) { m_stroker.miter_limit(ml); }
        public void miter_limit_theta(double t) { m_stroker.miter_limit_theta(t); }
        public void inner_miter_limit(double ml) { m_stroker.inner_miter_limit(ml); }
        public void approximation_scale(double approx_scale) { m_stroker.approximation_scale(approx_scale); }

        public double width() { return m_stroker.width(); }
        public double miter_limit() { return m_stroker.miter_limit(); }
        public double inner_miter_limit() { return m_stroker.inner_miter_limit(); }
        public double approximation_scale() { return m_stroker.approximation_scale(); }

        public void auto_detect_orientation(bool v) { throw new Exception(); }
        public bool auto_detect_orientation() { throw new Exception(); }

        public void shorten(double s) { m_shorten = s; }
        public double shorten() { return m_shorten; }

        // Vertex Generator Interface
        public void RemoveAll()
        {
            m_src_vertices.remove_all();
            m_closed = 0;
            m_status = StrokeMath.status_e.initial;
        }

        public void AddVertex(double x, double y, ShapePath.FlagsAndCommand cmd)
        {
            m_status = StrokeMath.status_e.initial;
            if (ShapePath.is_move_to(cmd))
            {
                m_src_vertices.modify_last(new VertexDistance(x, y));
            }
            else
            {
                if (ShapePath.is_vertex(cmd))
                {
                    m_src_vertices.add(new VertexDistance(x, y));
                }
                else
                {
                    m_closed = (int)ShapePath.get_close_flag(cmd);
                }
            }
        }

        // Vertex Source Interface
        public void Rewind(int idx)
        {
            if (m_status == StrokeMath.status_e.initial)
            {
                m_src_vertices.close(m_closed != 0);
                ShapePath.shorten_path(m_src_vertices, m_shorten, m_closed);
                if (m_src_vertices.size() < 3) m_closed = 0;
            }
            m_status = StrokeMath.status_e.ready;
            m_src_vertex = 0;
            m_out_vertex = 0;
        }

        public ShapePath.FlagsAndCommand Vertex(ref double x, ref double y)
        {
            ShapePath.FlagsAndCommand cmd = ShapePath.FlagsAndCommand.CommandLineTo;
            while (!ShapePath.is_stop(cmd))
            {
                switch (m_status)
                {
                    case StrokeMath.status_e.initial:
                        Rewind(0);
                        goto case StrokeMath.status_e.ready;

                    case StrokeMath.status_e.ready:
                        if (m_src_vertices.size() < 2 + (m_closed != 0 ? 1 : 0))
                        {
                            cmd = ShapePath.FlagsAndCommand.CommandStop;
                            break;
                        }
                        m_status = (m_closed != 0) ? StrokeMath.status_e.outline1 : StrokeMath.status_e.cap1;
                        cmd = ShapePath.FlagsAndCommand.CommandMoveTo;
                        m_src_vertex = 0;
                        m_out_vertex = 0;
                        break;

                    case StrokeMath.status_e.cap1:
                        m_stroker.calc_cap(m_out_vertices, m_src_vertices[0], m_src_vertices[1],
                            m_src_vertices[0].dist);
                        m_src_vertex = 1;
                        m_prev_status = StrokeMath.status_e.outline1;
                        m_status = StrokeMath.status_e.out_vertices;
                        m_out_vertex = 0;
                        break;

                    case StrokeMath.status_e.cap2:
                        m_stroker.calc_cap(m_out_vertices,
                            m_src_vertices[m_src_vertices.size() - 1],
                            m_src_vertices[m_src_vertices.size() - 2],
                            m_src_vertices[m_src_vertices.size() - 2].dist);
                        m_prev_status = StrokeMath.status_e.outline2;
                        m_status = StrokeMath.status_e.out_vertices;
                        m_out_vertex = 0;
                        break;

                    case StrokeMath.status_e.outline1:
                        if (m_closed != 0)
                        {
                            if (m_src_vertex >= m_src_vertices.size())
                            {
                                m_prev_status = StrokeMath.status_e.close_first;
                                m_status = StrokeMath.status_e.end_poly1;
                                break;
                            }
                        }
                        else
                        {
                            if (m_src_vertex >= m_src_vertices.size() - 1)
                            {
                                m_status = StrokeMath.status_e.cap2;
                                break;
                            }
                        }
                        m_stroker.calc_join(m_out_vertices,
                            m_src_vertices.prev(m_src_vertex),
                            m_src_vertices.curr(m_src_vertex),
                            m_src_vertices.next(m_src_vertex),
                            m_src_vertices.prev(m_src_vertex).dist,
                            m_src_vertices.curr(m_src_vertex).dist);
                        ++m_src_vertex;
                        m_prev_status = m_status;
                        m_status = StrokeMath.status_e.out_vertices;
                        m_out_vertex = 0;
                        break;

                    case StrokeMath.status_e.close_first:
                        m_status = StrokeMath.status_e.outline2;
                        cmd = ShapePath.FlagsAndCommand.CommandMoveTo;
                        goto case StrokeMath.status_e.outline2;

                    case StrokeMath.status_e.outline2:
                        if (m_src_vertex <= (m_closed == 0 ? 1 : 0))
                        {
                            m_status = StrokeMath.status_e.end_poly2;
                            m_prev_status = StrokeMath.status_e.stop;
                            break;
                        }

                        --m_src_vertex;
                        m_stroker.calc_join(m_out_vertices,
                            m_src_vertices.next(m_src_vertex),
                            m_src_vertices.curr(m_src_vertex),
                            m_src_vertices.prev(m_src_vertex),
                            m_src_vertices.curr(m_src_vertex).dist,
                            m_src_vertices.prev(m_src_vertex).dist);

                        m_prev_status = m_status;
                        m_status = StrokeMath.status_e.out_vertices;
                        m_out_vertex = 0;
                        break;

                    case StrokeMath.status_e.out_vertices:
                        if (m_out_vertex >= m_out_vertices.size())
                        {
                            m_status = m_prev_status;
                        }
                        else
                        {
                            Vector2 c = m_out_vertices[(int)m_out_vertex++];
                            x = c.x;
                            y = c.y;
                            return cmd;
                        }
                        break;

                    case StrokeMath.status_e.end_poly1:
                        m_status = m_prev_status;
                        return ShapePath.FlagsAndCommand.CommandEndPoly
                            | ShapePath.FlagsAndCommand.FlagClose
                            | ShapePath.FlagsAndCommand.FlagCCW;

                    case StrokeMath.status_e.end_poly2:
                        m_status = m_prev_status;
                        return ShapePath.FlagsAndCommand.CommandEndPoly
                            | ShapePath.FlagsAndCommand.FlagClose
                            | ShapePath.FlagsAndCommand.FlagCW;

                    case StrokeMath.status_e.stop:
                        cmd = ShapePath.FlagsAndCommand.CommandStop;
                        break;
                }
            }
            return cmd;
        }
    }
}

#endregion //StrokeGenerator.cs
#region StrokeMath.cs

namespace MatterHackers.Agg.VertexSource
{
    public enum LineCap
    {
        Butt,
        Square,
        Round
    }

    public enum LineJoin
    {
        Miter,
        MiterRevert,
        Round,
        Bevel,
        MiterRound
    }

    public enum InnerJoin
    {
        Bevel,
        Miter,
        Jag,
        Round
    }

    public class StrokeMath
    {
        public enum status_e
        {
            initial,
            ready,
            cap1,
            cap2,
            outline1,
            close_first,
            outline2,
            out_vertices,
            end_poly1,
            end_poly2,
            stop
        };

        double m_width;
        double m_width_abs;
        double m_width_eps;
        int m_width_sign;
        double m_miter_limit;
        double m_inner_miter_limit;
        double m_approx_scale;
        LineCap m_line_cap;
        LineJoin m_line_join;
        InnerJoin m_inner_join;

        public StrokeMath()
        {
            m_width = 0.5;
            m_width_abs = 0.5;
            m_width_eps = 0.5 / 1024.0;
            m_width_sign = 1;
            m_miter_limit = 4.0;
            m_inner_miter_limit = 1.01;
            m_approx_scale = 1.0;
            m_line_cap = LineCap.Butt;
            m_line_join = LineJoin.Miter;
            m_inner_join = InnerJoin.Miter;
        }

        public void line_cap(LineCap lc) { m_line_cap = lc; }
        public void line_join(LineJoin lj) { m_line_join = lj; }
        public void inner_join(InnerJoin ij) { m_inner_join = ij; }

        public LineCap line_cap() { return m_line_cap; }
        public LineJoin line_join() { return m_line_join; }
        public InnerJoin inner_join() { return m_inner_join; }

        public void width(double w)
        {
            m_width = w * 0.5;
            if (m_width < 0)
            {
                m_width_abs = -m_width;
                m_width_sign = -1;
            }
            else
            {
                m_width_abs = m_width;
                m_width_sign = 1;
            }
            m_width_eps = m_width / 1024.0;
        }

        public void miter_limit(double ml) { m_miter_limit = ml; }
        public void miter_limit_theta(double t)
        {
            m_miter_limit = 1.0 / Math.Sin(t * 0.5);
        }

        public void inner_miter_limit(double ml) { m_inner_miter_limit = ml; }
        public void approximation_scale(double aproxScale) { m_approx_scale = aproxScale; }

        public double width() { return m_width * 2.0; }
        public double miter_limit() { return m_miter_limit; }
        public double inner_miter_limit() { return m_inner_miter_limit; }
        public double approximation_scale() { return m_approx_scale; }

        public void calc_cap(IVertexDest vc, VertexDistance v0, VertexDistance v1, double len)
        {
            vc.remove_all();

            double dx1 = (v1.y - v0.y) / len;
            double dy1 = (v1.x - v0.x) / len;
            double dx2 = 0;
            double dy2 = 0;

            dx1 *= m_width;
            dy1 *= m_width;

            if (m_line_cap != LineCap.Round)
            {
                if (m_line_cap == LineCap.Square)
                {
                    dx2 = dy1 * m_width_sign;
                    dy2 = dx1 * m_width_sign;
                }
                add_vertex(vc, v0.x - dx1 - dx2, v0.y + dy1 - dy2);
                add_vertex(vc, v0.x + dx1 - dx2, v0.y - dy1 - dy2);
            }
            else
            {
                double da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;
                double a1;
                int i;
                int n = (int)(Math.PI / da);

                da = Math.PI / (n + 1);
                add_vertex(vc, v0.x - dx1, v0.y + dy1);
                if (m_width_sign > 0)
                {
                    a1 = Math.Atan2(dy1, -dx1);
                    a1 += da;
                    for (i = 0; i < n; i++)
                    {
                        add_vertex(vc, v0.x + Math.Cos(a1) * m_width,
                                       v0.y + Math.Sin(a1) * m_width);
                        a1 += da;
                    }
                }
                else
                {
                    a1 = Math.Atan2(-dy1, dx1);
                    a1 -= da;
                    for (i = 0; i < n; i++)
                    {
                        add_vertex(vc, v0.x + Math.Cos(a1) * m_width,
                                       v0.y + Math.Sin(a1) * m_width);
                        a1 -= da;
                    }
                }
                add_vertex(vc, v0.x + dx1, v0.y - dy1);
            }
        }

        public void calc_join(IVertexDest vc, VertexDistance v0,
                                        VertexDistance v1,
                                        VertexDistance v2,
                                        double len1,
                                        double len2)
        {
            double dx1 = m_width * (v1.y - v0.y) / len1;
            double dy1 = m_width * (v1.x - v0.x) / len1;
            double dx2 = m_width * (v2.y - v1.y) / len2;
            double dy2 = m_width * (v2.x - v1.x) / len2;

            vc.remove_all();

            double cp = agg_math.cross_product(v0.x, v0.y, v1.x, v1.y, v2.x, v2.y);
            if (cp != 0 && (cp > 0) == (m_width > 0))
            {
                // Inner join
                //---------------
                double limit = ((len1 < len2) ? len1 : len2) / m_width_abs;
                if (limit < m_inner_miter_limit)
                {
                    limit = m_inner_miter_limit;
                }

                switch (m_inner_join)
                {
                    default: // inner_bevel
                        add_vertex(vc, v1.x + dx1, v1.y - dy1);
                        add_vertex(vc, v1.x + dx2, v1.y - dy2);
                        break;

                    case InnerJoin.Miter:
                        calc_miter(vc,
                                   v0, v1, v2, dx1, dy1, dx2, dy2,
                                   LineJoin.MiterRevert,
                                   limit, 0);
                        break;

                    case InnerJoin.Jag:
                    case InnerJoin.Round:
                        cp = (dx1 - dx2) * (dx1 - dx2) + (dy1 - dy2) * (dy1 - dy2);
                        if (cp < len1 * len1 && cp < len2 * len2)
                        {
                            calc_miter(vc,
                                       v0, v1, v2, dx1, dy1, dx2, dy2,
                                       LineJoin.MiterRevert,
                                       limit, 0);
                        }
                        else
                        {
                            if (m_inner_join == InnerJoin.Jag)
                            {
                                add_vertex(vc, v1.x + dx1, v1.y - dy1);
                                add_vertex(vc, v1.x, v1.y);
                                add_vertex(vc, v1.x + dx2, v1.y - dy2);
                            }
                            else
                            {
                                add_vertex(vc, v1.x + dx1, v1.y - dy1);
                                add_vertex(vc, v1.x, v1.y);
                                calc_arc(vc, v1.x, v1.y, dx2, -dy2, dx1, -dy1);
                                add_vertex(vc, v1.x, v1.y);
                                add_vertex(vc, v1.x + dx2, v1.y - dy2);
                            }
                        }
                        break;
                }
            }
            else
            {
                // Outer join
                //---------------

                // Calculate the distance between v1 and 
                // the central point of the bevel line segment
                //---------------
                double dx = (dx1 + dx2) / 2;
                double dy = (dy1 + dy2) / 2;
                double dbevel = Math.Sqrt(dx * dx + dy * dy);

                if (m_line_join == LineJoin.Round || m_line_join == LineJoin.Bevel)
                {
                    // This is an optimization that reduces the number of points 
                    // in cases of almost collinear segments. If there's no
                    // visible difference between bevel and miter joins we'd rather
                    // use miter join because it adds only one point instead of two. 
                    //
                    // Here we calculate the middle point between the bevel points 
                    // and then, the distance between v1 and this middle point. 
                    // At outer joins this distance always less than stroke width, 
                    // because it's actually the height of an isosceles triangle of
                    // v1 and its two bevel points. If the difference between this
                    // width and this value is small (no visible bevel) we can 
                    // add just one point. 
                    //
                    // The constant in the expression makes the result approximately 
                    // the same as in round joins and caps. You can safely comment 
                    // out this entire "if".
                    //-------------------
                    if (m_approx_scale * (m_width_abs - dbevel) < m_width_eps)
                    {
                        if (agg_math.calc_intersection(v0.x + dx1, v0.y - dy1,
                                             v1.x + dx1, v1.y - dy1,
                                             v1.x + dx2, v1.y - dy2,
                                             v2.x + dx2, v2.y - dy2,
                                             out dx, out dy))
                        {
                            add_vertex(vc, dx, dy);
                        }
                        else
                        {
                            add_vertex(vc, v1.x + dx1, v1.y - dy1);
                        }
                        return;
                    }
                }

                switch (m_line_join)
                {
                    case LineJoin.Miter:
                    case LineJoin.MiterRevert:
                    case LineJoin.MiterRound:
                        calc_miter(vc,
                                   v0, v1, v2, dx1, dy1, dx2, dy2,
                                   m_line_join,
                                   m_miter_limit,
                                   dbevel);
                        break;

                    case LineJoin.Round:
                        calc_arc(vc, v1.x, v1.y, dx1, -dy1, dx2, -dy2);
                        break;

                    default: // Bevel join
                        add_vertex(vc, v1.x + dx1, v1.y - dy1);
                        add_vertex(vc, v1.x + dx2, v1.y - dy2);
                        break;
                }
            }
        }

        private void add_vertex(IVertexDest vc, double x, double y)
        {
            vc.add(new Vector2(x, y));
        }

        void calc_arc(IVertexDest vc,
                      double x, double y,
                      double dx1, double dy1,
                      double dx2, double dy2)
        {
            double a1 = Math.Atan2(dy1 * m_width_sign, dx1 * m_width_sign);
            double a2 = Math.Atan2(dy2 * m_width_sign, dx2 * m_width_sign);
            double da = a1 - a2;
            int i, n;

            da = Math.Acos(m_width_abs / (m_width_abs + 0.125 / m_approx_scale)) * 2;

            add_vertex(vc, x + dx1, y + dy1);
            if (m_width_sign > 0)
            {
                if (a1 > a2) a2 += 2 * Math.PI;
                n = (int)((a2 - a1) / da);
                da = (a2 - a1) / (n + 1);
                a1 += da;
                for (i = 0; i < n; i++)
                {
                    add_vertex(vc, x + Math.Cos(a1) * m_width, y + Math.Sin(a1) * m_width);
                    a1 += da;
                }
            }
            else
            {
                if (a1 < a2) a2 -= 2 * Math.PI;
                n = (int)((a1 - a2) / da);
                da = (a1 - a2) / (n + 1);
                a1 -= da;
                for (i = 0; i < n; i++)
                {
                    add_vertex(vc, x + Math.Cos(a1) * m_width, y + Math.Sin(a1) * m_width);
                    a1 -= da;
                }
            }
            add_vertex(vc, x + dx2, y + dy2);
        }

        void calc_miter(IVertexDest vc,
                        VertexDistance v0,
                        VertexDistance v1,
                        VertexDistance v2,
                        double dx1, double dy1,
                        double dx2, double dy2,
                        LineJoin lj,
                        double mlimit,
                        double dbevel)
        {
            double xi = v1.x;
            double yi = v1.y;
            double di = 1;
            double lim = m_width_abs * mlimit;
            bool miter_limit_exceeded = true; // Assume the worst
            bool intersection_failed = true; // Assume the worst

            if (agg_math.calc_intersection(v0.x + dx1, v0.y - dy1,
                                 v1.x + dx1, v1.y - dy1,
                                 v1.x + dx2, v1.y - dy2,
                                 v2.x + dx2, v2.y - dy2,
                                 out xi, out yi))
            {
                // Calculation of the intersection succeeded
                //---------------------
                di = agg_math.calc_distance(v1.x, v1.y, xi, yi);
                if (di <= lim)
                {
                    // Inside the miter limit
                    //---------------------
                    add_vertex(vc, xi, yi);
                    miter_limit_exceeded = false;
                }
                intersection_failed = false;
            }
            else
            {
                // Calculation of the intersection failed, most probably
                // the three points lie one straight line. 
                // First check if v0 and v2 lie on the opposite sides of vector: 
                // (v1.x, v1.y) -> (v1.x+dx1, v1.y-dy1), that is, the perpendicular
                // to the line determined by vertices v0 and v1.
                // This condition determines whether the next line segments continues
                // the previous one or goes back.
                //----------------
                double x2 = v1.x + dx1;
                double y2 = v1.y - dy1;
                if ((agg_math.cross_product(v0.x, v0.y, v1.x, v1.y, x2, y2) < 0.0) ==
                   (agg_math.cross_product(v1.x, v1.y, v2.x, v2.y, x2, y2) < 0.0))
                {
                    // This case means that the next segment continues 
                    // the previous one (straight line)
                    //-----------------
                    add_vertex(vc, v1.x + dx1, v1.y - dy1);
                    miter_limit_exceeded = false;
                }
            }

            if (miter_limit_exceeded)
            {
                // Miter limit exceeded
                //------------------------
                switch (lj)
                {
                    case LineJoin.MiterRevert:
                        // For the compatibility with SVG, PDF, etc, 
                        // we use a simple bevel join instead of
                        // "smart" bevel
                        //-------------------
                        add_vertex(vc, v1.x + dx1, v1.y - dy1);
                        add_vertex(vc, v1.x + dx2, v1.y - dy2);
                        break;

                    case LineJoin.MiterRound:
                        calc_arc(vc, v1.x, v1.y, dx1, -dy1, dx2, -dy2);
                        break;

                    default:
                        // If no miter-revert, calculate new dx1, dy1, dx2, dy2
                        //----------------
                        if (intersection_failed)
                        {
                            mlimit *= m_width_sign;
                            add_vertex(vc, v1.x + dx1 + dy1 * mlimit,
                                           v1.y - dy1 + dx1 * mlimit);
                            add_vertex(vc, v1.x + dx2 - dy2 * mlimit,
                                           v1.y - dy2 - dx2 * mlimit);
                        }
                        else
                        {
                            double x1 = v1.x + dx1;
                            double y1 = v1.y - dy1;
                            double x2 = v1.x + dx2;
                            double y2 = v1.y - dy2;
                            di = (lim - dbevel) / (di - dbevel);
                            add_vertex(vc, x1 + (xi - x1) * di,
                                           y1 + (yi - y1) * di);
                            add_vertex(vc, x2 + (xi - x2) * di,
                                           y2 + (yi - y2) * di);
                        }
                        break;
                }
            }
        }
    }
}

#endregion //StrokeMath.cs
#region StyledTypeFace.cs

namespace MatterHackers.Agg.Font
{
    public class GlyphWithUnderline : IVertexSource
    {
        int state = 0;
        IVertexSource underline;
        IVertexSource glyph;

        public GlyphWithUnderline(IVertexSource glyph, int advanceForCharacter, int Underline_position, int Underline_thickness)
        {
            underline = new RoundedRect(new RectangleDouble(0, Underline_position, advanceForCharacter, Underline_position + Underline_thickness), 0);
            this.glyph = glyph;
        }

        public IEnumerable<VertexData> Vertices()
        {
            // return all the data for the glyph
            foreach (VertexData vertexData in glyph.Vertices())
            {
                if (ShapePath.is_stop(vertexData.command))
                {
                    break;
                }
                yield return vertexData;
            }

            // then the underline
            foreach (VertexData vertexData in underline.Vertices())
            {
                yield return vertexData;
            }
        }

        public void rewind(int path_id)
        {
            underline.rewind(0);
            glyph.rewind(path_id);
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = 0;
            y = 0;
            ShapePath.FlagsAndCommand cmd = ShapePath.FlagsAndCommand.CommandStop;
            switch (state)
            {
                case 0:
                    cmd = glyph.vertex(out x, out y);
                    if (ShapePath.is_stop(cmd))
                    {
                        state++;
                        goto case 1;
                    }
                    return cmd;

                case 1:
                    cmd = underline.vertex(out x, out y);
                    break;
            }
            return cmd;
        }
    }

    public class StyledTypeFaceImageCache
    {
        static StyledTypeFaceImageCache instance;

        Dictionary<RGBA_Bytes, Dictionary<TypeFace, Dictionary<double, Dictionary<char, ImageBuffer>>>> typeFaceImageCache = new Dictionary<RGBA_Bytes, Dictionary<TypeFace, Dictionary<double, Dictionary<char, ImageBuffer>>>>();

        // private so you can't use it by accident (it is a singlton)
        StyledTypeFaceImageCache()
        {
        }

        public static Dictionary<char, ImageBuffer> GetCorrectCache(TypeFace typeFace, double emSizeInPoints, RGBA_Bytes color)
        {
            // check if the cache is getting too big and if so prune it (or just delete it and start over).

            Dictionary<TypeFace, Dictionary<double, Dictionary<char, ImageBuffer>>> foundTypeFaceColor;
            Instance.typeFaceImageCache.TryGetValue(color, out foundTypeFaceColor);
            if (foundTypeFaceColor == null)
            {
                // add in the type face
                foundTypeFaceColor = new Dictionary<TypeFace, Dictionary<double, Dictionary<char, ImageBuffer>>>();
                Instance.typeFaceImageCache.Add(color, foundTypeFaceColor);
            }

            Dictionary<double, Dictionary<char, ImageBuffer>> foundTypeFaceSizes;
            foundTypeFaceColor.TryGetValue(typeFace, out foundTypeFaceSizes);
            if (foundTypeFaceSizes == null)
            {
                // add in the type face
                foundTypeFaceSizes = new Dictionary<double, Dictionary<char, ImageBuffer>>();
                foundTypeFaceColor.Add(typeFace, foundTypeFaceSizes);
            }

            Dictionary<char, ImageBuffer> foundTypeFaceSize;
            foundTypeFaceSizes.TryGetValue(emSizeInPoints, out foundTypeFaceSize);
            if (foundTypeFaceSize == null)
            {
                // add in the point size
                foundTypeFaceSize = new Dictionary<char, ImageBuffer>();
                foundTypeFaceSizes.Add(emSizeInPoints, foundTypeFaceSize);
            }

            return foundTypeFaceSize;
        }

        static StyledTypeFaceImageCache Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new StyledTypeFaceImageCache();
                }

                return instance;
            }
        }
    }

    public class StyledTypeFace
    {
        TypeFace typeFace;

        const int PointsPerInch = 72;
        const int PixelsPerInch = 96;

        double emSizeInPixels;
        double currentEmScalling;
        bool flatenCurves = true;

        public StyledTypeFace(TypeFace typeFace, double emSizeInPoints, bool underline = false, bool flatenCurves = true)
        {
            this.typeFace = typeFace;
            emSizeInPixels = emSizeInPoints / PointsPerInch * PixelsPerInch;
            currentEmScalling = emSizeInPixels / typeFace.UnitsPerEm;
            DoUnderline = underline;
            FlatenCurves = flatenCurves;
        }

        public bool DoUnderline { get; set; }

        /// <summary>
        /// <para>If true the font will have it's curves flattened to the current point size when retrieved.</para>
        /// <para>You may want to disable this so you can flaten the curve after other transforms have been applied,</para>
        /// <para>such as skewing or scalling.  Rotation and Translation will not alter how a curve is flattened.</para>
        /// </summary>
        public bool FlatenCurves
        {
            get
            {
                return flatenCurves;
            }

            set
            {
                flatenCurves = value;
            }
        }

        /// <summary>
        /// Sets the Em size for the font in pixels.
        /// </summary>
        public double EmSizeInPixels
        {
            get
            {
                return emSizeInPixels;
            }
        }

        /// <summary>
        /// Sets the Em size for the font assuming there are 72 points per inch and there are 96 pixels per inch.
        /// </summary>
        public double EmSizeInPoints
        {
            get
            {
                return emSizeInPixels / PixelsPerInch * PointsPerInch;
            }
        }

        public double AscentInPixels
        {
            get
            {
                return typeFace.Ascent * currentEmScalling;
            }
        }

        public double DescentInPixels
        {
            get
            {
                return typeFace.Descent * currentEmScalling;
            }
        }

        public double XHeightInPixels
        {
            get
            {
                return typeFace.X_height * currentEmScalling;
            }
        }

        public double CapHeightInPixels
        {
            get
            {
                return typeFace.Cap_height * currentEmScalling;
            }
        }

        public RectangleDouble BoundingBoxInPixels
        {
            get
            {
                RectangleDouble pixelBounds = new RectangleDouble(typeFace.BoundingBox);
                pixelBounds *= currentEmScalling;
                return pixelBounds;
            }
        }

        public double UnderlineThicknessInPixels
        {
            get
            {
                return typeFace.Underline_thickness * currentEmScalling;
            }
        }

        public double UnderlinePositionInPixels
        {
            get
            {
                return typeFace.Underline_position * currentEmScalling;
            }
        }

        public ImageBuffer GetImageForCharacter(char character, double xFraction, double yFraction, RGBA_Bytes color)
        {
            if (xFraction > 1 || xFraction < 0 || yFraction > 1 || yFraction < 0)
            {
                throw new ArgumentException("The x and y fractions must both be between 0 and 1.");
            }

            ImageBuffer imageForCharacter;
            Dictionary<char, ImageBuffer> characterImageCache = StyledTypeFaceImageCache.GetCorrectCache(this.typeFace, this.emSizeInPixels, color);
            characterImageCache.TryGetValue(character, out imageForCharacter);
            if (imageForCharacter != null)
            {
                return imageForCharacter;
            }

            IVertexSource glyphForCharacter = GetGlyphForCharacter(character);
            if (glyphForCharacter == null)
            {
                return null;
            }

            glyphForCharacter.rewind(0);
            double x, y;
            ShapePath.FlagsAndCommand curCommand = glyphForCharacter.vertex(out x, out y);
            RectangleDouble bounds = new RectangleDouble(x, y, x, y);
            while (curCommand != ShapePath.FlagsAndCommand.CommandStop)
            {
                bounds.ExpandToInclude(x, y);
                curCommand = glyphForCharacter.vertex(out x, out y);
            }

            ImageBuffer charImage = new ImageBuffer(Math.Max((int)(bounds.Width + .5), 1), Math.Max((int)(bounds.Height + .5), 1), 32, new BlenderBGRA());
            charImage.NewGraphics2D().Render(glyphForCharacter, xFraction, yFraction, color);
            characterImageCache[character] = charImage;

            return charImage;
        }

        public IVertexSource GetGlyphForCharacter(char character)
        {
            // scale it to the correct size.
            IVertexSource sourceGlyph = typeFace.GetGlyphForCharacter(character);
            if (sourceGlyph != null)
            {
                if (DoUnderline)
                {
                    sourceGlyph = new GlyphWithUnderline(sourceGlyph, typeFace.GetAdvanceForCharacter(character), typeFace.Underline_position, typeFace.Underline_thickness);
                }
                Affine glyphTransform = Affine.NewIdentity();
                glyphTransform *= Affine.NewScaling(currentEmScalling, -currentEmScalling); //上下颠倒
                IVertexSource characterGlyph = new VertexSourceApplyTransform(sourceGlyph, glyphTransform);

                if (FlatenCurves)
                {
                    characterGlyph = new FlattenCurves(characterGlyph);
                }

                return characterGlyph;
            }

            return null;
        }

        public double GetAdvanceForCharacter(char character, char nextCharacterToKernWith)
        {
            return typeFace.GetAdvanceForCharacter(character, nextCharacterToKernWith) * currentEmScalling;
        }

        public double GetAdvanceForCharacter(char character)
        {
            return typeFace.GetAdvanceForCharacter(character) * currentEmScalling;
        }
    }
}

#endregion //StyledTypeFace.cs
#region SVGParser.cs

//namespace AGG
//{
//    public class SVGParser
//    {
//        public static IVertexSource PathStorageFromD(String DFromSVGFile, double xOffset, double yOffset)
//        {
//            PathStorage path = new PathStorage();
//            string[] splitOnSpace = DFromSVGFile.Split(' ');
//            string[] splitOnComma;
//            double xc1, yc1, xc2, yc2, x, y;
//            for (int i = 0; i < splitOnSpace.Length; i++)
//            {
//                switch (splitOnSpace[i++])
//                {
//                    case "M":
//                        {
//                            splitOnComma = splitOnSpace[i].Split(',');
//                            double.TryParse(splitOnComma[0], NumberStyles.Number, null, out x);
//                            double.TryParse(splitOnComma[1], NumberStyles.Number, null, out y);
//                            path.MoveTo(x, y + yOffset);
//                        }
//                        break;

//                    case "L":
//                        {
//                            splitOnComma = splitOnSpace[i].Split(',');
//                            double.TryParse(splitOnComma[0], NumberStyles.Number, null, out x);
//                            double.TryParse(splitOnComma[1], NumberStyles.Number, null, out y);
//                            path.LineTo(x, y + yOffset);
//                        }
//                        break;

//                    case "C":
//                        {
//                            splitOnComma = splitOnSpace[i++].Split(',');
//                            double.TryParse(splitOnComma[0], NumberStyles.Number, null, out xc1);
//                            double.TryParse(splitOnComma[1], NumberStyles.Number, null, out yc1);

//                            splitOnComma = splitOnSpace[i++].Split(',');
//                            double.TryParse(splitOnComma[0], NumberStyles.Number, null, out xc2);
//                            double.TryParse(splitOnComma[1], NumberStyles.Number, null, out yc2);

//                            splitOnComma = splitOnSpace[i].Split(',');
//                            double.TryParse(splitOnComma[0], NumberStyles.Number, null, out x);
//                            double.TryParse(splitOnComma[1], NumberStyles.Number, null, out y);
//                            path.curve4(xc1, yc1 + yOffset, xc2, yc2 + yOffset, x, y + yOffset);
//                        }
//                        break;

//                    case "z":
//                        if (i < splitOnSpace.Length)
//                        {
//                            throw new Exception();
//                        }
//                        break;

//                    default:
//                        throw new NotImplementedException();
//                }
//            }

//            path.arrange_orientations_all_paths(MatterHackers.Agg.ShapePath.FlagsAndCommand.FlagCW);
//            VertexSourceApplyTransform flipped = new VertexSourceApplyTransform(path, Affine.NewScaling(1, -1));
//            return flipped;
//        }
//    }

//    public class Glyph : IVertexSource
//    {
//        PathStorage glyphData;

//        public void rewind(int pathId)
//        {
//            glyphData.rewind(pathId);
//        }

//        public IEnumerable<VertexData> Vertices()
//        {
//            throw new NotImplementedException();
//        }

//        public MatterHackers.Agg.ShapePath.FlagsAndCommand vertex(out double x, out double y)
//        {
//            return glyphData.vertex(out x, out y);
//        }
//    }
//}

#endregion //SVGParser.cs
#region TextWrapping.cs

namespace MatterHackers.Agg.Font
{
    abstract public class TextWrapping
    {
        protected StyledTypeFace styledTypeFace;

        // you can't 
        public TextWrapping(StyledTypeFace styledTypeFace)
        {
            this.styledTypeFace = styledTypeFace;
        }

        public string InsertCRs(string textToWrap, double maxPixelWidth)
        {
            StringBuilder textWithCRs = new StringBuilder();
            string[] lines = WrapText(textToWrap, maxPixelWidth);
            for (int i = 0; i < lines.Length; i++)
            {
                string line = lines[i];
                if (i == 0)
                {
                    textWithCRs.Append(line);
                }
                else
                {
                    textWithCRs.Append("\n" + line);
                }
            }

            return textWithCRs.ToString();
        }

        public string[] WrapText(string textToWrap, double maxPixelWidth)
        {
            List<string> finalLines = new List<string>();
            string[] splitOnNL = textToWrap.Split('\n');
            foreach (string line in splitOnNL)
            {
                string[] linesFromWidth = WrapSingleLineOnWidth(line, maxPixelWidth);
                if (linesFromWidth.Length == 0)
                {
                    finalLines.Add("");
                }
                else
                {
                    finalLines.AddRange(linesFromWidth);
                }
            }

            return finalLines.ToArray();
        }

        abstract public string[] WrapSingleLineOnWidth(string originalTextToWrap, double maxPixelWidth);
    }

    public class EnglishTextWrapping : TextWrapping
    {
        public EnglishTextWrapping(StyledTypeFace styledTypeFace)
            : base(styledTypeFace)
        {
        }

        public EnglishTextWrapping(double pointSize)
            : base(new StyledTypeFace(LiberationSansFont.Instance, pointSize))
        {
        }

        public override string[] WrapSingleLineOnWidth(string originalTextToWrap, double maxPixelWidth)
        {
            List<string> lines = new List<string>();

            if (maxPixelWidth > 0)
            {
                string textToWrap = originalTextToWrap;
                while (textToWrap.Length > 0)
                {
                    TypeFacePrinter printer = new TypeFacePrinter(textToWrap);
                    int remainingLength = textToWrap.Length;
                    while (printer.GetSize().x > maxPixelWidth)
                    {
                        remainingLength--;
                        while (remainingLength > 1
                            && textToWrap.Substring(0, remainingLength).Contains(" ")
                            && textToWrap[remainingLength] != ' ')
                        {
                            remainingLength--;
                        }

                        printer.Text = textToWrap.Substring(0, remainingLength);
                    }

                    if (remainingLength >= 0)
                    {
                        lines.Add(textToWrap.Substring(0, remainingLength));
                    }


                    // check if we wrapped because of to long or a '\n'. If '\n' we only trim a leading space if to long.
                    if (remainingLength > 1 // we have more than 2 charecters left
                        && textToWrap.Length > remainingLength // we are longer than the remaining text
                        && textToWrap[remainingLength] == ' ' // the first new character is a space
                        && textToWrap[remainingLength - 1] != '\n') // the character before the space was not a cr (wrapped because of length)
                    {
                        textToWrap = textToWrap.Substring(remainingLength + 1);
                    }
                    else
                    {
                        textToWrap = textToWrap.Substring(remainingLength);
                    }
                }
            }
            else
            {
                lines.Add(originalTextToWrap);
            }

            return lines.ToArray();
        }
    }
}

#endregion //TextWrapping.cs
#region TimedLock.cs

namespace MatterHackers.Agg
{
#if DEBUG
    public class TimedLock : IDisposable
#else
    public struct TimedLock : IDisposable
#endif
    {
        static readonly int secondsToTryToLock = 3;
        private object target;
        string hint;
        bool gotLock;

        public static TimedLock Lock(object o, string hint)
        {
            return Lock(o, TimeSpan.FromSeconds(secondsToTryToLock), hint);
        }

        public static TimedLock Lock(object o, TimeSpan timeout, string hint)
        {
            TimedLock tl = new TimedLock(o, hint);
            if (!Monitor.TryEnter(o, timeout))
            {
#if DEBUG
                System.GC.SuppressFinalize(tl);
#endif
                string exceptionString = string.Format("Timeout waiting for lock: object type '{0}' content '{1}'",
                    o.GetType().ToString(),
                    o.ToString());
                throw new LockTimeoutException(exceptionString);
            }

            return tl;
        }

        public static TimedLock TryLock(object o, out bool gotLock, string hint)
        {
            TimedLock timedLock = new TimedLock(o, hint);
            if (!Monitor.TryEnter(o, 1))
            {
                timedLock.gotLock = false;
            }

            gotLock = timedLock.gotLock;
            return timedLock;
        }

        private TimedLock(object o, string hint)
        {
            gotLock = true;
            this.hint = hint;
            target = o;
        }

        public void Dispose()
        {
            if (gotLock)
            {
                Monitor.Exit(target);
            }

            // It's a bad error if someone forgets to call Dispose,
            // so in Debug builds, we put a finalizer in to detect
            // the error. If Dispose is called, we suppress the
            // finalizer.
#if DEBUG
            GC.SuppressFinalize(this);
#endif
        }

#if DEBUG
        ~TimedLock()
        {
            // If this finalizer runs, someone somewhere failed to
            // call Dispose, which means we've failed to leave
            // a monitor!
            //System.Diagnostics.Debug.Fail("Undisposed lock");
        }
#endif

    }
    public class LockTimeoutException : Exception
    {
        public LockTimeoutException(string message)
            : base(message)
        {
        }
    }
}

#endregion //TimedLock.cs
#region TrackBallController.cs

namespace MatterHackers.VectorMath
{
    public class TrackBallController
    {
        public enum MouseDownType { None, Translation, Rotation, Scale };

        private const double Epsilon = 1.0e-5;
        Vector2 screenCenter;
        double rotationTrackingRadius;

        MouseDownType currentTrackingType = MouseDownType.None;

        Matrix4X4 currentRotationMatrix = Matrix4X4.Identity;
        Matrix4X4 currentTranslationMatrix = Matrix4X4.Identity;

        Matrix4X4 localToScreenTransform;

        private Vector3 rotationStart;
        private Vector3 rotationCurrent;
        Quaternion activeRotationQuaternion = Quaternion.Identity;

        Vector2 lastTranslationMousePosition = Vector2.Zero;
        Vector2 lastScaleMousePosition = Vector2.Zero;

        public TrackBallController()
            : this(new Vector2(), 1)
        {
        }

        public TrackBallController(Vector2 screenCenter, double trackBallRadius)
        {
            rotationStart = new Vector3();
            rotationCurrent = new Vector3();
            this.screenCenter = screenCenter;
            this.rotationTrackingRadius = trackBallRadius;
        }

        public TrackBallController(TrackBallController trackBallToCopy)
        {
            this.screenCenter = trackBallToCopy.screenCenter;
            this.rotationTrackingRadius = trackBallToCopy.rotationTrackingRadius;
            this.currentRotationMatrix = trackBallToCopy.currentRotationMatrix;
            this.currentTranslationMatrix = trackBallToCopy.currentTranslationMatrix;
        }

        public double Scale
        {
            get
            {
                Vector3 scaledUnitVector = Vector3.TransformPosition(Vector3.UnitX, this.GetTransform4X4());
                return scaledUnitVector.Length;
            }

            set
            {
                double requiredChange = value / Scale;

                currentTranslationMatrix *= Matrix4X4.CreateScale(requiredChange);
            }
        }

        public void Translate(Vector3 deltaPosition)
        {
            currentTranslationMatrix = Matrix4X4.CreateTranslation(deltaPosition) * currentTranslationMatrix;
        }

        public MouseDownType CurrentTrackingType
        {
            get
            {
                return currentTrackingType;
            }
        }

        private void MapToSphere(Vector2 screenPoint, out Vector3 vector)
        {
            Vector2 deltaFromCenter = screenPoint - screenCenter;
            Vector2 deltaMinus1To1 = deltaFromCenter;

            //Adjust point coords and scale down to range of [-1 ... 1]
            deltaMinus1To1.x = (deltaMinus1To1.x / rotationTrackingRadius);
            deltaMinus1To1.y = (deltaMinus1To1.y / rotationTrackingRadius);

            //Compute square of the length of the vector from this point to the center
            double length = (deltaMinus1To1.x * deltaMinus1To1.x) + (deltaMinus1To1.y * deltaMinus1To1.y);

            //If the point is mapped outside the sphere... (length > radius squared)
            if (length > 1.0)
            {
                //Compute a normalizing factor (radius / sqrt(length))
                double normalizedLength = (1.0 / Math.Sqrt(length));

                //Return the "normalized" vector, a point on the sphere
                vector.x = deltaMinus1To1.x * normalizedLength;
                vector.y = deltaMinus1To1.y * normalizedLength;
                vector.z = 0.0;
            }
            else //Else it's inside
            {
                //Return a vector to a point mapped inside the sphere sqrt(radius squared - length)
                vector.x = deltaMinus1To1.x;
                vector.y = deltaMinus1To1.y;
                vector.z = Math.Sqrt(1.0 - length);
            }

            vector = Vector3.TransformVector(vector, localToScreenTransform);
        }

        //Mouse down
        public virtual void OnMouseDown(Vector2 mousePosition, Matrix4X4 screenToLocal, MouseDownType trackType = MouseDownType.Rotation)
        {
            if (currentTrackingType == MouseDownType.None)
            {
                localToScreenTransform = Matrix4X4.Invert(screenToLocal);
                currentTrackingType = trackType;
                switch (currentTrackingType)
                {
                    case MouseDownType.Rotation:
                        MapToSphere(mousePosition, out rotationStart);
                        break;

                    case MouseDownType.Translation:
                        lastTranslationMousePosition = mousePosition;
                        break;

                    case MouseDownType.Scale:
                        lastScaleMousePosition = mousePosition;
                        break;

                    default:
                        throw new NotImplementedException();
                }
            }
        }

        //Mouse drag, calculate rotation
        public void OnMouseMove(Vector2 mousePosition)
        {
            switch (currentTrackingType)
            {
                case MouseDownType.Rotation:
                    activeRotationQuaternion = Quaternion.Identity;
                    //Map the point to the sphere
                    MapToSphere(mousePosition, out rotationCurrent);

                    //Return the quaternion equivalent to the rotation
                    //Compute the vector perpendicular to the begin and end vectors
                    Vector3 Perp = Vector3.Cross(rotationStart, rotationCurrent);

                    //Compute the length of the perpendicular vector
                    if (Perp.Length > Epsilon)
                    {
                        //if its non-zero
                        //We're ok, so return the perpendicular vector as the transform after all
                        activeRotationQuaternion.X = Perp.x;
                        activeRotationQuaternion.Y = Perp.y;
                        activeRotationQuaternion.Z = Perp.z;
                        //In the quaternion values, w is cosine (theta / 2), where theta is the rotation angle
                        activeRotationQuaternion.W = Vector3.Dot(rotationStart, rotationCurrent);
                    }
                    break;

                case MouseDownType.Translation:
                    {
                        Vector2 mouseDelta = mousePosition - lastTranslationMousePosition;
                        Vector2 scalledDelta = mouseDelta / screenCenter.x * 4.75;
                        Vector3 offset = new Vector3(scalledDelta.x, scalledDelta.y, 0);
                        offset = Vector3.TransformPosition(offset, Matrix4X4.Invert(CurrentRotation));
                        offset = Vector3.TransformPosition(offset, localToScreenTransform);
                        currentTranslationMatrix = currentTranslationMatrix * Matrix4X4.CreateTranslation(offset);
                        lastTranslationMousePosition = mousePosition;
                    }
                    break;

                case MouseDownType.Scale:
                    {
                        Vector2 mouseDelta = mousePosition - lastScaleMousePosition;
                        double zoomDelta = 1;
                        if (mouseDelta.y < 0)
                        {
                            zoomDelta = 1 - (-1 * mouseDelta.y / 100);
                        }
                        else if (mouseDelta.y > 0)
                        {
                            zoomDelta = 1 + (1 * mouseDelta.y / 100);
                        }
                        currentTranslationMatrix *= Matrix4X4.CreateScale(zoomDelta);
                        lastScaleMousePosition = mousePosition;
                    }
                    break;

                default:
                    throw new NotImplementedException();
            }
        }

        public void OnMouseUp()
        {
            switch (currentTrackingType)
            {
                case MouseDownType.Rotation:
                    currentRotationMatrix = currentRotationMatrix * Matrix4X4.CreateRotation(activeRotationQuaternion);
                    activeRotationQuaternion = Quaternion.Identity;
                    break;

                case MouseDownType.Translation:
                    //currentTranslationMatrix = Matrix4X4.Identity;
                    break;

                case MouseDownType.Scale:
                    break;

                default:
                    throw new NotImplementedException();
            }
            currentTrackingType = MouseDownType.None;
        }

        public void Rotate(Quaternion rotation)
        {
            currentRotationMatrix = currentRotationMatrix * Matrix4X4.CreateRotation(rotation);
        }

        public void OnMouseWheel(int wheelDelta)
        {
            double zoomDelta = 1;
            if (wheelDelta > 0)
            {
                zoomDelta = 1.2;
            }
            else if (wheelDelta < 0)
            {
                zoomDelta = .8;
            }

            currentTranslationMatrix *= Matrix4X4.CreateScale(zoomDelta);
        }

        public Matrix4X4 CurrentRotation
        {
            get
            {
                if (activeRotationQuaternion == Quaternion.Identity)
                {
                    return currentRotationMatrix;
                }

                return currentRotationMatrix * Matrix4X4.CreateRotation(activeRotationQuaternion);
            }
        }

        public Matrix4X4 GetTransform4X4()
        {
            return currentTranslationMatrix * CurrentRotation;
        }

        public Vector2 ScreenCenter
        {
            get { return screenCenter; }
            set { screenCenter = value; }
        }

        public double TrackBallRadius
        {
            get { return rotationTrackingRadius; }
            set { rotationTrackingRadius = value; }
        }
    }
}

#endregion //TrackBallController.cs
#region Transposer.cs

namespace MatterHackers.Agg.Image
{
    //=======================================================pixfmt_transposer
    public sealed class FormatTransposer : ImageProxy
    {
        public FormatTransposer(IImageByte pixelFormat)
            : base(pixelFormat)
        {
        }

        public override int Width { get { return linkedImage.Height; } }
        public override int Height { get { return linkedImage.Width; } }

        public override RGBA_Bytes GetPixel(int x, int y)
        {
            return linkedImage.GetPixel(y, x);
        }

        public override void copy_pixel(int x, int y, byte[] c, int ByteOffset)
        {
            linkedImage.copy_pixel(y, x, c, ByteOffset);
        }

        public override void copy_hline(int x, int y, int len, RGBA_Bytes c)
        {
            linkedImage.copy_vline(y, x, len, c);
        }


        public override void copy_vline(int x, int y, int len, RGBA_Bytes c)
        {
            linkedImage.copy_hline(y, x, len, c);
        }

        public override void blend_hline(int x1, int y, int x2, RGBA_Bytes c, byte cover)
        {
            linkedImage.blend_vline(y, x1, x2, c, cover);
        }

        public override void blend_vline(int x, int y1, int y2, RGBA_Bytes c, byte cover)
        {
            linkedImage.blend_hline(y1, x, y2, c, cover);
        }

        public override void blend_solid_hspan(int x, int y, int len, RGBA_Bytes c, byte[] covers, int coversIndex)
        {
            linkedImage.blend_solid_vspan(y, x, len, c, covers, coversIndex);
        }

        public override void blend_solid_vspan(int x, int y, int len, RGBA_Bytes c, byte[] covers, int coversIndex)
        {
            linkedImage.blend_solid_hspan(y, x, len, c, covers, coversIndex);
        }

        public override void copy_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            linkedImage.copy_color_vspan(y, x, len, colors, colorsIndex);
        }

        public override void copy_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex)
        {
            linkedImage.copy_color_hspan(y, x, len, colors, colorsIndex);
        }

        public override void blend_color_hspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            linkedImage.blend_color_vspan(y, x, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }

        public override void blend_color_vspan(int x, int y, int len, RGBA_Bytes[] colors, int colorsIndex, byte[] covers, int coversIndex, bool firstCoverForAll)
        {
            linkedImage.blend_color_hspan(y, x, len, colors, colorsIndex, covers, coversIndex, firstCoverForAll);
        }
    };
}

#endregion //Transposer.cs
#region TypeFace.cs

namespace MatterHackers.Agg.Font
{
    public class TypeFace
    {
        class Glyph
        {
            public int horiz_adv_x;
            public int unicode;
            public string glyphName;
            public PathStorage glyphData = new PathStorage();
        }

        class Panos_1
        {
            // these are defined in the order in which they are present in the panos-1 attribute.
            enum Family { Any, No_Fit, Latin_Text_and_Display, Latin_Script, Latin_Decorative, Latin_Pictorial };
            enum Serif_Style { Any, No_Fit, Cove, Obtuse_Cove, Square_Cove, Obtuse_Square_Cove, Square, Thin, Bone, Exaggerated, Triangle, Normal_Sans, Obtuse_Sans, Perp_Sans, Flared, Rounded };
            enum Weight { Any, No_Fit, Very_Light_100, Light_200, Thin_300, Book_400_same_as_CSS1_normal, Medium_500, Demi_600, Bold_700_same_as_CSS1_bold, Heavy_800, Black_900, Extra_Black_Nord_900_force_mapping_to_CSS1_100_900_scale };
            enum Proportion { Any, No_Fit, Old_Style, Modern, Even_Width, Expanded, Condensed, Very_Expanded, Very_Condensed, Monospaced };
            enum Contrast { Any, No_Fit, None, Very_Low, Low, Medium_Low, Medium, Medium_High, High, Very_High };
            enum Stroke_Variation { Any, No_Fit, No_Variation, Gradual_Diagonal, Gradual_Transitional, Gradual_Vertical, Gradual_Horizontal, Rapid_Vertical, Rapid_Horizontal, Instant_Horizontal, Instant_Vertical };
            enum Arm_Style { Any, No_Fit, Straight_Arms_Horizontal, Straight_Arms_Wedge, Straight_Arms_Vertical, Straight_Arms_Single_Serif, Straight_Arms_Double_Serif, Non_Straight_Arms_Horizontal, Non_Straight_Arms_Wedge, Non_Straight_Arms_Vertical_90, Non_Straight_Arms_Single_Serif, Non_Straight_Arms_Double_Serif };
            enum Letterform { Any, No_Fit, Normal_Contact, Normal_Weighted, Normal_Boxed, Normal_Flattened, Normal_Rounded, Normal_Off_Center, Normal_Square, Oblique_Contact, Oblique_Weighted, Oblique_Boxed, Oblique_Flattened, Oblique_Rounded, Oblique_Off_Center, Oblique_Square };
            enum Midline { Any, No_Fit, Standard_Trimmed, Standard_Pointed, Standard_Serifed, High_Trimmed, High_Pointed, High_Serifed, Constant_Trimmed, Constant_Pointed, Constant_Serifed, Low_Trimmed, Low_Pointed, Low_Serifed };
            enum XHeight { Any, No_Fit, Constant_Small, Constant_Standard, Constant_Large, Ducking_Small, Ducking_Standard, Ducking_Large };

            Family family;
            Serif_Style serifStyle;
            Weight weight;
            Proportion proportion;
            Contrast contrast;
            Stroke_Variation strokeVariation;
            Arm_Style armStyle;
            Letterform letterform;
            Midline midline;
            XHeight xHeight;

            public Panos_1(String SVGPanos1String)
            {
                int tempInt;
                String[] valuesString = SVGPanos1String.Split(' ');
                if (int.TryParse(valuesString[0], out tempInt))
                    family = (Family)tempInt;
                if (int.TryParse(valuesString[1], out tempInt))
                    serifStyle = (Serif_Style)tempInt;
                if (int.TryParse(valuesString[2], out tempInt))
                    weight = (Weight)tempInt;
                if (int.TryParse(valuesString[3], out tempInt))
                    proportion = (Proportion)tempInt;
                if (int.TryParse(valuesString[4], out tempInt))
                    contrast = (Contrast)tempInt;
                if (int.TryParse(valuesString[5], out tempInt))
                    strokeVariation = (Stroke_Variation)tempInt;
                if (int.TryParse(valuesString[6], out tempInt))
                    armStyle = (Arm_Style)tempInt;
                if (int.TryParse(valuesString[7], out tempInt))
                    letterform = (Letterform)tempInt;
                if (int.TryParse(valuesString[8], out tempInt))
                    midline = (Midline)tempInt;
                if (int.TryParse(valuesString[0], out tempInt))
                    xHeight = (XHeight)tempInt;
            }
        }

        String fontId;
        int horiz_adv_x;
        String fontFamily;
        int font_weight;
        String font_stretch;
        int unitsPerEm;
        Panos_1 panose_1;
        int ascent;
        public int Ascent { get { return ascent; } }
        int descent;
        public int Descent { get { return descent; } }
        int x_height;
        public int X_height { get { return x_height; } }
        int cap_height;
        public int Cap_height { get { return cap_height; } }
        RectangleInt boundingBox;
        public RectangleInt BoundingBox { get { return boundingBox; } }
        int underline_thickness;
        public int Underline_thickness { get { return underline_thickness; } }
        int underline_position;
        public int Underline_position { get { return underline_position; } }
        String unicode_range;

        Glyph missingGlyph;

        Dictionary<int, Glyph> glyphs = new Dictionary<int, Glyph>(); // a glyph is indexed by the string it represents, usually one character, but sometimes multiple
        Dictionary<Char, Dictionary<Char, int>> HKerns = new Dictionary<char, Dictionary<char, int>>();

        public int UnitsPerEm
        {
            get
            {
                return unitsPerEm;
            }
        }

        static String GetSubString(String source, String start, String end)
        {
            int startIndex = 0;
            return GetSubString(source, start, end, ref startIndex);
        }

        static String GetSubString(String source, String start, String end, ref int startIndex)
        {
            int startPos = source.IndexOf(start, startIndex);
            if (startPos >= 0)
            {
                int endPos = source.IndexOf(end, startPos + start.Length);

                int length = endPos - (startPos + start.Length);
                startIndex = endPos + end.Length; // advance our start position to the last position used
                return source.Substring(startPos + start.Length, length);
            }

            return null;
        }

        static String GetStringValue(String source, String name)
        {
            String element = GetSubString(source, name + "=\"", "\"");
            return element;
        }

        static bool GetIntValue(String source, String name, out int outValue, ref int startIndex)
        {
            String element = GetSubString(source, name + "=\"", "\"", ref startIndex);
            if (int.TryParse(element, NumberStyles.Number, null, out outValue))
            {
                return true;
            }

            return false;
        }

        static bool GetIntValue(String source, String name, out int outValue)
        {
            int startIndex = 0;
            return GetIntValue(source, name, out outValue, ref startIndex);
        }

        public static TypeFace LoadSVG(String filename)
        {
            TypeFace fontUnderConstruction = new TypeFace();

            string svgContent = "";
            using (System.IO.FileStream fileStream = new System.IO.FileStream(filename, System.IO.FileMode.Open, System.IO.FileAccess.Read, System.IO.FileShare.ReadWrite))
            {
                using (System.IO.StreamReader reader = new System.IO.StreamReader(fileStream))
                {
                    svgContent = reader.ReadToEnd();
                }
            }
            fontUnderConstruction.ReadSVG(svgContent);

            return fontUnderConstruction;
        }

        static Regex numberRegex = new Regex(@"[-+]?[0-9]*\.?[0-9]+");
        static double GetNextNumber(String source, ref int startIndex)
        {
            Match numberMatch = numberRegex.Match(source, startIndex);
            String returnString = numberMatch.Value;
            startIndex = numberMatch.Index + numberMatch.Length;
            double returnVal;
            double.TryParse(returnString, NumberStyles.Number, CultureInfo.InvariantCulture, out returnVal);
            return returnVal;
        }

        Glyph CreateGlyphFromSVGGlyphData(String SVGGlyphData)
        {
            Glyph newGlyph = new Glyph();
            if (!GetIntValue(SVGGlyphData, "horiz-adv-x", out newGlyph.horiz_adv_x))
            {
                newGlyph.horiz_adv_x = horiz_adv_x;
            }

            newGlyph.glyphName = GetStringValue(SVGGlyphData, "glyph-name");
            String unicodeString = GetStringValue(SVGGlyphData, "unicode");

            if (unicodeString != null)
            {
                if (unicodeString.Length == 1)
                {
                    newGlyph.unicode = (int)unicodeString[0];
                }
                else
                {
                    if (unicodeString.Split(';').Length > 1 && unicodeString.Split(';')[1].Length > 0)
                    {
                        throw new NotImplementedException("We do not currently support glyphs longer than one character.  You need to wirite the seach so that it will find them if you want to support this");
                    }

                    if (int.TryParse(unicodeString, NumberStyles.Number, null, out newGlyph.unicode) == false)
                    {
                        // see if it is a unicode 
                        String hexNumber = GetSubString(unicodeString, "&#x", ";");
                        int.TryParse(hexNumber, NumberStyles.HexNumber, null, out newGlyph.unicode);
                    }
                }
            }

            String dString = GetStringValue(SVGGlyphData, "d");

            int parseIndex = 0;
            int polyStartVertexSourceIndex = 0;
            Vector2 polyStart = new Vector2(0, 0);
            Vector2 lastXY = new Vector2(0, 0);
            Vector2 curXY;

            if (dString == null || dString.Length == 0)
            {
                return newGlyph;
            }

            while (parseIndex < dString.Length)
            {
                Char command = dString[parseIndex];
                switch (command)
                {
                    case 'M':
                        parseIndex++;
                        // svg fonts are stored cw and agg expects its shapes to be ccw.  cw shapes are holes.
                        // so we store the position of the start of this polygon so we can flip it when we colse it.
                        polyStartVertexSourceIndex = newGlyph.glyphData.size();
                        curXY.x = GetNextNumber(dString, ref parseIndex);
                        curXY.y = GetNextNumber(dString, ref parseIndex);

                        newGlyph.glyphData.MoveTo(curXY.x, curXY.y);
                        polyStart = curXY;
                        break;

                    case 'v':
                    case 'V':
                        parseIndex++;
                        curXY.x = lastXY.x;
                        curXY.y = GetNextNumber(dString, ref parseIndex);
                        if (command == 'v')
                        {
                            curXY.y += lastXY.y;
                        }

                        newGlyph.glyphData.VerticalLineTo(curXY.y);
                        break;

                    case 'h':
                    case 'H':
                        parseIndex++;
                        curXY.y = lastXY.y;
                        curXY.x = GetNextNumber(dString, ref parseIndex);
                        if (command == 'h')
                        {
                            curXY.x += lastXY.x;
                        }

                        newGlyph.glyphData.HorizontalLineTo(curXY.x);
                        break;

                    case 'l':
                    case 'L':
                        parseIndex++;
                        curXY.x = GetNextNumber(dString, ref parseIndex);
                        curXY.y = GetNextNumber(dString, ref parseIndex);
                        if (command == 'l')
                        {
                            curXY += lastXY;
                        }

                        newGlyph.glyphData.LineTo(curXY.x, curXY.y);
                        break;

                    case 'q':
                    case 'Q':
                        {
                            parseIndex++;
                            Vector2 controlPoint;
                            controlPoint.x = GetNextNumber(dString, ref parseIndex);
                            controlPoint.y = GetNextNumber(dString, ref parseIndex);
                            curXY.x = GetNextNumber(dString, ref parseIndex);
                            curXY.y = GetNextNumber(dString, ref parseIndex);
                            if (command == 'q')
                            {
                                controlPoint += lastXY;
                                curXY += lastXY;
                            }

                            newGlyph.glyphData.curve3(controlPoint.x, controlPoint.y, curXY.x, curXY.y);
                        }
                        break;

                    case 't':
                    case 'T':
                        parseIndex++;
                        curXY.x = GetNextNumber(dString, ref parseIndex);
                        curXY.y = GetNextNumber(dString, ref parseIndex);
                        if (command == 't')
                        {
                            curXY += lastXY;
                        }

                        newGlyph.glyphData.curve3(curXY.x, curXY.y);
                        break;

                    case 'z':
                    case 'Z':
                        parseIndex++;
                        curXY = lastXY; // value not used this is to remove an error.
                        //newGlyph.glyphData.ClosePathStorage();
                        newGlyph.glyphData.ClosePolygon();
                        // svg fonts are stored cw and agg expects its shapes to be ccw.  cw shapes are holes.
                        // We stored the position of the start of this polygon, no we flip it as we colse it.
                        newGlyph.glyphData.invert_polygon(polyStartVertexSourceIndex);
                        break;

                    case ' ':
                    case '\n': // some white space we need to skip
                    case '\r':
                        parseIndex++;
                        curXY = lastXY; // value not used this is to remove an error.
                        break;

                    default:
                        throw new NotImplementedException("unrecognized d command '" + command + "'.");
                }

                lastXY = curXY;
            }

            return newGlyph;
        }

#if NOT_XML_VERSION
        public void ReadSVG(String svgContent)
        {
            int startIndex = 0;
            String fontElementString = GetSubString(svgContent, "<font", ">", ref startIndex);
            fontId = GetStringValue(fontElementString, "id");
            GetIntValue(fontElementString, "horiz-adv-x", out horiz_adv_x);

            String fontFaceString = GetSubString(svgContent, "<font-face", "/>", ref startIndex);
            fontFamily = GetStringValue(fontFaceString, "font-family");
            GetIntValue(fontFaceString, "font-weight", out font_weight);
            font_stretch = GetStringValue(fontFaceString, "font-stretch");
            GetIntValue(fontFaceString, "units-per-em", out unitsPerEm);
            panose_1 = new Panos_1(GetStringValue(fontFaceString, "panose-1"));
            GetIntValue(fontFaceString, "ascent", out ascent);
            GetIntValue(fontFaceString, "descent", out descent);
            GetIntValue(fontFaceString, "x-height", out x_height);
            GetIntValue(fontFaceString, "cap-height", out cap_height);

            String bboxString = GetStringValue(fontFaceString, "bbox");
            String[] valuesString = bboxString.Split(' ');
            int.TryParse(valuesString[0], out boundingBox.Left);
            int.TryParse(valuesString[1], out boundingBox.Bottom);
            int.TryParse(valuesString[2], out boundingBox.Right);
            int.TryParse(valuesString[3], out boundingBox.Top);

            GetIntValue(fontFaceString, "underline-thickness", out underline_thickness);
            GetIntValue(fontFaceString, "underline-position", out underline_position);
            unicode_range = GetStringValue(fontFaceString, "unicode-range");

            String missingGlyphString = GetSubString(svgContent, "<missing-glyph", "/>", ref startIndex);
            missingGlyph = CreateGlyphFromSVGGlyphData(missingGlyphString);

            String nextGlyphString = GetSubString(svgContent, "<glyph", "/>", ref startIndex);
            while (nextGlyphString != null)
            {
                // get the data and put it in the glyph dictionary
                Glyph newGlyph = CreateGlyphFromSVGGlyphData(nextGlyphString);
                if (newGlyph.unicode > 0)
                {
                    glyphs.Add(newGlyph.unicode, newGlyph);
                }

                nextGlyphString = GetSubString(svgContent, "<glyph", "/>", ref startIndex);
            }
        }
#else
        public void ReadSVG(String svgContent)
        {
            int startIndex = 0;
            String fontElementString = GetSubString(svgContent, "<font", ">", ref startIndex);
            fontId = GetStringValue(fontElementString, "id");
            GetIntValue(fontElementString, "horiz-adv-x", out horiz_adv_x);

            String fontFaceString = GetSubString(svgContent, "<font-face", "/>", ref startIndex);
            fontFamily = GetStringValue(fontFaceString, "font-family");
            GetIntValue(fontFaceString, "font-weight", out font_weight);
            font_stretch = GetStringValue(fontFaceString, "font-stretch");
            GetIntValue(fontFaceString, "units-per-em", out unitsPerEm);
            panose_1 = new Panos_1(GetStringValue(fontFaceString, "panose-1"));
            GetIntValue(fontFaceString, "ascent", out ascent);
            GetIntValue(fontFaceString, "descent", out descent);
            GetIntValue(fontFaceString, "x-height", out x_height);
            GetIntValue(fontFaceString, "cap-height", out cap_height);

            String bboxString = GetStringValue(fontFaceString, "bbox");
            String[] valuesString = bboxString.Split(' ');
            int.TryParse(valuesString[0], out boundingBox.Left);
            int.TryParse(valuesString[1], out boundingBox.Bottom);
            int.TryParse(valuesString[2], out boundingBox.Right);
            int.TryParse(valuesString[3], out boundingBox.Top);

            GetIntValue(fontFaceString, "underline-thickness", out underline_thickness);
            GetIntValue(fontFaceString, "underline-position", out underline_position);
            unicode_range = GetStringValue(fontFaceString, "unicode-range");

            String missingGlyphString = GetSubString(svgContent, "<missing-glyph", "/>", ref startIndex);
            missingGlyph = CreateGlyphFromSVGGlyphData(missingGlyphString);

            String nextGlyphString = GetSubString(svgContent, "<glyph", "/>", ref startIndex);
            while (nextGlyphString != null)
            {
                // get the data and put it in the glyph dictionary
                Glyph newGlyph = CreateGlyphFromSVGGlyphData(nextGlyphString);
                if (newGlyph.unicode > 0)
                {
                    glyphs.Add(newGlyph.unicode, newGlyph);
                }

                nextGlyphString = GetSubString(svgContent, "<glyph", "/>", ref startIndex);
            }
        }
#endif

        internal IVertexSource GetGlyphForCharacter(char character)
        {
            // TODO: check for multi character glyphs (we don't currently support them in the reader).
            Glyph glyph;
            if (glyphs.TryGetValue(character, out glyph))
            {
                PathStorage writeableGlyph = new PathStorage();
                writeableGlyph.ShareVertexData(glyph.glyphData);
                return writeableGlyph;
            }

            return null;
        }

        internal int GetAdvanceForCharacter(char character, char nextCharacterToKernWith)
        {
            // TODO: check for kerning and adjust
            Glyph glyph;
            if (glyphs.TryGetValue(character, out glyph))
            {
                return glyph.horiz_adv_x;
            }

            return 0;
        }

        internal int GetAdvanceForCharacter(char character)
        {
            Glyph glyph;
            if (glyphs.TryGetValue(character, out glyph))
            {
                return glyph.horiz_adv_x;
            }

            return 0;
        }

        public void ShowDebugInfo(Graphics2D graphics2D)
        {
            StyledTypeFace typeFaceNameStyle = new StyledTypeFace(this, 30);
            TypeFacePrinter fontNamePrinter = new TypeFacePrinter(this.fontFamily + " - 30 point", typeFaceNameStyle);

            RectangleDouble bounds = typeFaceNameStyle.BoundingBoxInPixels;
            double origX = 10 - bounds.Left;
            double x = origX;
            double y = 10 - typeFaceNameStyle.DescentInPixels;
            int width = 50;
            RGBA_Bytes boundingBoxColor = new RGBA_Bytes(0, 0, 0);
            RGBA_Bytes originColor = new RGBA_Bytes(0, 0, 0);
            RGBA_Bytes ascentColor = new RGBA_Bytes(255, 0, 0);
            RGBA_Bytes descentColor = new RGBA_Bytes(255, 0, 0);
            RGBA_Bytes xHeightColor = new RGBA_Bytes(12, 25, 200);
            RGBA_Bytes capHeightColor = new RGBA_Bytes(12, 25, 200);
            RGBA_Bytes underlineColor = new RGBA_Bytes(0, 150, 55);

            // the origin
            graphics2D.Line(x, y, x + width, y, originColor);

            graphics2D.Rectangle(x + bounds.Left, y + bounds.Bottom, x + bounds.Right, y + bounds.Top, boundingBoxColor);

            x += typeFaceNameStyle.BoundingBoxInPixels.Width * 1.5;

            width = width * 3;

            double temp = typeFaceNameStyle.AscentInPixels;
            graphics2D.Line(x, y + temp, x + width, y + temp, ascentColor);

            temp = typeFaceNameStyle.DescentInPixels;
            graphics2D.Line(x, y + temp, x + width, y + temp, descentColor);

            temp = typeFaceNameStyle.XHeightInPixels;
            graphics2D.Line(x, y + temp, x + width, y + temp, xHeightColor);

            temp = typeFaceNameStyle.CapHeightInPixels;
            graphics2D.Line(x, y + temp, x + width, y + temp, capHeightColor);

            temp = typeFaceNameStyle.UnderlinePositionInPixels;
            graphics2D.Line(x, y + temp, x + width, y + temp, underlineColor);

            Affine textTransform;
            textTransform = Affine.NewIdentity();
            textTransform *= Affine.NewTranslation(10, origX);

            VertexSourceApplyTransform transformedText = new VertexSourceApplyTransform(textTransform);
            fontNamePrinter.Render(graphics2D, RGBA_Bytes.Black, transformedText);

            graphics2D.Render(transformedText, RGBA_Bytes.Black);

            // render the legend
            StyledTypeFace legendFont = new StyledTypeFace(this, 12);
            Vector2 textPos = new Vector2(x + width / 2, y + typeFaceNameStyle.EmSizeInPixels * 1.5);
            graphics2D.Render(new TypeFacePrinter("Descent"), textPos, descentColor); textPos.y += legendFont.EmSizeInPixels;
            graphics2D.Render(new TypeFacePrinter("Underline"), textPos, underlineColor); textPos.y += legendFont.EmSizeInPixels;
            graphics2D.Render(new TypeFacePrinter("X Height"), textPos, xHeightColor); textPos.y += legendFont.EmSizeInPixels;
            graphics2D.Render(new TypeFacePrinter("CapHeight"), textPos, capHeightColor); textPos.y += legendFont.EmSizeInPixels;
            graphics2D.Render(new TypeFacePrinter("Ascent"), textPos, ascentColor); textPos.y += legendFont.EmSizeInPixels;
            graphics2D.Render(new TypeFacePrinter("Origin"), textPos, originColor); textPos.y += legendFont.EmSizeInPixels;
            graphics2D.Render(new TypeFacePrinter("Bounding Box"), textPos, boundingBoxColor);
        }
    }
}


#endregion //TypeFace.cs
#region TypeFacePrinter.cs

namespace MatterHackers.Agg.Font
{
    public enum Justification { Left, Center, Right };
    public enum Baseline { BoundsTop, BoundsCenter, TextCenter, Text, BoundsBottom };

    public class TypeFacePrinter : IVertexSource
    {
        StyledTypeFace typeFaceStyle;

        String text = "";

        Vector2 totalSizeCach;

        public Justification Justification { get; set; }
        public Baseline Baseline { get; set; }

        public bool DrawFromHintedCache { get; set; }

        public StyledTypeFace TypeFaceStyle
        {
            get
            {
                return typeFaceStyle;
            }
        }

        public String Text
        {
            get
            {
                return text;
            }
            set
            {
                if (text != value)
                {
                    totalSizeCach.x = 0;
                    text = value;
                }
            }
        }

        public Vector2 Origin { get; set; }


        public TypeFacePrinter(String text = "", double pointSize = 12, Vector2 origin = new Vector2(), Justification justification = Justification.Left, Baseline baseline = Baseline.Text)
            : this(text, new StyledTypeFace(LiberationSansFont.Instance, pointSize), origin, justification, baseline)
        {
        }

        public TypeFacePrinter(String text, StyledTypeFace typeFaceStyle, Vector2 origin = new Vector2(), Justification justification = Justification.Left, Baseline baseline = Baseline.Text)
        {
            this.typeFaceStyle = typeFaceStyle;
            this.text = text;
            this.Justification = justification;
            this.Origin = origin;
            this.Baseline = baseline;
        }

        public TypeFacePrinter(String text, TypeFacePrinter copyPropertiesFrom)
            : this(text, copyPropertiesFrom.TypeFaceStyle, copyPropertiesFrom.Origin, copyPropertiesFrom.Justification, copyPropertiesFrom.Baseline)
        {
        }

        public RectangleDouble LocalBounds
        {
            get
            {
                Vector2 size = GetSize();
                RectangleDouble bounds;

                switch (Justification)
                {
                    case Justification.Left:
                        bounds = new RectangleDouble(0, typeFaceStyle.DescentInPixels, size.x, size.y + typeFaceStyle.DescentInPixels);
                        break;

                    case Justification.Center:
                        bounds = new RectangleDouble(-size.x / 2, typeFaceStyle.DescentInPixels, size.x / 2, size.y + typeFaceStyle.DescentInPixels);
                        break;

                    case Justification.Right:
                        bounds = new RectangleDouble(-size.x, typeFaceStyle.DescentInPixels, 0, size.y + typeFaceStyle.DescentInPixels);
                        break;

                    default:
                        throw new NotImplementedException();
                }

                switch (Baseline)
                {
                    case Font.Baseline.BoundsCenter:
                        bounds.Offset(0, -typeFaceStyle.AscentInPixels / 2);
                        break;

                    default:
                        break;
                }

                bounds.Offset(Origin);
                return bounds;
            }
        }

        public void Render(Graphics2D graphics2D, RGBA_Bytes color, IVertexSourceProxy vertexSourceToApply)
        {
            vertexSourceToApply.VertexSource = this;
            rewind(0);
            if (DrawFromHintedCache)
            {
                // TODO: make this work
                graphics2D.Render(vertexSourceToApply, color);
            }
            else
            {
                graphics2D.Render(vertexSourceToApply, color);
            }
        }

        public void Render(Graphics2D graphics2D, RGBA_Bytes color)
        {
            rewind(0);
            if (DrawFromHintedCache)
            {
                RenderFromCache(graphics2D, color);
            }
            else
            {
                graphics2D.Render(this, color);
            }
        }

        void RenderFromCache(Graphics2D graphics2D, RGBA_Bytes color)
        {
            if (text != null && text.Length > 0)
            {
                Vector2 currentOffset = Vector2.Zero;

                currentOffset = GetBaseline(currentOffset);
                currentOffset.y += Origin.y;

                string[] lines = text.Split('\n');
                foreach (string line in lines)
                {
                    currentOffset = GetXPositionForLineBasedOnJustification(currentOffset, line);
                    currentOffset.x += Origin.x;

                    for (int currentChar = 0; currentChar < line.Length; currentChar++)
                    {
                        ImageBuffer currentGlyphImage = typeFaceStyle.GetImageForCharacter(line[currentChar], 0, 0, color);

                        if (currentGlyphImage != null)
                        {
                            graphics2D.Render(currentGlyphImage, currentOffset);
                        }

                        // get the advance for the next character
                        if (currentChar < line.Length - 1)
                        {
                            // pass the next char so the typeFaceStyle can do kerning if it needs to.
                            currentOffset.x += typeFaceStyle.GetAdvanceForCharacter(line[currentChar], line[currentChar + 1]);
                        }
                        else
                        {
                            currentOffset.x += typeFaceStyle.GetAdvanceForCharacter(line[currentChar]);
                        }
                    }

                    // before we go onto the next line we need to move down a line
                    currentOffset.x = 0;
                    currentOffset.y -= typeFaceStyle.EmSizeInPixels;
                }
            }
        }

        public IEnumerable<VertexData> Vertices()
        {
            if (text != null && text.Length > 0)
            {
                Vector2 currentOffset = new Vector2(0, 0);

                currentOffset = GetBaseline(currentOffset);

                string[] lines = text.Split('\n');
                Array.Reverse(lines);    //上下行颠倒
                foreach (string line in lines)
                {
                    currentOffset = GetXPositionForLineBasedOnJustification(currentOffset, line);

                    for (int currentChar = 0; currentChar < line.Length; currentChar++)
                    {
                        IVertexSource currentGlyph = typeFaceStyle.GetGlyphForCharacter(line[currentChar]);

                        if (currentGlyph != null)
                        {
                            foreach (VertexData vertexData in currentGlyph.Vertices())
                            {
                                if (vertexData.command != ShapePath.FlagsAndCommand.CommandStop)
                                {
                                    VertexData offsetVertex = new VertexData(vertexData.command, vertexData.position + currentOffset + Origin);
                                    yield return offsetVertex;
                                }
                            }
                        }

                        // get the advance for the next character
                        if (currentChar < line.Length - 1)
                        {
                            // pass the next char so the typeFaceStyle can do kerning if it needs to.
                            currentOffset.x += typeFaceStyle.GetAdvanceForCharacter(line[currentChar], line[currentChar + 1]);
                        }
                        else
                        {
                            currentOffset.x += typeFaceStyle.GetAdvanceForCharacter(line[currentChar]);
                        }
                    }

                    // before we go onto the next line we need to move down a line
                    currentOffset.x = 0;
                    currentOffset.y -= typeFaceStyle.EmSizeInPixels;
                }
            }

            VertexData endVertex = new VertexData(ShapePath.FlagsAndCommand.CommandStop, Vector2.Zero);
            yield return endVertex;
        }

        private Vector2 GetXPositionForLineBasedOnJustification(Vector2 currentOffset, string line)
        {
            Vector2 size = GetSize(line);
            switch (Justification)
            {
                case Justification.Left:
                    currentOffset.x = 0;
                    break;

                case Justification.Center:
                    currentOffset.x = -size.x / 2;
                    break;

                case Justification.Right:
                    currentOffset.x = -size.x;
                    break;

                default:
                    throw new NotImplementedException();
            }
            return currentOffset;
        }

        private Vector2 GetBaseline(Vector2 currentOffset)
        {
            switch (Baseline)
            {
                case Baseline.Text:
                    currentOffset.y = 0;
                    break;

                case Baseline.BoundsTop:
                    currentOffset.y = -typeFaceStyle.AscentInPixels;
                    break;

                case Baseline.BoundsCenter:
                    currentOffset.y = -typeFaceStyle.AscentInPixels / 2;
                    break;

                default:
                    throw new NotImplementedException();
            }
            return currentOffset;
        }

#if true
        IEnumerator<VertexData> currentEnumerator;
        public void rewind(int layerIndex)
        {
            currentEnumerator = Vertices().GetEnumerator();
            currentEnumerator.MoveNext();
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = currentEnumerator.Current.position.x;
            y = currentEnumerator.Current.position.y;
            ShapePath.FlagsAndCommand command = currentEnumerator.Current.command;

            currentEnumerator.MoveNext();

            return command;
        }
#else
        public void rewind(int pathId)
        {
            currentChar = 0;
            currentOffset = new Vector2(0, 0);
            if (text != null && text.Length > 0)
            {
                currentGlyph = typeFaceStyle.GetGlyphForCharacter(text[currentChar]);
                if (currentGlyph != null)
                {
                    currentGlyph.rewind(0);
                }
            }
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = 0;
            y = 0;
            if (text != null && text.Length > 0)
            {
                ShapePath.FlagsAndCommand curCommand = ShapePath.FlagsAndCommand.CommandStop;
                if (currentGlyph != null)
                {
                    curCommand = currentGlyph.vertex(out x, out y);
                }

                double xAlignOffset = 0;
                Vector2 size = GetSize();
                switch (Justification)
                {
                    case Justification.Left:
                        xAlignOffset = 0;
                        break;

                    case Justification.Center:
                        xAlignOffset = -size.x / 2;
                        break;

                    case Justification.Right:
                        xAlignOffset = -size.x;
                        break;

                    default:
                        throw new NotImplementedException();
                }

                double yAlignOffset = 0;
                switch (Baseline)
                {
                    case Baseline.Text:
                        //yAlignOffset = -typeFaceStyle.DescentInPixels;
                        yAlignOffset = 0;
                        break;

                    case Baseline.BoundsTop:
                        yAlignOffset = -typeFaceStyle.AscentInPixels;
                        break;

                    case Baseline.BoundsCenter:
                        yAlignOffset = -typeFaceStyle.AscentInPixels / 2;
                        break;

                    default:
                        throw new NotImplementedException();
                }


                while (curCommand == ShapePath.FlagsAndCommand.CommandStop
                    && currentChar < text.Length - 1)
                {
                    if (currentChar == 0 && text[currentChar] == '\n')
                    {
                        currentOffset.x = 0;
                        currentOffset.y -= typeFaceStyle.EmSizeInPixels;
                    }
                    else
                    {
                        if (currentChar < text.Length)
                        {
                            // pass the next char so the typeFaceStyle can do kerning if it needs to.
                            currentOffset.x += typeFaceStyle.GetAdvanceForCharacter(text[currentChar], text[currentChar + 1]);
                        }
                        else
                        {
                            currentOffset.x += typeFaceStyle.GetAdvanceForCharacter(text[currentChar]);
                        }
                    }

                    currentChar++;
                    currentGlyph = typeFaceStyle.GetGlyphForCharacter(text[currentChar]);
                    if (currentGlyph != null)
                    {
                        currentGlyph.rewind(0);
                        curCommand = currentGlyph.vertex(out x, out y);
                    }
                    else if (text[currentChar] == '\n')
                    {
                        if (currentChar + 1 < text.Length - 1 && (text[currentChar + 1] == '\n') && text[currentChar] != text[currentChar + 1])
                        {
                            currentChar++;
                        }
                        currentOffset.x = 0;
                        currentOffset.y -= typeFaceStyle.EmSizeInPixels;
                    }
                }

                if (ShapePath.is_vertex(curCommand))
                {

                    x += currentOffset.x + xAlignOffset + Origin.x;
                    y += currentOffset.y + yAlignOffset + Origin.y;

                }

                return curCommand;
            }

            return ShapePath.FlagsAndCommand.CommandStop;
        }
#endif

        public Vector2 GetSize(string text = null)
        {
            if (text == null)
            {
                text = this.text;
            }

            if (text != this.text)
            {
                Vector2 calculatedSize;
                GetSize(0, Math.Max(0, text.Length - 1), out calculatedSize, text);
                return calculatedSize;
            }

            if (totalSizeCach.x == 0)
            {
                Vector2 calculatedSize;
                GetSize(0, Math.Max(0, text.Length - 1), out calculatedSize, text);
                totalSizeCach = calculatedSize;
            }

            return totalSizeCach;
        }

        public void GetSize(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive, out Vector2 offset, string text = null)
        {
            if (text == null)
            {
                text = this.text;
            }

            offset.x = 0;
            offset.y = typeFaceStyle.EmSizeInPixels;

            double currentLineX = 0;

            for (int i = characterToMeasureStartIndexInclusive; i < characterToMeasureEndIndexInclusive; i++)
            {
                if (text[i] == '\n')
                {
                    if (i + 1 < characterToMeasureEndIndexInclusive && (text[i + 1] == '\n') && text[i] != text[i + 1])
                    {
                        i++;
                    }
                    currentLineX = 0;
                    offset.y += typeFaceStyle.EmSizeInPixels;
                }
                else
                {
                    if (i + 1 < text.Length)
                    {
                        currentLineX += typeFaceStyle.GetAdvanceForCharacter(text[i], text[i + 1]);
                    }
                    else
                    {
                        currentLineX += typeFaceStyle.GetAdvanceForCharacter(text[i]);
                    }
                    if (currentLineX > offset.x)
                    {
                        offset.x = currentLineX;
                    }
                }
            }

            if (text.Length > characterToMeasureEndIndexInclusive)
            {
                if (text[characterToMeasureEndIndexInclusive] == '\n')
                {
                    currentLineX = 0;
                    offset.y += typeFaceStyle.EmSizeInPixels;
                }
                else
                {
                    offset.x += typeFaceStyle.GetAdvanceForCharacter(text[characterToMeasureEndIndexInclusive]);
                }
            }
        }

        public int NumLines()
        {
            int characterToMeasureStartIndexInclusive = 0;
            int characterToMeasureEndIndexInclusive = text.Length - 1;
            return NumLines(characterToMeasureStartIndexInclusive, characterToMeasureEndIndexInclusive);
        }

        public int NumLines(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive)
        {
            int numLines = 1;

            characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, text.Length - 1));
            characterToMeasureEndIndexInclusive = Math.Max(0, Math.Min(characterToMeasureEndIndexInclusive, text.Length - 1));
            for (int i = characterToMeasureStartIndexInclusive; i < characterToMeasureEndIndexInclusive; i++)
            {
                if (text[i] == '\n')
                {
                    if (i + 1 < characterToMeasureEndIndexInclusive && (text[i + 1] == '\n') && text[i] != text[i + 1])
                    {
                        i++;
                    }
                    numLines++;
                }
            }

            return numLines;
        }

        public void GetOffset(int characterToMeasureStartIndexInclusive, int characterToMeasureEndIndexInclusive, out Vector2 offset)
        {
            offset = Vector2.Zero;

            characterToMeasureEndIndexInclusive = Math.Min(text.Length - 1, characterToMeasureEndIndexInclusive);

            for (int index = characterToMeasureStartIndexInclusive; index <= characterToMeasureEndIndexInclusive; index++)
            {
                if (text[index] == '\n')
                {
                    offset.x = 0;
                    offset.y -= typeFaceStyle.EmSizeInPixels;
                }
                else
                {
                    if (index < text.Length - 1)
                    {
                        offset.x += typeFaceStyle.GetAdvanceForCharacter(text[index], text[index + 1]);
                    }
                    else
                    {
                        offset.x += typeFaceStyle.GetAdvanceForCharacter(text[index]);
                    }
                }
            }
        }

        // this will return the position to the left of the requested character.
        public Vector2 GetOffsetLeftOfCharacterIndex(int characterIndex)
        {
            Vector2 offset;
            GetOffset(0, characterIndex - 1, out offset);
            return offset;
        }

        // If the Text is "TEXT" and the position is less than half the distance to the center
        // of "T" the return value will be 0 if it is between the center of 'T' and the center of 'E'
        // it will be 1 and so on.
        public int GetCharacterIndexToStartBefore(Vector2 position)
        {
            int clostestIndex = -1;
            double clostestXDistSquared = double.MaxValue;
            double clostestYDistSquared = double.MaxValue;
            Vector2 offset = new Vector2(0, typeFaceStyle.EmSizeInPixels * NumLines());
            int characterToMeasureStartIndexInclusive = 0;
            int characterToMeasureEndIndexInclusive = text.Length - 1;
            if (text.Length > 0)
            {
                characterToMeasureStartIndexInclusive = Math.Max(0, Math.Min(characterToMeasureStartIndexInclusive, text.Length - 1));
                characterToMeasureEndIndexInclusive = Math.Max(0, Math.Min(characterToMeasureEndIndexInclusive, text.Length - 1));
                for (int i = characterToMeasureStartIndexInclusive; i <= characterToMeasureEndIndexInclusive; i++)
                {
                    CheckForBetterClickPosition(ref position, ref clostestIndex, ref clostestXDistSquared, ref clostestYDistSquared, ref offset, i);

                    if (text[i] == '\r')
                    {
                        throw new Exception("All \\r's should have been converted to \\n's.");
                    }

                    if (text[i] == '\n')
                    {
                        offset.x = 0;
                        offset.y -= typeFaceStyle.EmSizeInPixels;
                    }
                    else
                    {
                        Vector2 nextSize;
                        GetOffset(i, i, out nextSize);

                        offset.x += nextSize.x;
                    }
                }

                CheckForBetterClickPosition(ref position, ref clostestIndex, ref clostestXDistSquared, ref clostestYDistSquared, ref offset, characterToMeasureEndIndexInclusive + 1);
            }

            return clostestIndex;
        }

        private static void CheckForBetterClickPosition(ref Vector2 position, ref int clostestIndex, ref double clostestXDistSquared, ref double clostestYDistSquared, ref Vector2 offset, int i)
        {
            Vector2 delta = position - offset;
            double deltaYLengthSquared = delta.y * delta.y;
            if (deltaYLengthSquared < clostestYDistSquared)
            {
                clostestYDistSquared = deltaYLengthSquared;
                clostestXDistSquared = delta.x * delta.x;
                clostestIndex = i;
            }
            else if (deltaYLengthSquared == clostestYDistSquared)
            {
                double deltaXLengthSquared = delta.x * delta.x;
                if (deltaXLengthSquared < clostestXDistSquared)
                {
                    clostestXDistSquared = deltaXLengthSquared;
                    clostestIndex = i;
                }
            }
        }
    }
}

#endregion //TypeFacePrinter.cs
#region Vector2.cs

namespace MatterHackers.VectorMath
{
    /// <summary>Represents a 2D vector using two double-precision floating-point numbers.</summary>
    //[Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public struct Vector2 : IEquatable<Vector2>
    {
        #region Fields

        /// <summary>The X coordinate of this instance.</summary>
        public double x;

        /// <summary>The Y coordinate of this instance.</summary>
        public double y;

        /// <summary>
        /// Defines a unit-length Vector2d that points towards the X-axis.
        /// </summary>
        public static Vector2 UnitX = new Vector2(1, 0);

        /// <summary>
        /// Defines a unit-length Vector2d that points towards the Y-axis.
        /// </summary>
        public static Vector2 UnitY = new Vector2(0, 1);

        /// <summary>
        /// Defines a zero-length Vector2d.
        /// </summary>
        public static Vector2 Zero = new Vector2(0, 0);

        /// <summary>
        /// Defines an instance with all components set to 1.
        /// </summary>
        public static readonly Vector2 One = new Vector2(1, 1);

        /// <summary>
        /// Defines the size of the Vector2d struct in bytes.
        /// </summary>
        public static readonly int SizeInBytes = Marshal.SizeOf(new Vector2());

        #endregion

        #region Constructors

        /// <summary>Constructs left vector with the given coordinates.</summary>
        /// <param name="x">The X coordinate.</param>
        /// <param name="y">The Y coordinate.</param>
        public Vector2(double x, double y)
        {
            this.x = x;
            this.y = y;
        }

        public Vector2(Vector3 vector)
        {
            this.x = vector.x;
            this.y = vector.y;
        }

        #endregion

        #region Properties

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    default: return 0;
                }
            }

            set
            {
                switch (index)
                {
                    case 0: x = value; break;
                    case 1: y = value; break;
                    default: throw new Exception();
                }
            }
        }

        #endregion

        #region Public Members

        #region Instance

        #region public double Length

        /// <summary>
        /// Gets the length (magnitude) of the vector.
        /// </summary>
        /// <seealso cref="LengthSquared"/>
        public double Length
        {
            get
            {
                return System.Math.Sqrt(x * x + y * y);
            }
        }

        #endregion

        #region public double LengthSquared

        /// <summary>
        /// Gets the square of the vector length (magnitude).
        /// </summary>
        /// <remarks>
        /// This property avoids the costly square root operation required by the Length property. This makes it more suitable
        /// for comparisons.
        /// </remarks>
        /// <see cref="Length"/>
        public double LengthSquared
        {
            get
            {
                return x * x + y * y;
            }
        }

        #endregion

        public void Rotate(double radians)
        {
            this = Vector2.Rotate(this, radians);
        }

        public double GetAngle()
        {
            return System.Math.Atan2(y, x);
        }

        public double GetAngle0To2PI()
        {
            return MathHelper.Range0ToTau(GetAngle());
        }

        #region public Vector2d PerpendicularRight

        /// <summary>
        /// Gets the perpendicular vector on the right side of this vector.
        /// </summary>
        public Vector2 GetPerpendicularRight()
        {
            return new Vector2(y, -x);
        }

        #endregion

        #region public Vector2d PerpendicularLeft

        /// <summary>
        /// Gets the perpendicular vector on the left side of this vector.
        /// </summary>
        public Vector2 GetPerpendicularLeft()
        {
            return new Vector2(-y, x);
        }

        #endregion

        #region public void Normalize()

        /// <summary>
        /// Returns a normalized Vector of this.
        /// </summary>
        /// <returns></returns>
        public Vector2 GetNormal()
        {
            Vector2 temp = this;
            temp.Normalize();
            return temp;
        }

        /// <summary>
        /// Scales the Vector2 to unit length.
        /// </summary>
        public void Normalize()
        {
            double scale = 1.0 / Length;
            x *= scale;
            y *= scale;
        }

        #endregion

        #endregion

        #region Static

        #region Add

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <returns>Result of operation.</returns>
        public static Vector2 Add(Vector2 a, Vector2 b)
        {
            Add(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <param name="result">Result of operation.</param>
        public static void Add(ref Vector2 a, ref Vector2 b, out Vector2 result)
        {
            result = new Vector2(a.x + b.x, a.y + b.y);
        }

        #endregion

        #region Subtract

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>Result of subtraction</returns>
        public static Vector2 Subtract(Vector2 a, Vector2 b)
        {
            Subtract(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">Result of subtraction</param>
        public static void Subtract(ref Vector2 a, ref Vector2 b, out Vector2 result)
        {
            result = new Vector2(a.x - b.x, a.y - b.y);
        }

        #endregion

        #region Multiply

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector2 Multiply(Vector2 vector, double scale)
        {
            Multiply(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector2 vector, double scale, out Vector2 result)
        {
            result = new Vector2(vector.x * scale, vector.y * scale);
        }

        /// <summary>
        /// Multiplies a vector by the components a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector2 Multiply(Vector2 vector, Vector2 scale)
        {
            Multiply(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector2 vector, ref Vector2 scale, out Vector2 result)
        {
            result = new Vector2(vector.x * scale.x, vector.y * scale.y);
        }

        #endregion

        #region Divide

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector2 Divide(Vector2 vector, double scale)
        {
            Divide(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector2 vector, double scale, out Vector2 result)
        {
            Multiply(ref vector, 1 / scale, out result);
        }

        /// <summary>
        /// Divides a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector2 Divide(Vector2 vector, Vector2 scale)
        {
            Divide(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divide a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector2 vector, ref Vector2 scale, out Vector2 result)
        {
            result = new Vector2(vector.x / scale.x, vector.y / scale.y);
        }

        #endregion

        #region Min

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise minimum</returns>
        public static Vector2 Min(Vector2 a, Vector2 b)
        {
            a.x = a.x < b.x ? a.x : b.x;
            a.y = a.y < b.y ? a.y : b.y;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise minimum</param>
        public static void Min(ref Vector2 a, ref Vector2 b, out Vector2 result)
        {
            result.x = a.x < b.x ? a.x : b.x;
            result.y = a.y < b.y ? a.y : b.y;
        }

        #endregion

        #region Max

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise maximum</returns>
        public static Vector2 Max(Vector2 a, Vector2 b)
        {
            a.x = a.x > b.x ? a.x : b.x;
            a.y = a.y > b.y ? a.y : b.y;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise maximum</param>
        public static void Max(ref Vector2 a, ref Vector2 b, out Vector2 result)
        {
            result.x = a.x > b.x ? a.x : b.x;
            result.y = a.y > b.y ? a.y : b.y;
        }

        #endregion

        #region Clamp

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <returns>The clamped vector</returns>
        public static Vector2 Clamp(Vector2 vec, Vector2 min, Vector2 max)
        {
            vec.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            vec.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
            return vec;
        }

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <param name="result">The clamped vector</param>
        public static void Clamp(ref Vector2 vec, ref Vector2 min, ref Vector2 max, out Vector2 result)
        {
            result.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            result.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
        }

        #endregion

        #region Normalize

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <returns>The normalized vector</returns>
        public static Vector2 Normalize(Vector2 vec)
        {
            double scale = 1.0 / vec.Length;
            vec.x *= scale;
            vec.y *= scale;
            return vec;
        }

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <param name="result">The normalized vector</param>
        public static void Normalize(ref Vector2 vec, out Vector2 result)
        {
            double scale = 1.0 / vec.Length;
            result.x = vec.x * scale;
            result.y = vec.y * scale;
        }

        #endregion

        #region Dot

        /// <summary>
        /// Calculate the dot (scalar) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The dot product of the two inputs</returns>
        public static double Dot(Vector2 left, Vector2 right)
        {
            return left.x * right.x + left.y * right.y;
        }

        /// <summary>
        /// Calculate the dot (scalar) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <param name="result">The dot product of the two inputs</param>
        public static void Dot(ref Vector2 left, ref Vector2 right, out double result)
        {
            result = left.x * right.x + left.y * right.y;
        }

        #endregion

        #region Cross

        /// <summary>
        /// Calculate the cross product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The cross product of the two inputs</returns>
        public static double Cross(Vector2 left, Vector2 right)
        {
            return left.x * right.y - left.y * right.x;
        }

        #endregion

        #region Rotate
        public static Vector2 Rotate(Vector2 toRotate, double radians)
        {
            Vector2 temp;
            Rotate(ref toRotate, radians, out temp);
            return temp;
        }

        public static void Rotate(ref Vector2 input, double radians, out Vector2 output)
        {
            double Cos, Sin;

            Cos = (double)System.Math.Cos(radians);
            Sin = (double)System.Math.Sin(radians);

            output.x = input.x * Cos - input.y * Sin;
            output.y = input.y * Cos + input.x * Sin;
        }
        #endregion

        #region Lerp

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <returns>a when blend=0, b when blend=1, and a linear combination otherwise</returns>
        public static Vector2 Lerp(Vector2 a, Vector2 b, double blend)
        {
            a.x = blend * (b.x - a.x) + a.x;
            a.y = blend * (b.y - a.y) + a.y;
            return a;
        }

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <param name="result">a when blend=0, b when blend=1, and a linear combination otherwise</param>
        public static void Lerp(ref Vector2 a, ref Vector2 b, double blend, out Vector2 result)
        {
            result.x = blend * (b.x - a.x) + a.x;
            result.y = blend * (b.y - a.y) + a.y;
        }

        #endregion

        #region Barycentric

        /// <summary>
        /// Interpolate 3 Vectors using Barycentric coordinates
        /// </summary>
        /// <param name="a">First input Vector</param>
        /// <param name="b">Second input Vector</param>
        /// <param name="c">Third input Vector</param>
        /// <param name="u">First Barycentric Coordinate</param>
        /// <param name="v">Second Barycentric Coordinate</param>
        /// <returns>a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</returns>
        public static Vector2 BaryCentric(Vector2 a, Vector2 b, Vector2 c, double u, double v)
        {
            return a + u * (b - a) + v * (c - a);
        }

        /// <summary>Interpolate 3 Vectors using Barycentric coordinates</summary>
        /// <param name="a">First input Vector.</param>
        /// <param name="b">Second input Vector.</param>
        /// <param name="c">Third input Vector.</param>
        /// <param name="u">First Barycentric Coordinate.</param>
        /// <param name="v">Second Barycentric Coordinate.</param>
        /// <param name="result">Output Vector. a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</param>
        public static void BaryCentric(ref Vector2 a, ref Vector2 b, ref Vector2 c, double u, double v, out Vector2 result)
        {
            result = a; // copy

            Vector2 temp = b; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, u, out temp);
            Add(ref result, ref temp, out result);

            temp = c; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, v, out temp);
            Add(ref result, ref temp, out result);
        }

        #endregion

        #region Transform

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 Transform(Vector2 vec, Quaternion quat)
        {
            Vector2 result;
            Transform(ref vec, ref quat, out result);
            return result;
        }

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <param name="result">The result of the operation.</param>
        public static void Transform(ref Vector2 vec, ref Quaternion quat, out Vector2 result)
        {
            Quaternion v = new Quaternion(vec.x, vec.y, 0, 0), i, t;
            Quaternion.Invert(ref quat, out i);
            Quaternion.Multiply(ref quat, ref v, out t);
            Quaternion.Multiply(ref t, ref i, out v);

            result = new Vector2(v.X, v.Y);
        }

        #endregion

        #region ComponentMin

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise minimum</returns>
        public static Vector2 ComponentMin(Vector2 a, Vector2 b)
        {
            a.x = a.x < b.x ? a.x : b.x;
            a.y = a.y < b.y ? a.y : b.y;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise minimum</param>
        public static void ComponentMin(ref Vector2 a, ref Vector2 b, out Vector2 result)
        {
            result.x = a.x < b.x ? a.x : b.x;
            result.y = a.y < b.y ? a.y : b.y;
        }

        #endregion

        #region ComponentMax

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise maximum</returns>
        public static Vector2 ComponentMax(Vector2 a, Vector2 b)
        {
            a.x = a.x > b.x ? a.x : b.x;
            a.y = a.y > b.y ? a.y : b.y;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise maximum</param>
        public static void ComponentMax(ref Vector2 a, ref Vector2 b, out Vector2 result)
        {
            result.x = a.x > b.x ? a.x : b.x;
            result.y = a.y > b.y ? a.y : b.y;
        }

        #endregion

        #endregion

        #region Operators

        /// <summary>
        /// Adds two instances.
        /// </summary>
        /// <param name="left">The left instance.</param>
        /// <param name="right">The right instance.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 operator +(Vector2 left, Vector2 right)
        {
            left.x += right.x;
            left.y += right.y;
            return left;
        }

        /// <summary>
        /// Subtracts two instances.
        /// </summary>
        /// <param name="left">The left instance.</param>
        /// <param name="right">The right instance.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 operator -(Vector2 left, Vector2 right)
        {
            left.x -= right.x;
            left.y -= right.y;
            return left;
        }

        /// <summary>
        /// Negates an instance.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 operator -(Vector2 vec)
        {
            vec.x = -vec.x;
            vec.y = -vec.y;
            return vec;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 operator *(Vector2 vec, double f)
        {
            vec.x *= f;
            vec.y *= f;
            return vec;
        }

        /// <summary>
        /// Multiply an instance by a scalar.
        /// </summary>
        /// <param name="f">The scalar.</param>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 operator *(double f, Vector2 vec)
        {
            vec.x *= f;
            vec.y *= f;
            return vec;
        }

        /// <summary>
        /// Divides an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="f">The scalar.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 operator /(Vector2 vec, double f)
        {
            double mult = 1.0 / f;
            vec.x *= mult;
            vec.y *= mult;
            return vec;
        }

        /// <summary>
        /// Divides a scaler by an instance components wise.
        /// </summary>
        /// <param name="vec">The scalar.</param>
        /// <param name="f">The instance.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector2 operator /(double f, Vector2 vec)
        {
            vec.x = f / vec.x;
            vec.y = f / vec.y;
            return vec;
        }

        /// <summary>
        /// Compares two instances for equality.
        /// </summary>
        /// <param name="left">The left instance.</param>
        /// <param name="right">The right instance.</param>
        /// <returns>True, if both instances are equal; false otherwise.</returns>
        public static bool operator ==(Vector2 left, Vector2 right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Compares two instances for ienquality.
        /// </summary>
        /// <param name="left">The left instance.</param>
        /// <param name="right">The right instance.</param>
        /// <returns>True, if the instances are not equal; false otherwise.</returns>
        public static bool operator !=(Vector2 left, Vector2 right)
        {
            return !left.Equals(right);
        }

        #endregion

        #region Overrides

        #region public override string ToString()

        /// <summary>
        /// Returns a System.String that represents the current instance.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("({0}, {1})", x, y);
        }

        #endregion

        #region public override int GetHashCode()

        /// <summary>
        /// Returns the hashcode for this instance.
        /// </summary>
        /// <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
        public override int GetHashCode()
        {
            return new { x, y }.GetHashCode();
        }

        #endregion

        #region public override bool Equals(object obj)

        /// <summary>
        /// Indicates whether this instance and a specified object are equal.
        /// </summary>
        /// <param name="obj">The object to compare to.</param>
        /// <returns>True if the instances are equal; false otherwise.</returns>
        public override bool Equals(object obj)
        {
            if (!(obj is Vector2))
                return false;

            return this.Equals((Vector2)obj);
        }

        #endregion

        #endregion

        #endregion

        #region IEquatable<Vector2d> Members

        /// <summary>Indicates whether the current vector is equal to another vector.</summary>
        /// <param name="other">A vector to compare with this vector.</param>
        /// <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
        public bool Equals(Vector2 other)
        {
            return
                x == other.x &&
                y == other.y;
        }

        /// <summary>Indicates whether the current vector is equal to another vector.</summary>
        /// <param name="other">A vector to compare with this vector.</param>
        /// <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
        public bool Equals(Vector2 other, double errorRange)
        {
            if ((x < other.x + errorRange && x > other.x - errorRange) &&
                (y < other.y + errorRange && y > other.y - errorRange))
            {
                return true;
            }

            return false;
        }

        #endregion

    }
}

#endregion //Vector2.cs
#region Vector3.cs

namespace MatterHackers.VectorMath
{
    /// <summary>
    /// Represents a 3D vector using three double-precision floating-point numbers.
    /// </summary>
    //[Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public struct Vector3 : IEquatable<Vector3>
    {
        #region Fields

        /// <summary>
        /// The X component of the Vector3.
        /// </summary>
        public double x;

        /// <summary>
        /// The Y component of the Vector3.
        /// </summary>
        public double y;

        /// <summary>
        /// The Z component of the Vector3.
        /// </summary>
        public double z;

        #endregion // Fields

        #region Constructors

        /// <summary>
        /// Constructs a new Vector3.
        /// </summary>
        /// <param name="x">The x component of the Vector3.</param>
        /// <param name="y">The y component of the Vector3.</param>
        /// <param name="z">The z component of the Vector3.</param>
        public Vector3(double x, double y, double z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        /// <summary>
        /// Constructs a new instance from the given Vector2d.
        /// </summary>
        /// <param name="v">The Vector2d to copy components from.</param>
        public Vector3(Vector2 v, double z = 0)
        {
            x = v.x;
            y = v.y;
            this.z = z;
        }

        /// <summary>
        /// Constructs a new instance from the given Vector3d.
        /// </summary>
        /// <param name="v">The Vector3d to copy components from.</param>
        public Vector3(Vector3 v)
        {
            x = v.x;
            y = v.y;
            z = v.z;
        }

        public Vector3(Vector3Float v)
        {
            x = v.x;
            y = v.y;
            z = v.z;
        }

        public Vector3(double[] doubleArray)
        {
            x = doubleArray[0];
            y = doubleArray[1];
            z = doubleArray[2];
        }

        /// <summary>
        /// Constructs a new instance from the given Vector4d.
        /// </summary>
        /// <param name="v">The Vector4d to copy components from.</param>
        public Vector3(Vector4 v)
        {
            x = v.x;
            y = v.y;
            z = v.z;
        }


        #endregion

        #region Properties

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    default: return 0;
                }
            }

            set
            {
                switch (index)
                {
                    case 0: x = value; break;
                    case 1: y = value; break;
                    case 2: z = value; break;
                    default: throw new Exception();
                }
            }
        }

        #endregion

        #region Public Members

        #region Instance

        #region public double Length

        /// <summary>
        /// Gets the length (magnitude) of the vector.
        /// </summary>
        /// <see cref="LengthFast"/>
        /// <seealso cref="LengthSquared"/>
        //[JsonIgnoreAttribute]
        public double Length
        {
            get
            {
                return System.Math.Sqrt(x * x + y * y + z * z);
            }
        }

        #endregion

        #region public double LengthSquared

        /// <summary>
        /// Gets the square of the vector length (magnitude).
        /// </summary>
        /// <remarks>
        /// This property avoids the costly square root operation required by the Length property. This makes it more suitable
        /// for comparisons.
        /// </remarks>
        /// <see cref="Length"/>
        /// <seealso cref="LengthFast"/>
        //[JsonIgnoreAttribute]
        public double LengthSquared
        {
            get
            {
                return x * x + y * y + z * z;
            }
        }

        #endregion

        #region public void Normalize()

        /// <summary>
        /// Returns a normalized Vector of this.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetNormal()
        {
            Vector3 temp = this;
            temp.Normalize();
            return temp;
        }

        /// <summary>
        /// Scales the Vector3d to unit length.
        /// </summary>
        public void Normalize()
        {
            double scale = 1.0 / this.Length;
            x *= scale;
            y *= scale;
            z *= scale;
        }

        #endregion

        #region public double[] ToArray()

        public double[] ToArray()
        {
            return new double[] { x, y, z };
        }

        #endregion

        #endregion

        #region Static

        #region Fields

        /// <summary>
        /// Defines a unit-length Vector3d that points towards the X-axis.
        /// </summary>
        public static readonly Vector3 UnitX = new Vector3(1, 0, 0);

        /// <summary>
        /// Defines a unit-length Vector3d that points towards the Y-axis.
        /// </summary>
        public static readonly Vector3 UnitY = new Vector3(0, 1, 0);

        /// <summary>
        /// /// Defines a unit-length Vector3d that points towards the Z-axis.
        /// </summary>
        public static readonly Vector3 UnitZ = new Vector3(0, 0, 1);

        /// <summary>
        /// Defines a zero-length Vector3.
        /// </summary>
        public static readonly Vector3 Zero = new Vector3(0, 0, 0);

        /// <summary>
        /// Defines an instance with all components set to 1.
        /// </summary>
        public static readonly Vector3 One = new Vector3(1, 1, 1);

        /// <summary>
        /// Defines an instance with all components set to positive infinity.
        /// </summary>
        public static readonly Vector3 PositiveInfinity = new Vector3(double.PositiveInfinity, double.PositiveInfinity, double.PositiveInfinity);

        /// <summary>
        /// Defines an instance with all components set to negative infinity.
        /// </summary>
        public static readonly Vector3 NegativeInfinity = new Vector3(double.NegativeInfinity, double.NegativeInfinity, double.NegativeInfinity);

        /// <summary>
        /// Defines the size of the Vector3d struct in bytes.
        /// </summary>
        public static readonly int SizeInBytes = Marshal.SizeOf(new Vector3());

        #endregion

        #region Add

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <returns>Result of operation.</returns>
        public static Vector3 Add(Vector3 a, Vector3 b)
        {
            Add(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <param name="result">Result of operation.</param>
        public static void Add(ref Vector3 a, ref Vector3 b, out Vector3 result)
        {
            result = new Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
        }

        #endregion

        #region Subtract

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>Result of subtraction</returns>
        public static Vector3 Subtract(Vector3 a, Vector3 b)
        {
            Subtract(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">Result of subtraction</param>
        public static void Subtract(ref Vector3 a, ref Vector3 b, out Vector3 result)
        {
            result = new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
        }

        #endregion

        #region Multiply

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3 Multiply(Vector3 vector, double scale)
        {
            Multiply(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector3 vector, double scale, out Vector3 result)
        {
            result = new Vector3(vector.x * scale, vector.y * scale, vector.z * scale);
        }

        /// <summary>
        /// Multiplies a vector by the components a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3 Multiply(Vector3 vector, Vector3 scale)
        {
            Multiply(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector3 vector, ref Vector3 scale, out Vector3 result)
        {
            result = new Vector3(vector.x * scale.x, vector.y * scale.y, vector.z * scale.z);
        }

        #endregion

        #region Divide

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3 Divide(Vector3 vector, double scale)
        {
            Divide(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector3 vector, double scale, out Vector3 result)
        {
            Multiply(ref vector, 1 / scale, out result);
        }

        /// <summary>
        /// Divides a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3 Divide(Vector3 vector, Vector3 scale)
        {
            Divide(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divide a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector3 vector, ref Vector3 scale, out Vector3 result)
        {
            result = new Vector3(vector.x / scale.x, vector.y / scale.y, vector.z / scale.z);
        }

        #endregion

        #region ComponentMin

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise minimum</returns>
        public static Vector3 ComponentMin(Vector3 a, Vector3 b)
        {
            a.x = a.x < b.x ? a.x : b.x;
            a.y = a.y < b.y ? a.y : b.y;
            a.z = a.z < b.z ? a.z : b.z;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise minimum</param>
        public static void ComponentMin(ref Vector3 a, ref Vector3 b, out Vector3 result)
        {
            result.x = a.x < b.x ? a.x : b.x;
            result.y = a.y < b.y ? a.y : b.y;
            result.z = a.z < b.z ? a.z : b.z;
        }

        #endregion

        #region ComponentMax

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise maximum</returns>
        public static Vector3 ComponentMax(Vector3 a, Vector3 b)
        {
            a.x = a.x > b.x ? a.x : b.x;
            a.y = a.y > b.y ? a.y : b.y;
            a.z = a.z > b.z ? a.z : b.z;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise maximum</param>
        public static void ComponentMax(ref Vector3 a, ref Vector3 b, out Vector3 result)
        {
            result.x = a.x > b.x ? a.x : b.x;
            result.y = a.y > b.y ? a.y : b.y;
            result.z = a.z > b.z ? a.z : b.z;
        }

        #endregion

        #region Min

        /// <summary>
        /// Returns the Vector3d with the minimum magnitude
        /// </summary>
        /// <param name="left">Left operand</param>
        /// <param name="right">Right operand</param>
        /// <returns>The minimum Vector3</returns>
        public static Vector3 Min(Vector3 left, Vector3 right)
        {
            return left.LengthSquared < right.LengthSquared ? left : right;
        }

        #endregion

        #region Max

        /// <summary>
        /// Returns the Vector3d with the minimum magnitude
        /// </summary>
        /// <param name="left">Left operand</param>
        /// <param name="right">Right operand</param>
        /// <returns>The minimum Vector3</returns>
        public static Vector3 Max(Vector3 left, Vector3 right)
        {
            return left.LengthSquared >= right.LengthSquared ? left : right;
        }

        #endregion

        #region Clamp

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <returns>The clamped vector</returns>
        public static Vector3 Clamp(Vector3 vec, Vector3 min, Vector3 max)
        {
            vec.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            vec.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
            vec.z = vec.z < min.z ? min.z : vec.z > max.z ? max.z : vec.z;
            return vec;
        }

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <param name="result">The clamped vector</param>
        public static void Clamp(ref Vector3 vec, ref Vector3 min, ref Vector3 max, out Vector3 result)
        {
            result.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            result.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
            result.z = vec.z < min.z ? min.z : vec.z > max.z ? max.z : vec.z;
        }

        #endregion

        #region Normalize

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <returns>The normalized vector</returns>
        public static Vector3 Normalize(Vector3 vec)
        {
            double scale = 1.0 / vec.Length;
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            return vec;
        }

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <param name="result">The normalized vector</param>
        public static void Normalize(ref Vector3 vec, out Vector3 result)
        {
            double scale = 1.0 / vec.Length;
            result.x = vec.x * scale;
            result.y = vec.y * scale;
            result.z = vec.z * scale;
        }

        #endregion

        #region Dot

        /// <summary>
        /// Calculate the dot (scalar) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The dot product of the two inputs</returns>
        public static double Dot(Vector3 left, Vector3 right)
        {
            return left.x * right.x + left.y * right.y + left.z * right.z;
        }

        /// <summary>
        /// Calculate the dot (scalar) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <param name="result">The dot product of the two inputs</param>
        public static void Dot(ref Vector3 left, ref Vector3 right, out double result)
        {
            result = left.x * right.x + left.y * right.y + left.z * right.z;
        }

        #endregion

        #region Cross

        /// <summary>
        /// Caclulate the cross (vector) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The cross product of the two inputs</returns>
        public static Vector3 Cross(Vector3 left, Vector3 right)
        {
            Vector3 result;
            Cross(ref left, ref right, out result);
            return result;
        }

        /// <summary>
        /// Caclulate the cross (vector) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The cross product of the two inputs</returns>
        /// <param name="result">The cross product of the two inputs</param>
        public static void Cross(ref Vector3 left, ref Vector3 right, out Vector3 result)
        {
            result = new Vector3(left.y * right.z - left.z * right.y,
                left.z * right.x - left.x * right.z,
                left.x * right.y - left.y * right.x);
        }

        #endregion // Cross

        #region Utility
        /// <summary>
        /// Checks if 3 points are collinear (all lie on the same line).
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="epsilon"></param>
        /// <returns></returns>
        public static bool Collinear(Vector3 a, Vector3 b, Vector3 c, double epsilon = .000001)
        {
            // Return true if a, b, and c all lie on the same line.
            return Math.Abs(Cross(b - a, c - a).Length) < epsilon;
        }

        public static Vector3 GetPerpendicular(Vector3 a, Vector3 b)
        {
            if (!Collinear(a, b, Zero))
            {
                return Vector3.Cross(a, b);
            }
            else
            {
                Vector3 zOne = new Vector3(0, 0, 100000);
                if (!Collinear(a, b, zOne))
                {
                    return Vector3.Cross(a - zOne, b - zOne);
                }
                else
                {
                    Vector3 xOne = new Vector3(1000000, 0, 0);
                    return Vector3.Cross(a - xOne, b - xOne);
                }
            }
        }

        #endregion // Utility

        #region Lerp

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <returns>a when blend=0, b when blend=1, and a linear combination otherwise</returns>
        public static Vector3 Lerp(Vector3 a, Vector3 b, double blend)
        {
            a.x = blend * (b.x - a.x) + a.x;
            a.y = blend * (b.y - a.y) + a.y;
            a.z = blend * (b.z - a.z) + a.z;
            return a;
        }

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <param name="result">a when blend=0, b when blend=1, and a linear combination otherwise</param>
        public static void Lerp(ref Vector3 a, ref Vector3 b, double blend, out Vector3 result)
        {
            result.x = blend * (b.x - a.x) + a.x;
            result.y = blend * (b.y - a.y) + a.y;
            result.z = blend * (b.z - a.z) + a.z;
        }

        #endregion

        #region Barycentric

        /// <summary>
        /// Interpolate 3 Vectors using Barycentric coordinates
        /// </summary>
        /// <param name="a">First input Vector</param>
        /// <param name="b">Second input Vector</param>
        /// <param name="c">Third input Vector</param>
        /// <param name="u">First Barycentric Coordinate</param>
        /// <param name="v">Second Barycentric Coordinate</param>
        /// <returns>a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</returns>
        public static Vector3 BaryCentric(Vector3 a, Vector3 b, Vector3 c, double u, double v)
        {
            return a + u * (b - a) + v * (c - a);
        }

        /// <summary>Interpolate 3 Vectors using Barycentric coordinates</summary>
        /// <param name="a">First input Vector.</param>
        /// <param name="b">Second input Vector.</param>
        /// <param name="c">Third input Vector.</param>
        /// <param name="u">First Barycentric Coordinate.</param>
        /// <param name="v">Second Barycentric Coordinate.</param>
        /// <param name="result">Output Vector. a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</param>
        public static void BaryCentric(ref Vector3 a, ref Vector3 b, ref Vector3 c, double u, double v, out Vector3 result)
        {
            result = a; // copy

            Vector3 temp = b; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, u, out temp);
            Add(ref result, ref temp, out result);

            temp = c; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, v, out temp);
            Add(ref result, ref temp, out result);
        }

        #endregion

        #region Transform

        /// <summary>Transform a direction vector by the given Matrix
        /// Assumes the matrix has a bottom row of (0,0,0,1), that is the translation part is ignored.
        /// </summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed vector</returns>
        public static Vector3 TransformVector(Vector3 vec, Matrix4X4 mat)
        {
            return new Vector3(
                Vector3.Dot(vec, new Vector3(mat.Column0)),
                Vector3.Dot(vec, new Vector3(mat.Column1)),
                Vector3.Dot(vec, new Vector3(mat.Column2)));
        }

        /// <summary>Transform a direction vector by the given Matrix
        /// Assumes the matrix has a bottom row of (0,0,0,1), that is the translation part is ignored.
        /// </summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed vector</param>
        public static void TransformVector(ref Vector3 vec, ref Matrix4X4 mat, out Vector3 result)
        {
            result.x = vec.x * mat.Row0.x +
                       vec.y * mat.Row1.x +
                       vec.z * mat.Row2.x;

            result.y = vec.x * mat.Row0.y +
                       vec.y * mat.Row1.y +
                       vec.z * mat.Row2.y;

            result.z = vec.x * mat.Row0.z +
                       vec.y * mat.Row1.z +
                       vec.z * mat.Row2.z;
        }

        /// <summary>Transform a Normal by the given Matrix</summary>
        /// <remarks>
        /// This calculates the inverse of the given matrix, use TransformNormalInverse if you
        /// already have the inverse to avoid this extra calculation
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed normal</returns>
        public static Vector3 TransformNormal(Vector3 norm, Matrix4X4 mat)
        {
            mat.Invert();
            return TransformNormalInverse(norm, mat);
        }

        /// <summary>Transform a Normal by the given Matrix</summary>
        /// <remarks>
        /// This calculates the inverse of the given matrix, use TransformNormalInverse if you
        /// already have the inverse to avoid this extra calculation
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed normal</param>
        public static void TransformNormal(ref Vector3 norm, ref Matrix4X4 mat, out Vector3 result)
        {
            Matrix4X4 Inverse = Matrix4X4.Invert(mat);
            Vector3.TransformNormalInverse(ref norm, ref Inverse, out result);
        }

        /// <summary>Transform a Normal by the (transpose of the) given Matrix</summary>
        /// <remarks>
        /// This version doesn't calculate the inverse matrix.
        /// Use this version if you already have the inverse of the desired transform to hand
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="invMat">The inverse of the desired transformation</param>
        /// <returns>The transformed normal</returns>
        public static Vector3 TransformNormalInverse(Vector3 norm, Matrix4X4 invMat)
        {
            return new Vector3(
                Vector3.Dot(norm, new Vector3(invMat.Row0)),
                Vector3.Dot(norm, new Vector3(invMat.Row1)),
                Vector3.Dot(norm, new Vector3(invMat.Row2)));
        }

        /// <summary>Transform a Normal by the (transpose of the) given Matrix</summary>
        /// <remarks>
        /// This version doesn't calculate the inverse matrix.
        /// Use this version if you already have the inverse of the desired transform to hand
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="invMat">The inverse of the desired transformation</param>
        /// <param name="result">The transformed normal</param>
        public static void TransformNormalInverse(ref Vector3 norm, ref Matrix4X4 invMat, out Vector3 result)
        {
            result.x = norm.x * invMat.Row0.x +
                       norm.y * invMat.Row0.y +
                       norm.z * invMat.Row0.z;

            result.y = norm.x * invMat.Row1.x +
                       norm.y * invMat.Row1.y +
                       norm.z * invMat.Row1.z;

            result.z = norm.x * invMat.Row2.x +
                       norm.y * invMat.Row2.y +
                       norm.z * invMat.Row2.z;
        }

        /// <summary>Transform a Position by the given Matrix</summary>
        /// <param name="pos">The position to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed position</returns>
        public static Vector3 TransformPosition(Vector3 pos, Matrix4X4 mat)
        {
            return new Vector3(
                Vector3.Dot(pos, new Vector3(mat.Column0)) + mat.Row3.x,
                Vector3.Dot(pos, new Vector3(mat.Column1)) + mat.Row3.y,
                Vector3.Dot(pos, new Vector3(mat.Column2)) + mat.Row3.z);
        }

        /// <summary>Transform a Position by the given Matrix</summary>
        /// <param name="pos">The position to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed position</param>
        public static void TransformPosition(ref Vector3 pos, ref Matrix4X4 mat, out Vector3 result)
        {
            result.x = pos.x * mat.Row0.x +
                       pos.y * mat.Row1.x +
                       pos.z * mat.Row2.x +
                       mat.Row3.x;

            result.y = pos.x * mat.Row0.y +
                       pos.y * mat.Row1.y +
                       pos.z * mat.Row2.y +
                       mat.Row3.y;

            result.z = pos.x * mat.Row0.z +
                       pos.y * mat.Row1.z +
                       pos.z * mat.Row2.z +
                       mat.Row3.z;
        }

        /// <summary>
        /// Transform all the vectors in the array by the given Matrix.
        /// </summary>
        /// <param name="boundsVerts"></param>
        /// <param name="rotationQuaternion"></param>
        public static void Transform(Vector3[] vecArray, Matrix4X4 mat)
        {
            for (int i = 0; i < vecArray.Length; i++)
            {
                vecArray[i] = Transform(vecArray[i], mat);
            }
        }

        /// <summary>Transform a Vector by the given Matrix</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed vector</returns>
        public static Vector3 Transform(Vector3 vec, Matrix4X4 mat)
        {
            Vector3 result;
            Transform(ref vec, ref mat, out result);
            return result;
        }

        /// <summary>Transform a Vector by the given Matrix</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed vector</param>
        public static void Transform(ref Vector3 vec, ref Matrix4X4 mat, out Vector3 result)
        {
            Vector4 v4 = new Vector4(vec.x, vec.y, vec.z, 1.0);
            Vector4.Transform(ref v4, ref mat, out v4);
            result = v4.Xyz;
        }

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector3 Transform(Vector3 vec, Quaternion quat)
        {
            Vector3 result;
            Transform(ref vec, ref quat, out result);
            return result;
        }

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <param name="result">The result of the operation.</param>
        public static void Transform(ref Vector3 vec, ref Quaternion quat, out Vector3 result)
        {
            // Since vec.W == 0, we can optimize quat * vec * quat^-1 as follows:
            // vec + 2.0 * cross(quat.xyz, cross(quat.xyz, vec) + quat.w * vec)
            Vector3 xyz = quat.Xyz, temp, temp2;
            Vector3.Cross(ref xyz, ref vec, out temp);
            Vector3.Multiply(ref vec, quat.W, out temp2);
            Vector3.Add(ref temp, ref temp2, out temp);
            Vector3.Cross(ref xyz, ref temp, out temp);
            Vector3.Multiply(ref temp, 2, out temp);
            Vector3.Add(ref vec, ref temp, out result);
        }

        /// <summary>
        /// Transform all the vectors in the array by the quaternion rotation.
        /// </summary>
        /// <param name="boundsVerts"></param>
        /// <param name="rotationQuaternion"></param>
        public static void Transform(Vector3[] vecArray, Quaternion rotationQuaternion)
        {
            for (int i = 0; i < vecArray.Length; i++)
            {
                vecArray[i] = Transform(vecArray[i], rotationQuaternion);
            }
        }

        /// <summary>
        /// Transform a Vector3d by the given Matrix, and project the resulting Vector4 back to a Vector3
        /// </summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed vector</returns>
        public static Vector3 TransformPerspective(Vector3 vec, Matrix4X4 mat)
        {
            Vector3 result;
            TransformPerspective(ref vec, ref mat, out result);
            return result;
        }

        /// <summary>Transform a Vector3d by the given Matrix, and project the resulting Vector4d back to a Vector3d</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed vector</param>
        public static void TransformPerspective(ref Vector3 vec, ref Matrix4X4 mat, out Vector3 result)
        {
            Vector4 v = new Vector4(vec);
            Vector4.Transform(ref v, ref mat, out v);
            result.x = v.x / v.w;
            result.y = v.y / v.w;
            result.z = v.z / v.w;
        }

        #endregion

        #region CalculateAngle

        /// <summary>
        /// Calculates the angle (in radians) between two vectors.
        /// </summary>
        /// <param name="first">The first vector.</param>
        /// <param name="second">The second vector.</param>
        /// <returns>Angle (in radians) between the vectors.</returns>
        /// <remarks>Note that the returned angle is never bigger than the constant Pi.</remarks>
        public static double CalculateAngle(Vector3 first, Vector3 second)
        {
            return System.Math.Acos((Vector3.Dot(first, second)) / (first.Length * second.Length));
        }

        /// <summary>Calculates the angle (in radians) between two vectors.</summary>
        /// <param name="first">The first vector.</param>
        /// <param name="second">The second vector.</param>
        /// <param name="result">Angle (in radians) between the vectors.</param>
        /// <remarks>Note that the returned angle is never bigger than the constant Pi.</remarks>
        public static void CalculateAngle(ref Vector3 first, ref Vector3 second, out double result)
        {
            double temp;
            Vector3.Dot(ref first, ref second, out temp);
            result = System.Math.Acos(temp / (first.Length * second.Length));
        }

        #endregion

        #endregion

        #region Swizzle

        /// <summary>
        /// Gets or sets an OpenTK.Vector2d with the X and Y components of this instance.
        /// </summary>
        //[JsonIgnoreAttribute]
        public Vector2 Xy { get { return new Vector2(x, y); } set { x = value.x; y = value.y; } }

        #endregion

        #region Operators

        /// <summary>
        /// Adds two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3 operator +(Vector3 left, Vector3 right)
        {
            left.x += right.x;
            left.y += right.y;
            left.z += right.z;
            return left;
        }

        /// <summary>
        /// Subtracts two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3 operator -(Vector3 left, Vector3 right)
        {
            left.x -= right.x;
            left.y -= right.y;
            left.z -= right.z;
            return left;
        }

        /// <summary>
        /// Negates an instance.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3 operator -(Vector3 vec)
        {
            vec.x = -vec.x;
            vec.y = -vec.y;
            vec.z = -vec.z;
            return vec;
        }

        /// <summary>
        /// Component wise multiply two vectors together, x*x, y*y, z*z.
        /// </summary>
        /// <param name="vecA"></param>
        /// <param name="vecB"></param>
        /// <returns></returns>
        public static Vector3 operator *(Vector3 vecA, Vector3 vecB)
        {
            vecA.x *= vecB.x;
            vecA.y *= vecB.y;
            vecA.z *= vecB.z;
            return vecA;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3 operator *(Vector3 vec, double scale)
        {
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            return vec;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="scale">The scalar.</param>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3 operator *(double scale, Vector3 vec)
        {
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            return vec;
        }

        /// <summary>
        /// Creates a new vector which is the numerator devided by each component of the vector.
        /// </summary>
        /// <param name="numerator"></param>
        /// <param name="vec"></param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3 operator /(double numerator, Vector3 vec)
        {
            return new Vector3((numerator / vec.x), (numerator / vec.y), (numerator / vec.z));
        }

        /// <summary>
        /// Divides an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3 operator /(Vector3 vec, double scale)
        {
            double mult = 1 / scale;
            vec.x *= mult;
            vec.y *= mult;
            vec.z *= mult;
            return vec;
        }

        /// <summary>
        /// Compares two instances for equality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left equals right; false otherwise.</returns>
        public static bool operator ==(Vector3 left, Vector3 right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Compares two instances for inequality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left does not equa lright; false otherwise.</returns>
        public static bool operator !=(Vector3 left, Vector3 right)
        {
            return !left.Equals(right);
        }

        #endregion

        #region Overrides

        #region public override string ToString()

        /// <summary>
        /// Returns a System.String that represents the current Vector3.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("[{0}, {1}, {2}]", x, y, z);
        }

        #endregion

        #region public override int GetHashCode()

        /// <summary>
        /// Returns the hashcode for this instance.
        /// </summary>
        /// <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
        public override int GetHashCode()
        {
            return new { x, y, z }.GetHashCode();
        }

        #endregion

        #region public override bool Equals(object obj)

        /// <summary>
        /// Indicates whether this instance and a specified object are equal.
        /// </summary>
        /// <param name="obj">The object to compare to.</param>
        /// <returns>True if the instances are equal; false otherwise.</returns>
        public override bool Equals(object obj)
        {
            if (!(obj is Vector3))
                return false;

            return this.Equals((Vector3)obj);
        }

        /// <summary>
        /// Indicates whether this instance and a specified object are equal within an error range.
        /// </summary>
        /// <param name="OtherVector"></param>
        /// <param name="ErrorValue"></param>
        /// <returns>True if the instances are equal; false otherwise.</returns>
        public bool Equals(Vector3 OtherVector, double ErrorValue)
        {
            if ((x < OtherVector.x + ErrorValue && x > OtherVector.x - ErrorValue) &&
                (y < OtherVector.y + ErrorValue && y > OtherVector.y - ErrorValue) &&
                (z < OtherVector.z + ErrorValue && z > OtherVector.z - ErrorValue))
            {
                return true;
            }

            return false;
        }

        #endregion

        #endregion

        #endregion

        #region IEquatable<Vector3> Members

        /// <summary>Indicates whether the current vector is equal to another vector.</summary>
        /// <param name="other">A vector to compare with this vector.</param>
        /// <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
        public bool Equals(Vector3 other)
        {
            return
                x == other.x &&
                y == other.y &&
                z == other.z;
        }

        #endregion

        public static double ComponentMax(Vector3 vector3)
        {
            return Math.Max(vector3.x, Math.Max(vector3.y, vector3.z));
        }

        public static double ComponentMin(Vector3 vector3)
        {
            return Math.Min(vector3.x, Math.Min(vector3.y, vector3.z));
        }
    }
}

#endregion //Vector3.cs
#region Vector3Float.cs

namespace MatterHackers.VectorMath
{
    /// <summary>
    /// Represents a 3D vector using three float-precision floating-point numbers.
    /// </summary>
    //[Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public struct Vector3Float : IEquatable<Vector3Float>
    {
        #region Fields

        /// <summary>
        /// The X component of the Vector3Float.
        /// </summary>
        public float x;

        /// <summary>
        /// The Y component of the Vector3Float.
        /// </summary>
        public float y;

        /// <summary>
        /// The Z component of the Vector3Float.
        /// </summary>
        public float z;

        #endregion // Fields

        #region Constructors

        /// <summary>
        /// Constructs a new Vector3Float.
        /// </summary>
        /// <param name="x">The x component of the Vector3Float.</param>
        /// <param name="y">The y component of the Vector3Float.</param>
        /// <param name="z">The z component of the Vector3Float.</param>
        public Vector3Float(float x, float y, float z)
        {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        /// <summary>
        /// Constructs a new instance from the given Vector2d.
        /// </summary>
        /// <param name="v">The Vector2d to copy components from.</param>
        public Vector3Float(Vector2 v, float z = 0)
        {
#if true
            throw new NotImplementedException();
#else
            x = v.x;
            y = v.y;
            this.z = z;
#endif
        }

        /// <summary>
        /// Constructs a new instance from the given Vector3Floatd.
        /// </summary>
        /// <param name="v">The Vector3Floatd to copy components from.</param>
        public Vector3Float(Vector3Float v)
        {
            x = v.x;
            y = v.y;
            z = v.z;
        }

        public Vector3Float(float[] floatArray)
        {
            x = floatArray[0];
            y = floatArray[1];
            z = floatArray[2];
        }

        /// <summary>
        /// Constructs a new instance from the given Vector4d.
        /// </summary>
        /// <param name="v">The Vector4d to copy components from.</param>
        public Vector3Float(Vector4 v)
        {
#if true
            throw new NotImplementedException();
#else
            x = v.x;
            y = v.y;
            z = v.z;
#endif
        }

        public Vector3Float(Vector3 position)
        {
            this.x = (float)position.x;
            this.y = (float)position.y;
            this.z = (float)position.z;
        }

        #endregion

        #region Properties

        public float this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0: return x;
                    case 1: return y;
                    case 2: return z;
                    default: return 0;
                }
            }

            set
            {
                switch (index)
                {
                    case 0: x = value; break;
                    case 1: y = value; break;
                    case 2: z = value; break;
                    default: throw new Exception();
                }
            }
        }

        #endregion

        #region Public Members

        #region Instance

        #region public float Length

        /// <summary>
        /// Gets the length (magnitude) of the vector.
        /// </summary>
        /// <see cref="LengthFast"/>
        /// <seealso cref="LengthSquared"/>
        public float Length
        {
            get
            {
                return (float)Math.Sqrt(x * x + y * y + z * z);
            }
        }

        #endregion

        #region public float LengthSquared

        /// <summary>
        /// Gets the square of the vector length (magnitude).
        /// </summary>
        /// <remarks>
        /// This property avoids the costly square root operation required by the Length property. This makes it more suitable
        /// for comparisons.
        /// </remarks>
        /// <see cref="Length"/>
        /// <seealso cref="LengthFast"/>
        public float LengthSquared
        {
            get
            {
                return x * x + y * y + z * z;
            }
        }

        #endregion

        #region public void Normalize()

        /// <summary>
        /// Returns a normalized Vector of this.
        /// </summary>
        /// <returns></returns>
        public Vector3Float GetNormal()
        {
            Vector3Float temp = this;
            temp.Normalize();
            return temp;
        }

        /// <summary>
        /// Scales the Vector3Floatd to unit length.
        /// </summary>
        public void Normalize()
        {
            float scale = 1.0f / this.Length;
            x *= scale;
            y *= scale;
            z *= scale;
        }

        #endregion

        #region public float[] ToArray()

        public float[] ToArray()
        {
            return new float[] { x, y, z };
        }

        #endregion

        #endregion

        #region Static

        #region Fields

        /// <summary>
        /// Defines a unit-length Vector3Floatd that points towards the X-axis.
        /// </summary>
        public static readonly Vector3Float UnitX = new Vector3Float(1, 0, 0);

        /// <summary>
        /// Defines a unit-length Vector3Floatd that points towards the Y-axis.
        /// </summary>
        public static readonly Vector3Float UnitY = new Vector3Float(0, 1, 0);

        /// <summary>
        /// /// Defines a unit-length Vector3Floatd that points towards the Z-axis.
        /// </summary>
        public static readonly Vector3Float UnitZ = new Vector3Float(0, 0, 1);

        /// <summary>
        /// Defines a zero-length Vector3Float.
        /// </summary>
        public static readonly Vector3Float Zero = new Vector3Float(0, 0, 0);

        /// <summary>
        /// Defines an instance with all components set to 1.
        /// </summary>
        public static readonly Vector3Float One = new Vector3Float(1, 1, 1);

        /// <summary>
        /// Defines an instance with all components set to positive infinity.
        /// </summary>
        public static readonly Vector3Float PositiveInfinity = new Vector3Float(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity);

        /// <summary>
        /// Defines an instance with all components set to negative infinity.
        /// </summary>
        public static readonly Vector3Float NegativeInfinity = new Vector3Float(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity);

        /// <summary>
        /// Defines the size of the Vector3Floatd struct in bytes.
        /// </summary>
        public static readonly int SizeInBytes = Marshal.SizeOf(new Vector3Float());

        #endregion

        #region Add

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <returns>Result of operation.</returns>
        public static Vector3Float Add(Vector3Float a, Vector3Float b)
        {
            Add(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <param name="result">Result of operation.</param>
        public static void Add(ref Vector3Float a, ref Vector3Float b, out Vector3Float result)
        {
            result = new Vector3Float(a.x + b.x, a.y + b.y, a.z + b.z);
        }

        #endregion

        #region Subtract

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>Result of subtraction</returns>
        public static Vector3Float Subtract(Vector3Float a, Vector3Float b)
        {
            Subtract(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">Result of subtraction</param>
        public static void Subtract(ref Vector3Float a, ref Vector3Float b, out Vector3Float result)
        {
            result = new Vector3Float(a.x - b.x, a.y - b.y, a.z - b.z);
        }

        #endregion

        #region Multiply

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3Float Multiply(Vector3Float vector, float scale)
        {
            Multiply(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector3Float vector, float scale, out Vector3Float result)
        {
            result = new Vector3Float(vector.x * scale, vector.y * scale, vector.z * scale);
        }

        /// <summary>
        /// Multiplies a vector by the components a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3Float Multiply(Vector3Float vector, Vector3Float scale)
        {
            Multiply(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector3Float vector, ref Vector3Float scale, out Vector3Float result)
        {
            result = new Vector3Float(vector.x * scale.x, vector.y * scale.y, vector.z * scale.z);
        }

        #endregion

        #region Divide

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3Float Divide(Vector3Float vector, float scale)
        {
            Divide(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector3Float vector, float scale, out Vector3Float result)
        {
            Multiply(ref vector, 1 / scale, out result);
        }

        /// <summary>
        /// Divides a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector3Float Divide(Vector3Float vector, Vector3Float scale)
        {
            Divide(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divide a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector3Float vector, ref Vector3Float scale, out Vector3Float result)
        {
            result = new Vector3Float(vector.x / scale.x, vector.y / scale.y, vector.z / scale.z);
        }

        #endregion

        #region ComponentMin

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise minimum</returns>
        public static Vector3Float ComponentMin(Vector3Float a, Vector3Float b)
        {
            a.x = a.x < b.x ? a.x : b.x;
            a.y = a.y < b.y ? a.y : b.y;
            a.z = a.z < b.z ? a.z : b.z;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise minimum</param>
        public static void ComponentMin(ref Vector3Float a, ref Vector3Float b, out Vector3Float result)
        {
            result.x = a.x < b.x ? a.x : b.x;
            result.y = a.y < b.y ? a.y : b.y;
            result.z = a.z < b.z ? a.z : b.z;
        }

        #endregion

        #region ComponentMax

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise maximum</returns>
        public static Vector3Float ComponentMax(Vector3Float a, Vector3Float b)
        {
            a.x = a.x > b.x ? a.x : b.x;
            a.y = a.y > b.y ? a.y : b.y;
            a.z = a.z > b.z ? a.z : b.z;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise maximum</param>
        public static void ComponentMax(ref Vector3Float a, ref Vector3Float b, out Vector3Float result)
        {
            result.x = a.x > b.x ? a.x : b.x;
            result.y = a.y > b.y ? a.y : b.y;
            result.z = a.z > b.z ? a.z : b.z;
        }

        #endregion

        #region Min

        /// <summary>
        /// Returns the Vector3d with the minimum magnitude
        /// </summary>
        /// <param name="left">Left operand</param>
        /// <param name="right">Right operand</param>
        /// <returns>The minimum Vector3Float</returns>
        public static Vector3Float Min(Vector3Float left, Vector3Float right)
        {
            return left.LengthSquared < right.LengthSquared ? left : right;
        }

        #endregion

        #region Max

        /// <summary>
        /// Returns the Vector3d with the minimum magnitude
        /// </summary>
        /// <param name="left">Left operand</param>
        /// <param name="right">Right operand</param>
        /// <returns>The minimum Vector3Float</returns>
        public static Vector3Float Max(Vector3Float left, Vector3Float right)
        {
            return left.LengthSquared >= right.LengthSquared ? left : right;
        }

        #endregion

        #region Clamp

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <returns>The clamped vector</returns>
        public static Vector3Float Clamp(Vector3Float vec, Vector3Float min, Vector3Float max)
        {
            vec.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            vec.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
            vec.z = vec.z < min.z ? min.z : vec.z > max.z ? max.z : vec.z;
            return vec;
        }

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <param name="result">The clamped vector</param>
        public static void Clamp(ref Vector3Float vec, ref Vector3Float min, ref Vector3Float max, out Vector3Float result)
        {
            result.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            result.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
            result.z = vec.z < min.z ? min.z : vec.z > max.z ? max.z : vec.z;
        }

        #endregion

        #region Normalize

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <returns>The normalized vector</returns>
        public static Vector3Float Normalize(Vector3Float vec)
        {
            float scale = 1.0f / vec.Length;
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            return vec;
        }

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <param name="result">The normalized vector</param>
        public static void Normalize(ref Vector3Float vec, out Vector3Float result)
        {
            float scale = 1.0f / vec.Length;
            result.x = vec.x * scale;
            result.y = vec.y * scale;
            result.z = vec.z * scale;
        }

        #endregion

        #region Dot

        /// <summary>
        /// Calculate the dot (scalar) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The dot product of the two inputs</returns>
        public static float Dot(Vector3Float left, Vector3Float right)
        {
            return left.x * right.x + left.y * right.y + left.z * right.z;
        }

        /// <summary>
        /// Calculate the dot (scalar) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <param name="result">The dot product of the two inputs</param>
        public static void Dot(ref Vector3Float left, ref Vector3Float right, out float result)
        {
            result = left.x * right.x + left.y * right.y + left.z * right.z;
        }

        #endregion

        #region Cross

        /// <summary>
        /// Caclulate the cross (vector) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The cross product of the two inputs</returns>
        public static Vector3Float Cross(Vector3Float left, Vector3Float right)
        {
            Vector3Float result;
            Cross(ref left, ref right, out result);
            return result;
        }

        /// <summary>
        /// Caclulate the cross (vector) product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The cross product of the two inputs</returns>
        /// <param name="result">The cross product of the two inputs</param>
        public static void Cross(ref Vector3Float left, ref Vector3Float right, out Vector3Float result)
        {
            result = new Vector3Float(left.y * right.z - left.z * right.y,
                left.z * right.x - left.x * right.z,
                left.x * right.y - left.y * right.x);
        }

        #endregion // Cross

        #region Utility
        /// <summary>
        /// Checks if 3 points are collinear (all lie on the same line).
        /// </summary>
        /// <param name="a"></param>
        /// <param name="b"></param>
        /// <param name="c"></param>
        /// <param name="epsilon"></param>
        /// <returns></returns>
        public static bool Collinear(Vector3Float a, Vector3Float b, Vector3Float c, float epsilon = .000001f)
        {
            // Return true if a, b, and c all lie on the same line.
            return Math.Abs(Cross(b - a, c - a).Length) < epsilon;
        }

        #endregion // Utility

        #region Lerp

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <returns>a when blend=0, b when blend=1, and a linear combination otherwise</returns>
        public static Vector3Float Lerp(Vector3Float a, Vector3Float b, float blend)
        {
            a.x = blend * (b.x - a.x) + a.x;
            a.y = blend * (b.y - a.y) + a.y;
            a.z = blend * (b.z - a.z) + a.z;
            return a;
        }

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <param name="result">a when blend=0, b when blend=1, and a linear combination otherwise</param>
        public static void Lerp(ref Vector3Float a, ref Vector3Float b, float blend, out Vector3Float result)
        {
            result.x = blend * (b.x - a.x) + a.x;
            result.y = blend * (b.y - a.y) + a.y;
            result.z = blend * (b.z - a.z) + a.z;
        }

        #endregion

        #region Barycentric

        /// <summary>
        /// Interpolate 3 Vectors using Barycentric coordinates
        /// </summary>
        /// <param name="a">First input Vector</param>
        /// <param name="b">Second input Vector</param>
        /// <param name="c">Third input Vector</param>
        /// <param name="u">First Barycentric Coordinate</param>
        /// <param name="v">Second Barycentric Coordinate</param>
        /// <returns>a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</returns>
        public static Vector3Float BaryCentric(Vector3Float a, Vector3Float b, Vector3Float c, float u, float v)
        {
            return a + u * (b - a) + v * (c - a);
        }

        /// <summary>Interpolate 3 Vectors using Barycentric coordinates</summary>
        /// <param name="a">First input Vector.</param>
        /// <param name="b">Second input Vector.</param>
        /// <param name="c">Third input Vector.</param>
        /// <param name="u">First Barycentric Coordinate.</param>
        /// <param name="v">Second Barycentric Coordinate.</param>
        /// <param name="result">Output Vector. a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</param>
        public static void BaryCentric(ref Vector3Float a, ref Vector3Float b, ref Vector3Float c, float u, float v, out Vector3Float result)
        {
            result = a; // copy

            Vector3Float temp = b; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, u, out temp);
            Add(ref result, ref temp, out result);

            temp = c; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, v, out temp);
            Add(ref result, ref temp, out result);
        }

        #endregion

        #region Transform

        /// <summary>Transform a direction vector by the given Matrix
        /// Assumes the matrix has a bottom row of (0,0,0,1), that is the translation part is ignored.
        /// </summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed vector</returns>
        public static Vector3Float TransformVector(Vector3Float vec, Matrix4X4 mat)
        {
            return new Vector3Float(
                Vector3Float.Dot(vec, new Vector3Float(mat.Column0)),
                Vector3Float.Dot(vec, new Vector3Float(mat.Column1)),
                Vector3Float.Dot(vec, new Vector3Float(mat.Column2)));
        }

        /// <summary>Transform a direction vector by the given Matrix
        /// Assumes the matrix has a bottom row of (0,0,0,1), that is the translation part is ignored.
        /// </summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed vector</param>
        public static void TransformVector(ref Vector3Float vec, ref Matrix4X4 mat, out Vector3Float result)
        {
#if true
            throw new NotImplementedException();
#else
            result.x = vec.x * mat.Row0.x +
                       vec.y * mat.Row1.x +
                       vec.z * mat.Row2.x;

            result.y = vec.x * mat.Row0.y +
                       vec.y * mat.Row1.y +
                       vec.z * mat.Row2.y;

            result.z = vec.x * mat.Row0.z +
                       vec.y * mat.Row1.z +
                       vec.z * mat.Row2.z;
#endif
        }

        /// <summary>Transform a Normal by the given Matrix</summary>
        /// <remarks>
        /// This calculates the inverse of the given matrix, use TransformNormalInverse if you
        /// already have the inverse to avoid this extra calculation
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed normal</returns>
        public static Vector3Float TransformNormal(Vector3Float norm, Matrix4X4 mat)
        {
            mat.Invert();
            return TransformNormalInverse(norm, mat);
        }

        /// <summary>Transform a Normal by the given Matrix</summary>
        /// <remarks>
        /// This calculates the inverse of the given matrix, use TransformNormalInverse if you
        /// already have the inverse to avoid this extra calculation
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed normal</param>
        public static void TransformNormal(ref Vector3Float norm, ref Matrix4X4 mat, out Vector3Float result)
        {
            Matrix4X4 Inverse = Matrix4X4.Invert(mat);
            Vector3Float.TransformNormalInverse(ref norm, ref Inverse, out result);
        }

        /// <summary>Transform a Normal by the (transpose of the) given Matrix</summary>
        /// <remarks>
        /// This version doesn't calculate the inverse matrix.
        /// Use this version if you already have the inverse of the desired transform to hand
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="invMat">The inverse of the desired transformation</param>
        /// <returns>The transformed normal</returns>
        public static Vector3Float TransformNormalInverse(Vector3Float norm, Matrix4X4 invMat)
        {
            return new Vector3Float(
                Vector3Float.Dot(norm, new Vector3Float(invMat.Row0)),
                Vector3Float.Dot(norm, new Vector3Float(invMat.Row1)),
                Vector3Float.Dot(norm, new Vector3Float(invMat.Row2)));
        }

        /// <summary>Transform a Normal by the (transpose of the) given Matrix</summary>
        /// <remarks>
        /// This version doesn't calculate the inverse matrix.
        /// Use this version if you already have the inverse of the desired transform to hand
        /// </remarks>
        /// <param name="norm">The normal to transform</param>
        /// <param name="invMat">The inverse of the desired transformation</param>
        /// <param name="result">The transformed normal</param>
        public static void TransformNormalInverse(ref Vector3Float norm, ref Matrix4X4 invMat, out Vector3Float result)
        {
#if true
            throw new NotImplementedException();
#else
            result.x = norm.x * invMat.Row0.x +
                       norm.y * invMat.Row0.y +
                       norm.z * invMat.Row0.z;

            result.y = norm.x * invMat.Row1.x +
                       norm.y * invMat.Row1.y +
                       norm.z * invMat.Row1.z;

            result.z = norm.x * invMat.Row2.x +
                       norm.y * invMat.Row2.y +
                       norm.z * invMat.Row2.z;
#endif
        }

        /// <summary>Transform a Position by the given Matrix</summary>
        /// <param name="pos">The position to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed position</returns>
        public static Vector3Float TransformPosition(Vector3Float pos, Matrix4X4 mat)
        {
#if true
            throw new NotImplementedException();
#else
            return new Vector3Float(
                Vector3Float.Dot(pos, new Vector3Float((float)mat.Column0)) + mat.Row3.x,
                Vector3Float.Dot(pos, new Vector3Float((float)mat.Column1)) + mat.Row3.y,
                Vector3Float.Dot(pos, new Vector3Float((float)mat.Column2)) + mat.Row3.z);
#endif
        }

        /// <summary>Transform a Position by the given Matrix</summary>
        /// <param name="pos">The position to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed position</param>
        public static void TransformPosition(ref Vector3Float pos, ref Matrix4X4 mat, out Vector3Float result)
        {
#if true
            throw new NotImplementedException();
#else
            result.x = pos.x * mat.Row0.x +
                       pos.y * mat.Row1.x +
                       pos.z * mat.Row2.x +
                       mat.Row3.x;

            result.y = pos.x * mat.Row0.y +
                       pos.y * mat.Row1.y +
                       pos.z * mat.Row2.y +
                       mat.Row3.y;

            result.z = pos.x * mat.Row0.z +
                       pos.y * mat.Row1.z +
                       pos.z * mat.Row2.z +
                       mat.Row3.z;
#endif
        }

        /// <summary>
        /// Transform all the vectors in the array by the given Matrix.
        /// </summary>
        /// <param name="boundsVerts"></param>
        /// <param name="rotationQuaternion"></param>
        public static void Transform(Vector3Float[] vecArray, Matrix4X4 mat)
        {
            for (int i = 0; i < vecArray.Length; i++)
            {
                vecArray[i] = Transform(vecArray[i], mat);
            }
        }

        /// <summary>Transform a Vector by the given Matrix</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed vector</returns>
        public static Vector3Float Transform(Vector3Float vec, Matrix4X4 mat)
        {
            Vector3Float result;
            Transform(ref vec, ref mat, out result);
            return result;
        }

        /// <summary>Transform a Vector by the given Matrix</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed vector</param>
        public static void Transform(ref Vector3Float vec, ref Matrix4X4 mat, out Vector3Float result)
        {
#if true
            throw new NotImplementedException();
#else
            Vector4 v4 = new Vector4(vec.x, vec.y, vec.z, 1.0);
            Vector4.Transform(ref v4, ref mat, out v4);
            result = v4.Xyz;
#endif
        }

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector3Float Transform(Vector3Float vec, Quaternion quat)
        {
#if true
            throw new NotImplementedException();
#else
            Vector3Float result;
            Transform(ref vec, ref quat, out result);
            return result;
#endif
        }

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <param name="result">The result of the operation.</param>
        public static void Transform(ref Vector3Float vec, ref Quaternion quat, out Vector3Float result)
        {
#if true
            throw new NotImplementedException();
#else
            // Since vec.W == 0, we can optimize quat * vec * quat^-1 as follows:
            // vec + 2.0 * cross(quat.xyz, cross(quat.xyz, vec) + quat.w * vec)
            Vector3Float xyz = quat.Xyz, temp, temp2;
            Vector3Float.Cross(ref xyz, ref vec, out temp);
            Vector3Float.Multiply(ref vec, quat.W, out temp2);
            Vector3Float.Add(ref temp, ref temp2, out temp);
            Vector3Float.Cross(ref xyz, ref temp, out temp);
            Vector3Float.Multiply(ref temp, 2, out temp);
            Vector3Float.Add(ref vec, ref temp, out result);
#endif
        }

        /// <summary>
        /// Transform all the vectors in the array by the quaternion rotation.
        /// </summary>
        /// <param name="boundsVerts"></param>
        /// <param name="rotationQuaternion"></param>
        public static void Transform(Vector3Float[] vecArray, Quaternion rotationQuaternion)
        {
            for (int i = 0; i < vecArray.Length; i++)
            {
                vecArray[i] = Transform(vecArray[i], rotationQuaternion);
            }
        }

        /// <summary>
        /// Transform a Vector3d by the given Matrix, and project the resulting Vector4 back to a Vector3Float
        /// </summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed vector</returns>
        public static Vector3Float TransformPerspective(Vector3Float vec, Matrix4X4 mat)
        {
#if true
            throw new NotImplementedException();
#else
            Vector3Float result;
            TransformPerspective(ref vec, ref mat, out result);
            return result;
#endif
        }

        /// <summary>Transform a Vector3d by the given Matrix, and project the resulting Vector4d back to a Vector3d</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed vector</param>
        public static void TransformPerspective(ref Vector3Float vec, ref Matrix4X4 mat, out Vector3Float result)
        {
#if true
            throw new NotImplementedException();
#else
            Vector4 v = new Vector4(vec);
            Vector4.Transform(ref v, ref mat, out v);
            result.x = v.x / v.w;
            result.y = v.y / v.w;
            result.z = v.z / v.w;
#endif
        }

        #endregion

        #region CalculateAngle

        /// <summary>
        /// Calculates the angle (in radians) between two vectors.
        /// </summary>
        /// <param name="first">The first vector.</param>
        /// <param name="second">The second vector.</param>
        /// <returns>Angle (in radians) between the vectors.</returns>
        /// <remarks>Note that the returned angle is never bigger than the constant Pi.</remarks>
        public static float CalculateAngle(Vector3Float first, Vector3Float second)
        {
            return (float)Math.Acos((Vector3Float.Dot(first, second)) / (first.Length * second.Length));
        }

        /// <summary>Calculates the angle (in radians) between two vectors.</summary>
        /// <param name="first">The first vector.</param>
        /// <param name="second">The second vector.</param>
        /// <param name="result">Angle (in radians) between the vectors.</param>
        /// <remarks>Note that the returned angle is never bigger than the constant Pi.</remarks>
        public static void CalculateAngle(ref Vector3Float first, ref Vector3Float second, out float result)
        {
            float temp;
            Vector3Float.Dot(ref first, ref second, out temp);
            result = (float)Math.Acos(temp / (first.Length * second.Length));
        }

        #endregion

        #endregion

        #region Swizzle

        /// <summary>
        /// Gets or sets an OpenTK.Vector2d with the X and Y components of this instance.
        /// </summary>
        public Vector2 Xy
        {
            get
            {
                return new Vector2(x, y);
            }
            set
            {
#if true
                throw new NotImplementedException();
#else
                x = value.x; y = value.y; 
#endif
            }
        }

        #endregion

        #region Operators

        /// <summary>
        /// Adds two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3Float operator +(Vector3Float left, Vector3Float right)
        {
            left.x += right.x;
            left.y += right.y;
            left.z += right.z;
            return left;
        }

        /// <summary>
        /// Subtracts two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3Float operator -(Vector3Float left, Vector3Float right)
        {
            left.x -= right.x;
            left.y -= right.y;
            left.z -= right.z;
            return left;
        }

        /// <summary>
        /// Negates an instance.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3Float operator -(Vector3Float vec)
        {
            vec.x = -vec.x;
            vec.y = -vec.y;
            vec.z = -vec.z;
            return vec;
        }

        /// <summary>
        /// Component wise multiply two vectors together, x*x, y*y, z*z.
        /// </summary>
        /// <param name="vecA"></param>
        /// <param name="vecB"></param>
        /// <returns></returns>
        public static Vector3Float operator *(Vector3Float vecA, Vector3Float vecB)
        {
            vecA.x *= vecB.x;
            vecA.y *= vecB.y;
            vecA.z *= vecB.z;
            return vecA;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3Float operator *(Vector3Float vec, float scale)
        {
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            return vec;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="scale">The scalar.</param>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3Float operator *(float scale, Vector3Float vec)
        {
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            return vec;
        }

        /// <summary>
        /// Creates a new vector which is the numerator devided by each component of the vector.
        /// </summary>
        /// <param name="numerator"></param>
        /// <param name="vec"></param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3Float operator /(float numerator, Vector3Float vec)
        {
            return new Vector3Float((numerator / vec.x), (numerator / vec.y), (numerator / vec.z));
        }

        /// <summary>
        /// Divides an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector3Float operator /(Vector3Float vec, float scale)
        {
            float mult = 1 / scale;
            vec.x *= mult;
            vec.y *= mult;
            vec.z *= mult;
            return vec;
        }

        /// <summary>
        /// Compares two instances for equality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left equals right; false otherwise.</returns>
        public static bool operator ==(Vector3Float left, Vector3Float right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Compares two instances for inequality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left does not equa lright; false otherwise.</returns>
        public static bool operator !=(Vector3Float left, Vector3Float right)
        {
            return !left.Equals(right);
        }

        #endregion

        #region Overrides

        #region public override string ToString()

        /// <summary>
        /// Returns a System.String that represents the current Vector3Float.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("[{0}, {1}, {2}]", x, y, z);
        }

        #endregion

        #region public override int GetHashCode()

        /// <summary>
        /// Returns the hashcode for this instance.
        /// </summary>
        /// <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
        public override int GetHashCode()
        {
            return new { x, y, z }.GetHashCode();
        }

        #endregion

        #region public override bool Equals(object obj)

        /// <summary>
        /// Indicates whether this instance and a specified object are equal.
        /// </summary>
        /// <param name="obj">The object to compare to.</param>
        /// <returns>True if the instances are equal; false otherwise.</returns>
        public override bool Equals(object obj)
        {
            if (!(obj is Vector3Float))
                return false;

            return this.Equals((Vector3Float)obj);
        }

        /// <summary>
        /// Indicates whether this instance and a specified object are equal within an error range.
        /// </summary>
        /// <param name="OtherVector"></param>
        /// <param name="ErrorValue"></param>
        /// <returns>True if the instances are equal; false otherwise.</returns>
        public bool Equals(Vector3Float OtherVector, float ErrorValue)
        {
            if ((x < OtherVector.x + ErrorValue && x > OtherVector.x - ErrorValue) &&
                (y < OtherVector.y + ErrorValue && y > OtherVector.y - ErrorValue) &&
                (z < OtherVector.z + ErrorValue && z > OtherVector.z - ErrorValue))
            {
                return true;
            }

            return false;
        }

        #endregion

        #endregion

        #endregion

        #region IEquatable<Vector3Float> Members

        /// <summary>Indicates whether the current vector is equal to another vector.</summary>
        /// <param name="other">A vector to compare with this vector.</param>
        /// <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
        public bool Equals(Vector3Float other)
        {
            return
                x == other.x &&
                y == other.y &&
                z == other.z;
        }

        #endregion

        public static float ComponentMax(Vector3Float vector3)
        {
            return Math.Max(vector3.x, Math.Max(vector3.y, vector3.z));
        }

        public static float ComponentMin(Vector3Float vector3)
        {
            return Math.Min(vector3.x, Math.Min(vector3.y, vector3.z));
        }
    }
}

#endregion //Vector3Float.cs
#region Vector4.cs

namespace MatterHackers.VectorMath
{
    /// <summary>Represents a 4D vector using four double-precision floating-point numbers.</summary>
    //[Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public struct Vector4 : IEquatable<Vector4>
    {
        #region Fields

        /// <summary>
        /// The X component of the Vector4d.
        /// </summary>
        public double x;

        /// <summary>
        /// The Y component of the Vector4d.
        /// </summary>
        public double y;

        /// <summary>
        /// The Z component of the Vector4d.
        /// </summary>
        public double z;

        /// <summary>
        /// The W component of the Vector4d.
        /// </summary>
        public double w;

        /// <summary>
        /// Defines a unit-length Vector4d that points towards the X-axis.
        /// </summary>
        public static Vector4 UnitX = new Vector4(1, 0, 0, 0);

        /// <summary>
        /// Defines a unit-length Vector4d that points towards the Y-axis.
        /// </summary>
        public static Vector4 UnitY = new Vector4(0, 1, 0, 0);

        /// <summary>
        /// Defines a unit-length Vector4d that points towards the Z-axis.
        /// </summary>
        public static Vector4 UnitZ = new Vector4(0, 0, 1, 0);

        /// <summary>
        /// Defines a unit-length Vector4d that points towards the W-axis.
        /// </summary>
        public static Vector4 UnitW = new Vector4(0, 0, 0, 1);

        /// <summary>
        /// Defines a zero-length Vector4d.
        /// </summary>
        public static Vector4 Zero = new Vector4(0, 0, 0, 0);

        /// <summary>
        /// Defines an instance with all components set to 1.
        /// </summary>
        public static readonly Vector4 One = new Vector4(1, 1, 1, 1);

        /// <summary>
        /// Defines the size of the Vector4d struct in bytes.
        /// </summary>
        public static readonly int SizeInBytes = Marshal.SizeOf(new Vector4());

        #endregion

        #region Constructors

        /// <summary>
        /// Constructs a new Vector4d.
        /// </summary>
        /// <param name="x">The x component of the Vector4d.</param>
        /// <param name="y">The y component of the Vector4d.</param>
        /// <param name="z">The z component of the Vector4d.</param>
        /// <param name="w">The w component of the Vector4d.</param>
        public Vector4(double x, double y, double z, double w)
        {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }

        /// <summary>
        /// Constructs a new Vector4d from the given Vector2d.
        /// </summary>
        /// <param name="v">The Vector2d to copy components from.</param>
        public Vector4(Vector2 v)
        {
            x = v.x;
            y = v.y;
            z = 0.0f;
            w = 0.0f;
        }

        /// <summary>
        /// Constructs a new Vector4d from the given Vector3d.
        /// </summary>
        /// <param name="v">The Vector3d to copy components from.</param>
        public Vector4(Vector3 v)
        {
            x = v.x;
            y = v.y;
            z = v.z;
            w = 0.0f;
        }

        /// <summary>
        /// Constructs a new Vector4d from the specified Vector3d and w component.
        /// </summary>
        /// <param name="v">The Vector3d to copy components from.</param>
        /// <param name="w">The w component of the new Vector4.</param>
        public Vector4(Vector3 v, double w)
        {
            x = v.x;
            y = v.y;
            z = v.z;
            this.w = w;
        }

        /// <summary>
        /// Constructs a new Vector4d from the given Vector4d.
        /// </summary>
        /// <param name="v">The Vector4d to copy components from.</param>
        public Vector4(Vector4 v)
        {
            x = v.x;
            y = v.y;
            z = v.z;
            w = v.w;
        }

        #endregion

        #region Public Members

        #region Properties

        public double this[int index]
        {
            get
            {
                switch (index)
                {
                    case 0:
                        return x;
                    case 1:
                        return y;
                    case 2:
                        return z;
                    case 3:
                        return w;
                    default:
                        return 0;
                }
            }

            set
            {
                switch (index)
                {
                    case 0:
                        x = value;
                        break;
                    case 1:
                        y = value;
                        break;
                    case 2:
                        z = value;
                        break;
                    case 3:
                        w = value;
                        break;
                    default:
                        throw new Exception();
                }
            }
        }

        #endregion

        #region Instance

        #region public double Length

        /// <summary>
        /// Gets the length (magnitude) of the vector.
        /// </summary>
        /// <see cref="LengthFast"/>
        /// <seealso cref="LengthSquared"/>
        public double Length
        {
            get
            {
                return System.Math.Sqrt(x * x + y * y + z * z + w * w);
            }
        }

        #endregion

        #region public double LengthSquared

        /// <summary>
        /// Gets the square of the vector length (magnitude).
        /// </summary>
        /// <remarks>
        /// This property avoids the costly square root operation required by the Length property. This makes it more suitable
        /// for comparisons.
        /// </remarks>
        /// <see cref="Length"/>
        public double LengthSquared
        {
            get
            {
                return x * x + y * y + z * z + w * w;
            }
        }

        #endregion

        #region public void Normalize()

        /// <summary>
        /// Scales the Vector4d to unit length.
        /// </summary>
        public void Normalize()
        {
            double scale = 1.0 / this.Length;
            x *= scale;
            y *= scale;
            z *= scale;
            w *= scale;
        }

        #endregion

        #region public void Scale()

        #endregion public void Scale()

        #endregion

        #region Static

        #region Add

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <returns>Result of operation.</returns>
        public static Vector4 Add(Vector4 a, Vector4 b)
        {
            Add(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Adds two vectors.
        /// </summary>
        /// <param name="a">Left operand.</param>
        /// <param name="b">Right operand.</param>
        /// <param name="result">Result of operation.</param>
        public static void Add(ref Vector4 a, ref Vector4 b, out Vector4 result)
        {
            result = new Vector4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
        }

        #endregion

        #region Subtract

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>Result of subtraction</returns>
        public static Vector4 Subtract(Vector4 a, Vector4 b)
        {
            Subtract(ref a, ref b, out a);
            return a;
        }

        /// <summary>
        /// Subtract one Vector from another
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">Result of subtraction</param>
        public static void Subtract(ref Vector4 a, ref Vector4 b, out Vector4 result)
        {
            result = new Vector4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
        }

        #endregion

        #region Multiply

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector4 Multiply(Vector4 vector, double scale)
        {
            Multiply(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector4 vector, double scale, out Vector4 result)
        {
            result = new Vector4(vector.x * scale, vector.y * scale, vector.z * scale, vector.w * scale);
        }

        /// <summary>
        /// Multiplies a vector by the components a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector4 Multiply(Vector4 vector, Vector4 scale)
        {
            Multiply(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Multiplies a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Multiply(ref Vector4 vector, ref Vector4 scale, out Vector4 result)
        {
            result = new Vector4(vector.x * scale.x, vector.y * scale.y, vector.z * scale.z, vector.w * scale.w);
        }

        #endregion

        #region Divide

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector4 Divide(Vector4 vector, double scale)
        {
            Divide(ref vector, scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divides a vector by a scalar.
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector4 vector, double scale, out Vector4 result)
        {
            Multiply(ref vector, 1 / scale, out result);
        }

        /// <summary>
        /// Divides a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <returns>Result of the operation.</returns>
        public static Vector4 Divide(Vector4 vector, Vector4 scale)
        {
            Divide(ref vector, ref scale, out vector);
            return vector;
        }

        /// <summary>
        /// Divide a vector by the components of a vector (scale).
        /// </summary>
        /// <param name="vector">Left operand.</param>
        /// <param name="scale">Right operand.</param>
        /// <param name="result">Result of the operation.</param>
        public static void Divide(ref Vector4 vector, ref Vector4 scale, out Vector4 result)
        {
            result = new Vector4(vector.x / scale.x, vector.y / scale.y, vector.z / scale.z, vector.w / scale.w);
        }

        #endregion

        #region Min

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise minimum</returns>
        public static Vector4 Min(Vector4 a, Vector4 b)
        {
            a.x = a.x < b.x ? a.x : b.x;
            a.y = a.y < b.y ? a.y : b.y;
            a.z = a.z < b.z ? a.z : b.z;
            a.w = a.w < b.w ? a.w : b.w;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise minimum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise minimum</param>
        public static void Min(ref Vector4 a, ref Vector4 b, out Vector4 result)
        {
            result.x = a.x < b.x ? a.x : b.x;
            result.y = a.y < b.y ? a.y : b.y;
            result.z = a.z < b.z ? a.z : b.z;
            result.w = a.w < b.w ? a.w : b.w;
        }

        #endregion

        #region Max

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <returns>The component-wise maximum</returns>
        public static Vector4 Max(Vector4 a, Vector4 b)
        {
            a.x = a.x > b.x ? a.x : b.x;
            a.y = a.y > b.y ? a.y : b.y;
            a.z = a.z > b.z ? a.z : b.z;
            a.w = a.w > b.w ? a.w : b.w;
            return a;
        }

        /// <summary>
        /// Calculate the component-wise maximum of two vectors
        /// </summary>
        /// <param name="a">First operand</param>
        /// <param name="b">Second operand</param>
        /// <param name="result">The component-wise maximum</param>
        public static void Max(ref Vector4 a, ref Vector4 b, out Vector4 result)
        {
            result.x = a.x > b.x ? a.x : b.x;
            result.y = a.y > b.y ? a.y : b.y;
            result.z = a.z > b.z ? a.z : b.z;
            result.w = a.w > b.w ? a.w : b.w;
        }

        #endregion

        #region Clamp

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <returns>The clamped vector</returns>
        public static Vector4 Clamp(Vector4 vec, Vector4 min, Vector4 max)
        {
            vec.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            vec.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
            vec.z = vec.x < min.z ? min.z : vec.z > max.z ? max.z : vec.z;
            vec.w = vec.y < min.w ? min.w : vec.w > max.w ? max.w : vec.w;
            return vec;
        }

        /// <summary>
        /// Clamp a vector to the given minimum and maximum vectors
        /// </summary>
        /// <param name="vec">Input vector</param>
        /// <param name="min">Minimum vector</param>
        /// <param name="max">Maximum vector</param>
        /// <param name="result">The clamped vector</param>
        public static void Clamp(ref Vector4 vec, ref Vector4 min, ref Vector4 max, out Vector4 result)
        {
            result.x = vec.x < min.x ? min.x : vec.x > max.x ? max.x : vec.x;
            result.y = vec.y < min.y ? min.y : vec.y > max.y ? max.y : vec.y;
            result.z = vec.x < min.z ? min.z : vec.z > max.z ? max.z : vec.z;
            result.w = vec.y < min.w ? min.w : vec.w > max.w ? max.w : vec.w;
        }

        #endregion

        #region Normalize

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <returns>The normalized vector</returns>
        public static Vector4 Normalize(Vector4 vec)
        {
            double scale = 1.0 / vec.Length;
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            vec.w *= scale;
            return vec;
        }

        /// <summary>
        /// Scale a vector to unit length
        /// </summary>
        /// <param name="vec">The input vector</param>
        /// <param name="result">The normalized vector</param>
        public static void Normalize(ref Vector4 vec, out Vector4 result)
        {
            double scale = 1.0 / vec.Length;
            result.x = vec.x * scale;
            result.y = vec.y * scale;
            result.z = vec.z * scale;
            result.w = vec.w * scale;
        }

        #endregion

        #region Dot

        /// <summary>
        /// Calculate the dot product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <returns>The dot product of the two inputs</returns>
        public static double Dot(Vector4 left, Vector4 right)
        {
            return left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        }

        /// <summary>
        /// Calculate the dot product of two vectors
        /// </summary>
        /// <param name="left">First operand</param>
        /// <param name="right">Second operand</param>
        /// <param name="result">The dot product of the two inputs</param>
        public static void Dot(ref Vector4 left, ref Vector4 right, out double result)
        {
            result = left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;
        }

        #endregion

        #region Lerp

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <returns>a when blend=0, b when blend=1, and a linear combination otherwise</returns>
        public static Vector4 Lerp(Vector4 a, Vector4 b, double blend)
        {
            a.x = blend * (b.x - a.x) + a.x;
            a.y = blend * (b.y - a.y) + a.y;
            a.z = blend * (b.z - a.z) + a.z;
            a.w = blend * (b.w - a.w) + a.w;
            return a;
        }

        /// <summary>
        /// Returns a new Vector that is the linear blend of the 2 given Vectors
        /// </summary>
        /// <param name="a">First input vector</param>
        /// <param name="b">Second input vector</param>
        /// <param name="blend">The blend factor. a when blend=0, b when blend=1.</param>
        /// <param name="result">a when blend=0, b when blend=1, and a linear combination otherwise</param>
        public static void Lerp(ref Vector4 a, ref Vector4 b, double blend, out Vector4 result)
        {
            result.x = blend * (b.x - a.x) + a.x;
            result.y = blend * (b.y - a.y) + a.y;
            result.z = blend * (b.z - a.z) + a.z;
            result.w = blend * (b.w - a.w) + a.w;
        }

        #endregion

        #region Barycentric

        /// <summary>
        /// Interpolate 3 Vectors using Barycentric coordinates
        /// </summary>
        /// <param name="a">First input Vector</param>
        /// <param name="b">Second input Vector</param>
        /// <param name="c">Third input Vector</param>
        /// <param name="u">First Barycentric Coordinate</param>
        /// <param name="v">Second Barycentric Coordinate</param>
        /// <returns>a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</returns>
        public static Vector4 BaryCentric(Vector4 a, Vector4 b, Vector4 c, double u, double v)
        {
            return a + u * (b - a) + v * (c - a);
        }

        /// <summary>Interpolate 3 Vectors using Barycentric coordinates</summary>
        /// <param name="a">First input Vector.</param>
        /// <param name="b">Second input Vector.</param>
        /// <param name="c">Third input Vector.</param>
        /// <param name="u">First Barycentric Coordinate.</param>
        /// <param name="v">Second Barycentric Coordinate.</param>
        /// <param name="result">Output Vector. a when u=v=0, b when u=1,v=0, c when u=0,v=1, and a linear combination of a,b,c otherwise</param>
        public static void BaryCentric(ref Vector4 a, ref Vector4 b, ref Vector4 c, double u, double v, out Vector4 result)
        {
            result = a; // copy

            Vector4 temp = b; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, u, out temp);
            Add(ref result, ref temp, out result);

            temp = c; // copy
            Subtract(ref temp, ref a, out temp);
            Multiply(ref temp, v, out temp);
            Add(ref result, ref temp, out result);
        }

        #endregion

        #region Transform

        /// <summary>Transform a Vector by the given Matrix</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <returns>The transformed vector</returns>
        public static Vector4 Transform(Vector4 vec, Matrix4X4 mat)
        {
            Vector4 result;
            Transform(ref vec, ref mat, out result);
            return result;
        }

        /// <summary>Transform a Vector by the given Matrix</summary>
        /// <param name="vec">The vector to transform</param>
        /// <param name="mat">The desired transformation</param>
        /// <param name="result">The transformed vector</param>
        public static void Transform(ref Vector4 vec, ref Matrix4X4 mat, out Vector4 result)
        {
            result = new Vector4(
                vec.x * mat.Row0.x + vec.y * mat.Row1.x + vec.z * mat.Row2.x + vec.w * mat.Row3.x,
                vec.x * mat.Row0.y + vec.y * mat.Row1.y + vec.z * mat.Row2.y + vec.w * mat.Row3.y,
                vec.x * mat.Row0.z + vec.y * mat.Row1.z + vec.z * mat.Row2.z + vec.w * mat.Row3.z,
                vec.x * mat.Row0.w + vec.y * mat.Row1.w + vec.z * mat.Row2.w + vec.w * mat.Row3.w);
        }

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <returns>The result of the operation.</returns>
        public static Vector4 Transform(Vector4 vec, Quaternion quat)
        {
            Vector4 result;
            Transform(ref vec, ref quat, out result);
            return result;
        }

        /// <summary>
        /// Transforms a vector by a quaternion rotation.
        /// </summary>
        /// <param name="vec">The vector to transform.</param>
        /// <param name="quat">The quaternion to rotate the vector by.</param>
        /// <param name="result">The result of the operation.</param>
        public static void Transform(ref Vector4 vec, ref Quaternion quat, out Vector4 result)
        {
            Quaternion v = new Quaternion(vec.x, vec.y, vec.z, vec.w), i, t;
            Quaternion.Invert(ref quat, out i);
            Quaternion.Multiply(ref quat, ref v, out t);
            Quaternion.Multiply(ref t, ref i, out v);

            result = new Vector4(v.X, v.Y, v.Z, v.W);
        }

        #endregion

        #endregion

        #region Swizzle

        /// <summary>
        /// Gets or sets an OpenTK.Vector2d with the X and Y components of this instance.
        /// </summary>
        public Vector2 Xy { get { return new Vector2(x, y); } set { x = value.x; y = value.y; } }

        /// <summary>
        /// Gets or sets an OpenTK.Vector3d with the X, Y and Z components of this instance.
        /// </summary>
        public Vector3 Xyz { get { return new Vector3(x, y, z); } set { x = value.x; y = value.y; z = value.z; } }

        #endregion

        #region Operators

        /// <summary>
        /// Adds two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector4 operator +(Vector4 left, Vector4 right)
        {
            left.x += right.x;
            left.y += right.y;
            left.z += right.z;
            left.w += right.w;
            return left;
        }

        /// <summary>
        /// Subtracts two instances.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector4 operator -(Vector4 left, Vector4 right)
        {
            left.x -= right.x;
            left.y -= right.y;
            left.z -= right.z;
            left.w -= right.w;
            return left;
        }

        /// <summary>
        /// Negates an instance.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector4 operator -(Vector4 vec)
        {
            vec.x = -vec.x;
            vec.y = -vec.y;
            vec.z = -vec.z;
            vec.w = -vec.w;
            return vec;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector4 operator *(Vector4 vec, double scale)
        {
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            vec.w *= scale;
            return vec;
        }

        /// <summary>
        /// Multiplies an instance by a scalar.
        /// </summary>
        /// <param name="scale">The scalar.</param>
        /// <param name="vec">The instance.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector4 operator *(double scale, Vector4 vec)
        {
            vec.x *= scale;
            vec.y *= scale;
            vec.z *= scale;
            vec.w *= scale;
            return vec;
        }

        /// <summary>
        /// Divides an instance by a scalar.
        /// </summary>
        /// <param name="vec">The instance.</param>
        /// <param name="scale">The scalar.</param>
        /// <returns>The result of the calculation.</returns>
        public static Vector4 operator /(Vector4 vec, double scale)
        {
            double mult = 1 / scale;
            vec.x *= mult;
            vec.y *= mult;
            vec.z *= mult;
            vec.w *= mult;
            return vec;
        }

        /// <summary>
        /// Compares two instances for equality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left equals right; false otherwise.</returns>
        public static bool operator ==(Vector4 left, Vector4 right)
        {
            return left.Equals(right);
        }

        /// <summary>
        /// Compares two instances for inequality.
        /// </summary>
        /// <param name="left">The first instance.</param>
        /// <param name="right">The second instance.</param>
        /// <returns>True, if left does not equa lright; false otherwise.</returns>
        public static bool operator !=(Vector4 left, Vector4 right)
        {
            return !left.Equals(right);
        }

        #endregion

        #region Overrides

        #region public override string ToString()

        /// <summary>
        /// Returns a System.String that represents the current Vector4d.
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return String.Format("{0}, {1}, {2}, {3}", x, y, z, w);
        }

        /// <summary>
        /// Returns a System.String that represents the current Vector4d, formatting each element with format.
        /// </summary>
        /// <param name="format"></param>
        /// <returns></returns>
        public string ToString(string format = "")
        {
            return x.ToString(format) + ", " + y.ToString(format) + ", " + z.ToString(format) + ", " + w.ToString(format);
        }

        #endregion

        #region public override int GetHashCode()

        /// <summary>
        /// Returns the hashcode for this instance.
        /// </summary>
        /// <returns>A System.Int32 containing the unique hashcode for this instance.</returns>
        public override int GetHashCode()
        {
            return new { x, y, z, w }.GetHashCode();
        }

        #endregion

        #region public override bool Equals(object obj)

        /// <summary>
        /// Indicates whether this instance and a specified object are equal.
        /// </summary>
        /// <param name="obj">The object to compare to.</param>
        /// <returns>True if the instances are equal; false otherwise.</returns>
        public override bool Equals(object obj)
        {
            if (!(obj is Vector4))
                return false;

            return this.Equals((Vector4)obj);
        }

        #endregion

        #endregion

        #endregion

        #region IEquatable<Vector4d> Members

        /// <summary>Indicates whether the current vector is equal to another vector.</summary>
        /// <param name="other">A vector to compare with this vector.</param>
        /// <returns>true if the current vector is equal to the vector parameter; otherwise, false.</returns>
        public bool Equals(Vector4 other)
        {
            return
                x == other.x &&
                y == other.y &&
                z == other.z &&
                w == other.w;
        }

        #endregion
    }
}

#endregion //Vector4.cs
#region VectorClipper.cs

namespace MatterHackers.Agg
{
    //--------------------------------------------------------poly_max_coord_e
    enum poly_max_coord_e
    {
        poly_max_coord = (1 << 30) - 1 //----poly_max_coord
    };

    public class VectorClipper
    {
        public RectangleInt clipBox;
        private int m_x1;
        private int m_y1;
        private int m_f1;
        private bool m_clipping;

        int mul_div(double a, double b, double c)
        {
            return agg_basics.iround(a * b / c);
        }
        int xi(int v) { return v; }
        int yi(int v) { return v; }
        public int upscale(double v) { return agg_basics.iround(v * (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_scale); }
        public int downscale(int v) { return v / (int)MatterHackers.Agg.agg_basics.poly_subpixel_scale_e.poly_subpixel_scale; }

        //--------------------------------------------------------------------
        public VectorClipper()
        {
            clipBox = new RectangleInt(0, 0, 0, 0);
            m_x1 = (0);
            m_y1 = (0);
            m_f1 = (0);
            m_clipping = (false);
        }

        //--------------------------------------------------------------------
        public void reset_clipping()
        {
            m_clipping = false;
        }

        //--------------------------------------------------------------------
        public void clip_box(int x1, int y1, int x2, int y2)
        {
            clipBox = new RectangleInt(x1, y1, x2, y2);
            clipBox.normalize();
            m_clipping = true;
        }

        //--------------------------------------------------------------------
        public void move_to(int x1, int y1)
        {
            m_x1 = x1;
            m_y1 = y1;
            if (m_clipping)
            {
                m_f1 = ClipLiangBarsky.clipping_flags(x1, y1, clipBox);
            }
        }

        //------------------------------------------------------------------------
        private void line_clip_y(rasterizer_cells_aa ras, int x1, int y1, int x2, int y2, int f1, int f2)
        {
            f1 &= 10;
            f2 &= 10;
            if ((f1 | f2) == 0)
            {
                // Fully visible
                ras.line(x1, y1, x2, y2);
            }
            else
            {
                if (f1 == f2)
                {
                    // Invisible by Y
                    return;
                }

                int tx1 = x1;
                int ty1 = y1;
                int tx2 = x2;
                int ty2 = y2;

                if ((f1 & 8) != 0) // y1 < clip.y1
                {
                    tx1 = x1 + mul_div(clipBox.Bottom - y1, x2 - x1, y2 - y1);
                    ty1 = clipBox.Bottom;
                }

                if ((f1 & 2) != 0) // y1 > clip.y2
                {
                    tx1 = x1 + mul_div(clipBox.Top - y1, x2 - x1, y2 - y1);
                    ty1 = clipBox.Top;
                }

                if ((f2 & 8) != 0) // y2 < clip.y1
                {
                    tx2 = x1 + mul_div(clipBox.Bottom - y1, x2 - x1, y2 - y1);
                    ty2 = clipBox.Bottom;
                }

                if ((f2 & 2) != 0) // y2 > clip.y2
                {
                    tx2 = x1 + mul_div(clipBox.Top - y1, x2 - x1, y2 - y1);
                    ty2 = clipBox.Top;
                }

                ras.line(tx1, ty1, tx2, ty2);
            }
        }

        //--------------------------------------------------------------------
        public void line_to(rasterizer_cells_aa ras, int x2, int y2)
        {
            if (m_clipping)
            {
                int f2 = ClipLiangBarsky.clipping_flags(x2, y2, clipBox);

                if ((m_f1 & 10) == (f2 & 10) && (m_f1 & 10) != 0)
                {
                    // Invisible by Y
                    m_x1 = x2;
                    m_y1 = y2;
                    m_f1 = f2;
                    return;
                }

                int x1 = m_x1;
                int y1 = m_y1;
                int f1 = m_f1;
                int y3, y4;
                int f3, f4;

                switch (((f1 & 5) << 1) | (f2 & 5))
                {
                    case 0: // Visible by X
                        line_clip_y(ras, x1, y1, x2, y2, f1, f2);
                        break;

                    case 1: // x2 > clip.x2
                        y3 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
                        f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
                        line_clip_y(ras, x1, y1, clipBox.Right, y3, f1, f3);
                        line_clip_y(ras, clipBox.Right, y3, clipBox.Right, y2, f3, f2);
                        break;

                    case 2: // x1 > clip.x2
                        y3 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
                        f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
                        line_clip_y(ras, clipBox.Right, y1, clipBox.Right, y3, f1, f3);
                        line_clip_y(ras, clipBox.Right, y3, x2, y2, f3, f2);
                        break;

                    case 3: // x1 > clip.x2 && x2 > clip.x2
                        line_clip_y(ras, clipBox.Right, y1, clipBox.Right, y2, f1, f2);
                        break;

                    case 4: // x2 < clip.x1
                        y3 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
                        f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
                        line_clip_y(ras, x1, y1, clipBox.Left, y3, f1, f3);
                        line_clip_y(ras, clipBox.Left, y3, clipBox.Left, y2, f3, f2);
                        break;

                    case 6: // x1 > clip.x2 && x2 < clip.x1
                        y3 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
                        y4 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
                        f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
                        f4 = ClipLiangBarsky.clipping_flags_y(y4, clipBox);
                        line_clip_y(ras, clipBox.Right, y1, clipBox.Right, y3, f1, f3);
                        line_clip_y(ras, clipBox.Right, y3, clipBox.Left, y4, f3, f4);
                        line_clip_y(ras, clipBox.Left, y4, clipBox.Left, y2, f4, f2);
                        break;

                    case 8: // x1 < clip.x1
                        y3 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
                        f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
                        line_clip_y(ras, clipBox.Left, y1, clipBox.Left, y3, f1, f3);
                        line_clip_y(ras, clipBox.Left, y3, x2, y2, f3, f2);
                        break;

                    case 9:  // x1 < clip.x1 && x2 > clip.x2
                        y3 = y1 + mul_div(clipBox.Left - x1, y2 - y1, x2 - x1);
                        y4 = y1 + mul_div(clipBox.Right - x1, y2 - y1, x2 - x1);
                        f3 = ClipLiangBarsky.clipping_flags_y(y3, clipBox);
                        f4 = ClipLiangBarsky.clipping_flags_y(y4, clipBox);
                        line_clip_y(ras, clipBox.Left, y1, clipBox.Left, y3, f1, f3);
                        line_clip_y(ras, clipBox.Left, y3, clipBox.Right, y4, f3, f4);
                        line_clip_y(ras, clipBox.Right, y4, clipBox.Right, y2, f4, f2);
                        break;

                    case 12: // x1 < clip.x1 && x2 < clip.x1
                        line_clip_y(ras, clipBox.Left, y1, clipBox.Left, y2, f1, f2);
                        break;
                }
                m_f1 = f2;
            }
            else
            {
                ras.line(m_x1, m_y1,
                         x2, y2);
            }
            m_x1 = x2;
            m_y1 = y2;
        }
    }
}

#endregion //VectorClipper.cs
#region VertexSourceAdapter.cs

namespace MatterHackers.Agg.VertexSource
{
    //------------------------------------------------------------null_markers
    public struct null_markers : IMarkers
    {
        public void remove_all() { }
        public void add_vertex(double x, double y, ShapePath.FlagsAndCommand unknown) { }
        public void prepare_src() { }

        public void rewind(int unknown) { }
        public ShapePath.FlagsAndCommand vertex(ref double x, ref double y) { return ShapePath.FlagsAndCommand.CommandStop; }
    };

    //------------------------------------------------------conv_adaptor_vcgen
    public class VertexSourceAdapter : IVertexSourceProxy
    {
        private IGenerator generator;
        private IMarkers markers;
        private status m_status;
        private ShapePath.FlagsAndCommand m_last_cmd;
        private double m_start_x;
        private double m_start_y;

        public IVertexSource VertexSource
        {
            get;
            set;
        }

        private enum status
        {
            initial,
            accumulate,
            generate
        };

        public VertexSourceAdapter(IVertexSource vertexSource, IGenerator generator)
        {
            markers = new null_markers();
            this.VertexSource = vertexSource;
            this.generator = generator;
            m_status = status.initial;
        }

        public VertexSourceAdapter(IVertexSource vertexSource, IGenerator generator, IMarkers markers)
            : this(vertexSource, generator)
        {
            this.markers = markers;
        }
        void Attach(IVertexSource vertexSource) { this.VertexSource = vertexSource; }

        protected IGenerator GetGenerator() { return generator; }

        IMarkers GetMarkers() { return markers; }

        public IEnumerable<VertexData> Vertices()
        {
            rewind(0);
            ShapePath.FlagsAndCommand command = ShapePath.FlagsAndCommand.CommandStop;
            do
            {
                double x;
                double y;
                command = vertex(out x, out y);
                yield return new VertexData(command, new Vector2(x, y));
            } while (command != ShapePath.FlagsAndCommand.CommandStop);
        }

        public void rewind(int path_id)
        {
            VertexSource.rewind(path_id);
            m_status = status.initial;
        }

        public ShapePath.FlagsAndCommand vertex(out double x, out double y)
        {
            x = 0;
            y = 0;
            ShapePath.FlagsAndCommand command = ShapePath.FlagsAndCommand.CommandStop;
            bool done = false;
            while (!done)
            {
                switch (m_status)
                {
                    case status.initial:
                        markers.remove_all();
                        m_last_cmd = VertexSource.vertex(out m_start_x, out m_start_y);
                        m_status = status.accumulate;
                        goto case status.accumulate;

                    case status.accumulate:
                        if (ShapePath.is_stop(m_last_cmd))
                        {
                            return ShapePath.FlagsAndCommand.CommandStop;
                        }

                        generator.RemoveAll();
                        generator.AddVertex(m_start_x, m_start_y, ShapePath.FlagsAndCommand.CommandMoveTo);
                        markers.add_vertex(m_start_x, m_start_y, ShapePath.FlagsAndCommand.CommandMoveTo);

                        for (; ; )
                        {
                            command = VertexSource.vertex(out x, out y);
                            //DebugFile.Print("x=" + x.ToString() + " y=" + y.ToString() + "\n");
                            if (ShapePath.is_vertex(command))
                            {
                                m_last_cmd = command;
                                if (ShapePath.is_move_to(command))
                                {
                                    m_start_x = x;
                                    m_start_y = y;
                                    break;
                                }
                                generator.AddVertex(x, y, command);
                                markers.add_vertex(x, y, ShapePath.FlagsAndCommand.CommandLineTo);
                            }
                            else
                            {
                                if (ShapePath.is_stop(command))
                                {
                                    m_last_cmd = ShapePath.FlagsAndCommand.CommandStop;
                                    break;
                                }
                                if (ShapePath.is_end_poly(command))
                                {
                                    generator.AddVertex(x, y, command);
                                    break;
                                }
                            }
                        }
                        generator.Rewind(0);
                        m_status = status.generate;
                        goto case status.generate;

                    case status.generate:
                        command = generator.Vertex(ref x, ref y);
                        //DebugFile.Print("x=" + x.ToString() + " y=" + y.ToString() + "\n");
                        if (ShapePath.is_stop(command))
                        {
                            m_status = status.accumulate;
                            break;
                        }
                        done = true;
                        break;
                }
            }
            return command;
        }
    }
}

#endregion //VertexSourceAdapter.cs
#region VertexSourceIO.cs

namespace MatterHackers.Agg.VertexSource
{
    public class VertexSourceIO
    {
        public static void Load(PathStorage vertexSource, string pathAndFileName)
        {
            vertexSource.remove_all();

            //string[] allLines = System.IO.File.ReadAllLines(pathAndFileName);
            string[] allLines = null;
            using (System.IO.StreamReader r = new System.IO.StreamReader(pathAndFileName))
            {
                List<string> lines = new List<string>();
                string line = null;
                while ((line = r.ReadLine()) != null)
                    lines.Add(line);
                allLines = lines.ToArray();
            }

            foreach (string line in allLines)
            {
                string[] elements = line.Split(',');
                double x = double.Parse(elements[0]);
                double y = double.Parse(elements[1]);
                ShapePath.FlagsAndCommand flagsAndCommand = (ShapePath.FlagsAndCommand)System.Enum.Parse(typeof(ShapePath.FlagsAndCommand), elements[2].Trim());
                for (int i = 3; i < elements.Length; i++)
                {
                    flagsAndCommand |= (ShapePath.FlagsAndCommand)System.Enum.Parse(typeof(ShapePath.FlagsAndCommand), elements[i].Trim());
                }

                vertexSource.Add(x, y, flagsAndCommand);
            }
        }

        public static void Save(IVertexSource vertexSource, string pathAndFileName, bool oldStyle = true)
        {
            if (oldStyle)
            {
                using (System.IO.StreamWriter outFile = new System.IO.StreamWriter(pathAndFileName))
                {
                    vertexSource.rewind(0);
                    double x;
                    double y;
                    ShapePath.FlagsAndCommand flagsAndCommand = vertexSource.vertex(out x, out y);
                    do
                    {
                        outFile.WriteLine("{0}, {1}, {2}", x, y, flagsAndCommand.ToString());
                        flagsAndCommand = vertexSource.vertex(out x, out y);
                    }
                    while (flagsAndCommand != ShapePath.FlagsAndCommand.CommandStop);
                }
            }
            else
            {
                using (System.IO.StreamWriter outFile = new System.IO.StreamWriter(pathAndFileName))
                {
                    foreach (VertexData vertexData in vertexSource.Vertices())
                    {
                        outFile.WriteLine("{0}, {1}, {2}", vertexData.position.x, vertexData.position.y, vertexData.command.ToString());
                    }
                }
            }
        }
    }
}

#endregion //VertexSourceIO.cs
#region Viewport.cs

namespace MatterHackers.Agg.Transform
{
    //----------------------------------------------------------trans_viewport
    public sealed class Viewport
    {
        double m_world_x1;
        double m_world_y1;
        double m_world_x2;
        double m_world_y2;
        double m_device_x1;
        double m_device_y1;
        double m_device_x2;
        double m_device_y2;
        aspect_ratio_e m_aspect;
        bool m_is_valid;
        double m_align_x;
        double m_align_y;
        double m_wx1;
        double m_wy1;
        double m_wx2;
        double m_wy2;
        double m_dx1;
        double m_dy1;
        double m_kx;
        double m_ky;

        public enum aspect_ratio_e
        {
            aspect_ratio_stretch,
            aspect_ratio_meet,
            aspect_ratio_slice
        };

        //-------------------------------------------------------------------
        public Viewport()
        {
            m_world_x1 = (0.0);
            m_world_y1 = (0.0);
            m_world_x2 = (1.0);
            m_world_y2 = (1.0);
            m_device_x1 = (0.0);
            m_device_y1 = (0.0);
            m_device_x2 = (1.0);
            m_device_y2 = (1.0);
            m_aspect = aspect_ratio_e.aspect_ratio_stretch;
            m_is_valid = (true);
            m_align_x = (0.5);
            m_align_y = (0.5);
            m_wx1 = (0.0);
            m_wy1 = (0.0);
            m_wx2 = (1.0);
            m_wy2 = (1.0);
            m_dx1 = (0.0);
            m_dy1 = (0.0);
            m_kx = (1.0);
            m_ky = (1.0);
        }

        //-------------------------------------------------------------------
        public void preserve_aspect_ratio(double alignx, double aligny, aspect_ratio_e aspect)
        {
            m_align_x = alignx;
            m_align_y = aligny;
            m_aspect = aspect;
            update();
        }

        //-------------------------------------------------------------------
        public void device_viewport(double x1, double y1, double x2, double y2)
        {
            m_device_x1 = x1;
            m_device_y1 = y1;
            m_device_x2 = x2;
            m_device_y2 = y2;
            update();
        }

        //-------------------------------------------------------------------
        public void world_viewport(double x1, double y1, double x2, double y2)
        {
            m_world_x1 = x1;
            m_world_y1 = y1;
            m_world_x2 = x2;
            m_world_y2 = y2;
            update();
        }

        //-------------------------------------------------------------------
        public void device_viewport(out double x1, out double y1, out double x2, out double y2)
        {
            x1 = m_device_x1;
            y1 = m_device_y1;
            x2 = m_device_x2;
            y2 = m_device_y2;
        }

        //-------------------------------------------------------------------
        public void world_viewport(out double x1, out double y1, out double x2, out double y2)
        {
            x1 = m_world_x1;
            y1 = m_world_y1;
            x2 = m_world_x2;
            y2 = m_world_y2;
        }

        //-------------------------------------------------------------------
        public void world_viewport_actual(out double x1, out double y1, out double x2, out double y2)
        {
            x1 = m_wx1;
            y1 = m_wy1;
            x2 = m_wx2;
            y2 = m_wy2;
        }

        //-------------------------------------------------------------------
        public bool is_valid() { return m_is_valid; }
        public double align_x() { return m_align_x; }
        public double align_y() { return m_align_y; }
        public aspect_ratio_e aspect_ratio() { return m_aspect; }

        //-------------------------------------------------------------------
        public void transform(ref double x, ref double y)
        {
            x = (x - m_wx1) * m_kx + m_dx1;
            y = (y - m_wy1) * m_ky + m_dy1;
        }

        //-------------------------------------------------------------------
        public void transform_scale_only(ref double x, ref double y)
        {
            x *= m_kx;
            y *= m_ky;
        }

        //-------------------------------------------------------------------
        public void inverse_transform(ref double x, ref double y)
        {
            x = (x - m_dx1) / m_kx + m_wx1;
            y = (y - m_dy1) / m_ky + m_wy1;
        }

        //-------------------------------------------------------------------
        public void inverse_transform_scale_only(ref double x, ref double y)
        {
            x /= m_kx;
            y /= m_ky;
        }

        //-------------------------------------------------------------------
        public double device_dx() { return m_dx1 - m_wx1 * m_kx; }
        public double device_dy() { return m_dy1 - m_wy1 * m_ky; }

        //-------------------------------------------------------------------
        public double scale_x()
        {
            return m_kx;
        }

        //-------------------------------------------------------------------
        public double scale_y()
        {
            return m_ky;
        }

        //-------------------------------------------------------------------
        public double scale()
        {
            return (m_kx + m_ky) * 0.5;
        }

        //-------------------------------------------------------------------
        public Affine to_affine()
        {
            Affine mtx = Affine.NewTranslation(-m_wx1, -m_wy1);
            mtx *= Affine.NewScaling(m_kx, m_ky);
            mtx *= Affine.NewTranslation(m_dx1, m_dy1);
            return mtx;
        }

        //-------------------------------------------------------------------
        public Affine to_affine_scale_only()
        {
            return Affine.NewScaling(m_kx, m_ky);
        }

        private void update()
        {
            double epsilon = 1e-30;
            if (Math.Abs(m_world_x1 - m_world_x2) < epsilon ||
               Math.Abs(m_world_y1 - m_world_y2) < epsilon ||
               Math.Abs(m_device_x1 - m_device_x2) < epsilon ||
               Math.Abs(m_device_y1 - m_device_y2) < epsilon)
            {
                m_wx1 = m_world_x1;
                m_wy1 = m_world_y1;
                m_wx2 = m_world_x1 + 1.0;
                m_wy2 = m_world_y2 + 1.0;
                m_dx1 = m_device_x1;
                m_dy1 = m_device_y1;
                m_kx = 1.0;
                m_ky = 1.0;
                m_is_valid = false;
                return;
            }

            double world_x1 = m_world_x1;
            double world_y1 = m_world_y1;
            double world_x2 = m_world_x2;
            double world_y2 = m_world_y2;
            double device_x1 = m_device_x1;
            double device_y1 = m_device_y1;
            double device_x2 = m_device_x2;
            double device_y2 = m_device_y2;
            if (m_aspect != aspect_ratio_e.aspect_ratio_stretch)
            {
                double d;
                m_kx = (device_x2 - device_x1) / (world_x2 - world_x1);
                m_ky = (device_y2 - device_y1) / (world_y2 - world_y1);

                if ((m_aspect == aspect_ratio_e.aspect_ratio_meet) == (m_kx < m_ky))
                {
                    d = (world_y2 - world_y1) * m_ky / m_kx;
                    world_y1 += (world_y2 - world_y1 - d) * m_align_y;
                    world_y2 = world_y1 + d;
                }
                else
                {
                    d = (world_x2 - world_x1) * m_kx / m_ky;
                    world_x1 += (world_x2 - world_x1 - d) * m_align_x;
                    world_x2 = world_x1 + d;
                }
            }
            m_wx1 = world_x1;
            m_wy1 = world_y1;
            m_wx2 = world_x2;
            m_wy2 = world_y2;
            m_dx1 = device_x1;
            m_dy1 = device_y1;
            m_kx = (device_x2 - device_x1) / (world_x2 - world_x1);
            m_ky = (device_y2 - device_y1) / (world_y2 - world_y1);
            m_is_valid = true;
        }
    };
}

#endregion //Viewport.cs
